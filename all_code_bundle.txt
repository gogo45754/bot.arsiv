### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\.pytest_cache\v\cache\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\.pytest_cache\v\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\.pytest_cache\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\.venv311\Include\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\.venv311\Lib\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\.venv311\Scripts\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\.venv311\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\analysis\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\bots\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\bots\price_tracker.py
import ccxt.async_support as ccxt
import asyncio
from datetime import datetime, timezone

def log(msg, level="INFO"):
    ts = datetime.now(timezone.utc).isoformat()
    print(f"[{ts}] | {level.upper()} | {msg}")

async def fetch_price_loop(symbol="BTC/USDT:USDT", interval=10):
    exchange = ccxt.binanceusdm({
        'enableRateLimit': True,
        'options': {'defaultType': 'future'}
    })

    try:
        while True:
            ticker = await exchange.fetch_ticker(symbol)
            price = ticker['last']
            log(f"{symbol} fiyatÄ±: {price}", level="DATA")
            await asyncio.sleep(interval)

    except ccxt.BaseError as e:
        log(f"Hata oluÅŸtu: {str(e)}", level="ERROR")

    finally:
        await exchange.close()

if __name__ == "__main__":
    asyncio.run(fetch_price_loop())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\logs\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\logs\backtest_kamalquantx.py
def backtest(strategy, historical_prices):
    results = []
    for i, price in enumerate(historical_prices):
        ts = f"t{i}"
        signal = strategy.update(price, ts)
        if signal:
            results.append({
                'ts': ts,
                'action': signal['action'],
                'price': signal['price_now'],
                'future': signal['future_price'],
                'confidence': signal['confidence']
            })

    df = pd.DataFrame(results)
    df['return'] = np.where(df['action'] == 'BUY',
                            df['future'] / df['price'] - 1,
                            np.where(df['action'] == 'SELL',
                                     df['price'] / df['future'] - 1,
                                     0))
    total_return = df['return'].sum()
    sharpe = df['return'].mean() / df['return'].std() * np.sqrt(252)
    drawdown = (df['return'].cumsum().cummax() - df['return'].cumsum()).max()

    return {
        'total_return': round(total_return, 3),
        'sharpe_ratio': round(sharpe, 2),
        'max_drawdown': round(drawdown, 2),
        'win_rate': round((df['return'] > 0).mean(), 2)
    }

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\logs\ultra_elite_engine_ai.py
from __future__ import annotations
"""
Ultra Elite Strategy Engine â€” Full Stack (MTF + All Indicators + Risk + Binance Testnet)
--------------------------------------------------------------------------------------
- Multiâ€‘timeframe (signal / trend / HTF) with CLOSEDâ€‘bar signals (no repaint)
- Broad indicator pack (RSI, Stoch, MACD, EMA/SMA, Bollinger, Keltner, ATR, ADX,
  CCI, MFI, OBV, VWAP, Ichimoku, SAR, Supertrend) computed efficiently
- ATR SL/TP + breakeven + ATR trailing; volatility/chop filters; cooldown; session filter
- RiskManager: perâ€‘trade risk, min notional guard, daily max drawdown (Zurich reset)
- Fast deques, vectorized calc; optional Numba JIT for EMA & Supertrend
- Binance Futures Testnet executor (isolated, leverage, hedge mode, reduceâ€‘only),
  bracket orders (SL/TP), markâ€‘price working type, DRYâ€‘RUN support

Requires: python>=3.10, pandas, numpy, ta, pytz, python-dotenv, binance-connector, websocket-client, (optional) numba
Install:  pip install "pandas>=2" numpy ta pytz python-dotenv "binance-connector>=3" websocket-client numba

.env template (example):
BINANCE_API_KEY=your_testnet_key_here
BINANCE_API_SECRET=your_testnet_secret_here
USE_TESTNET=true
SYMBOLS=BTCUSDT,DOGEUSDT
BINANCE_HEDGE_MODE=true
BINANCE_MARGIN_TYPE=ISOLATED
BINANCE_LEVERAGE=5
RISK_MAX_DAILY_DRAWDOWN=0.02
RISK_MAX_RISK_PCT_PER_TRADE=0.015
MIN_NOTIONAL_USDT=10
WORKING_TYPE=MARK_PRICE   # MARK_PRICE | CONTRACT_PRICE
DRY_RUN=true

Run example:
python ultra_elite_engine.py --symbols BTCUSDT DOGEUSDT --signal_tf 1m --trend_tf 15m --htf 1h --dry-run
"""

from dataclasses import dataclass, field
from collections import deque
from typing import Deque, Dict, Optional, Literal, Tuple, List
import os
import math
import pandas as pd
import numpy as np
import pytz
import ta
import time
import logging
from datetime import datetime, timezone
from dotenv import load_dotenv

# Optional ML deps ------------------------------------------------------------
# Optional ML deps ------------------------------------------------------------
try:
    from sklearn.linear_model import LogisticRegression
    from sklearn.ensemble import IsolationForest
    from sklearn.preprocessing import StandardScaler
    SKLEARN_OK = True
except Exception:
    SKLEARN_OK = False

try:
    import torch
    import torch.nn as nn
    TORCH_OK = True
except Exception:
    TORCH_OK = False

# Optional Numba for speed ----------------------------------------------------
try:
    from numba import njit
except Exception:  # pragma: no cover
    def njit(*args, **kwargs):
        def wrap(fn):
            return fn
        return wrap

# ----------------------------------------------------------------------------
# Logging
# ----------------------------------------------------------------------------
logger = logging.getLogger("UltraElite")
logger.setLevel(logging.INFO)
if not logger.handlers:
    ch = logging.StreamHandler()
    ch.setFormatter(logging.Formatter("%(asctime)s | %(levelname)s | %(message)s"))
    logger.addHandler(ch)

TF = Literal["1m","3m","5m","15m","30m","1h","2h","4h","6h","8h","12h","1d","3d","1w","1M"]
Side = Literal["LONG","SHORT"]

TF_TO_SEC = {"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"2h":7200,"4h":14400,"6h":21600,"8h":28800,"12h":43200,"1d":86400,"3d":259200,"1w":604800,"1M":2592000}  # 1Mâ‰ˆ30d for aggregation only

# ----------------------------------------------------------------------------
# Data structures
# ----------------------------------------------------------------------------
@dataclass
class Bar:
    ts: pd.Timestamp  # bar close time UTC
    open: float
    high: float
    low: float
    close: float
    volume: float = 0.0

@dataclass
class Signal:
    symbol: str
    side: Side
    price: float
    sl: float
    tp: float
    size: float
    reason: str
    meta: dict = field(default_factory=dict)

# ----------------------------------------------------------------------------
# Helpers
# ----------------------------------------------------------------------------

def as_utc(ts) -> pd.Timestamp:
    if isinstance(ts, pd.Timestamp):
        if ts.tzinfo is None:
            return ts.tz_localize("UTC")
        return ts.tz_convert("UTC")
    # assume seconds since epoch
    return pd.to_datetime(ts, unit="s", utc=True)

# JIT EMA (fast incremental)
@njit(cache=True)
def ema_numba(vals: np.ndarray, period: int) -> np.ndarray:
    out = np.empty_like(vals)
    if len(vals) == 0:
        return out
    alpha = 2.0 / (period + 1.0)
    out[0] = vals[0]
    for i in range(1, len(vals)):
        out[i] = alpha * vals[i] + (1.0 - alpha) * out[i - 1]
    return out

# Supertrend (Numbaâ€‘friendly)
@njit(cache=True)
def supertrend(high, low, close, period=10, multiplier=3.0):
    n = len(close)
    atr = np.empty(n)
    atr[:] = np.nan

    # TR & ATR (RMA)
    tr = np.empty(n)
    tr[0] = high[0] - low[0]
    for i in range(1, n):
        hl = high[i] - low[i]
        hc = abs(high[i] - close[i-1])
        lc = abs(low[i] - close[i-1])
        tr[i] = hl if (hl >= hc and hl >= lc) else (hc if hc >= lc else lc)
    # RMA
    alpha = 1.0/period
    atr[period-1] = np.mean(tr[:period])
    for i in range(period, n):
        atr[i] = (atr[i-1] * (period-1) + tr[i]) / period

    upper = np.empty(n); lower = np.empty(n)
    upper[:] = np.nan; lower[:] = np.nan
    st = np.empty(n); st[:] = np.nan
    trend = np.empty(n); trend[:] = 1

    for i in range(n):
        if np.isnan(atr[i]):
            continue
        basic_upper = (high[i] + low[i]) / 2.0 + multiplier * atr[i]
        basic_lower = (high[i] + low[i]) / 2.0 - multiplier * atr[i]
        if i == 0:
            upper[i] = basic_upper
            lower[i] = basic_lower
            st[i] = basic_lower
            trend[i] = 1
            continue
        upper[i] = basic_upper if (basic_upper < upper[i-1] or close[i-1] > upper[i-1]) else upper[i-1]
        lower[i] = basic_lower if (basic_lower > lower[i-1] or close[i-1] < lower[i-1]) else lower[i-1]
        if close[i] > upper[i-1]:
            trend[i] = 1
        elif close[i] < lower[i-1]:
            trend[i] = -1
        else:
            trend[i] = trend[i-1]
        st[i] = lower[i] if trend[i] == 1 else upper[i]
    return st, trend, atr

# VWAP helper

def vwap_np(high, low, close, volume):
    tp = (high + low + close) / 3.0
    cum_v = np.cumsum(volume)
    cum_tp_v = np.cumsum(tp * volume)
    vwap = cum_tp_v / np.maximum(cum_v, 1e-12)
    return vwap

# ----------------------------------------------------------------------------
# Window state & Aggregators
# ----------------------------------------------------------------------------
@dataclass
class WindowState:
    tf: TF
    maxlen: int
    rows: Deque[Tuple[pd.Timestamp, float, float, float, float, float]] = field(default_factory=deque)

    def append(self, bar: Bar):
        if len(self.rows) == self.maxlen:
            self.rows.popleft()
        self.rows.append((as_utc(bar.ts), bar.open, bar.high, bar.low, bar.close, bar.volume))

    def to_df(self) -> pd.DataFrame:
        return pd.DataFrame(self.rows, columns=["ts","open","high","low","close","volume"])  

# Tick â†’ OHLCV aggregator for a single TF
class TickAggregator:
    def __init__(self, tf: TF):
        self.tf = tf
        self.period = TF_TO_SEC[tf]
        self.reset()

    def reset(self):
        self._open = None; self._high = -math.inf; self._low = math.inf; self._vol = 0.0; self._start = None

    def update(self, ts_sec: float, price: float, qty: float) -> Optional[Bar]:
        # ts_sec: seconds (float) epoch
        if self._start is None:
            self._start = int(ts_sec // self.period) * self.period
            self._open = price
            self._high = price
            self._low = price
        elif ts_sec >= self._start + self.period:
            # close current bar
            bar = Bar(ts=as_utc(self._start + self.period), open=self._open, high=self._high,
                      low=self._low, close=price, volume=self._vol)
            # start new
            self.reset()
            self._start = int(ts_sec // self.period) * self.period
            self._open = price; self._high = price; self._low = price; self._vol = qty
            return bar
        # update inâ€‘bar
        if price > self._high: self._high = price
        if price < self._low: self._low = price
        self._vol += qty
        return None

# ----------------------------------------------------------------------------
# Indicator Engine (broad coverage)
# ----------------------------------------------------------------------------
@dataclass
class IndicatorParams:
    # dynamic + presets together
    ma_periods: Tuple[int, ...] = (7, 25, 99)
    ema_periods: Tuple[int, ...] = (7, 21, 50, 99)
    wma_periods: Tuple[int, ...] = (7, 25)
    mavol_periods: Tuple[int, ...] = (7, 14)
    trix_periods: Tuple[int, ...] = (9,)
    bb_window: int = 20
    kelt_window: int = 20
    kelt_atr: int = 10
    supertrend_period: int = 10
    supertrend_mult: float = 3.0

class IndicatorEngine:
    def __init__(self, rsi_period=14, ema_fast=21, ema_slow=50, atr_period=14, adx_period=14,
                 params: IndicatorParams | None = None):
        self.rsi_period = rsi_period
        self.ema_fast = ema_fast
        self.ema_slow = ema_slow
        self.atr_period = atr_period
        self.adx_period = adx_period
        self.p = params or IndicatorParams()

    def _wma(self, x: pd.Series, period: int) -> pd.Series:
        # weighted moving average (linear weights 1..n)
        if period <= 1:
            return x
        w = np.arange(1, period + 1)
        return x.rolling(period).apply(lambda a: np.dot(a, w) / w.sum(), raw=True)

    def _ema_series(self, arr: np.ndarray, p: int, index) -> pd.Series:
        return pd.Series(ema_numba(arr, p), index=index)

    def _ema(self, s: pd.Series, p: int) -> pd.Series:
        return self._ema_series(s.to_numpy(), p, s.index)

    def compute_all(self, df: pd.DataFrame) -> pd.DataFrame:
        c = df["close"].to_numpy()
        c = df["close"].to_numpy()
        h = df["high"].to_numpy()
        l = df["low"].to_numpy()
        v = df["volume"].to_numpy()

        out = df.copy()
        # === Core single-pass arrays ===
        out["rsi"] = ta.momentum.RSIIndicator(close=df["close"], window=self.rsi_period).rsi()
        out["ema_fast"] = pd.Series(ema_numba(c, self.ema_fast), index=df.index)
        out["ema_slow"] = pd.Series(ema_numba(c, self.ema_slow), index=df.index)
        out["atr"] = ta.volatility.AverageTrueRange(h, l, c, window=self.atr_period).average_true_range()
        out["adx"] = ta.trend.ADXIndicator(df["high"], df["low"], df["close"], window=self.adx_period).adx()

        # === Dynamic presets (fast loops) ===
        for p in self.p.ma_periods:
            out[f"ma{p}"] = df["close"].rolling(p).mean()
        for p in self.p.ema_periods:
            out[f"ema{p}"] = pd.Series(ema_numba(c, p), index=df.index)
        for p in self.p.wma_periods:
            out[f"wma{p}"] = self._wma(df["close"], p)
        for p in self.p.mavol_periods:
            out[f"mavol{p}"] = df["volume"].rolling(p).mean()
        for p in self.p.trix_periods:
            e1 = pd.Series(ema_numba(c, p), index=df.index)
            e2 = pd.Series(ema_numba(e1.to_numpy(), p), index=df.index)
            e3 = pd.Series(ema_numba(e2.to_numpy(), p), index=df.index)
            out[f"trix{p}"] = e3.pct_change() * 100.0

        # Stoch / KDJ
        stoch = ta.momentum.StochasticOscillator(df["high"], df["low"], df["close"])
        out["stoch_k"], out["stoch_d"] = stoch.stoch(), stoch.stoch_signal()
        out["kdj_k"], out["kdj_d"] = out["stoch_k"], out["stoch_d"]
        out["kdj_j"] = (3 * out["kdj_k"] - 2 * out["kdj_d"]).clip(0, 100)

        # MACD
        macd = ta.trend.MACD(close=df["close"]) 
        out["macd"], out["macd_signal"], out["macd_hist"] = macd.macd(), macd.macd_signal(), macd.macd_diff()

        # Williams %R
        try:
            wr = ta.momentum.WilliamsRIndicator(df["high"], df["low"], df["close"], lbp=14)
            out["wr14"] = wr.williams_r()
        except Exception:
            out["wr14"] = np.nan

        # TRIX signal (EMA of TRIX)
        if "trix9" in out.columns:
            out["trix9_signal"] = self._ema(out["trix9"].fillna(0), 9)
            out["trix9_hist"] = out["trix9"] - out["trix9_signal"]

        # Volatility packs
        bb = ta.volatility.BollingerBands(close=df["close"], window=self.p.bb_window)
        out["bb_high"], out["bb_low"], out["bb_mid"] = bb.bollinger_hband(), bb.bollinger_lband(), bb.bollinger_mavg()
        kelt = ta.volatility.KeltnerChannel(h, l, c, window=self.p.kelt_window, original_version=True)
        out["kc_high"], out["kc_low"], out["kc_mid"] = kelt.keltner_channel_hband(), kelt.keltner_channel_lband(), kelt.keltner_channel_mband()

        # Volumeâ€‘based
        out["obv"] = ta.volume.OnBalanceVolumeIndicator(close=df["close"], volume=df["volume"]).on_balance_volume()
        out["mfi"] = ta.volume.MFIIndicator(h, l, c, v).money_flow_index()
        out["vwap"] = pd.Series(vwap_np(h, l, c, v), index=df.index)
        
        # Others
        out["cci"] = ta.trend.CCIIndicator(h, l, c).cci()
        out["sar"] = ta.trend.PSARIndicator(h, l, c).psar()
        try:
            ichi = ta.trend.IchimokuIndicator(h, l)
            out["ichi_base"], out["ichi_conv"] = ichi.ichimoku_base_line(), ichi.ichimoku_conversion_line()
        except Exception:
            out["ichi_base"], out["ichi_conv"] = np.nan, np.nan

        # Supertrend (custom JIT)
        st, trend, atr_rma = supertrend(h.astype(np.float64), l.astype(np.float64), c.astype(np.float64),
                                        period=self.p.supertrend_period, multiplier=self.p.supertrend_mult)
        out["supertrend"], out["supertrend_trend"], out["atr_rma"] = st, trend, atr_rma
        return out

# ----------------------------------------------------------------------------
# AI modules (optional, plug & play)
# ----------------------------------------------------------------------------
class FeatureBuilder:
    """Builds a compact feature vector from the latest indicator snapshot.
    Uses only numeric, normalized, low-leakage features.
    """
    def __init__(self):
        self.cols = [
            "rsi","stoch_k","stoch_d","kdj_k","kdj_d","kdj_j",
            "wr14","macd","macd_signal","macd_hist","trix9","trix9_signal","trix9_hist",
            "ema_fast","ema_slow","sma50","sma200","bb_high","bb_low","bb_mid",
            "kc_high","kc_low","kc_mid","atr","adx","vwap","obv","mfi","cci","sar",
            "supertrend","supertrend_trend","atr_rma"
        ]
        # Only keep those that exist
    def build(self, df: pd.DataFrame) -> Tuple[np.ndarray, List[str]]:
        row = df.iloc[-1]
        avail = [c for c in self.cols if c in df.columns]
        x = np.array([float(row[c]) if np.isfinite(row.get(c, np.nan)) else 0.0 for c in avail], dtype=float)
        return x, avail

class AIModule:
    """Ensemble of: (1) Rule-based signal, (2) Logistic classifier on features,
    (3) IsolationForest anomaly veto. Returns accept/reject + score in [0,1].
    """
    def __init__(self, min_samples: int = 500):
        self.min_samples = min_samples
        self.scaler = StandardScaler() if SKLEARN_OK else None
        self.clf = LogisticRegression(max_iter=200) if SKLEARN_OK else None
        self.anom = IsolationForest(n_estimators=100, contamination=0.02, random_state=42) if SKLEARN_OK else None
        self.fb = FeatureBuilder()
        self._trained = False
        self._feat_names: List[str] = []
        self._buffer_X: List[np.ndarray] = []
        self._buffer_y: List[int] = []

    def update_and_maybe_train(self, df: pd.DataFrame, rule_signal: int):
        """rule_signal in {0,1} := whether the rule engine emitted a buy/short intent.
        We use rule labels as pseudo-labels to learn a classifier that mimics/improves timing.
        """
        if not SKLEARN_OK or len(df) < self.min_samples:
            return
        x, names = self.fb.build(df)
        if not self._feat_names:
            self._feat_names = names
        self._buffer_X.append(x)
        self._buffer_y.append(int(rule_signal))
        if len(self._buffer_X) >= self.min_samples and (len(self._buffer_X) % 50 == 0):
            X = np.vstack(self._buffer_X)
            y = np.array(self._buffer_y)
            Xs = self.scaler.fit_transform(X)
            self.clf.fit(Xs, y)
            try:
                self.anom.fit(Xs)
            except Exception:
                pass
            self._trained = True

    def predict_accept(self, df: pd.DataFrame) -> Tuple[bool, float, dict]:
        if not SKLEARN_OK or not self._trained:
            return True, 0.5, {"ai": "bypass"}
        x, _ = self.fb.build(df)
        xs = self.scaler.transform([x])
        prob = float(self.clf.predict_proba(xs)[0,1])
        try:
            an = float(self.anom.score_samples(xs)[0])  # higher is less anomalous
        except Exception:
            an = 0.0
        score = 0.7*prob + 0.3*(1/(1+np.exp(-an)))
        return (score >= 0.5), score, {"prob": prob, "anom": an}

# ----------------------------------------------------------------------------
# Risk management
# ----------------------------------------------------------------------------
@dataclass
class RiskConfig:
    account_equity_usdt: float = 1000.0
    max_risk_pct_per_trade: float = 0.015
    max_daily_drawdown_pct: float = 0.02
    leverage: int = 5
    min_notional_usdt: float = 10.0
    symbol_price_precision: int = 2
    symbol_qty_precision: int = 3
    tz_reset: str = "Europe/Zurich"

class RiskManager:
    def __init__(self, cfg: RiskConfig):
        self.cfg = cfg
        self.daily_pnl = 0.0
        self._current_date = None

    def _roll_date(self, now_utc: pd.Timestamp):
        tz = pytz.timezone(self.cfg.tz_reset)
        d = now_utc.tz_convert(tz).date()
        if self._current_date is None:
            self._current_date = d
        elif d != self._current_date:
            logger.info("[Risk] New day â†’ reset daily PnL")
            self._current_date = d
            self.daily_pnl = 0.0

    def update_realized_pnl(self, pnl: float, now_utc: pd.Timestamp):
        self._roll_date(now_utc)
        self.daily_pnl += pnl

    def hard_guard(self, now_utc: pd.Timestamp) -> bool:
        self._roll_date(now_utc)
        limit = -self.cfg.account_equity_usdt * self.cfg.max_daily_drawdown_pct
        allowed = self.daily_pnl > limit
        if not allowed:
            logger.warning("[Risk] Daily DD reached: pnl=%.2f limit=%.2f", self.daily_pnl, limit)
        return allowed

    def position_size(self, entry: float, sl: float) -> float:
        risk_usdt = self.cfg.account_equity_usdt * self.cfg.max_risk_pct_per_trade
        stop = max(1e-8, abs(entry - sl))
        qty = risk_usdt / stop * self.cfg.leverage
        qty = max(0.0, round(qty, self.cfg.symbol_qty_precision))
        # min notional (margin notionally = entry*qty/leverage)
        if (qty * entry / self.cfg.leverage) < self.cfg.min_notional_usdt:
            qty = round((self.cfg.min_notional_usdt * self.cfg.leverage) / entry, self.cfg.symbol_qty_precision)
        return qty

# ----------------------------------------------------------------------------
# Strategy (MTF + filters)
# ----------------------------------------------------------------------------
@dataclass
class StratConfig:
    symbol: str = "BTCUSDT"
    signal_tf: TF = "1m"
    trend_tf: TF = "15m"
    htf: TF = "1h"

    rsi_period: int = 14
    ema_fast: int = 21
    ema_slow: int = 50
    adx_period: int = 14
    atr_period: int = 14

    rsi_buy: int = 30
    rsi_sell: int = 70
    adx_min: float = 18.0

    atr_sl_mult: float = 1.5
    atr_tp_mult: float = 3.0

    cooldown_bars: int = 3
    min_atr_pct_of_price: float = 0.05 / 100.0

    session_start_utc: Optional[int] = None
    session_end_utc: Optional[int] = None

    # Extra trigger toggles & thresholds
    use_kdj: bool = True
    use_wr: bool = True
    use_trix: bool = True
    wr_buy: float = -80.0
    wr_sell: float = -20.0

    # AI controls
    use_ai: bool = True
    ai_min_samples: int = 800


class StrategyEngine:
    def __init__(self, sc: StratConfig, rc: RiskConfig):
        self.sc = sc
        self.rm = RiskManager(rc)
        self.ind = IndicatorEngine(sc.rsi_period, sc.ema_fast, sc.ema_slow, sc.atr_period, sc.adx_period)

        def _mlen(n):
            return int(max(100, n*6))
        self.win: Dict[TF, WindowState] = {
            sc.signal_tf: WindowState(sc.signal_tf, _mlen(max(sc.ema_slow, sc.rsi_period, sc.atr_period))),
            sc.trend_tf:  WindowState(sc.trend_tf,  _mlen(max(sc.ema_slow, sc.adx_period))),
            sc.htf:       WindowState(sc.htf,       _mlen(sc.ema_slow*2)),
        }
        self.cooldown = 0
        self.last_signal: Optional[Side] = None

    def update_bar_close(self, tf: TF, bar: Bar) -> Optional[Signal]:
        bar.ts = as_utc(bar.ts)
        self.win[tf].append(bar)

        if tf != self.sc.signal_tf:
            return None

        if not self.rm.hard_guard(bar.ts):
            return None

        if self.sc.session_start_utc is not None and self.sc.session_end_utc is not None:
            h = bar.ts.hour
            if not (self.sc.session_start_utc <= h < self.sc.session_end_utc):
                return None

        sdf = self.win[self.sc.signal_tf].to_df()
        tdf = self.win[self.sc.trend_tf].to_df()
        hdf = self.win[self.sc.htf].to_df()
        if min(len(sdf), len(tdf), len(hdf)) < 60:
            return None

        sdf = self.ind.compute_all(sdf)
        last = sdf.iloc[-1]
        prev = sdf.iloc[-2]

        # Volatility floor
        if (last.atr / max(1e-8, last.close)) < self.sc.min_atr_pct_of_price:
            return None

        # Trend TF indicators
        tdf = self.ind.compute_all(tdf)
        t_last = tdf.iloc[-1]
        trend_up = (t_last.ema_fast > t_last.ema_slow) and (t_last.adx >= self.sc.adx_min)
        trend_dn = (t_last.ema_fast < t_last.ema_slow) and (t_last.adx >= self.sc.adx_min)

        # HTF bias via SMA200 slope
        hdf = self.win[self.sc.htf].to_df()
        hdf["sma200"] = hdf["close"].rolling(200).mean()
        if len(hdf) < 202:
            return None
        h_last, h_prev = hdf.iloc[-1], hdf.iloc[-2]
        htf_up = h_last.sma200 > h_prev.sma200
        htf_dn = h_last.sma200 < h_prev.sma200

        # Triggers: RSI exit from OB/OS + EMA_fast cross, supported by Supertrend trend
        long_trig = (prev.rsi < self.sc.rsi_buy) and (last.rsi >= self.sc.rsi_buy) \
                    and (prev.close < prev.ema_fast) and (last.close > last.ema_fast) \
                    and (int(last.supertrend_trend) == 1)
        short_trig = (prev.rsi > self.sc.rsi_sell) and (last.rsi <= self.sc.rsi_sell) \
                     and (prev.close > prev.ema_fast) and (last.close < last.ema_fast) \
                     and (int(last.supertrend_trend) == -1)

        # Optional extra triggers: KDJ cross / WR thresholds / TRIX cross
        if self.sc.use_kdj:
            kdj_long = (prev.kdj_k < prev.kdj_d) and (last.kdj_k > last.kdj_d) and (last.kdj_k < 40)
            kdj_short = (prev.kdj_k > prev.kdj_d) and (last.kdj_k < last.kdj_d) and (last.kdj_k > 60)
            long_trig = long_trig or kdj_long
            short_trig = short_trig or kdj_short
        if self.sc.use_wr and not np.isnan(last.get("wr14", np.nan)):
            wr_long = last.wr14 <= self.sc.wr_buy
            wr_short = last.wr14 >= self.sc.wr_sell
            long_trig = long_trig or wr_long
            short_trig = short_trig or wr_short
        if self.sc.use_trix and "trix9_signal" in sdf.columns:
            trix_long = (prev.trix9 < prev.trix9_signal) and (last.trix9 > last.trix9_signal)
            trix_short = (prev.trix9 > prev.trix9_signal) and (last.trix9 < last.trix9_signal)
            long_trig = long_trig or trix_long
            short_trig = short_trig or trix_short

        want_long = long_trig and trend_up and htf_up
        want_short = short_trig and trend_dn and htf_dn

        if self.cooldown > 0:
            self.cooldown -= 1
            return None
        if self.last_signal == "LONG" and want_long:
            return None
        if self.last_signal == "SHORT" and want_short:
            return None

        if want_long:
            entry = round(float(last.close), self.rm.cfg.symbol_price_precision)
            sl = round(entry - self.sc.atr_sl_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            tp = round(entry + self.sc.atr_tp_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            qty = self.rm.position_size(entry, sl)
            if qty <= 0: return None
            self.last_signal = "LONG"; self.cooldown = self.sc.cooldown_bars
            return Signal(self.sc.symbol, "LONG", entry, sl, tp, qty,
                          reason="RSI up-cross + EMA_fast break + ST up; Trend/HTF aligned",
                          meta={"rsi": float(last.rsi), "atr": float(last.atr), "adx": float(t_last.adx)})

        if want_short:
            entry = round(float(last.close), self.rm.cfg.symbol_price_precision)
            sl = round(entry + self.sc.atr_sl_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            tp = round(entry - self.sc.atr_tp_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            qty = self.rm.position_size(entry, sl)
            if qty <= 0: return None
            self.last_signal = "SHORT"; self.cooldown = self.sc.cooldown_bars
            return Signal(self.sc.symbol, "SHORT", entry, sl, tp, qty,
                          reason="RSI down-cross + EMA_fast break + ST down; Trend/HTF aligned",
                          meta={"rsi": float(last.rsi), "atr": float(last.atr), "adx": float(t_last.adx)})
        return None

# Trailing stop utility -------------------------------------------------------
def atr_trailing_stop(side: Side, entry: float, best_price: float, atr: float,
                      be_rr: float = 1.0, trail_mult: float = 1.0) -> float:
    if side == "LONG":
        rr = (best_price - entry) / max(1e-8, atr)
        return max(entry, best_price - trail_mult * atr) if rr >= be_rr else entry - 1e-6
    else:
        rr = (entry - best_price) / max(1e-8, atr)
        return min(entry, best_price + trail_mult * atr) if rr >= be_rr else entry + 1e-6

# ----------------------------------------------------------------------------
# Binance Executor (Testnet/Mainnet) â€” bracket orders & settings
# ----------------------------------------------------------------------------
class BinanceExecutor:
    def __init__(self, api_key: str, api_secret: str, testnet: bool = True, dry_run: bool = True,
                 hedge_mode: bool = True, margin_type: str = "ISOLATED", leverage: int = 5,
                 working_type: str = "MARK_PRICE"):
        self.dry_run = dry_run
        self.testnet = testnet
        self.hedge_mode = hedge_mode
        self.margin_type = margin_type
        self.leverage = leverage
        self.working_type = working_type
        try:
            from binance.um_futures import UMFutures
        except Exception as e:
            logger.error("binance-connector missing: %s", e)
            UMFutures = None
        base_url = "https://testnet.binancefuture.com" if testnet else None
        self.client = None
        if UMFutures is not None:
            self.client = UMFutures(api_key=api_key, api_secret=api_secret, base_url=base_url)

    # Defensive account setup
    def ensure_account(self, symbol: str):
        if self.dry_run or self.client is None:
            return
        try:
            if self.hedge_mode:
                self.client.change_position_mode(dualSidePosition="true")
            else:
                self.client.change_position_mode(dualSidePosition="false")
        except Exception as e:
            logger.warning("position mode: %s", e)
        try:
            self.client.change_margin_type(symbol=symbol, marginType=self.margin_type)
        except Exception:
            pass
        try:
            self.client.change_leverage(symbol=symbol, leverage=self.leverage)
        except Exception:
            pass

    def place_bracket(self, symbol: str, side: Side, qty: float, entry: float, sl: float, tp: float):
        logger.info("[ORDER] %s %s qty=%.6f entry=%.4f sl=%.4f tp=%.4f", side, symbol, qty, entry, sl, tp)
        if self.dry_run or self.client is None:
            return {"dry_run": True}
        is_buy = side == "LONG"
        order_side = "BUY" if is_buy else "SELL"
        try:
            self.client.new_order(symbol=symbol, side=order_side, type="LIMIT",
                                  quantity=str(qty), price=str(entry), timeInForce="GTC",
                                  reduceOnly="false")
            # SL / TP as closePosition true (brackets)
            self.client.new_order(symbol=symbol, side=("SELL" if is_buy else "BUY"), type="STOP_MARKET",
                                  stopPrice=str(sl), closePosition="true", workingType=self.working_type)
            self.client.new_order(symbol=symbol, side=("SELL" if is_buy else "BUY"), type="TAKE_PROFIT_MARKET",
                                  stopPrice=str(tp), closePosition="true", workingType=self.working_type)
        except Exception as e:
            logger.error("order error: %s", e)

    def update_trailing_stop(self, symbol: str, side: Side, new_stop: float):
        """Naive trailing: place a fresh STOP_MARKET closePosition (some venues allow multiple). 
        In production you may cancel/replace previous stop to avoid duplicates."""
        logger.info("[TRAIL] %s %s new_stop=%.4f", side, symbol, new_stop)
        if self.dry_run or self.client is None:
            return {"dry_run": True}
        try:
            self.client.new_order(symbol=symbol, side=("SELL" if side == "LONG" else "BUY"), type="STOP_MARKET",
                                  stopPrice=str(new_stop), closePosition="true", workingType=self.working_type)
        except Exception as e:
            logger.error("trail error: %s", e)

# ----------------------------------------------------------------------------
# App wiring (example loop; integrate with your WS feed)
# ----------------------------------------------------------------------------
class App:
    def __init__(self, symbols: List[str], sc: StratConfig, rc: RiskConfig, execu: BinanceExecutor):
        self.symbols = symbols
        self.sc = sc
        self.rc = rc
        self.exec = execu
        self.engines: Dict[str, StrategyEngine] = {s: StrategyEngine(StratConfig(symbol=s, signal_tf=sc.signal_tf, trend_tf=sc.trend_tf, htf=sc.htf,
                                                                                 rsi_period=sc.rsi_period, ema_fast=sc.ema_fast, ema_slow=sc.ema_slow,
                                                                                 adx_period=sc.adx_period, atr_period=sc.atr_period,
                                                                                 rsi_buy=sc.rsi_buy, rsi_sell=sc.rsi_sell, adx_min=sc.adx_min,
                                                                                 atr_sl_mult=sc.atr_sl_mult, atr_tp_mult=sc.atr_tp_mult,
                                                                                 cooldown_bars=sc.cooldown_bars, min_atr_pct_of_price=sc.min_atr_pct_of_price,
                                                                                 session_start_utc=sc.session_start_utc, session_end_utc=sc.session_end_utc,
                                                                                 use_kdj=sc.use_kdj, use_wr=sc.use_wr, use_trix=sc.use_trix,
                                                                                 wr_buy=sc.wr_buy, wr_sell=sc.wr_sell), rc)
                                            for s in symbols}
        # Simple position tracker for trailing
        self.positions: Dict[str, Dict[str, dict]] = {s: {"LONG": None, "SHORT": None} for s in symbols}

    def on_bar(self, symbol: str, tf: TF, bar: Bar):
        sig = self.engines[symbol].update_bar_close(tf, bar)
        if sig:
            self.exec.ensure_account(symbol)
            self.exec.place_bracket(symbol, sig.side, sig.size, sig.price, sig.sl, sig.tp)

# ----------------------------------------------------------------------------
# Binance WebSocket streamer (klines, closed-only) -> feeds App.on_bar
# ----------------------------------------------------------------------------
class BinanceWS:
    def __init__(self, symbols: List[str], tfs: List[TF], app: App, testnet: bool = True):
        self.symbols = [s.lower() for s in symbols]  # binance stream wants lowercase
        self.tfs = tfs
        self.app = app
        self.testnet = testnet
        self.ws_apps: List[object] = []

    def _make_urls(self) -> List[str]:
        base = "wss://stream.binancefuture.com" if self.testnet else "wss://fstream.binance.com"
        streams = [f"{sym}@kline_{tf}" for sym in self.symbols for tf in self.tfs]
        MAX = 200
        urls = []
        for i in range(0, len(streams), MAX):
            chunk = "/".join(streams[i:i+MAX])
            urls.append(f"{base}/stream?streams={chunk}")
        return urls

    def start(self):
        import json, threading
        import websocket

        def make_app(url):
            def on_message(ws, message):
                try:
                    msg = json.loads(message)
                    if "data" not in msg:
                        return
                    d = msg["data"]
                    if d.get("e") != "kline":
                        return
                    k = d.get("k", {})
                    if not k.get("x", False):
                        return
                    symbol = d.get("s", "").upper()
                    tf = k.get("i")
                    bar = Bar(
                        ts=as_utc(k.get("T")/1000),
                        open=float(k.get("o")),
                        high=float(k.get("h")),
                        low=float(k.get("l")),
                        close=float(k.get("c")),
                        volume=float(k.get("q", 0.0)),
                    )
                    self.app.on_bar(symbol, tf, bar)
                except Exception as e:
                    logger.error("WS message error: %s", e)
            def on_error(ws, error):
                logger.error("WS error: %s", error)
            def on_close(ws, code, msg):
                logger.warning("WS closed: %s %s", code, msg)
            def on_open(ws):
                logger.info("WS connected: %s", url)
            return websocket.WebSocketApp(url, on_message=on_message, on_error=on_error, on_close=on_close, on_open=on_open)

        urls = self._make_urls()
        for url in urls:
            app = make_app(url)
            t = threading.Thread(target=lambda: app.run_forever(ping_interval=20, ping_timeout=10), daemon=True)
            t.start()
            self.ws_apps.append(app)
        while True:
            time.sleep(60)

# ----------------------------------------------------------------------------
# Backtest (CSV klines) â€” simple PnL with SL/TP & trailing
# ----------------------------------------------------------------------------
class Backtester:
    def __init__(self, sc: StratConfig, rc: RiskConfig):
        self.engine = StrategyEngine(sc, rc)

    def run_csv(self, path: str, tf: TF) -> Dict[str, float]:
        df = pd.read_csv(path)
        # Expect columns: ts/open/high/low/close/volume (ts in seconds or ISO)
        if 'ts' in df.columns:
            try:
                ts = pd.to_datetime(df['ts'], utc=True)
            except Exception:
                ts = pd.to_datetime(df['ts'], unit='s', utc=True)
        else:
            ts = pd.to_datetime(df['close_time'], unit='ms', utc=True)
        pnl = 0.0; wins=0; losses=0; trades=0
        pos=None
        for i in range(len(df)):
            bar = Bar(ts=ts.iloc[i], open=float(df['open'].iloc[i]), high=float(df['high'].iloc[i]),
                      low=float(df['low'].iloc[i]), close=float(df['close'].iloc[i]), volume=float(df.get('volume', pd.Series([0]*len(df))).iloc[i]))
            sig = self.engine.update_bar_close(tf, bar)
            if sig and pos is None:
                pos = {"side": sig.side, "entry": sig.price, "sl": sig.sl, "tp": sig.tp, "best": sig.price, "atr": sig.meta.get("atr", 0.0)}
                trades += 1
            if pos:
                if pos["side"] == "LONG":
                    pos["best"] = max(pos["best"], bar.close)
                    new_sl = atr_trailing_stop("LONG", pos["entry"], pos["best"], pos["atr"] or max(1e-8, bar.high-bar.low))
                    pos["sl"] = max(pos["sl"], new_sl)
                    if bar.low <= pos["sl"]:
                        pnl += (pos["sl"] - pos["entry"]) ; losses += int(pos["sl"]<pos["entry"]) ; wins += int(pos["sl"]>pos["entry"]) ; pos=None
                    elif bar.high >= pos["tp"]:
                        pnl += (pos["tp"] - pos["entry"]) ; wins += 1 ; pos=None
                else:
                    pos["best"] = min(pos["best"], bar.close)
                    new_sl = atr_trailing_stop("SHORT", pos["entry"], pos["best"], pos["atr"] or max(1e-8, bar.high-bar.low))
                    pos["sl"] = min(pos["sl"], new_sl)
                    if bar.high >= pos["sl"]:
                        pnl += (pos["entry"] - pos["sl"]) ; losses += int(pos["sl"]>pos["entry"]) ; wins += int(pos["sl"]<pos["entry"]) ; pos=None
                    elif bar.low <= pos["tp"]:
                        pnl += (pos["entry"] - pos["tp"]) ; wins += 1 ; pos=None
        return {"pnl": pnl, "trades": trades, "wins": wins, "losses": losses}

# ----------------------------------------------------------------------------
# CLI / bootstrap (live WS demo)
# ----------------------------------------------------------------------------
if __name__ == "__main__":
    load_dotenv()
    api_key = os.getenv("BINANCE_API_KEY", "")
    api_secret = os.getenv("BINANCE_API_SECRET", "")
    testnet = os.getenv("USE_TESTNET", "true").lower() == "true"
    hedge_mode = os.getenv("BINANCE_HEDGE_MODE", "true").lower() == "true"
    margin_type = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED")
    leverage = int(os.getenv("BINANCE_LEVERAGE", "5"))
    working_type = os.getenv("WORKING_TYPE", "MARK_PRICE")
    dry_run = os.getenv("DRY_RUN", "true").lower() == "true"

    # Symbols: ALL â†’ discover all USDT perpetuals
    symbols_env = os.getenv("SYMBOLS", "BTCUSDT")
    discover_all = symbols_env.strip().upper() in ("ALL", "*") or os.getenv("ALL_SYMBOLS", "false").lower()=="true"
    symbols = []
    if discover_all:
        try:
            from binance.um_futures import UMFutures
            base_url = "https://testnet.binancefuture.com" if testnet else None
            client = UMFutures(api_key=api_key, api_secret=api_secret, base_url=base_url)
            info = client.exchange_info()
            for s in info.get('symbols', []):
                if s.get('status') == 'TRADING' and s.get('quoteAsset') == 'USDT':
                    symbols.append(s.get('symbol'))
        except Exception as e:
            logger.error("symbol discovery failed: %s", e)
            symbols = ["BTCUSDT"]
    else:
        symbols = [s.strip().upper() for s in symbols_env.split(',') if s.strip()]

    # Timeframes: ALL â†’ subscribe to all Binance futures klines
    tfs_env = os.getenv("TIMEFRAMES", "ALL")
all_tfs = ["1m","3m","5m","15m","30m","1h","2h","4h","6h","8h","12h","1d","3d","1w","1M"]
if tfs_env.strip().upper() in ("ALL", "*"):
    tfs = all_tfs
else:
    tfs = [tf.strip() for tf in tfs_env.split(',') if tf.strip()]

# Build configs (Risk reads from .env)
rc = RiskConfig(
    account_equity_usdt=float(os.getenv("ACCOUNT_EQUITY", "5000")),
    leverage=leverage,
    min_notional_usdt=float(os.getenv("MIN_NOTIONAL_USDT", "10")),
    max_risk_pct_per_trade=float(os.getenv("MAX_RISK_PCT_PER_TRADE", "0.015")),
    max_daily_drawdown_pct=float(os.getenv("MAX_DAILY_DRAWDOWN", "0.02"))
)

# Optional: log level from .env
log_level = os.getenv("LOG_LEVEL", "INFO").upper()
try:
    logger.setLevel(getattr(logging, log_level))
except Exception:
    pass

sc = StratConfig(symbol=symbols[0], signal_tf="1m", trend_tf="15m", htf="1h")
executor = BinanceExecutor(api_key, api_secret, testnet=testnet, dry_run=dry_run,
                           hedge_mode=hedge_mode, margin_type=margin_type,
                           leverage=leverage, working_type=working_type)
app = App(symbols, sc, rc, executor)

ws = BinanceWS(symbols, tfs, app, testnet=testnet)
logger.info("Starting Binance WS | symbols=%s | tfs=%s | dry_run=%s", symbols, tfs, dry_run)
ws.start()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\strategic_ai_engine\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\strategic_ai_engine\adaptive_strategy.py
from typing import List, Dict, Callable


import torch
import torch.nn as nn

class NeuralIntegrator(nn.Module):
    def __init__(self):
        super(NeuralIntegrator, self).__init__()
        self.fc1 = nn.Linear(10, 50)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(50, 2)  # Karar yollarÄ±

    def forward(self, x):
        x = self.relu(self.fc1(x))
        decision = self.fc2(x)
        return decision



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\agent_commander.py
class AgentCommander:
    def __init__(self):
        self.modules = {
            "data": None,
            "strategy": None,
            "optimizer": None,
            "dashboard": None
        }

    def register_module(self, name, module):
        self.modules[name] = module

    def coordinate(self):
        # ModÃ¼ller arasÄ± iletiÅŸim ve kontrol
        signal = self.modules["data"].get_signal()
        decision = self.modules["strategy"].evaluate(signal)
        optimization = self.modules["optimizer"].analyze_module("strategy")

        self.modules["dashboard"].update_view(signal, decision, optimization)
        print("ðŸ§  AI Komutan: TÃ¼m modÃ¼ller senkronize edildi.")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\crypto_hunter.py
import hashlib, datetime

class CryptoHunter:
    def __init__(self):
        self.traces = []

    def scan_block(self, block_data):
        trace = hashlib.sha256(block_data.encode()).hexdigest()
        timestamp = datetime.datetime.now()
        self.traces.append({"hash": trace, "time": timestamp})
        print(f"ðŸŽ¯ Ä°z bulundu: {trace} - {timestamp}")

    def detect_anomalies(self):
        # Basit davranÄ±ÅŸ analizi
        suspicious = [t for t in self.traces if str(t["hash"]).startswith("00")]
        return suspicious



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\data_feed.py
import websocket
import requests
import schedule
import time

class DataFeed:
    def __init__(self, api_url, ws_url):
        self.api_url = api_url
        self.ws_url = ws_url

    def fetch_http_data(self):
        data = requests.get(self.api_url).json()
        # Gelen verileri analiz iÃ§in dÃ¶ndÃ¼r
        return data

    def start_websocket(self):
        def on_message(ws, message):
            # AnlÄ±k sinyal yakalama
            print("Websocket verisi:", message)
        
        ws = websocket.WebSocketApp(self.ws_url, on_message=on_message)
        ws.run_forever()

    def run_scheduled_tasks(self):
        schedule.every(5).seconds.do(lambda: print(self.fetch_http_data()))
        while True:
            schedule.run_pending()
            time.sleep(1)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\deep_crypto_hunter.py
import torch
import torch.nn as nn

class DeepCryptoHunter(nn.Module):
    def __init__(self):
        super(DeepCryptoHunter, self).__init__()
        self.fc1 = nn.Linear(64, 128)
        self.relu = nn.LeakyReLU()
        self.fc2 = nn.Linear(128, 2)  # Tehdit / Temiz

    def forward(self, x):
        x = self.relu(self.fc1(x))
        prediction = self.fc2(x)
        return prediction

    def trace_hash(self, data):
        hashed = torch.tensor([ord(c) % 64 for c in data[:64]], dtype=torch.float32)
        decision = self.forward(hashed)
        status = "ðŸ›¡ï¸ GÃ¼venli" if decision[0] < decision[1] else "âš ï¸ ÅžÃ¼pheli"
        print(f"{status} | Tahmin: {decision.tolist()}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\log_to_chain.py
import json
from datetime import datetime

class ChainLogger:
    def __init__(self, log_file='activity_chain.json'):
        self.log_file = log_file

    def log_event(self, event_type, module, details):
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "event": event_type,
            "module": module,
            "details": details
        }
        with open(self.log_file, 'a') as f:
            f.write(json.dumps(log_entry) + "\n")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\neuro_sync.py
import torch
import torch.nn as nn

class NeuralIntegrator(nn.Module):
    def __init__(self):
        super(NeuralIntegrator, self).__init__()
        self.fc1 = nn.Linear(10, 50)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(50, 2)  # Karar yollarÄ±

    def forward(self, x):
        x = self.relu(self.fc1(x))
        decision = self.fc2(x)
        return decision



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\optimizer.py
import psutil

class CodeOptimizer:
    def __init__(self, module_name):
        self.module = module_name

    def check_performance(self):
        cpu = psutil.cpu_percent()
        ram = psutil.virtual_memory().percent

        if cpu > 80 or ram > 80:
            return f"{self.module}: YÃ¼ksek kaynak tÃ¼ketimi tespit edildi. Optimize edilmeli."
        return f"{self.module}: Performans normal."

    def suggest_optimization(self):
        analysis = self.check_performance()
        if "Optimize" in analysis:
            return "Kodun async yapÄ±lmasÄ±, dÃ¶ngÃ¼lerin sadeleÅŸtirilmesi veya cache eklenmesi Ã¶nerilir."
        else:
            return "Kod ÅŸu anda verimli Ã§alÄ±ÅŸÄ±yor."



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\strategy_engine.py
def evaluate_signal(signal_data):
    if signal_data['volume'] > THRESHOLD and signal_data['sentiment'] > 0.7:
        return "BUY"
    elif signal_data['volume'] < LOW_THRESHOLD:
        return "HOLD"
    else:
        return "SELL"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\tactical_decision_simulator.py
def run_simulation(strategies, market_data):
    results = {}
    for name, strategy in strategies.items():
        score = 0
        for data in market_data:
            action = strategy(data)
            if action == data["optimal"]:
                score += 1
        results[name] = round(score / len(market_data), 3)
    return results



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\trainer.py
class SignalTrainer:
    def __init__(self):
        self.model = SomeRLModel()

    def train_on_result(self, result):
        reward = calculate_reward(result)
        self.model.update(reward)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\test_modules.py\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\test_modules.py\test_modules.py
from emotion_sync_adapter import sync_emotion_to_task

task = "Yeni Proje BaÅŸlat"
emotion = "ðŸ’¡ Ä°lham"

print(sync_emotion_to_task(emotion, task))



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\adaptive_signal_trainer.py
class SignalTrainer:
    def __init__(self):
        self.performance_log = {}

    def update_performance(self, wallet, signal, outcome):
        if wallet not in self.performance_log:
            self.performance_log[wallet] = []
        self.performance_log[wallet].append({
            "signal": signal,
            "outcome": outcome
        })

    def optimize_signal(self, wallet):
        log = self.performance_log.get(wallet, [])
        if not log:
            return "HOLD"

        buy_success = sum(1 for entry in log if entry["signal"] == "BUY" and entry["outcome"] == "success")
        buy_total = sum(1 for entry in log if entry["signal"] == "BUY")
        success_rate = buy_success / buy_total if buy_total else 0

        return "BUY" if success_rate > 0.6 else "HOLD"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\adaptive_task_engine.py
def adaptive_task_engine(logs, previous_success, boost_emotion="ðŸ’¡ Ä°lham"):
    task_scores = {}
    for log in logs:
        task = log["task_id"]
        strength = log["feeling_strength"]
        emotion = log["emotion"]

        # Duygu gÃ¼cÃ¼ + geÃ§miÅŸ baÅŸarÄ±ya gÃ¶re puanlama
        base_score = strength
        if previous_success.get(task, False):
            base_score += 20  # baÅŸarÄ± bonusu

        if emotion == boost_emotion:
            base_score *= 1.3  # motivasyon etkisi

        task_scores[task] = round(base_score, 2)

    # GÃ¶revleri en yÃ¼ksek puana gÃ¶re sÄ±rala
    sorted_tasks = sorted(task_scores.items(), key=lambda x: x[1], reverse=True)
    return sorted_tasks



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\adaptive_trader_gui.py
from PyQt5 import QtWidgets, QtCore

class TraderDashboard(QtWidgets.QWidget):
    def __init__(self, user_profile):
        super().__init__()
        self.setWindowTitle("ðŸ“Š Kamal Trading Panel")
        self.layout = QtWidgets.QVBoxLayout()

        self.label = QtWidgets.QLabel(f"HoÅŸ geldin Komutan {user_profile['name']}")
        self.layout.addWidget(self.label)

        self.risk_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.risk_slider.setMinimum(1)
        self.risk_slider.setMaximum(10)
        self.risk_slider.setValue(user_profile["risk_level"])
        self.layout.addWidget(QtWidgets.QLabel("âš™ï¸ Risk Seviyesi"))
        self.layout.addWidget(self.risk_slider)

        self.signal_box = QtWidgets.QTextEdit()
        self.signal_box.setReadOnly(True)
        self.layout.addWidget(QtWidgets.QLabel("ðŸ“¡ Gelen Sinyaller"))
        self.layout.addWidget(self.signal_box)

        self.setLayout(self.layout)
        self.resize(400, 300)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\anamaly_trade_orchestrator.py
def trade_orchestrator(chainsignals, risk_threshold=0.6):
    trades = []
    for signal in chainsignals:
        asset = signal["asset"]
        volatility = signal["volatility"]
        momentum = signal["momentum"]
        anomaly_score = signal["anomaly_score"]

        risk = round(volatility * anomaly_score * (1 - momentum), 2)

        if risk > risk_threshold:
            decision = f"â›” {asset}: Ticaret AskÄ±ya AlÄ±ndÄ± (Risk={risk})"
        else:
            decision = f"âœ… {asset}: Ä°ÅŸlem AktifleÅŸtirildi (Risk={risk})"
        
        trades.append(decision)
    return trades



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\autonomous_trade_initiator.py
import random

def generate_trade_signal(predictions):
    signals = {}
    for wallet, note in predictions.items():
        if "bÃ¼yÃ¼k hareket" in note:
            signals[wallet] = {
                "action": "BUY",
                "confidence": round(random.uniform(0.8, 0.95), 2),
                "leverage": 3
            }
        else:
            signals[wallet] = {
                "action": "HOLD",
                "confidence": round(random.uniform(0.5, 0.7), 2),
                "leverage": 1
            }
    return signals



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\chain_listener.py
from web3 import Web3
import threading

eth_node = "wss://mainnet.infura.io/ws/v3/YOUR_PROJECT_ID"
web3 = Web3(Web3.WebsocketProvider(eth_node))

def handle_block(block_hash):
    block = web3.eth.get_block(block_hash, full_transactions=True)
    print(f"ðŸ§¿ Yeni Blok: {block.number} â€” Ä°ÅŸlem SayÄ±sÄ±: {len(block.transactions)}")

def listener():
    print("ðŸ“¡ Ethereum zincir dinleyicisi baÅŸlatÄ±lÄ±yor...")
    sub = web3.eth.subscribe("newHeads", {}, lambda event: handle_block(event['hash']))

listener_thread = threading.Thread(target=listener)
listener_thread.start()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\chain_momentum_bot.py
class ChainMomentumBot:
    def __init__(self, transactions):
        self.transactions = transactions
        self.predictions = predict_wallet_behavior(transactions)
        self.signals = generate_trade_signal(self.predictions)
        self.executed_trades = []

    def execute_trades(self):
        for wallet, signal in self.signals.items():
            action = signal["action"]
            confidence = signal["confidence"]
            if action == "BUY" and confidence > 0.85:
                self.executed_trades.append({
                    "wallet": wallet,
                    "action": action,
                    "confidence": confidence
                })
    
    def react_to_live_tx(self, tx):
        eth_value = Web3.fromWei(tx["value"], 'ether')
        if eth_value > 5:
            print(f"ðŸš¨ CanlÄ± Tepki: {tx['from']} âž¡ï¸ {tx['to']} | DeÄŸer: {eth_value} ETH")
            self.executed_trades.append({
                "wallet": tx["to"],
                "action": "BUY",
                "confidence": 0.9
            })



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\chain_sentiment_translator.py
def translate_sentiment(posts):
    sentiment_map = {
        "bullish": 1,
        "bearish": -1,
        "neutral": 0
    }

    asset_sentiments = {}
    for post in posts:
        asset = post["asset"]
        sentiment = sentiment_map.get(post["sentiment"], 0)

        if asset not in asset_sentiments:
            asset_sentiments[asset] = 0
        asset_sentiments[asset] += sentiment

    sorted_assets = sorted(asset_sentiments.items(), key=lambda x: x[1], reverse=True)
    return sorted_assets



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\cognitive_flow_optimizer.py
if emotion == "ðŸ”¥ Tutku" and focus_level > 75:
    flow_mode = "ðŸŽ¯ Hedefe kilitlen â€“ Kod akÄ±ÅŸÄ± baÅŸlasÄ±n!"
else:
    flow_mode = "ðŸŒ™ YavaÅŸ mod â€“ HazÄ±rlÄ±k aÅŸamasÄ±"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\cryptXSentinel.py
"""YÃ¼ksek GÃ¼venlikli Kripto Veri TaramasÄ± ve Ä°stihbarat Filtreleme"""

class CryptXSentinel:
    def __init__(self):
        self.logs = []

    def record_signal(self, origin, hash_signature, entropy, timestamp):
        self.logs.append({
            "origin": origin,
            "hash_signature": hash_signature,
            "entropy": entropy,
            "timestamp": timestamp
        })

    def shield_scan(self):
        return [
            log for log in self.logs
            if log["entropy"] > 0.85 and log["origin"] != "authorized_zone"
        ]

    def stealth_metric(self):
        import statistics
        entropy_values = [log["entropy"] for log in self.logs]
        return round(statistics.median(entropy_values), 4)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\data_reinforcement_unit.py
def reinforce_from_logs(logs):
    patterns = detect_efficiency_patterns(logs)
    return f"ðŸ“ˆ Ã–ÄŸrenildi: {patterns} â€” Yeni gÃ¶rev Ã¶nerilecek"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\emotion_sync_adapter.py
if current_mission == "Yeni Proje BaÅŸlat":
    emotion_check = "âœ… Uyumluysa senkronize et, deÄŸilse beklet"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\emotive_flux_visualizer.py
import matplotlib.pyplot as plt
from datetime import datetime

def visualize_emotions(logs):
    times = [datetime.strptime(log["timestamp"], "%Y-%m-%dT%H:%M") for log in logs]
    strengths = [log["feeling_strength"] for log in logs]
    emotions = [log["emotion"] for log in logs]

    plt.figure(figsize=(10, 6))
    plt.plot(times, strengths, marker='o', linestyle='-', color='skyblue')
    for i, emotion in enumerate(emotions):
        plt.text(times[i], strengths[i]+2, emotion, fontsize=10, ha='center')

    plt.title("ðŸ§­ Duygu AkÄ±ÅŸÄ± Zaman Ã‡izelgesi", fontsize=14)
    plt.xlabel("â± Zaman")
    plt.ylabel("âš¡ Duygu GÃ¼cÃ¼")
    plt.grid(True)
    plt.tight_layout()
    plt.show()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\futures_bot.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\galactic_emotion_pluse.py
"""Galaktik GÃ¶rev AnalitiÄŸi ve Ã‡ok KatmanlÄ± Duygu Dinamikleri"""

import datetime

class GalacticEngine:
    def __init__(self):
        self.records = []

    def log_event(self, task_id, emotion, strength, timestamp=None):
        if not timestamp:
            timestamp = datetime.datetime.now()
        self.records.append({
            "task_id": task_id,
            "emotion": emotion,
            "strength": strength,
            "timestamp": timestamp
        })

    def deep_scan(self):
        from collections import defaultdict
        import statistics

        emotion_clusters = defaultdict(list)
        for record in self.records:
            emotion_clusters[record["emotion"]].append(record["strength"])

        report = {}
        for emotion, values in emotion_clusters.items():
            report[emotion] = {
                "average_strength": round(statistics.mean(values), 2),
                "peak_strength": max(values),
                "count": len(values)
            }

        return report


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\insight_predictor.py
if fatigue_rising and emotional_drop:
    prediction = "âš ï¸ OlasÄ± tÄ±kanma â€“ Dinlenme Ã¶nerisi"
else:
    prediction = "ðŸ”® AÃ§Ä±lÄ±m yaklaÅŸÄ±yor â€“ GÃ¶rev Ã¶ner"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\liquidity_wave_detector.py
def detect_liquidity_wave(blocks, threshold=3):
    wave_alerts = []
    for i in range(1, len(blocks)):
        prev_volume = blocks[i - 1]["volume"]
        curr_volume = blocks[i]["volume"]
        delta = curr_volume - prev_volume

        if delta > threshold * prev_volume:
            wave_alerts.append({
                "block": blocks[i]["number"],
                "delta": delta,
                "risk_level": "HIGH",
                "message": f"âš ï¸ Likidite DalgasÄ± AlgÄ±landÄ±: Blok {blocks[i]['number']} | ArtÄ±ÅŸ: {delta}"
            })
    return wave_alerts



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\market_shock_predictor.py
from textblob import TextBlob

def predict_market_impact(news_feed):
    impact_scores = []
    for news in news_feed:
        sentiment = TextBlob(news["content"]).sentiment.polarity
        if sentiment > 0.3:
            impact_scores.append({
                "source": news["source"],
                "impact": "Bullish",
                "score": round(sentiment, 2)
            })
        elif sentiment < -0.3:
            impact_scores.append({
                "source": news["source"],
                "impact": "Bearish",
                "score": round(sentiment, 2)
            })
        else:
            impact_scores.append({
                "source": news["source"],
                "impact": "Neutral",
                "score": round(sentiment, 2)
            })
    return impact_scores



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\mission_trigger_resolver.py
def resolve_triggers(logs):
    triggers = {}
    for log in logs:
        emotion = log["emotion"]
        task = log["task_id"]
        if emotion not in triggers:
            triggers[emotion] = []
        triggers[emotion].append(task)
    return triggers



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\multi_chain_oracle.py
def multi_chain_oracle(chain_data):
    unified_signals = {}
    for chain_name, signals in chain_data.items():
        for asset, signal in signals.items():
            if asset not in unified_signals:
                unified_signals[asset] = {"BUY": 0, "HOLD": 0, "SELL": 0}
            unified_signals[asset][signal] += 1

    final_decisions = {}
    for asset, votes in unified_signals.items():
        decision = max(votes, key=votes.get)
        confidence = round(votes[decision] / sum(votes.values()), 2)
        final_decisions[asset] = {
            "decision": decision,
            "confidence": confidence
        }
    return final_decisions



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\neural_tactical_engine.py
"""Stratejik GÃ¶rev Analizi ve Veri Ä°stihbaratÄ±"""

class StrategicProject:
    def __init__(self):
        self.tasks = []
    
    def add_task(self, task_id, emotion, strength, timestamp):
        self.tasks.append({
            "task_id": task_id,
            "emotion": emotion,
            "strength": strength,
            "timestamp": timestamp
        })

    def analyze(self):
        from collections import Counter
        import statistics

        summary = {}
        task_counter = Counter([task["task_id"] for task in self.tasks])
        strength_values = [task["strength"] for task in self.tasks]

        summary["top_tasks"] = task_counter.most_common(3)
        summary["average_strength"] = round(statistics.mean(strength_values), 3)
        summary["max_strength"] = max(strength_values)

        return summary



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\next_mission_oracle.py
def suggest_mission(logs, intuition_map):
    for log in logs:
        task = log["task_id"]
        if intuition_map[task] == "ðŸ”® FÄ±rsat Penceresi":
            print(f"âœ… GÃ¶rev {task}: Åžimdi BaÅŸla! Ä°lham zirvede.")
        elif intuition_map[task] == "âš ï¸ KararsÄ±zlÄ±k Engeli":
            print(f"ðŸ§˜ GÃ¶rev {task}: Beklet â€“ Ã–nce zihinsel rahatlama gerek.")
        else:
            print(f"ðŸ“Œ GÃ¶rev {task}: NÃ¶tr verim â€“ Stratejik zamanlama uygula.")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\Nova_Strategos_v10_offchain.py
# NovaStrategosPrime_v10.py
# Ultra hibrit, pro-elit, AI destekli duygu-strateji paneli (tek dosya)

import sys, csv, json, random, statistics, os
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from PyQt5 import QtWidgets, QtCore

# ====== Veri Modeli ======

@dataclass
class EmotionLog:
    task_id: str
    emotion: str
    feeling_strength: float
    timestamp: datetime

# ====== YardÄ±mcÄ±lar ======

class NotificationBus:
    def send(self, message: str):
        # Gerekirse burada Telegram/Email entegrasyonu baÄŸlanabilir
        print(f"[NOTIFY] {message}")

class Persist:
    def __init__(self, path: str = "nova_config.json"):
        self.path = path
        self.data = {}
        self.load()

    def load(self):
        if os.path.exists(self.path):
            try:
                with open(self.path, "r", encoding="utf-8") as f:
                    self.data = json.load(f)
            except Exception:
                self.data = {}
        else:
            self.data = {}

    def save(self):
        try:
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump(self.data, f, ensure_ascii=False, indent=2, default=str)
        except Exception as e:
            print(f"[Persist] Kaydetme hatasÄ±: {e}")

# ====== CSV KÃ¶prÃ¼sÃ¼ ======

class CSVBridge:
    @staticmethod
    def load_logs(path: str) -> List[EmotionLog]:
        logs = []
        with open(path, "r", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            for row in reader:
                try:
                    ts = row.get("timestamp") or datetime.utcnow().isoformat()
                    logs.append(
                        EmotionLog(
                            task_id=row["task_id"],
                            emotion=row.get("emotion", "Neutral"),
                            feeling_strength=float(row["feeling_strength"]),
                            timestamp=datetime.fromisoformat(ts.replace("Z",""))
                        )
                    )
                except Exception:
                    # HatalÄ± satÄ±rlar atlanÄ±r
                    continue
        return logs

    @staticmethod
    def save_report(path: str, report: Dict[str, Any]):
        keys = ["task_id", "avg", "max", "vol", "risk", "count"]
        with open(path, "w", encoding="utf-8", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(keys)
            for task, m in report.items():
                writer.writerow([task, m["avg"], m["max"], m["vol"], m["risk"], m["count"]])

# ====== Ultra Hibrit Ã‡ekirdek ======

class NovaEmotionStrategos:
    def __init__(self):
        self.logs: List[EmotionLog] = []
        self._cache_report: Optional[Dict[str, Any]] = None

    def ingest(self, log: EmotionLog):
        self.logs.append(log)
        self._cache_report = None  # cache invalidation

    def _series(self, task_id: str) -> List[float]:
        return [l.feeling_strength for l in self.logs if l.task_id == task_id]

    def analyze(self) -> Dict[str, Any]:
        if self._cache_report is not None:
            return self._cache_report
        report = {}
        by_task = {}
        for l in self.logs:
            by_task.setdefault(l.task_id, []).append(l.feeling_strength)

        for task, strengths in by_task.items():
            avg = round(statistics.mean(strengths), 2) if strengths else 0
            mx = max(strengths) if strengths else 0
            vol = round(statistics.stdev(strengths), 2) if len(strengths) > 1 else 0
            risk = self.classify_risk(avg, vol)
            report[task] = {"avg": avg, "max": mx, "vol": vol, "risk": risk, "count": len(strengths)}
        self._cache_report = report
        return report

    def classify_risk(self, avg: float, vol: float) -> str:
        if avg >= 7 and vol >= 2:
            return "YÃ¼ksek"
        if avg >= 5:
            return "Orta"
        return "DÃ¼ÅŸÃ¼k"

class SignalEngine:
    def __init__(self, cooldown_sec: int = 20):
        self.last_signal_at: Dict[str, datetime] = {}
        self.cooldown = timedelta(seconds=cooldown_sec)

    def can_signal(self, task_id: str) -> bool:
        t = self.last_signal_at.get(task_id)
        return (t is None) or (datetime.utcnow() - t >= self.cooldown)

    def mark_signaled(self, task_id: str):
        self.last_signal_at[task_id] = datetime.utcnow()

    def generate(self, task_id: str, metrics: Dict[str, Any], user_risk: int) -> str:
        risk = metrics["risk"]
        avg, vol = metrics["avg"], metrics["vol"]
        # KullanÄ±cÄ± risk seviyesi eÅŸikleri kaydÄ±rÄ±r
        sens = max(0.5, min(1.5, 1 + (user_risk - 5) * 0.08))  # 1 = nÃ¶tr
        score = avg * 0.6 + vol * 0.4
        score *= sens

        if risk == "YÃ¼ksek" and score > 7:
            return f"âš ï¸ {task_id}: Duygusal stres yÃ¼ksek (avg:{avg}, vol:{vol}). HÄ±zlÄ± mÃ¼dahale Ã¶nerilir."
        if risk == "Orta" and score > 5.5:
            return f"ðŸ” {task_id}: Dalgalanma mevcut (avg:{avg}, vol:{vol}). YakÄ±n izleme Ã¶nerilir."
        return f"âœ… {task_id}: Stabil (avg:{avg}, vol:{vol})."

class RiskManager:
    def size(self, confidence: float, user_risk: int) -> Dict[str, Any]:
        # SimÃ¼lasyon: pozisyon boyutu ve SL/TP Ã¶nerisi (gerÃ§ek iÅŸlem yapmaz)
        base = min(max(confidence, 0.5), 0.95)
        risk_factor = 0.5 + (user_risk / 20)  # 0.5..1.0
        size = round(1000 * base * risk_factor, 0)
        sl = round(1.0 + (1.0 - base) * 0.5, 3)   # 1.0xâ€“1.25x
        tp = round(1.0 + base * 1.2, 3)          # 1.6xâ€™a kadar
        return {"size": size, "sl_mult": sl, "tp_mult": tp}

# ====== CanlÄ± AkÄ±ÅŸ SimÃ¼latÃ¶rÃ¼ ======

class StreamSimulator(QtCore.QObject):
    newLog = QtCore.pyqtSignal(EmotionLog)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.timer = QtCore.QTimer(self)
        self.timer.timeout.connect(self._tick)
        self.tasks = ["ALPHA", "BETA", "GAMMA"]

    def start(self, interval_ms=1500):
        self.timer.start(interval_ms)

    def stop(self):
        self.timer.stop()

    def _tick(self):
        task = random.choice(self.tasks)
        emotion = random.choice(["Stress", "Focus", "Anxiety", "Calm"])
        strength = round(random.uniform(3.0, 9.5), 2)
        log = EmotionLog(task, emotion, strength, datetime.utcnow())
        self.newLog.emit(log)

# ====== UI Panel ======

class TraderDashboard(QtWidgets.QWidget):
    def __init__(self, user_profile: Dict[str, Any], core: NovaEmotionStrategos,
                 signals: SignalEngine, risk: RiskManager, persist: Persist, bus: NotificationBus):
        super().__init__()
        self.setWindowTitle("ðŸ“Š Nova Strategos Prime â€” Zirve Panel")
        self.core = core
        self.signals = signals
        self.risk = risk
        self.persist = persist
        self.bus = bus

        self.layout = QtWidgets.QVBoxLayout(self)
        # Ãœst baÅŸlÄ±k
        self.title = QtWidgets.QLabel(f"HoÅŸ geldin Komutan {user_profile['name']}")
        self.title.setStyleSheet("font-weight:600;font-size:16px;")
        self.layout.addWidget(self.title)

        # Risk seviyesi
        self.layout.addWidget(QtWidgets.QLabel("âš™ï¸ Risk Seviyesi"))
        self.risk_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.risk_slider.setMinimum(1); self.risk_slider.setMaximum(10)
        self.risk_slider.setValue(user_profile.get("risk_level", 5))
        self.layout.addWidget(self.risk_slider)

        # Butonlar
        btns = QtWidgets.QHBoxLayout()
        self.btn_load = QtWidgets.QPushButton("ðŸ“¥ CSV YÃ¼kle")
        self.btn_export = QtWidgets.QPushButton("ðŸ“¤ Raporu CSV'ye Yaz")
        self.btn_analyze = QtWidgets.QPushButton("ðŸ§  Analiz Yap")
        self.btn_stream = QtWidgets.QPushButton("â–¶ï¸ CanlÄ± AkÄ±ÅŸ")
        self.btn_stop = QtWidgets.QPushButton("â¸ï¸ Durdur")
        btns.addWidget(self.btn_load); btns.addWidget(self.btn_export)
        btns.addWidget(self.btn_analyze); btns.addWidget(self.btn_stream); btns.addWidget(self.btn_stop)
        self.layout.addLayout(btns)

        # Sinyaller ve metrikler
        self.layout.addWidget(QtWidgets.QLabel("ðŸ“¡ Gelen Sinyaller"))
        self.signal_box = QtWidgets.QTextEdit(); self.signal_box.setReadOnly(True)
        self.layout.addWidget(self.signal_box)

        self.layout.addWidget(QtWidgets.QLabel("ðŸ“ˆ Metrikler"))
        self.metrics = QtWidgets.QTextEdit(); self.metrics.setReadOnly(True)
        self.layout.addWidget(self.metrics)

        # Durum Ã§ubuÄŸu
        self.status = QtWidgets.QLabel("HazÄ±r.")
        self.layout.addWidget(self.status)

        # BaÄŸlantÄ±lar
        self.btn_load.clicked.connect(self.on_load_csv)
        self.btn_export.clicked.connect(self.on_export_csv)
        self.btn_analyze.clicked.connect(self.on_analyze)
        self.btn_stream.clicked.connect(self.on_stream)
        self.btn_stop.clicked.connect(self.on_stop)
        self.risk_slider.valueChanged.connect(self.on_risk_change)

        # SimÃ¼latÃ¶r
        self.sim = StreamSimulator(self)
        self.sim.newLog.connect(self.on_new_log)

        # KullanÄ±cÄ± profili
        self.user_profile = user_profile

        # Ä°lk durum
        self.refresh_metrics()

    # --- Event handlers ---

    def on_risk_change(self, v: int):
        self.user_profile["risk_level"] = v
        self.persist.data["user_profile"] = self.user_profile
        self.persist.save()
        self.status.setText(f"Risk seviyesi gÃ¼ncellendi: {v}")

    def on_load_csv(self):
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "CSV DosyasÄ± SeÃ§", "", "CSV Files (*.csv)")
        if not path: 
            return
        logs = CSVBridge.load_logs(path)
        for l in logs:
            self.core.ingest(l)
        self.refresh_metrics()
        self.status.setText(f"{len(logs)} kayÄ±t yÃ¼klendi.")
        self.bus.send(f"{len(logs)} CSV kaydÄ± panele aktarÄ±ldÄ±.")

    def on_export_csv(self):
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Raporu Kaydet", "nova_report.csv", "CSV Files (*.csv)")
        if not path:
            return
        report = self.core.analyze()
        CSVBridge.save_report(path, report)
        self.status.setText(f"Rapor kaydedildi: {os.path.basename(path)}")
        self.bus.send("Rapor CSVâ€™ye yazÄ±ldÄ±.")

    def on_analyze(self):
        self.refresh_metrics()
        self.emit_signals()

    def on_stream(self):
        self.sim.start(1200)
        self.status.setText("CanlÄ± akÄ±ÅŸ baÅŸlatÄ±ldÄ±.")
        self.bus.send("SimÃ¼lasyon akÄ±ÅŸÄ± aktif.")

    def on_stop(self):
        self.sim.stop()
        self.status.setText("AkÄ±ÅŸ durduruldu.")
        self.bus.send("SimÃ¼lasyon akÄ±ÅŸÄ± durduruldu.")

    def on_new_log(self, log: EmotionLog):
        self.core.ingest(log)
        # AnlÄ±k mikro-sinyal (cooldown kontrolÃ¼)
        rep = self.core.analyze()
        m = rep.get(log.task_id)
        if m and self.signals.can_signal(log.task_id):
            msg = self.signals.generate(log.task_id, m, self.user_profile["risk_level"])
            self.signal_box.append(f"{datetime.utcnow().isoformat()} â€” {msg}")
            self.signals.mark_signaled(log.task_id)
        # Metrikleri periyodik gÃ¼ncelle
        self.refresh_metrics()

    # --- YardÄ±mcÄ±lar ---

    def refresh_metrics(self):
        rep = self.core.analyze()
        lines = []
        for task, m in sorted(rep.items()):
            lines.append(f"[GÃ¶rev: {task}] avg:{m['avg']} | max:{m['max']} | vol:{m['vol']} | risk:{m['risk']} | n:{m['count']}")
        self.metrics.setText("\n".join(lines) if lines else "HenÃ¼z veri yok.")

    def emit_signals(self):
        rep = self.core.analyze()
        for task_id, m in rep.items():
            if self.signals.can_signal(task_id):
                msg = self.signals.generate(task_id, m, self.user_profile["risk_level"])
                # Pozisyon boyutu Ã¶nerisi (simÃ¼lasyon)
                conf = self._confidence_from_metrics(m)
                sizing = self.risk.size(conf, self.user_profile["risk_level"])
                enriched = f"{msg} | size:{sizing['size']} | SLx:{sizing['sl_mult']} | TPx:{sizing['tp_mult']}"
                self.signal_box.append(f"{datetime.utcnow().isoformat()} â€” {enriched}")
                self.signals.mark_signaled(task_id)

    def _confidence_from_metrics(self, m: Dict[str, Any]) -> float:
        # Basit gÃ¼ven skoru: dÃ¼ÅŸÃ¼k risk -> daha yÃ¼ksek gÃ¼ven
        base = 0.7 if m["risk"] == "DÃ¼ÅŸÃ¼k" else 0.6 if m["risk"] == "Orta" else 0.55
        adj = max(0.9, min(1.1, 1 - (m["vol"] / 10)))
        return round(base * adj, 2)

# ====== Uygulama GiriÅŸi ======

def main():
    # VarsayÄ±lan profil
    persist = Persist()
    user_profile = persist.data.get("user_profile") or {"name": "Kamal", "risk_level": 6}

    core = NovaEmotionStrategos()
    signals = SignalEngine(cooldown_sec=20)
    risk = RiskManager()
    bus = NotificationBus()

    app = QtWidgets.QApplication(sys.argv)
    panel = TraderDashboard(user_profile, core, signals, risk, persist, bus)

    # Ã–rnek baÅŸlangÄ±Ã§ verisi
    seed = [
        EmotionLog("ALPHA", "Stress", 7.8, datetime.utcnow()),
        EmotionLog("ALPHA", "Anxiety", 6.9, datetime.utcnow()),
        EmotionLog("BETA", "Focus", 4.2, datetime.utcnow()),
        EmotionLog("GAMMA", "Calm", 3.8, datetime.utcnow()),
    ]
    for l in seed: core.ingest(l)

    panel.resize(720, 600)
    panel.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\Nova_StrategosPrime_v12_onchain.py
# NovaStrategosPrime_v12_onchain.py
# Ultra hibrit ALTRA AI + On-Chain entegrasyonlu tek dosya zirve paneli

import sys, csv, json, os, math, random, statistics, hashlib, webbrowser
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from PyQt5 import QtWidgets, QtCore, QtGui

# --- Web3 isteÄŸe baÄŸlÄ± ---
try:
    from web3 import Web3
    from eth_account import Account
    from eth_account.messages import encode_structured_data
    HAS_WEB3 = True
except Exception:
    HAS_WEB3 = False

# =========================
# Veri modeli
# =========================

@dataclass
class EmotionLog:
    task_id: str
    emotion: str
    feeling_strength: float
    timestamp: datetime

# =========================
# YardÄ±mcÄ±lar / KalÄ±cÄ±lÄ±k
# =========================

class NotificationBus:
    def __init__(self, sound_on=True):
        self.sound_on = sound_on
    def send(self, msg: str, widget: Optional[QtWidgets.QWidget]=None):
        ts = datetime.utcnow().strftime("%H:%M:%S")
        print(f"[{ts}] {msg}")
        if widget and self.sound_on:
            QtWidgets.QApplication.beep()

class Persist:
    def __init__(self, path="nova_config.json"):
        self.path = path
        self.data: Dict[str, Any] = {}
        self.load()
    def load(self):
        if os.path.exists(self.path):
            try:
                with open(self.path, "r", encoding="utf-8") as f:
                    self.data = json.load(f)
            except Exception:
                self.data = {}
    def save(self):
        try:
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump(self.data, f, ensure_ascii=False, indent=2, default=str)
        except Exception as e:
            print(f"[Persist] save error: {e}")

# =========================
# IO KÃ¶prÃ¼sÃ¼ (CSV/JSON/HTML)
# =========================

class IOBridge:
    @staticmethod
    def load_logs_csv(path: str) -> List[EmotionLog]:
        logs = []
        with open(path, "r", encoding="utf-8") as f:
            r = csv.DictReader(f)
            for row in r:
                try:
                    ts = row.get("timestamp") or datetime.utcnow().isoformat()
                    logs.append(EmotionLog(
                        task_id=row["task_id"],
                        emotion=row.get("emotion","Neutral"),
                        feeling_strength=float(row["feeling_strength"]),
                        timestamp=datetime.fromisoformat(ts.replace("Z",""))
                    ))
                except Exception:
                    continue
        return logs

    @staticmethod
    def save_report_csv(path: str, report: Dict[str, Any]):
        keys = ["task_id","avg","max","vol","risk","regime","count"]
        with open(path, "w", encoding="utf-8", newline="") as f:
            w = csv.writer(f); w.writerow(keys)
            for t,m in report.items():
                w.writerow([t, m["avg"], m["max"], m["vol"], m["risk"], m.get("regime","-"), m["count"]])

    @staticmethod
    def save_snapshot_json(path: str, payload: Dict[str, Any]):
        with open(path, "w", encoding="utf-8") as f:
            json.dump(payload, f, ensure_ascii=False, indent=2, default=str)

    @staticmethod
    def save_html_overview(path: str, overview: Dict[str, Any]):
        head = "<style>body{font-family:Segoe UI,Arial}table{border-collapse:collapse}td,th{border:1px solid #ccc;padding:6px}</style>"
        rows = ""
        for task, m in overview["report"].items():
            rows += f"<tr><td>{task}</td><td>{m['avg']}</td><td>{m['max']}</td><td>{m['vol']}</td><td>{m['risk']}</td><td>{m.get('regime','-')}</td></tr>"
        html = f"""<html><head>{head}</head><body>
        <h2>Nova Strategos Prime â€” Ã–zet</h2>
        <p>KullanÄ±cÄ±: {overview['user']['name']} | Risk: {overview['user']['risk_level']} | Tarih: {datetime.utcnow().isoformat()}</p>
        <table><tr><th>GÃ¶rev</th><th>Ortalama</th><th>Maks</th><th>Vol</th><th>Risk</th><th>Rejim</th></tr>{rows}</table>
        <h3>Notlar</h3><pre>{overview.get('notes','')}</pre></body></html>"""
        with open(path,"w",encoding="utf-8") as f: f.write(html)

# =========================
# Ã‡ekirdek analiz/gÃ¶sterge
# =========================

class NovaEmotionStrategos:
    def __init__(self):
        self.logs: List[EmotionLog] = []
        self._cache: Optional[Dict[str, Any]] = None
    def ingest(self, log: EmotionLog):
        self.logs.append(log); self._cache = None
    def series(self, task_id: str) -> List[float]:
        return [l.feeling_strength for l in self.logs if l.task_id==task_id]
    def analyze(self) -> Dict[str, Any]:
        if self._cache is not None: return self._cache
        out: Dict[str, Any] = {}; bucket: Dict[str, List[float]] = {}
        for l in self.logs: bucket.setdefault(l.task_id, []).append(l.feeling_strength)
        for t, arr in bucket.items():
            avg = round(statistics.mean(arr),2) if arr else 0
            mx  = max(arr) if arr else 0
            vol = round(statistics.stdev(arr),2) if len(arr)>1 else 0
            risk = "YÃ¼ksek" if (avg>=7 and vol>=2) else "Orta" if avg>=5 else "DÃ¼ÅŸÃ¼k"
            out[t] = {"avg":avg,"max":mx,"vol":vol,"risk":risk,"count":len(arr)}
        self._cache = out
        return out

class IndicatorEngine:
    def __init__(self, core: NovaEmotionStrategos):
        self.core = core
        self.alpha_fast = 2/(5+1); self.alpha_slow = 2/(12+1)
    def _ema(self, vals, a):
        if not vals: return 0.0
        ema = vals[0]
        for v in vals[1:]: ema = a*v + (1-a)*ema
        return round(ema,3)
    def _rsi(self, vals, p=14):
        if len(vals)<2: return 50.0
        g,l = [],[]
        for i in range(1,len(vals)):
            d = vals[i]-vals[i-1]; g.append(max(0,d)); l.append(max(0,-d))
        pg = sum(g[-p:])/max(1,min(p,len(g))); pl = sum(l[-p:])/max(1,min(p,len(l)))
        rs = pg/(pl if pl!=0 else 1e-6); rsi = 100 - (100/(1+rs))
        return round(max(0,min(100,rsi)),2)
    def _ew_vol(self, vals, a=0.2):
        if len(vals)<2: return 0.0
        mean=vals[0]; var=0.0
        for v in vals[1:]:
            mean = a*v + (1-a)*mean
            var = a*((v-mean)**2) + (1-a)*var
        return round(math.sqrt(var),3)
    def _z(self, vals, w=20):
        if not vals: return 0.0
        sl = vals[-w:]; mu = statistics.mean(sl); sd = statistics.pstdev(sl) if len(sl)>1 else 1.0
        return round((vals[-1]-mu)/(sd if sd>1e-6 else 1.0),3)
    def features(self, task_id: str) -> Dict[str,float]:
        s = self.core.series(task_id)
        fast = self._ema(s,self.alpha_fast); slow = self._ema(s,self.alpha_slow)
        macd = round(fast-slow,3); rsi=self._rsi(s); ewv=self._ew_vol(s); z=self._z(s)
        return {"ema_fast":fast,"ema_slow":slow,"macd":macd,"rsi":rsi,"ew_vol":ewv,"z":z}

class RegimeDetector:
    def detect(self, f: Dict[str,float]) -> str:
        if f["rsi"]>65 or (f["ew_vol"]>2 and f["z"]>1): return "Stres"
        if 45<=f["rsi"]<=65 and (0.5<f["ew_vol"]<2.5):   return "DalgalÄ±"
        return "Sakin"

class SignalEngine:
    def __init__(self, cooldown_sec=20):
        self.cooldown = timedelta(seconds=cooldown_sec)
        self.last_at: Dict[str, datetime] = {}
    def can_signal(self, task_id: str)->bool:
        t=self.last_at.get(task_id); return (t is None) or (datetime.utcnow()-t>=self.cooldown)
    def mark(self, task_id: str): self.last_at[task_id]=datetime.utcnow()
    def generate(self, task_id, m, user_risk, regime, f) -> str:
        avg, vol = m["avg"], m["vol"]
        sens = max(0.5,min(1.5,1+(user_risk-5)*0.08))
        base = avg*0.5 + vol*0.3 + max(0,f["z"])*0.2
        if regime=="Stres": base += 1.0
        score = base*sens
        if score>7:   return f"âš ï¸ {task_id}: YÃ¼ksek stres (avg:{avg}, vol:{vol}, z:{f['z']}, rejim:{regime})"
        if score>5.5: return f"ðŸ” {task_id}: Dalgalanma izlenmeli (avg:{avg}, vol:{vol}, rejim:{regime})"
        return f"âœ… {task_id}: Stabil (avg:{avg}, vol:{vol}, rejim:{regime})"

class AIAdvisor:
    def __init__(self, persist: Persist):
        self.persist = persist
        self.w = persist.data.get("ai_weights") or {"macd":0.8,"rsi":0.5,"z":0.6,"ew_vol":0.4,"bias":-0.5}
        self.lr = persist.data.get("ai_lr") or 0.05
    def _vec(self, f): return {"macd":f["macd"], "rsi":(f["rsi"]-50)/25, "z":f["z"], "ew_vol":f["ew_vol"]/3.0}
    def score(self, f)->float:
        x=self._vec(f); s=sum(self.w.get(k,0)*x[k] for k in x)+self.w.get("bias",0); return round(s,3)
    def advise(self, f, regime):
        s=self.score(f)
        if s>1.2 or regime=="Stres": return "Deeskalasyon: mola, gÃ¶rev rotasyonu, nefes."
        if s>0.4: return "YakÄ±n izleme: kÄ±sa check-in, odak teknikleri."
        return "Devam: akÄ±ÅŸta kal, kÃ¼Ã§Ã¼k kazanÄ±mlarÄ± pekiÅŸtir."
    def feedback(self, f, good: bool):
        y=1 if good else -1; x=self._vec(f)
        margin = y*(sum(self.w.get(k,0)*x[k] for k in x)+self.w.get("bias",0))
        if margin<1:
            for k in x: self.w[k]=self.w.get(k,0)+self.lr*y*x[k]
            self.w["bias"]=self.w.get("bias",0)+self.lr*y
            self.persist.data["ai_weights"]=self.w; self.persist.save()

class RiskManager:
    def size(self, conf: float, user_risk: int)->Dict[str,Any]:
        base=min(max(conf,0.5),0.95); rf=0.5+(user_risk/20); size=round(1000*base*rf,0)
        sl=round(1.0+(1.0-base)*0.5,3); tp=round(1.0+base*1.2,3)
        return {"size":size,"sl_mult":sl,"tp_mult":tp}

# =========================
# Backtester
# =========================

class Backtester:
    def __init__(self, core: NovaEmotionStrategos, ind: IndicatorEngine, regime: RegimeDetector, ai: AIAdvisor):
        self.core=core; self.ind=ind; self.regime=regime; self.ai=ai
    def run(self)->Dict[str,Any]:
        logs=sorted(self.core.logs,key=lambda x:x.timestamp)
        if not logs: return {"trades":0,"win_rate":0,"pnl":0,"sharpe_like":0}
        pnl=[]; wins=0; trades=0; last={}
        for l in logs:
            f=self.ind.features(l.task_id); r=self.regime.detect(f); s=self.ai.score(f)
            action = (s>0.4) or (r=="Stres")
            prev = last.get(l.task_id, l.feeling_strength); d=l.feeling_strength-prev
            reward = -abs(d) if not action else -abs(d)*0.5
            pnl.append(reward); trades+=1; wins+=1 if reward>-0.2 else 0; last[l.task_id]=l.feeling_strength
        total = round(sum(pnl),2); wr = round(100*wins/max(1,trades),1)
        mu = statistics.mean(pnl); sd=statistics.pstdev(pnl) if len(pnl)>1 else 1.0
        sr = round((mu/(sd if sd>1e-6 else 1.0))*math.sqrt(252),2)
        return {"trades":trades,"win_rate":wr,"pnl":total,"sharpe_like":sr}

# =========================
# On-Chain katman
# =========================

DEFAULT_NETWORKS = {
    "Ethereum Sepolia": {"rpc": os.environ.get("RPC_SEPOLIA",""), "chainId": 11155111},
    "Polygon Amoy":     {"rpc": os.environ.get("RPC_AMOY",""),    "chainId": 80002},
    "BSC Testnet":      {"rpc": os.environ.get("RPC_BSCT",""),    "chainId": 97},
}

def keccak_hex(data: bytes)->str:
    return "0x"+hashlib.sha3_256(data).hexdigest()

class MockChain:
    def __init__(self):
        self.ledger = {"signals":{}, "stakes":{}, "votes":{}, "rewards":{}}
        self.tx_counter = 0
    def submit_signal(self, addr: str, sig_hash: str, meta: Dict[str,Any])->str:
        self.tx_counter+=1; tx=f"mocktx_{self.tx_counter}"
        self.ledger["signals"].setdefault(addr,[]).append({"hash":sig_hash,"meta":meta,"tx":tx,"ts":datetime.utcnow().isoformat()})
        return tx
    def stake(self, addr: str, amount: int)->str:
        self.ledger["stakes"][addr]=self.ledger["stakes"].get(addr,0)+amount; self.tx_counter+=1
        return f"mocktx_{self.tx_counter}"
    def vote(self, addr: str, pid: int, support: bool)->str:
        self.ledger["votes"].setdefault(pid,[]).append({"addr":addr,"support":support}); self.tx_counter+=1
        return f"mocktx_{self.tx_counter}"
    def reward(self, addr: str, amount: int)->str:
        self.ledger["rewards"][addr]=self.ledger["rewards"].get(addr,0)+amount; self.tx_counter+=1
        return f"mocktx_{self.tx_counter}"

class OnChainClient:
    def __init__(self, persist: Persist, bus: NotificationBus):
        self.persist=persist; self.bus=bus
        self.networks = DEFAULT_NETWORKS
        self.active_net = None
        self.address = None
        self._w3 = None
        self._acct = None
        self.mock = MockChain()

    def connect(self, net_name: str, privkey: Optional[str]):
        cfg = self.networks.get(net_name)
        if not cfg or not cfg["rpc"]:
            self.bus.send("RPC bulunamadÄ±, MockChain devrede.")
            self.active_net = {"name":"Mock","chainId":0}
            self._w3=None; self._acct=None; self.address="0xMOCK"
            return
        if not HAS_WEB3:
            self.bus.send("web3 bulunamadÄ±, MockChain devrede.")
            self.active_net = {"name":net_name,"chainId":cfg["chainId"]}
            self._w3=None; self._acct=None; self.address="0xMOCK"
            return
        try:
            w3 = Web3(Web3.HTTPProvider(cfg["rpc"]))
            if not w3.is_connected():
                self.bus.send("RPC baÄŸlantÄ±sÄ± baÅŸarÄ±sÄ±z, MockChain devrede.")
                self._w3=None; self.address="0xMOCK"
            else:
                self._w3 = w3
                if privkey:
                    acct = Account.from_key(privkey)
                    self._acct = acct; self.address = acct.address
                else:
                    self._acct=None; self.address=None
                self.active_net = {"name":net_name,"chainId":cfg["chainId"]}
                self.bus.send(f"AÄŸa baÄŸlandÄ±: {net_name} (chainId {cfg['chainId']})")
        except Exception as e:
            self.bus.send(f"BaÄŸlantÄ± hatasÄ±, MockChain: {e}")
            self._w3=None; self.address="0xMOCK"; self.active_net={"name":"Mock","chainId":0}

    def gas_info(self)->Dict[str,Any]:
        if self._w3:
            try:
                gp = self._w3.eth.gas_price
                blk = self._w3.eth.get_block("latest")
                base = blk.get("baseFeePerGas", gp)
                return {"gas_price": int(gp), "base_fee": int(base), "block": blk.number}
            except Exception:
                pass
        # Mock
        return {"gas_price": 1_000_000_000, "base_fee": 1_000_000_000, "block": 0}

    def anchor_signal(self, payload: Dict[str,Any])->Dict[str,str]:
        # 1) Hashle
        data = json.dumps(payload, sort_keys=True, ensure_ascii=False).encode("utf-8")
        sig_hash = keccak_hex(data)
        # 2) EIP-712 imza (off-chain kanÄ±t)
        signature = ""
        if HAS_WEB3 and self._acct:
            try:
                typed = {
                    "types": {
                        "EIP712Domain":[{"name":"name","type":"string"}],
                        "Signal":[
                            {"name":"task","type":"string"},
                            {"name":"hash","type":"bytes32"},
                            {"name":"timestamp","type":"string"}
                        ]
                    },
                    "domain":{"name":"NovaStrategosPrime"},
                    "primaryType":"Signal",
                    "message":{"task":payload["task_id"],"hash":sig_hash,"timestamp":payload["timestamp"]}
                }
                msg = encode_structured_data(primitive=typed)
                signature = self._acct.sign_message(msg).signature.hex()
            except Exception:
                signature = ""
        # 3) Zincire yaz (varsa) yoksa Mock
        meta = {"risk": payload.get("risk","-"), "score": payload.get("score",0)}
        if self._w3 and self._acct:
            # Ã–rnek: bir kontrata submitSignal(bytes32,uint8,uint256) Ã§aÄŸrÄ±sÄ± yapÄ±labilir.
            # Bu Ã¶rnekte mock tx Ã¼retelim; gerÃ§ek kontrat adres/ABI eklenince kullanÄ±labilir.
            tx = f"0x{sig_hash[2:10]}_sim"
        else:
            tx = self.mock.submit_signal(self.address or "0xMOCK", sig_hash, meta)
        return {"hash": sig_hash, "signature": signature, "tx": tx}

    def stake(self, amount: int)->str:
        if self._w3 and self._acct:
            return f"0xstake_sim_{amount}"
        return self.mock.stake(self.address or "0xMOCK", amount)

    def vote(self, proposal_id: int, support: bool)->str:
        if self._w3 and self._acct:
            return f"0xvote_sim_{proposal_id}_{int(support)}"
        return self.mock.vote(self.address or "0xMOCK", proposal_id, support)

    def reward(self, amount: int)->str:
        if self._w3 and self._acct:
            return f"0xreward_sim_{amount}"
        return self.mock.reward(self.address or "0xMOCK", amount)

# =========================
# AkÄ±ÅŸ simÃ¼latÃ¶rÃ¼
# =========================

class StreamSimulator(QtCore.QObject):
    newLog = QtCore.pyqtSignal(EmotionLog)
    def __init__(self, parent=None, tasks=None):
        super().__init__(parent)
        self.timer = QtCore.QTimer(self); self.timer.timeout.connect(self._tick)
        self.tasks = tasks or ["ALPHA","BETA","GAMMA"]
        self.speed_ms = 1200
    def start(self, ms=None):
        self.speed_ms = ms or self.speed_ms; self.timer.start(self.speed_ms)
    def stop(self): self.timer.stop()
    def _tick(self):
        t=random.choice(self.tasks); e=random.choice(["Stress","Focus","Anxiety","Calm"])
        s=round(random.uniform(3.0,9.5),2)
        self.newLog.emit(EmotionLog(t,e,s,datetime.utcnow()))

# =========================
# UI Panel
# =========================

class TraderDashboard(QtWidgets.QWidget):
    def __init__(self, user: Dict[str,Any], core: NovaEmotionStrategos,
                 ind: IndicatorEngine, regime: RegimeDetector,
                 sig: SignalEngine, ai: AIAdvisor, risk: RiskManager,
                 persist: Persist, bus: NotificationBus, chain: OnChainClient):
        super().__init__()
        self.setWindowTitle("ðŸ“Š Nova Strategos Prime â€” Ultra Hibrit Onâ€‘Chain")
        self.user=user; self.core=core; self.ind=ind; self.regime=regime
        self.sig=sig; self.ai=ai; self.risk=risk; self.persist=persist; self.bus=bus; self.chain=chain
        self.sim = StreamSimulator(self); self.sim.newLog.connect(self.on_new_log)
        self._build_ui(); self._bind(); self.refresh_all()

    def _build_ui(self):
        lay = QtWidgets.QVBoxLayout(self)
        title = QtWidgets.QLabel(f"HoÅŸ geldin {self.user['name']}"); title.setStyleSheet("font-weight:700;font-size:16px;")
        lay.addWidget(title)
        self.tabs = QtWidgets.QTabWidget(); lay.addWidget(self.tabs)

        # Dashboard
        dash = QtWidgets.QWidget(); d = QtWidgets.QVBoxLayout(dash)
        ctr = QtWidgets.QHBoxLayout()
        self.risk_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal); self.risk_slider.setRange(1,10); self.risk_slider.setValue(self.user.get("risk_level",6))
        self.chk_anchor = QtWidgets.QCheckBox("Sinyali zincire Ã§apala"); self.chk_anchor.setChecked(True)
        self.btn_stream = QtWidgets.QPushButton("â–¶ï¸ CanlÄ±"); self.btn_stop = QtWidgets.QPushButton("â¸ï¸ Durdur")
        self.btn_analyze= QtWidgets.QPushButton("ðŸ§  Analiz"); self.btn_signal= QtWidgets.QPushButton("ðŸ“¡ Sinyal Bas")
        ctr.addWidget(QtWidgets.QLabel("âš™ï¸ Risk:")); ctr.addWidget(self.risk_slider); ctr.addWidget(self.chk_anchor)
        ctr.addWidget(self.btn_stream); ctr.addWidget(self.btn_stop); ctr.addWidget(self.btn_analyze); ctr.addWidget(self.btn_signal)
        d.addLayout(ctr)
        split = QtWidgets.QSplitter()
        left = QtWidgets.QWidget(); ll = QtWidgets.QVBoxLayout(left)
        ll.addWidget(QtWidgets.QLabel("ðŸ“¡ Sinyaller")); self.signal_box = QtWidgets.QTextEdit(); self.signal_box.setReadOnly(True); ll.addWidget(self.signal_box)
        ll.addWidget(QtWidgets.QLabel("ðŸ§­ AI DanÄ±ÅŸman")); self.ai_box=QtWidgets.QTextEdit(); self.ai_box.setReadOnly(True); ll.addWidget(self.ai_box)
        fb = QtWidgets.QHBoxLayout(); self.btn_good=QtWidgets.QPushButton("ðŸ‘ Ä°yi"); self.btn_bad=QtWidgets.QPushButton("ðŸ‘Ž KÃ¶tÃ¼"); fb.addWidget(self.btn_good); fb.addWidget(self.btn_bad); ll.addLayout(fb)
        right = QtWidgets.QWidget(); rr = QtWidgets.QVBoxLayout(right)
        rr.addWidget(QtWidgets.QLabel("ðŸ“ˆ GÃ¶rev Metrikleri")); self.metrics=QtWidgets.QTextEdit(); self.metrics.setReadOnly(True); rr.addWidget(self.metrics)
        rr.addWidget(QtWidgets.QLabel("ðŸ“Š GÃ¶stergeler")); self.inds=QtWidgets.QTextEdit(); self.inds.setReadOnly(True); rr.addWidget(self.inds)
        split.addWidget(left); split.addWidget(right); d.addWidget(split)
        self.status = QtWidgets.QLabel("HazÄ±r."); d.addWidget(self.status)
        self.tabs.addTab(dash,"Dashboard")

        # Veri
        dataw = QtWidgets.QWidget(); dv = QtWidgets.QVBoxLayout(dataw)
        btns = QtWidgets.QHBoxLayout()
        self.btn_load=QtWidgets.QPushButton("ðŸ“¥ CSV YÃ¼kle"); self.btn_export=QtWidgets.QPushButton("ðŸ“¤ CSV Rapor"); self.btn_snap=QtWidgets.QPushButton("ðŸ§¾ JSON Snapshot"); self.btn_html=QtWidgets.QPushButton("ðŸ–¨ï¸ HTML Ã–zet")
        btns.addWidget(self.btn_load); btns.addWidget(self.btn_export); btns.addWidget(self.btn_snap); btns.addWidget(self.btn_html); dv.addLayout(btns)
        self.table = QtWidgets.QTableWidget(0,4); self.table.setHorizontalHeaderLabels(["timestamp","task_id","emotion","feeling_strength"]); self.table.horizontalHeader().setStretchLastSection(True)
        dv.addWidget(self.table)
        self.tabs.addTab(dataw,"Veri")

        # Backtest
        btw = QtWidgets.QWidget(); bv = QtWidgets.QVBoxLayout(btw)
        self.btn_back=QtWidgets.QPushButton("â±ï¸ Backtest"); self.bt_out=QtWidgets.QTextEdit(); self.bt_out.setReadOnly(True)
        bv.addWidget(self.btn_back); bv.addWidget(self.bt_out)
        self.tabs.addTab(btw,"Backtest")

        # On-Chain
        chw = QtWidgets.QWidget(); chv = QtWidgets.QFormLayout(chw)
        self.cmb_net = QtWidgets.QComboBox(); self.cmb_net.addItems(list(DEFAULT_NETWORKS.keys())+["Mock"])
        self.ed_priv = QtWidgets.QLineEdit(); self.ed_priv.setEchoMode(QtWidgets.QLineEdit.Password); self.ed_priv.setPlaceholderText("Ã–zel anahtar (0x...) â€” opsiyonel")
        self.btn_connect = QtWidgets.QPushButton("ðŸ”— BaÄŸlan")
        self.lbl_addr = QtWidgets.QLabel("Adres: -")
        self.lbl_chain = QtWidgets.QLabel("AÄŸ: -"); self.lbl_gas = QtWidgets.QLabel("Gas: -")
        self.ed_stake = QtWidgets.QSpinBox(); self.ed_stake.setRange(0,1_000_000); self.btn_stake=QtWidgets.QPushButton("ðŸª™ Stake")
        self.ed_pid = QtWidgets.QSpinBox(); self.ed_pid.setRange(0,1_000_000); self.chk_support=QtWidgets.QCheckBox("Destekle"); self.btn_vote=QtWidgets.QPushButton("ðŸ—³ï¸ Oy Ver")
        self.btn_reward=QtWidgets.QPushButton("ðŸŽ Ã–dÃ¼l Talep (simÃ¼lasyon)")
        self.tx_log = QtWidgets.QTextEdit(); self.tx_log.setReadOnly(True); self.tx_log.setMaximumHeight(140)
        chv.addRow("AÄŸ", self.cmb_net); chv.addRow("Ã–zel anahtar", self.ed_priv); chv.addRow(self.btn_connect)
        chv.addRow(self.lbl_chain); chv.addRow(self.lbl_addr); chv.addRow(self.lbl_gas)
        chv.addRow("Stake miktarÄ±", self.ed_stake); chv.addRow(self.btn_stake)
        chv.addRow("Teklif ID", self.ed_pid); chv.addRow(self.chk_support); chv.addRow(self.btn_vote)
        chv.addRow(self.btn_reward); chv.addRow(QtWidgets.QLabel("Ä°ÅŸlem GÃ¼nlÃ¼ÄŸÃ¼")); chv.addRow(self.tx_log)
        self.tabs.addTab(chw,"Onâ€‘Chain")

        # Ayarlar
        stw = QtWidgets.QWidget(); sf = QtWidgets.QFormLayout(stw)
        self.chk_sound=QtWidgets.QCheckBox("Bildirim sesi"); self.chk_sound.setChecked(True)
        self.spin_cd=QtWidgets.QSpinBox(); self.spin_cd.setRange(5,120); self.spin_cd.setValue(20)
        self.spin_speed=QtWidgets.QSpinBox(); self.spin_speed.setRange(200,5000); self.spin_speed.setValue(1200)
        self.chk_ind=QtWidgets.QCheckBox("GÃ¶stergeleri kullan"); self.chk_ind.setChecked(True)
        self.chk_ai=QtWidgets.QCheckBox("AI danÄ±ÅŸmanÄ± aktif"); self.chk_ai.setChecked(True)
        self.btn_save=QtWidgets.QPushButton("ðŸ’¾ AyarlarÄ± Kaydet")
        sf.addRow(self.chk_sound); sf.addRow("SoÄŸuma (sn)", self.spin_cd); sf.addRow("AkÄ±ÅŸ (ms)", self.spin_speed); sf.addRow(self.chk_ind); sf.addRow(self.chk_ai); sf.addRow(self.btn_save)
        self.tabs.addTab(stw,"Ayarlar")

        # KÄ±sayollar
        QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+L"), self, activated=self.on_load_csv)
        QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+E"), self, activated=self.on_export_csv)
        QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+B"), self, activated=self.on_backtest)

    def _bind(self):
        self.btn_stream.clicked.connect(self.on_stream)
        self.btn_stop.clicked.connect(self.on_stop)
        self.btn_analyze.clicked.connect(self.on_analyze)
        self.btn_signal.clicked.connect(self.emit_signals)
        self.btn_load.clicked.connect(self.on_load_csv)
        self.btn_export.clicked.connect(self.on_export_csv)
        self.btn_snap.clicked.connect(self.on_snapshot)
        self.btn_html.clicked.connect(self.on_html)
        self.btn_back.clicked.connect(self.on_backtest)
        self.btn_good.clicked.connect(lambda: self.on_feedback(True))
        self.btn_bad.clicked.connect(lambda: self.on_feedback(False))
        self.btn_save.clicked.connect(self.on_save)
        self.risk_slider.valueChanged.connect(self.on_risk)
        self.btn_connect.clicked.connect(self.on_connect)
        self.btn_stake.clicked.connect(self.on_stake)
        self.btn_vote.clicked.connect(self.on_vote)
        self.btn_reward.clicked.connect(self.on_reward)

    # ---- event handlers ----

    def on_stream(self):
        self.sim.start(self.spin_speed.value()); self.status.setText("AkÄ±ÅŸ baÅŸlatÄ±ldÄ±."); self.bus.send("Sim akÄ±ÅŸÄ± aÃ§Ä±k.", self)
    def on_stop(self):
        self.sim.stop(); self.status.setText("AkÄ±ÅŸ durdu."); self.bus.send("Sim akÄ±ÅŸÄ± kapalÄ±.", self)
    def on_analyze(self):
        self.refresh_all(); self.emit_signals()
    def on_new_log(self, log: EmotionLog):
        self.core.ingest(log); self._append_row(log)
        rep=self.core.analyze(); m=rep.get(log.task_id); 
        if not m: return
        f = self.ind.features(log.task_id) if self.chk_ind.isChecked() else {"z":0,"ew_vol":0,"rsi":50,"macd":0,"ema_fast":0,"ema_slow":0}
        reg = self.regime.detect(f)
        if self.sig.can_signal(log.task_id):
            msg = self.sig.generate(log.task_id, m, self.user.get("risk_level",6), reg, f)
            conf = self._confidence(m,f,reg); sizing = risk.size(conf, self.user.get("risk_level",6))
            enriched = f"{msg} | size:{sizing['size']} | SLx:{sizing['sl_mult']} | TPx:{sizing['tp_mult']}"
            self.signal_box.append(f"{datetime.utcnow().isoformat()} â€” {enriched}")
            if self.chk_ai.isChecked(): self.ai_box.append(f"{datetime.utcnow().isoformat()} â€” {self.ai.advise(f,reg)}")
            self.sig.mark(log.task_id)
            if self.chk_anchor.isChecked(): self._anchor_signal(log.task_id, m, f, enriched)
        self.refresh_panels(task_hint=log.task_id)

    def on_load_csv(self):
        path,_=QtWidgets.QFileDialog.getOpenFileName(self,"CSV SeÃ§","","CSV (*.csv)")
        if not path: return
        logs = IOBridge.load_logs_csv(path)
        for l in logs: self.core.ingest(l); self._append_row(l)
        self.refresh_all(); self.status.setText(f"{len(logs)} kayÄ±t yÃ¼klendi."); self.bus.send("CSV yÃ¼klendi.", self)

    def on_export_csv(self):
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"Rapor Kaydet","nova_report.csv","CSV (*.csv)")
        if not path: return
        IOBridge.save_report_csv(path, self._rep_reg())
        self.status.setText("Rapor kaydedildi."); self.bus.send("CSV rapor yazÄ±ldÄ±.", self)

    def on_snapshot(self):
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"Snapshot","nova_snapshot.json","JSON (*.json)")
        if not path: return
        payload={"user":self.user,"report":self._rep_reg(),"ai_weights":self.ai.w,"timestamp":datetime.utcnow().isoformat()}
        IOBridge.save_snapshot_json(path,payload); self.status.setText("Snapshot kaydedildi."); self.bus.send("JSON snapshot.", self)

    def on_html(self):
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"HTML Ã–zet","nova_overview.html","HTML (*.html)")
        if not path: return
        IOBridge.save_html_overview(path, {"user":self.user,"report":self._rep_reg(),"notes":self.ai_box.toPlainText()[-1000:]})
        self.status.setText("HTML Ã¶zet kaydedildi."); self.bus.send("HTML Ã¶zet yazÄ±ldÄ±.", self)
        try: webbrowser.open(f"file://{os.path.abspath(path)}")
        except Exception: pass

    def on_backtest(self):
        res = Backtester(self.core,self.ind,self.regime,self.ai).run()
        self.bt_out.setText(f"Ä°ÅŸlem: {res['trades']}\nÄ°sabet: %{res['win_rate']}\nSim PnL: {res['pnl']}\nSharpe-benzeri: {res['sharpe_like']}")
        self.bus.send("Backtest tamam.", self)

    def on_feedback(self, good: bool):
        rep=self.core.analyze()
        if not rep: return
        task=max(rep.items(), key=lambda kv: kv[1]["count"])[0]
        f=self.ind.features(task); self.ai.feedback(f, good)
        self.ai_box.append(f"{datetime.utcnow().isoformat()} â€” Geri bildirim iÅŸlendi ({'iyi' if good else 'kÃ¶tÃ¼'}).")
        self.status.setText("AI aÄŸÄ±rlÄ±klarÄ± gÃ¼ncellendi."); self.bus.send("AI feedback.", self)

    def on_save(self):
        self.bus.sound_on=self.chk_sound.isChecked()
        self.sig.cooldown=timedelta(seconds=self.spin_cd.value())
        self.sim.speed_ms=self.spin_speed.value()
        self.persist.data["settings"]={"sound_on":self.bus.sound_on,"cooldown":self.spin_cd.value(),"speed_ms":self.sim.speed_ms,"use_ind":self.chk_ind.isChecked(),"use_ai":self.chk_ai.isChecked()}
        self.persist.save(); self.status.setText("Ayarlar kaydedildi.")

    def on_risk(self, v: int):
        self.user["risk_level"]=v; self.persist.data["user_profile"]=self.user; self.persist.save()
        self.status.setText(f"Risk seviyesi: {v}")

    # --- Onâ€‘Chain handlers ---
    def on_connect(self):
        net = self.cmb_net.currentText()
        priv = self.ed_priv.text().strip() or None
        self.chain.connect(net, priv)
        info = self.chain.gas_info()
        self.lbl_chain.setText(f"AÄŸ: {self.chain.active_net['name'] if self.chain.active_net else '-'}")
        self.lbl_addr.setText(f"Adres: {self.chain.address or '-'}")
        self.lbl_gas.setText(f"Gas/base: {info['gas_price']}/{info['base_fee']} | Blok: {info['block']}")
        # Gaz / aÄŸ gÃ¼rÃ¼ltÃ¼sÃ¼ne gÃ¶re dinamik hassasiyet ayarÄ±: yÃ¼ksek baseFee -> biraz daha temkinli
        if info["base_fee"]>5_000_000_000:
            self.sig.cooldown = timedelta(seconds=max(10, self.spin_cd.value()+10))
            self.status.setText("AÄŸ yoÄŸun: soÄŸuma sÃ¼resi artÄ±rÄ±ldÄ±.")

    def on_stake(self):
        amt = int(self.ed_stake.value()); 
        tx = self.chain.stake(amt)
        self.tx_log.append(f"{datetime.utcnow().isoformat()} â€” Stake tx: {tx}")
        self.bus.send("Stake gÃ¶nderildi.", self)

    def on_vote(self):
        pid = int(self.ed_pid.value()); sup = self.chk_support.isChecked()
        tx = self.chain.vote(pid, sup)
        self.tx_log.append(f"{datetime.utcnow().isoformat()} â€” Vote tx: {tx}")
        self.bus.send("Oy gÃ¶nderildi.", self)

    def on_reward(self):
        tx = self.chain.reward(100)  # simÃ¼lasyon
        self.tx_log.append(f"{datetime.utcnow().isoformat()} â€” Reward tx: {tx}")
        self.bus.send("Ã–dÃ¼l talep edildi.", self)

    # --- yardÄ±mcÄ±lar ---

    def _anchor_signal(self, task_id: str, m: Dict[str,Any], f: Dict[str,float], text: str):
        payload = {
            "task_id": task_id,
            "metrics": m,
            "features": f,
            "message": text,
            "risk": m["risk"],
            "score": round(f.get("z",0)*100),
            "timestamp": datetime.utcnow().isoformat()
        }
        # snapshotâ€™Ä± yaz ve hasha dayalÄ± isimle sakla
        snap_name = f"nova_signal_{task_id}_{int(datetime.utcnow().timestamp())}.json"
        IOBridge.save_snapshot_json(snap_name, payload)
        res = self.chain.anchor_signal(payload)
        self.tx_log.append(f"{datetime.utcnow().isoformat()} â€” Anchor: hash={res['hash']} tx={res['tx']} sig={res['signature'][:14]}...")
        self.bus.send("Sinyal zincire Ã§apalandÄ±.", self)

    def refresh_all(self):
        self.refresh_panels(); self._reload_table()

    def refresh_panels(self, task_hint: Optional[str]=None):
        rep = self._rep_reg(); lines=[]
        for t,m in sorted(rep.items()):
            lines.append(f"[{t}] avg:{m['avg']} | max:{m['max']} | vol:{m['vol']} | risk:{m['risk']} | rejim:{m['regime']} | n:{m['count']}")
        self.metrics.setText("\n".join(lines) if lines else "HenÃ¼z veri yok.")
        if rep:
            t = task_hint or next(iter(rep.keys()))
            f=self.ind.features(t)
            self.inds.setText(f"GÃ¶rev: {t}\nEMAf:{f['ema_fast']} EMAs:{f['ema_slow']} MACD:{f['macd']}\nRSI:{f['rsi']} EWVol:{f['ew_vol']} Z:{f['z']}\nRejim:{self.regime.detect(f)} | AI skor:{self.ai.score(f)}")

    def emit_signals(self):
        rep=self.core.analyze()
        for t,m in rep.items():
            if not self.sig.can_signal(t): continue
            f = self.ind.features(t) if self.chk_ind.isChecked() else {"z":0,"ew_vol":0,"rsi":50,"macd":0,"ema_fast":0,"ema_slow":0}
            reg = self.regime.detect(f)
            msg = self.sig.generate(t, m, self.user.get("risk_level",6), reg, f)
            conf = self._confidence(m,f,reg); sizing = risk.size(conf, self.user.get("risk_level",6))
            enriched = f"{msg} | size:{sizing['size']} | SLx:{sizing['sl_mult']} | TPx:{sizing['tp_mult']}"
            self.signal_box.append(f"{datetime.utcnow().isoformat()} â€” {enriched}")
            if self.chk_ai.isChecked(): self.ai_box.append(f"{datetime.utcnow().isoformat()} â€” {self.ai.advise(f,reg)}")
            self.sig.mark(t)
            if self.chk_anchor.isChecked(): self._anchor_signal(t, m, f, enriched)
        self.bus.send("Toplu sinyaller Ã¼retildi.", self)

    def _rep_reg(self)->Dict[str,Any]:
        rep=self.core.analyze(); out={}
        for t,m in rep.items():
            f=self.ind.features(t); out[t]={**m,"regime":self.regime.detect(f)}
        return out

    def _reload_table(self):
        self.table.setRowCount(0)
        for l in sorted(self.core.logs, key=lambda x: x.timestamp)[-1000:]:
            self._append_row(l)

    def _append_row(self, l: EmotionLog):
        r=self.table.rowCount(); self.table.insertRow(r)
        self.table.setItem(r,0,QtWidgets.QTableWidgetItem(l.timestamp.isoformat()))
        self.table.setItem(r,1,QtWidgets.QTableWidgetItem(l.task_id))
        self.table.setItem(r,2,QtWidgets.QTableWidgetItem(l.emotion))
        self.table.setItem(r,3,QtWidgets.QTableWidgetItem(str(l.feeling_strength)))

    def _confidence(self, m: Dict[str,Any], f: Dict[str,float], regime: str)->float:
        base = 0.7 if m["risk"]=="DÃ¼ÅŸÃ¼k" else 0.6 if m["risk"]=="Orta" else 0.55
        adj = max(0.85,min(1.15, 1-(m["vol"]/10) + (max(0, -abs(f['z'])+1)*0.05) + (0.03 if regime=="Sakin" else 0)))
        # AÄŸ yoÄŸunluÄŸuna gÃ¶re mikro ayar
        g = chain.gas_info()
        if g["base_fee"]>5_000_000_000: adj -= 0.02
        return round(min(0.95,max(0.5,base*adj)),2)

# =========================
# GiriÅŸ noktasÄ±
# =========================

def main():
    persist=Persist()
    user = persist.data.get("user_profile") or {"name":"Kamal","risk_level":6}
    core=NovaEmotionStrategos(); ind=IndicatorEngine(core); regime=RegimeDetector()
    sig=SignalEngine(cooldown_sec=persist.data.get("settings",{}).get("cooldown",20))
    ai=AIAdvisor(persist); global risk; risk=RiskManager()
    bus=NotificationBus(sound_on=persist.data.get("settings",{}).get("sound_on",True))
    global chain; chain=OnChainClient(persist,bus)

    app = QtWidgets.QApplication(sys.argv)
    panel = TraderDashboard(user, core, ind, regime, sig, ai, risk, persist, bus, chain)

    # Tohum veri
    seed=[EmotionLog("ALPHA","Stress",7.8,datetime.utcnow()),
          EmotionLog("ALPHA","Anxiety",6.9,datetime.utcnow()),
          EmotionLog("BETA","Focus",4.2,datetime.utcnow()),
          EmotionLog("GAMMA","Calm",3.8,datetime.utcnow()),
          EmotionLog("BETA","Stress",6.1,datetime.utcnow()),
          EmotionLog("GAMMA","Anxiety",5.5,datetime.utcnow())]
    for l in seed: core.ingest(l)

    panel.resize(980, 700); panel.show()
    sys.exit(app.exec_())

if __name__=="__main__":
    main()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\nova_ultra_single.py
# nova_ultra_single.py
# Tek dosya: 20+ TA, ultra hibrit strateji, AI, risk, backtest, onâ€‘chain (mock), CCXT broker, async canlÄ± dÃ¶ngÃ¼

import os, sys, csv, json, math, time, asyncio, statistics, argparse
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional, Tuple

# Opsiyonel hÄ±zlandÄ±rmalar
HAS_NP=False; HAS_PD=False; HAS_CCXT=False
try:
    import numpy as np
    HAS_NP=True
except Exception:
    HAS_NP=False
try:
    import pandas as pd
    HAS_PD=True
except Exception:
    HAS_PD=False
try:
    import ccxt  # type: ignore
    HAS_CCXT=True
except Exception:
    HAS_CCXT=False

# =======================
# Tipler
# =======================

@dataclass
class MarketBar:
    ts: datetime
    symbol: str
    open: float
    high: float
    low: float
    close: float
    volume: float

@dataclass
class Signal:
    symbol: str
    action: str         # BUY | SELL | HOLD
    confidence: float   # 0..1
    regime: str         # Trend | Range | Unknown
    features: Dict[str, float]
    timestamp: datetime

@dataclass
class BacktestReport:
    trades: int
    win_rate: float
    pnl: float
    sharpe_like: float
    notes: Optional[str] = None

# =======================
# IO yardÄ±mcÄ±larÄ±
# =======================

def load_ohlcv_csv(path: str, symbol_col: str="symbol") -> List[MarketBar]:
    out=[]
    with open(path,"r",encoding="utf-8") as f:
        r=csv.DictReader(f)
        for row in r:
            ts=row.get("timestamp") or row.get("time") or row.get("date")
            dt=datetime.fromisoformat(ts.replace("Z","")) if ts else datetime.utcnow()
            out.append(MarketBar(
                ts=dt,
                symbol=row.get(symbol_col,"SYMBOL"),
                open=float(row["open"]),
                high=float(row["high"]),
                low=float(row["low"]),
                close=float(row["close"]),
                volume=float(row.get("volume",0))
            ))
    return sorted(out, key=lambda b: b.ts)

def save_html_report(path: str, overview: Dict[str,Any]) -> None:
    head="<style>body{font-family:Segoe UI,Arial}table{border-collapse:collapse}td,th{border:1px solid #ccc;padding:6px}</style>"
    rows="".join(f"<tr><td>{k}</td><td>{v}</td></tr>" for k,v in overview["metrics"].items())
    html=f"<html><head>{head}</head><body><h2>{overview['symbol']} â€” Ã–zet</h2><p>Tarih: {datetime.utcnow().isoformat()}</p><table><tr><th>Ad</th><th>DeÄŸer</th></tr>{rows}</table><pre>{overview.get('notes','')}</pre></body></html>"
    with open(path,"w",encoding="utf-8") as f: f.write(html)

# =======================
# 20+ Teknik indikatÃ¶rler
# =======================

class TA:
    @staticmethod
    def SMA(vals: List[float], n:int)->float:
        if len(vals)<n: return float('nan')
        if HAS_NP:
            return float(np.mean(np.array(vals[-n:], dtype=float)))
        return sum(vals[-n:])/n

    @staticmethod
    def EMA(vals: List[float], n:int)->float:
        if not vals: return float('nan')
        if HAS_NP:
            arr=np.array(vals, dtype=float)
            k=2.0/(n+1.0)
            ema=arr[0]
            for v in arr[1:]:
                ema=k*v+(1-k)*ema
            return float(ema)
        k=2/(n+1); ema=vals[0]
        for v in vals[1:]: ema=k*v+(1-k)*ema
        return ema

    @staticmethod
    def _ema_series(vals: List[float], n:int)->List[float]:
        if not vals: return []
        k=2/(n+1); out=[vals[0]]
        for v in vals[1:]: out.append(k*v+(1-k)*out[-1])
        return out

    @staticmethod
    def MACD(close: List[float], fast=12, slow=26, signal=9)->Tuple[float,float,float]:
        if len(close)<slow: return float('nan'),float('nan'),float('nan')
        ef=TA._ema_series(close, fast)
        es=TA._ema_series(close, slow)
        ln=min(len(ef), len(es))
        macd_series=[ef[i]-es[i] for i in range(-ln,0)]
        sig=TA._ema_series(macd_series, signal)[-1] if macd_series else float('nan')
        macd=macd_series[-1] if macd_series else float('nan')
        hist=macd - sig if macd==macd and sig==sig else float('nan')
        return macd, sig, hist

    @staticmethod
    def RSI(close: List[float], period=14)->float:
        if len(close)<2: return float('nan')
        gains=[]; losses=[]
        for i in range(1,len(close)):
            d=close[i]-close[i-1]
            gains.append(max(0,d)); losses.append(max(0,-d))
        pg=sum(gains[-period:])/max(1, min(period, len(gains)))
        pl=sum(losses[-period:])/max(1, min(period, len(losses)))
        rs=pg/(pl if pl>0 else 1e-6)
        return 100-(100/(1+rs))

    @staticmethod
    def Stochastic(high: List[float], low: List[float], close: List[float], k_period=14, d_period=3)->Tuple[float,float]:
        if len(close)<k_period: return float('nan'),float('nan')
        hh=max(high[-k_period:]); ll=min(low[-k_period:])
        k=100*(close[-1]-ll)/(hh-ll if hh!=ll else 1e-6)
        return k, k

    @staticmethod
    def StochRSI(close: List[float], period=14, k=14, d=3)->Tuple[float,float]:
        if len(close)<period+1: return float('nan'),float('nan')
        rsival=[]
        for i in range(2,len(close)+1):
            rsival.append(TA.RSI(close[:i], period))
        if len(rsival)<k: return float('nan'),float('nan')
        ll=min(rsival[-k:]); hh=max(rsival[-k:])
        stoch=100*(rsival[-1]-ll)/(hh-ll if hh!=ll else 1e-6)
        return stoch, stoch

    @staticmethod
    def CCI(high: List[float], low: List[float], close: List[float], period=20)->float:
        if len(close)<period: return float('nan')
        tp=[(h+l+c)/3 for h,l,c in zip(high,low,close)]
        sma=TA.SMA(tp,period)
        md=sum(abs(x-sma) for x in tp[-period:])/period
        return (tp[-1]-sma)/(0.015*md if md!=0 else 1e-6)

    @staticmethod
    def WilliamsR(high: List[float], low: List[float], close: List[float], period=14)->float:
        if len(close)<period: return float('nan')
        hh=max(high[-period:]); ll=min(low[-period:])
        return -100*(hh-close[-1])/(hh-ll if hh!=ll else 1e-6)

    @staticmethod
    def Bollinger(close: List[float], period=20, mult=2)->Tuple[float,float,float]:
        if len(close)<period: return float('nan'),float('nan'),float('nan')
        ma=TA.SMA(close,period)
        sd=statistics.pstdev(close[-period:]) if period>1 else 0
        return ma-mult*sd, ma, ma+mult*sd

    @staticmethod
    def ATR(high: List[float], low: List[float], close: List[float], period=14)->float:
        if len(close)<2: return float('nan')
        trs=[]
        for i in range(1,len(close)):
            tr=max(high[i]-low[i], abs(high[i]-close[i-1]), abs(low[i]-close[i-1]))
            trs.append(tr)
        if len(trs)<period: return statistics.mean(trs) if trs else float('nan')
        return statistics.mean(trs[-period:])

    @staticmethod
    def Keltner(high: List[float], low: List[float], close: List[float], ema_period=20, atr_period=10, mult=2)->Tuple[float,float,float]:
        ema=TA.EMA(close, ema_period)
        atr=TA.ATR(high, low, close, atr_period)
        return ema-mult*atr, ema, ema+mult*atr

    @staticmethod
    def DMI_ADX(high: List[float], low: List[float], close: List[float], period=14)->Tuple[float,float,float]:
        if len(close)<period+1: return float('nan'),float('nan'),float('nan')
        plusDM=[]; minusDM=[]; TR=[]
        for i in range(1,len(close)):
            up=high[i]-high[i-1]; dn=low[i-1]-low[i]
            plusDM.append(up if (up>dn and up>0) else 0)
            minusDM.append(dn if (dn>up and dn>0) else 0)
            TR.append(max(high[i]-low[i], abs(high[i]-close[i-1]), abs(low[i]-close[i-1])))
        def smooth(x,n):
            if not x: return []
            k=2/(n+1); out=[x[0]]
            for v in x[1:]: out.append(k*v+(1-k)*out[-1])
            return out
        smTR=smooth(TR, period); smPlus=smooth(plusDM, period); smMinus=smooth(minusDM, period)
        if not smTR or not smPlus or not smMinus: return float('nan'),float('nan'),float('nan')
        plusDI=100*(smPlus[-1]/(smTR[-1] if smTR[-1]!=0 else 1e-6))
        minusDI=100*(smMinus[-1]/(smTR[-1] if smTR[-1]!=0 else 1e-6))
        dx=100*abs(plusDI-minusDI)/(plusDI+minusDI if (plusDI+minusDI)!=0 else 1e-6)
        adx_series=[dx]
        for _ in range(1,period):
            adx_series.append( (adx_series[-1]*(period-1)+dx)/period )
        return plusDI, minusDI, adx_series[-1]

    @staticmethod
    def OBV(close: List[float], volume: List[float])->float:
        if not close: return 0.0
        obv=0.0
        for i in range(1,len(close)):
            obv += (volume[i] if close[i]>close[i-1] else (-volume[i] if close[i]<close[i-1] else 0))
        return obv

    @staticmethod
    def VWAP(high: List[float], low: List[float], close: List[float], volume: List[float])->float:
        if not close or not volume: return float('nan')
        tp=[(h+l+c)/3 for h,l,c in zip(high,low,close)]
        cum_pv=sum(p*v for p,v in zip(tp,volume))
        cum_v=sum(volume)
        return cum_pv/(cum_v if cum_v!=0 else 1e-6)

    @staticmethod
    def CMF(high: List[float], low: List[float], close: List[float], volume: List[float], period=20)->float:
        if len(close)<period: return float('nan')
        mfv=[]
        for h,l,c,v in zip(high,low,close,volume):
            mfm=((c-l)-(h-c))/((h-l) if h!=l else 1e-6)
            mfv.append(mfm*v)
        return sum(mfv[-period:])/(sum(volume[-period:]) if sum(volume[-period:])!=0 else 1e-6)

    @staticmethod
    def Donchian(high: List[float], low: List[float], period=20)->Tuple[float,float]:
        if len(high)<period: return float('nan'),float('nan')
        return max(high[-period:]), min(low[-period:])

    @staticmethod
    def PSAR(high: List[float], low: List[float], af_start=0.02, af_step=0.02, af_max=0.2)->float:
        if len(high)<2: return float('nan')
        uptrend=True
        sar=low[0]; ep=high[0]; af=af_start
        for i in range(1,len(high)):
            prev_sar=sar
            sar = prev_sar + af*(ep - prev_sar)
            if uptrend:
                sar=min(sar, low[i-1], low[i])
                if high[i]>ep:
                    ep=high[i]; af=min(af+af_step, af_max)
                if low[i]<sar:
                    uptrend=False; sar=ep; ep=low[i]; af=af_start
            else:
                sar=max(sar, high[i-1], high[i])
                if low[i]<ep:
                    ep=low[i]; af=min(af+af_step, af_max)
                if high[i]>sar:
                    uptrend=True; sar=ep; ep=high[i]; af=af_start
        return sar

    @staticmethod
    def Ichimoku(high: List[float], low: List[float], close: List[float])->Dict[str,float]:
        def mid(vals, n): 
            if len(vals)<n: return float('nan')
            return (max(vals[-n:])+min(vals[-n:]))/2
        tenkan=mid(high,9); tenkan=(tenkan+mid(low,9))/2 if not math.isnan(tenkan) else float('nan')
        kijun=mid(high,26); kijun=(kijun+mid(low,26))/2 if not math.isnan(kijun) else float('nan')
        spanA=(tenkan+kijun)/2 if not math.isnan(tenkan) and not math.isnan(kijun) else float('nan')
        spanB=(max(high[-52:])+min(low[-52:]))/2 if len(high)>=52 else float('nan')
        chikou=close[-26] if len(close)>=26 else float('nan')
        return {"tenkan":tenkan,"kijun":kijun,"spanA":spanA,"spanB":spanB,"chikou":chikou}

# =======================
# Strateji ve AI
# =======================

class StrategyPro:
    """
    Ultra hibrit: rejim tespiti (ADX), trend bloÄŸu (EMA/MACD/Ichimoku),
    range bloÄŸu (RSI/W%R/Bollinger), AI skoruyla aÄŸÄ±rlÄ±klandÄ±rma.
    """
    def regime(self, high: List[float], low: List[float], close: List[float]) -> str:
        _,_,adx = TA.DMI_ADX(high, low, close, 14)
        if adx!=adx: return "Unknown"
        return "Trend" if adx>=22 else "Range"

    def score(self, high: List[float], low: List[float], close: List[float], volume: List[float]) -> Tuple[str,float,Dict[str,float]]:
        ema12=TA.EMA(close,12); ema26=TA.EMA(close,26)
        macd, macds, hist = TA.MACD(close)
        _,_,adx = TA.DMI_ADX(high, low, close, 14)
        rsi=TA.RSI(close,14)
        bbL, bbM, bbU = TA.Bollinger(close,20,2)
        ich=TA.Ichimoku(high, low, close)

        reg=self.regime(high,low,close)
        s=0.0
        if reg=="Trend":
            if ema12>ema26: s+=1
            if macd>macds: s+=1
            if adx>=22: s+=1
            if not math.isnan(ich["spanA"]) and not math.isnan(ich["spanB"]) and close[-1]>max(ich["spanA"],ich["spanB"]): s+=1
        else:
            if rsi<30: s+=1
            if bbL==bbL and close[-1]<=bbL: s+=1
            stK,_=TA.Stochastic(high, low, close, 14, 3)
            if stK<20: s+=1

        if reg=="Trend" and ema12<ema26: s-=0.5
        if reg=="Range" and rsi>70: s-=0.5

        conf=max(0.0, min(1.0, (s+0.5)/4.0))
        action="BUY" if conf>=0.6 else ("HOLD" if conf>=0.4 else "SELL")
        feats={"rsi":rsi, "adx":adx, "macd_hist":hist, "last_price": close[-1]}
        return action, conf, feats

class AIAdvisorPro:
    """
    Ultra hibrit: kural tabanlÄ± skor + Ã¶ÄŸrenen aÄŸÄ±rlÄ±klar + momentum/mean-reversion karmasÄ±.
    Bot karar verir; bu sÄ±nÄ±f sadece tavsiye/sayÄ± Ã¼retir.
    """
    def __init__(self, w=None, lr:float=0.02):
        self.w=w or {"trend":0.7,"range":0.6,"momentum":0.5,"oversold":0.4,"bias":0.0}
        self.lr=lr

    def _features_to_x(self, feats: Dict[str,float]) -> Dict[str,float]:
        rsi=feats.get("rsi",50.0); adx=feats.get("adx",15.0); hist=feats.get("macd_hist",0.0)
        return {
            "trend": adx/30.0,
            "range": (100.0 - rsi)/100.0,
            "momentum": max(0.0, hist)/2.0,
            "oversold": (30.0 - min(30.0, rsi))/30.0,
            "bias": 1.0
        }

    def score(self, feats: Dict[str,float]) -> float:
        x=self._features_to_x(feats)
        return sum(self.w[k]*x[k] for k in x)

    def advise(self, proto_action:str, confidence:float, feats:Dict[str,float]) -> str:
        s=self.score(feats)
        if proto_action=="BUY" and (confidence>0.65 or s>0.6): return "Kademeli giriÅŸ, teyitli devam"
        if proto_action=="SELL" and (confidence>0.6): return "Kademeli Ã§Ä±kÄ±ÅŸ, koruma odaklÄ±"
        return "Ä°zle ve teyit arayÄ±ÅŸÄ±"

    def feedback(self, feats: Dict[str,float], good: bool) -> Dict[str,float]:
        y=1 if good else -1
        x=self._features_to_x(feats)
        margin=y*(sum(self.w.get(k,0)*x[k] for k in x))
        if margin<1:
            for k in x:
                self.w[k]=self.w.get(k,0)+self.lr*y*x[k]
        return self.w

# =======================
# Risk ve backtest
# =======================

class RiskManager:
    def position_size(self, equity: float, risk_per_trade: float, atr: float, tick_value: float=1.0) -> float:
        if atr!=atr or atr<=0: return 0.0
        risk_amount=equity*risk_per_trade
        size=risk_amount/(atr*tick_value)
        return max(0.0, size)

    def stops(self, price: float, atr: float, mult_sl: float=1.5, mult_tp: float=2.5) -> Dict[str,float]:
        if atr!=atr or atr<=0: return {"sl": None, "tp": None}
        return {"sl": round(price - mult_sl*atr, 8), "tp": round(price + mult_tp*atr, 8)}

class Backtester:
    def run(self, bars: List[MarketBar], strat: StrategyPro) -> BacktestReport:
        if len(bars)<50: return BacktestReport(0,0,0,0,"veri yetersiz")
        pnl=[]; wins=0; trades=0; pos=0.0; entry=0.0
        for i in range(30,len(bars)):
            window=bars[:i+1]
            h=[b.high for b in window]; l=[b.low for b in window]; c=[b.close for b in window]; v=[b.volume for b in window]
            action, conf, feats = strat.score(h,l,c,v)
            if action=="BUY" and pos<=0:
                pos=1.0; entry=c[-1]; trades+=1
            elif action=="SELL" and pos>0:
                r=c[-1]-entry; pnl.append(r); wins+=1 if r>0 else 0; pos=0.0
        if pos>0:
            r=bars[-1].close-entry; pnl.append(r); wins+=1 if r>0 else 0
        total=sum(pnl); wr=round(100*wins/max(1,len(pnl)),1)
        mu=statistics.mean(pnl) if pnl else 0; sd=statistics.pstdev(pnl) if len(pnl)>1 else 1
        sharpe=round((mu/(sd if sd!=0 else 1))*math.sqrt(252),2) if pnl else 0
        return BacktestReport(trades, wr, round(total,2), sharpe)

# =======================
# Onâ€‘chain (mock)
# =======================

DEFAULT_NETWORKS={
    "Mock":{"rpc":"","chainId":0}
}

def keccak_hex(data:bytes)->str:
    try:
        from web3 import Web3
        return Web3.keccak(data).hex()
    except Exception:
        import hashlib
        return "0x"+hashlib.sha3_256(data).hexdigest()

class MockChain:
    def __init__(self):
        self.ledger={"signals":[]} ; self.tx=0
    def submit_signal(self, addr, h, meta):
        self.tx+=1; tid=f"mocktx_{self.tx}"
        self.ledger["signals"].append({"addr":addr,"hash":h,"meta":meta,"tx":tid})
        return tid

class OnChainClient:
    def __init__(self):
        self.address="0xMOCK"; self.active={"name":"Mock","chainId":0}
        self.mock=MockChain()
    def connect(self, name:str="Mock", priv:Optional[str]=None):
        self.address="0xMOCK"; self.active={"name":name if name in DEFAULT_NETWORKS else "Mock","chainId":DEFAULT_NETWORKS.get(name,{}).get("chainId",0)}
    def anchor(self, payload:Dict[str,Any])->Dict[str,str]:
        data=json.dumps(payload, ensure_ascii=False, sort_keys=True, default=str).encode("utf-8")
        h=keccak_hex(data)
        tx=self.mock.submit_signal(self.address,h,{"act":payload.get("action"),"conf":payload.get("confidence")})
        return {"hash":h,"tx":tx,"address":self.address}

# =======================
# Broker arayÃ¼zleri
# =======================

class DummyBroker:
    def __init__(self, equity: float=10_000.0): self._eq=equity
    def send_order(self, symbol, side, size, price=None): 
        print(f"[ORDER] {symbol} {side} size={round(size,6)} price={price}")
        return {"ok":True, "symbol":symbol, "side":side, "size":size, "price":price, "ts":datetime.utcnow().isoformat()}
    def get_equity(self)->float: return self._eq

class CCXTBroker:
    def __init__(self, exchange_id: str, apiKey: Optional[str]=None, secret: Optional[str]=None, password: Optional[str]=None, sandbox: bool=False):
        if not HAS_CCXT: raise RuntimeError("ccxt kurulu deÄŸil. `pip install ccxt`")
        ex_class=getattr(ccxt, exchange_id)
        self.ex=ex_class({'apiKey': apiKey, 'secret': secret, 'password': password, 'enableRateLimit': True})
        if sandbox and hasattr(self.ex, 'set_sandbox_mode'): self.ex.set_sandbox_mode(True)
    def send_order(self, symbol: str, side: str, size: float, price: float|None=None, order_type: str="market"):
        params={}
        if order_type.lower()=="market":
            return self.ex.create_order(symbol, "market", side.lower(), size, None, params)
        else:
            if price is None: raise ValueError("Limit emir iÃ§in price gerekli")
            return self.ex.create_order(symbol, "limit", side.lower(), size, price, params)
    def get_equity(self)->float:
        try:
            bal=self.ex.fetch_balance()
            # Spot iÃ§in "total" veya "USD" benzeri; basitÃ§e toplamlaÅŸtÄ±r
            total=0.0
            for k,v in bal.get("total", {}).items():
                if isinstance(v,(int,float)): total+=float(v)
            return total
        except Exception:
            return 0.0
    def fetch_ohlcv(self, symbol: str, timeframe: str="1m", limit: int=200):
        return self.ex.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)

# =======================
# Bot kontrolÃ¼
# =======================

class TradingBot:
    def __init__(self, broker):
        self.broker=broker
        self.strat=StrategyPro()
        self.ai=AIAdvisorPro()
        self.risk=RiskManager()
        self.onchain=OnChainClient()

    def decide(self, bars: List[MarketBar]) -> Signal:
        h=[b.high for b in bars]; l=[b.low for b in bars]; c=[b.close for b in bars]; v=[b.volume for b in bars]
        action, conf, feats = self.strat.score(h,l,c,v)
        reg="Trend" if feats.get("adx",0)>=22 else "Range"
        return Signal(bars[-1].symbol, action, conf, reg, feats, bars[-1].ts)

    def act(self, sig: Signal, atr: float=1.0, risk_per_trade: float=0.01, order_type: str="market", dryrun: bool=True):
        price=sig.features.get("last_price")
        size=self.risk.position_size(self.broker.get_equity(), risk_per_trade, atr=atr, tick_value=1.0)
        if sig.action in ("BUY","SELL") and size>0:
            if dryrun:
                print(f"[DRYRUN] {sig.symbol} {sig.action} size={round(size,6)} price={price} type={order_type}")
                return {"ok":True,"dryrun":True}
            return self.broker.send_order(sig.symbol, "BUY" if sig.action=="BUY" else "SELL", size, price=price)

    def anchor_signal(self, sig: Signal):
        payload={"symbol":sig.symbol,"action":sig.action,"confidence":sig.confidence,"regime":sig.regime,"timestamp":sig.timestamp.isoformat()}
        ack=self.onchain.anchor(payload)
        print("[ONCHAIN]", ack)

# =======================
# DÃ¶nÃ¼ÅŸÃ¼mler ve yardÄ±mcÄ±lar
# =======================

def df_to_bars(df, symbol: Optional[str]=None) -> List[MarketBar]:
    bars=[]
    for _,row in df.iterrows():
        bars.append(MarketBar(
            ts=pd.to_datetime(row["timestamp"]).to_pydatetime(),
            symbol=symbol or row.get("symbol","SYMBOL") if hasattr(row,'get') else (symbol or "SYMBOL"),
            open=float(row["open"]),
            high=float(row["high"]),
            low=float(row["low"]),
            close=float(row["close"]),
            volume=float(row.get("volume",0.0) if hasattr(row,'get') else row["volume"] if "volume" in df.columns else 0.0)
        ))
    return bars

def list_to_bars(rows: List[List[Any]], symbol: str) -> List[MarketBar]:
    # rows: [ms, open, high, low, close, volume]
    out=[]
    for r in rows:
        ts=datetime.utcfromtimestamp(int(r[0])/1000)
        out.append(MarketBar(ts, symbol, float(r[1]), float(r[2]), float(r[3]), float(r[4]), float(r[5] if len(r)>5 else 0)))
    return out

# =======================
# Async canlÄ± dÃ¶ngÃ¼ (opsiyonel hÄ±zlandÄ±rma)
# =======================

async def live_loop(exchange_id: str, symbol: str, timeframe: str="1m", apiKey: Optional[str]=None, secret: Optional[str]=None, dryrun: bool=True, sandbox: bool=False, onchain: bool=False, use_mp: bool=False, risk_per_trade: float=0.01):
    if not HAS_CCXT: raise RuntimeError("ccxt gerekli. `pip install ccxt`")
    broker=CCXTBroker(exchange_id, apiKey=apiKey, secret=secret, sandbox=sandbox)
    bot=TradingBot(broker)
    bot.onchain.connect("Mock", None)

    last_ts=None
    while True:
        try:
            raw=broker.fetch_ohlcv(symbol, timeframe=timeframe, limit=200)
            bars=list_to_bars(raw, symbol)
            if not bars: 
                await asyncio.sleep(1); 
                continue
            if last_ts is not None and bars[-1].ts<=last_ts:
                await asyncio.sleep(0.5)
                continue
            last_ts=bars[-1].ts

            # HesaplamayÄ± istenirse ayrÄ± sÃ¼reÃ§te yap
            if use_mp:
                from concurrent.futures import ProcessPoolExecutor
                loop=asyncio.get_running_loop()
                with ProcessPoolExecutor(max_workers=1) as pool:
                    sig=await loop.run_in_executor(pool, _decide_sync, bars)
            else:
                sig=bot.decide(bars)

            print(f"[SIGNAL] {sig.symbol} {sig.action} conf={round(sig.confidence,3)} reg={sig.regime} t={sig.timestamp}")

            # ATR kabaca son 14 bar Ã¼zerinden
            atr=TA.ATR([b.high for b in bars], [b.low for b in bars], [b.close for b in bars], 14)
            bot.act(sig, atr=atr if atr==atr else 1.0, risk_per_trade=risk_per_trade, order_type="market", dryrun=dryrun)
            if onchain: bot.anchor_signal(sig)

            # timeframeâ€™e gÃ¶re uyku
            await asyncio.sleep(1.0)
        except Exception as e:
            print("[LIVE ERROR]", e)
            await asyncio.sleep(2.0)

def _decide_sync(bars: List[MarketBar]) -> Signal:
    # AyrÄ± sÃ¼reÃ§te Ã§aÄŸrÄ±labilir
    tb=TradingBot(DummyBroker())
    return tb.decide(bars)

# =======================
# CLI
# =======================

def main():
    p=argparse.ArgumentParser(description="Nova Ultra (tek dosya) â€” 20+ TA, AI, backtest, onâ€‘chain, CCXT")
    sub=p.add_subparsers(dest="cmd")

    a=sub.add_parser("analyze", help="CSV analiz ve sinyal")
    a.add_argument("--csv", required=True)
    a.add_argument("--symbol", required=False)

    b=sub.add_parser("backtest", help="CSV backtest")
    b.add_argument("--csv", required=True)
    b.add_argument("--symbol", required=False)
    b.add_argument("--html", required=False, help="HTML rapor yolu")

    l=sub.add_parser("live", help="CanlÄ± CCXT dÃ¶ngÃ¼")
    l.add_argument("--exchange", required=True, help="Ã¶rn. binance, bybit, okx")
    l.add_argument("--symbol", required=True, help="Ã¶rn. BTC/USDT")
    l.add_argument("--timeframe", default="1m")
    l.add_argument("--apikey", default=None)
    l.add_argument("--secret", default=None)
    l.add_argument("--sandbox", action="store_true")
    l.add_argument("--dryrun", action="store_true")
    l.add_argument("--onchain", action="store_true")
    l.add_argument("--use-mp", action="store_true")
    l.add_argument("--risk", type=float, default=0.01, help="iÅŸlem baÅŸÄ±na risk oranÄ± (0.01=%%1)")

    args=p.parse_args()
    if args.cmd=="analyze":
        bars=load_ohlcv_csv(args.csv)
        if args.symbol:
            bars=[b for b in bars if b.symbol==args.symbol]
        if not bars:
            print("Veri bulunamadÄ±."); sys.exit(1)
        strat=StrategyPro()
        h=[b.high for b in bars]; l=[b.low for b in bars]; c=[b.close for b in bars]; v=[b.volume for b in bars]
        action, conf, feats=strat.score(h,l,c,v)
        reg="Trend" if feats.get("adx",0)>=22 else "Range"
        sig=Signal(bars[-1].symbol, action, conf, reg, feats, bars[-1].ts)
        print(json.dumps({
            "symbol":sig.symbol,"action":sig.action,"confidence":round(sig.confidence,3),
            "regime":sig.regime,"features":{k: (round(v,6) if isinstance(v,float) else v) for k,v in sig.features.items()},
            "timestamp":sig.timestamp.isoformat()
        }, ensure_ascii=False, indent=2))
    elif args.cmd=="backtest":
        bars=load_ohlcv_csv(args.csv)
        if args.symbol:
            bars=[b for b in bars if b.symbol==args.symbol]
        if not bars:
            print("Veri bulunamadÄ±."); sys.exit(1)
        rep=Backtester().run(bars, StrategyPro())
        print(json.dumps({
            "trades":rep.trades,"win_rate":rep.win_rate,"pnl":rep.pnl,"sharpe_like":rep.sharpe_like,"notes":rep.notes
        }, ensure_ascii=False, indent=2))
        if args.html:
            overview={"symbol": bars[-1].symbol if bars else "SYMBOL", "metrics":{
                "Ä°ÅŸlem sayÄ±sÄ±": rep.trades,
                "Kazanma oranÄ± %": rep.win_rate,
                "PNL": rep.pnl,
                "Sharpe-benzeri": rep.sharpe_like
            }}
            save_html_report(args.html, overview)
            print(f"HTML rapor yazÄ±ldÄ±: {args.html}")
    elif args.cmd=="live":
        asyncio.run(live_loop(args.exchange, args.symbol, timeframe=args.timeframe, apiKey=args.apikey, secret=args.secret, dryrun=args.dryrun, sandbox=args.sandbox, onchain=args.onchain, use_mp=args.use_mp, risk_per_trade=args.risk))
    else:
        p.print_help()

if __name__=="__main__":
    main()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\NovaStrategos_v10X_ultra_onchain.py
# NovaStrategos_v10X_ultra_onchain.py
# Ultra hibrit v10 â€” tek dosyada onâ€‘chain + offâ€‘chain mÃ¼kemmeliyetÃ§i strateji paneli

import sys, csv, json, os, math, random, statistics, hashlib, webbrowser
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from PyQt5 import QtWidgets, QtCore, QtGui

# --- Web3 / Keccak isteÄŸe baÄŸlÄ± ---
HAS_WEB3 = False
HAS_KECCAK = False
try:
    from web3 import Web3
    from eth_account import Account
    from eth_account.messages import encode_structured_data
    HAS_WEB3 = True
except Exception:
    HAS_WEB3 = False

try:
    from eth_utils import keccak as ethutils_keccak
    HAS_KECCAK = True
except Exception:
    HAS_KECCAK = False

# =========================
# Veri modeli
# =========================

@dataclass
class EmotionLog:
    task_id: str
    emotion: str
    feeling_strength: float
    timestamp: datetime

# =========================
# YardÄ±mcÄ±lar / KalÄ±cÄ±lÄ±k
# =========================

class NotificationBus:
    def __init__(self, sound_on=True):
        self.sound_on = sound_on
    def send(self, msg: str, widget: Optional[QtWidgets.QWidget]=None):
        ts = datetime.utcnow().strftime("%H:%M:%S")
        print(f"[{ts}] {msg}")
        if widget and self.sound_on:
            QtWidgets.QApplication.beep()

class Persist:
    def __init__(self, path="nova_config.json"):
        self.path = path
        self.data: Dict[str, Any] = {}
        self.load()
    def load(self):
        if os.path.exists(self.path):
            try:
                with open(self.path, "r", encoding="utf-8") as f:
                    self.data = json.load(f)
            except Exception:
                self.data = {}
    def save(self):
        try:
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump(self.data, f, ensure_ascii=False, indent=2, default=str)
        except Exception as e:
            print(f"[Persist] save error: {e}")

# =========================
# IO KÃ¶prÃ¼sÃ¼ (CSV/JSON/HTML)
# =========================

class IOBridge:
    @staticmethod
    def load_logs_csv(path: str) -> List[EmotionLog]:
        logs = []
        with open(path, "r", encoding="utf-8") as f:
            r = csv.DictReader(f)
            for row in r:
                try:
                    ts = row.get("timestamp") or datetime.utcnow().isoformat()
                    logs.append(EmotionLog(
                        task_id=row["task_id"],
                        emotion=row.get("emotion","Neutral"),
                        feeling_strength=float(row["feeling_strength"]),
                        timestamp=datetime.fromisoformat(ts.replace("Z",""))
                    ))
                except Exception:
                    continue
        return logs

    @staticmethod
    def save_report_csv(path: str, report: Dict[str, Any]):
        keys = ["task_id","avg","max","vol","risk","regime","count"]
        with open(path, "w", encoding="utf-8", newline="") as f:
            w = csv.writer(f); w.writerow(keys)
            for t,m in report.items():
                w.writerow([t, m["avg"], m["max"], m["vol"], m["risk"], m.get("regime","-"), m["count"]])

    @staticmethod
    def save_snapshot_json(path: str, payload: Dict[str, Any]):
        with open(path, "w", encoding="utf-8") as f:
            json.dump(payload, f, ensure_ascii=False, indent=2, default=str)

    @staticmethod
    def save_html_overview(path: str, overview: Dict[str, Any]):
        head = "<style>body{font-family:Segoe UI,Arial}table{border-collapse:collapse}td,th{border:1px solid #ccc;padding:6px}</style>"
        rows = ""
        for task, m in overview["report"].items():
            rows += f"<tr><td>{task}</td><td>{m['avg']}</td><td>{m['max']}</td><td>{m['vol']}</td><td>{m['risk']}</td><td>{m.get('regime','-')}</td></tr>"
        html = f"""<html><head>{head}</head><body>
        <h2>Nova Strategos â€” Ã–zet</h2>
        <p>KullanÄ±cÄ±: {overview['user']['name']} | Risk: {overview['user']['risk_level']} | Tarih: {datetime.utcnow().isoformat()}</p>
        <table><tr><th>GÃ¶rev</th><th>Ortalama</th><th>Maks</th><th>Vol</th><th>Risk</th><th>Rejim</th></tr>{rows}</table>
        <h3>Notlar</h3><pre>{overview.get('notes','')}</pre></body></html>"""
        with open(path,"w",encoding="utf-8") as f: f.write(html)

# =========================
# Ã‡ekirdek analiz/gÃ¶sterge
# =========================

class NovaEmotionStrategos:
    def __init__(self):
        self.logs: List[EmotionLog] = []
        self._cache: Optional[Dict[str, Any]] = None
    def ingest(self, log: EmotionLog):
        self.logs.append(log); self._cache = None
    def series(self, task_id: str) -> List[float]:
        return [l.feeling_strength for l in self.logs if l.task_id==task_id]
    def analyze(self) -> Dict[str, Any]:
        if self._cache is not None: return self._cache
        out: Dict[str, Any] = {}; bucket: Dict[str, List[float]] = {}
        for l in self.logs: bucket.setdefault(l.task_id, []).append(l.feeling_strength)
        for t, arr in bucket.items():
            avg = round(statistics.mean(arr),2) if arr else 0
            mx  = max(arr) if arr else 0
            vol = round(statistics.stdev(arr),2) if len(arr)>1 else 0
            risk = "YÃ¼ksek" if (avg>=7 and vol>=2) else "Orta" if avg>=5 else "DÃ¼ÅŸÃ¼k"
            out[t] = {"avg":avg,"max":mx,"vol":vol,"risk":risk,"count":len(arr)}
        self._cache = out
        return out

class IndicatorEngine:
    def __init__(self, core: NovaEmotionStrategos):
        self.core = core
        self.alpha_fast = 2/(5+1); self.alpha_slow = 2/(12+1)
    def _ema(self, vals, a):
        if not vals: return 0.0
        ema = vals[0]
        for v in vals[1:]: ema = a*v + (1-a)*ema
        return round(ema,3)
    def _rsi(self, vals, p=14):
        if len(vals)<2: return 50.0
        g,l = [],[]
        for i in range(1,len(vals)):
            d = vals[i]-vals[i-1]; g.append(max(0,d)); l.append(max(0,-d))
        pg = sum(g[-p:])/max(1,min(p,len(g))); pl = sum(l[-p:])/max(1,min(p,len(l)))
        rs = pg/(pl if pl!=0 else 1e-6); rsi = 100 - (100/(1+rs))
        return round(max(0,min(100,rsi)),2)
    def _ew_vol(self, vals, a=0.2):
        if len(vals)<2: return 0.0
        mean=vals[0]; var=0.0
        for v in vals[1:]:
            mean = a*v + (1-a)*mean
            var = a*((v-mean)**2) + (1-a)*var
        return round(math.sqrt(var),3)
    def _z(self, vals, w=20):
        if not vals: return 0.0
        sl = vals[-w:]; mu = statistics.mean(sl); sd = statistics.pstdev(sl) if len(sl)>1 else 1.0
        return round((vals[-1]-mu)/(sd if sd>1e-6 else 1.0),3)
    def features(self, task_id: str) -> Dict[str,float]:
        s = self.core.series(task_id)
        fast = self._ema(s,self.alpha_fast); slow = self._ema(s,self.alpha_slow)
        macd = round(fast-slow,3); rsi=self._rsi(s); ewv=self._ew_vol(s); z=self._z(s)
        return {"ema_fast":fast,"ema_slow":slow,"macd":macd,"rsi":rsi,"ew_vol":ewv,"z":z}

class RegimeDetector:
    def detect(self, f: Dict[str,float]) -> str:
        if f["rsi"]>65 or (f["ew_vol"]>2 and f["z"]>1): return "Stres"
        if 45<=f["rsi"]<=65 and (0.5<f["ew_vol"]<2.5):   return "DalgalÄ±"
        return "Sakin"

class SignalEngine:
    def __init__(self, cooldown_sec=20):
        self.cooldown = timedelta(seconds=cooldown_sec)
        self.last_at: Dict[str, datetime] = {}
    def can_signal(self, task_id: str)->bool:
        t=self.last_at.get(task_id); return (t is None) or (datetime.utcnow()-t>=self.cooldown)
    def mark(self, task_id: str): self.last_at[task_id]=datetime.utcnow()
    def generate(self, task_id, m, user_risk, regime, f) -> str:
        avg, vol = m["avg"], m["vol"]
        sens = max(0.5,min(1.5,1+(user_risk-5)*0.08))
        base = avg*0.5 + vol*0.3 + max(0,f["z"])*0.2
        if regime=="Stres": base += 1.0
        score = base*sens
        if score>7:   return f"âš ï¸ {task_id}: YÃ¼ksek stres (avg:{avg}, vol:{vol}, z:{f['z']}, rejim:{regime})"
        if score>5.5: return f"ðŸ” {task_id}: Dalgalanma izlenmeli (avg:{avg}, vol:{vol}, rejim:{regime})"
        return f"âœ… {task_id}: Stabil (avg:{avg}, vol:{vol}, rejim:{regime})"

class AIAdvisor:
    def __init__(self, persist: Persist):
        self.persist = persist
        self.w = persist.data.get("ai_weights") or {"macd":0.8,"rsi":0.5,"z":0.6,"ew_vol":0.4,"bias":-0.5}
        self.lr = persist.data.get("ai_lr") or 0.05
    def _vec(self, f): return {"macd":f["macd"], "rsi":(f["rsi"]-50)/25, "z":f["z"], "ew_vol":f["ew_vol"]/3.0}
    def score(self, f)->float:
        x=self._vec(f); s=sum(self.w.get(k,0)*x[k] for k in x)+self.w.get("bias",0); return round(s,3)
    def advise(self, f, regime):
        s=self.score(f)
        if s>1.2 or regime=="Stres": return "Deeskalasyon: kÄ±sa mola, gÃ¶rev rotasyonu, nefes."
        if s>0.4: return "YakÄ±n izleme: mikro check-in, odak teknikleri."
        return "Devam: akÄ±ÅŸta kal, kÃ¼Ã§Ã¼k kazanÄ±mlarÄ± pekiÅŸtir."
    def feedback(self, f, good: bool):
        y=1 if good else -1; x=self._vec(f)
        margin = y*(sum(self.w.get(k,0)*x[k] for k in x)+self.w.get("bias",0))
        if margin<1:
            for k in x: self.w[k]=self.w.get(k,0)+self.lr*y*x[k]
            self.w["bias"]=self.w.get("bias",0)+self.lr*y
            self.persist.data["ai_weights"]=self.w; self.persist.save()

class RiskManager:
    def size(self, conf: float, user_risk: int)->Dict[str,Any]:
        base=min(max(conf,0.5),0.95); rf=0.5+(user_risk/20); size=round(1000*base*rf,0)
        sl=round(1.0+(1.0-base)*0.5,3); tp=round(1.0+base*1.2,3)
        return {"size":size,"sl_mult":sl,"tp_mult":tp}

# =========================
# Backtester
# =========================

class Backtester:
    def __init__(self, core: NovaEmotionStrategos, ind: IndicatorEngine, regime: RegimeDetector, ai: AIAdvisor):
        self.core=core; self.ind=ind; self.regime=regime; self.ai=ai
    def run(self)->Dict[str,Any]:
        logs=sorted(self.core.logs,key=lambda x:x.timestamp)
        if not logs: return {"trades":0,"win_rate":0,"pnl":0,"sharpe_like":0}
        pnl=[]; wins=0; trades=0; last={}
        for l in logs:
            f=self.ind.features(l.task_id); r=self.regime.detect(f); s=self.ai.score(f)
            action = (s>0.4) or (r=="Stres")
            prev = last.get(l.task_id, l.feeling_strength); d=l.feeling_strength-prev
            reward = -abs(d) if not action else -abs(d)*0.5
            pnl.append(reward); trades+=1; wins+=1 if reward>-0.2 else 0; last[l.task_id]=l.feeling_strength
        total = round(sum(pnl),2); wr = round(100*wins/max(1,trades),1)
        mu = statistics.mean(pnl); sd=statistics.pstdev(pnl) if len(pnl)>1 else 1.0
        sr = round((mu/(sd if sd>1e-6 else 1.0))*math.sqrt(252),2)
        return {"trades":trades,"win_rate":wr,"pnl":total,"sharpe_like":sr}

# =========================
# On-Chain katman
# =========================

DEFAULT_NETWORKS = {
    "Ethereum Sepolia": {"rpc": os.environ.get("RPC_SEPOLIA",""), "chainId": 11155111},
    "Polygon Amoy":     {"rpc": os.environ.get("RPC_AMOY",""),    "chainId": 80002},
    "BSC Testnet":      {"rpc": os.environ.get("RPC_BSCT",""),    "chainId": 97},
}

def keccak_hex(data: bytes)->str:
    if HAS_WEB3:
        try:
            return Web3.keccak(data).hex()
        except Exception:
            pass
    if HAS_KECCAK:
        try:
            return "0x"+ethutils_keccak(data).hex()
        except Exception:
            pass
    # Fallback: SHA3-256 (Ethereum keccak'tan kÃ¼Ã§Ã¼k farkÄ± vardÄ±r; Mock iÃ§in yeterli)
    return "0x"+hashlib.sha3_256(data).hexdigest()

class MockChain:
    def __init__(self):
        self.ledger = {"signals":{}, "stakes":{}, "votes":{}, "rewards":{}}
        self.tx_counter = 0
    def submit_signal(self, addr: str, sig_hash: str, meta: Dict[str,Any])->str:
        self.tx_counter+=1; tx=f"mocktx_{self.tx_counter}"
        self.ledger["signals"].setdefault(addr,[]).append({"hash":sig_hash,"meta":meta,"tx":tx,"ts":datetime.utcnow().isoformat()})
        return tx
    def stake(self, addr: str, amount: int)->str:
        self.ledger["stakes"][addr]=self.ledger["stakes"].get(addr,0)+amount; self.tx_counter+=1
        return f"mocktx_{self.tx_counter}"
    def vote(self, addr: str, pid: int, support: bool)->str:
        self.ledger["votes"].setdefault(pid,[]).append({"addr":addr,"support":support}); self.tx_counter+=1
        return f"mocktx_{self.tx_counter}"
    def reward(self, addr: str, amount: int)->str:
        self.ledger["rewards"][addr]=self.ledger["rewards"].get(addr,0)+amount; self.tx_counter+=1
        return f"mocktx_{self.tx_counter}"

class OnChainClient:
    def __init__(self, persist: Persist, bus: NotificationBus):
        self.persist=persist; self.bus=bus
        self.networks = DEFAULT_NETWORKS
        self.active_net = None
        self.address = None
        self._w3 = None
        self._acct = None
        self.mock = MockChain()

    def connect(self, net_name: str, privkey: Optional[str]):
        cfg = self.networks.get(net_name)
        if (not cfg) or (not cfg["rpc"]):
            self.bus.send("RPC bulunamadÄ±, MockChain devrede.")
            self.active_net = {"name":"Mock","chainId":0}
            self._w3=None; self._acct=None; self.address="0xMOCK"
            return
        if not HAS_WEB3:
            self.bus.send("web3 yok, MockChain devrede.")
            self.active_net = {"name":net_name,"chainId":cfg["chainId"]}
            self._w3=None; self._acct=None; self.address="0xMOCK"
            return
        try:
            w3 = Web3(Web3.HTTPProvider(cfg["rpc"]))
            if not w3.is_connected():
                self.bus.send("RPC baÄŸlantÄ±sÄ± baÅŸarÄ±sÄ±z, MockChain devrede.")
                self._w3=None; self.address="0xMOCK"
            else:
                self._w3 = w3
                if privkey:
                    acct = Account.from_key(privkey)
                    self._acct = acct; self.address = acct.address
                else:
                    self._acct=None; self.address=None
                self.active_net = {"name":net_name,"chainId":cfg["chainId"]}
                self.bus.send(f"AÄŸa baÄŸlandÄ±: {net_name} (chainId {cfg['chainId']})")
        except Exception as e:
            self.bus.send(f"BaÄŸlantÄ± hatasÄ±, MockChain: {e}")
            self._w3=None; self.address="0xMOCK"; self.active_net={"name":"Mock","chainId":0}

    def gas_info(self)->Dict[str,Any]:
        if self._w3:
            try:
                gp = self._w3.eth.gas_price
                blk = self._w3.eth.get_block("latest")
                base = blk.get("baseFeePerGas", gp)
                return {"gas_price": int(gp), "base_fee": int(base), "block": blk.number}
            except Exception:
                pass
        # Mock
        return {"gas_price": 1_000_000_000, "base_fee": 1_000_000_000, "block": 0}

    def anchor_signal(self, payload: Dict[str,Any])->Dict[str,str]:
        data = json.dumps(payload, sort_keys=True, ensure_ascii=False).encode("utf-8")
        sig_hash = keccak_hex(data)
        signature = ""
        if HAS_WEB3 and self._acct:
            try:
                typed = {
                    "types": {
                        "EIP712Domain":[{"name":"name","type":"string"}],
                        "Signal":[
                            {"name":"task","type":"string"},
                            {"name":"hash","type":"bytes32"},
                            {"name":"timestamp","type":"string"}
                        ]
                    },
                    "domain":{"name":"NovaStrategos"},
                    "primaryType":"Signal",
                    "message":{"task":payload["task_id"],"hash":sig_hash,"timestamp":payload["timestamp"]}
                }
                msg = encode_structured_data(primitive=typed)
                signature = self._acct.sign_message(msg).signature.hex()
            except Exception:
                signature = ""
        meta = {"risk": payload.get("risk","-"), "score": payload.get("score",0)}
        if self._w3 and self._acct:
            tx = f"0x{sig_hash[2:10]}_sim"  # Kontrat entegrasyonu eklenince gerÃ§ek tx
        else:
            tx = self.mock.submit_signal(self.address or "0xMOCK", sig_hash, meta)
        return {"hash": sig_hash, "signature": signature, "tx": tx}

    def stake(self, amount: int)->str:
        if self._w3 and self._acct:
            return f"0xstake_sim_{amount}"
        return self.mock.stake(self.address or "0xMOCK", amount)

    def vote(self, proposal_id: int, support: bool)->str:
        if self._w3 and self._acct:
            return f"0xvote_sim_{proposal_id}_{int(support)}"
        return self.mock.vote(self.address or "0xMOCK", proposal_id, support)

    def reward(self, amount: int)->str:
        if self._w3 and self._acct:
            return f"0xreward_sim_{amount}"
        return self.mock.reward(self.address or "0xMOCK", amount)

# =========================
# AkÄ±ÅŸ simÃ¼latÃ¶rÃ¼
# =========================

class StreamSimulator(QtCore.QObject):
    newLog = QtCore.pyqtSignal(EmotionLog)
    def __init__(self, parent=None, tasks=None):
        super().__init__(parent)
        self.timer = QtCore.QTimer(self); self.timer.timeout.connect(self._tick)
        self.tasks = tasks or ["ALPHA","BETA","GAMMA"]
        self.speed_ms = 1200
    def start(self, ms=None):
        self.speed_ms = ms or self.speed_ms; self.timer.start(self.speed_ms)
    def stop(self): self.timer.stop()
    def _tick(self):
        t=random.choice(self.tasks); e=random.choice(["Stress","Focus","Anxiety","Calm"])
        s=round(random.uniform(3.0,9.5),2)
        self.newLog.emit(EmotionLog(t,e,s,datetime.utcnow()))

# =========================
# UI Panel
# =========================

class TraderDashboard(QtWidgets.QWidget):
    def __init__(self, user: Dict[str,Any], core: NovaEmotionStrategos,
                 ind: IndicatorEngine, regime: RegimeDetector,
                 sig: SignalEngine, ai: AIAdvisor, risk: RiskManager,
                 persist: Persist, bus: NotificationBus, chain: OnChainClient):
        super().__init__()
        self.setWindowTitle("ðŸ“Š Nova Strategos v10X â€” Ultra Hibrit Onâ€‘Chain")
        self.user=user; self.core=core; self.ind=ind; self.regime=regime
        self.sig=sig; self.ai=ai; self.risk=risk; self.persist=persist; self.bus=bus; self.chain=chain
        self.sim = StreamSimulator(self); self.sim.newLog.connect(self.on_new_log)
        self._build_ui(); self._bind(); self.refresh_all()

    def _build_ui(self):
        lay = QtWidgets.QVBoxLayout(self)
        title = QtWidgets.QLabel(f"HoÅŸ geldin {self.user['name']}"); title.setStyleSheet("font-weight:700;font-size:16px;")
        lay.addWidget(title)
        self.tabs = QtWidgets.QTabWidget(); lay.addWidget(self.tabs)

        # Dashboard
        dash = QtWidgets.QWidget(); d = QtWidgets.QVBoxLayout(dash)
        ctr = QtWidgets.QHBoxLayout()
        self.risk_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal); self.risk_slider.setRange(1,10); self.risk_slider.setValue(self.user.get("risk_level",6))
        self.chk_anchor = QtWidgets.QCheckBox("Sinyali zincire Ã§apala"); self.chk_anchor.setChecked(True)
        self.btn_stream = QtWidgets.QPushButton("â–¶ï¸ CanlÄ±"); self.btn_stop = QtWidgets.QPushButton("â¸ï¸ Durdur")
        self.btn_analyze= QtWidgets.QPushButton("ðŸ§  Analiz"); self.btn_signal= QtWidgets.QPushButton("ðŸ“¡ Sinyal Bas")
        ctr.addWidget(QtWidgets.QLabel("âš™ï¸ Risk:")); ctr.addWidget(self.risk_slider); ctr.addWidget(self.chk_anchor)
        ctr.addWidget(self.btn_stream); ctr.addWidget(self.btn_stop); ctr.addWidget(self.btn_analyze); ctr.addWidget(self.btn_signal)
        d.addLayout(ctr)
        split = QtWidgets.QSplitter()
        left = QtWidgets.QWidget(); ll = QtWidgets.QVBoxLayout(left)
        ll.addWidget(QtWidgets.QLabel("ðŸ“¡ Sinyaller")); self.signal_box = QtWidgets.QTextEdit(); self.signal_box.setReadOnly(True); ll.addWidget(self.signal_box)
        ll.addWidget(QtWidgets.QLabel("ðŸ§­ AI DanÄ±ÅŸman")); self.ai_box=QtWidgets.QTextEdit(); self.ai_box.setReadOnly(True); ll.addWidget(self.ai_box)
        fb = QtWidgets.QHBoxLayout(); self.btn_good=QtWidgets.QPushButton("ðŸ‘ Ä°yi"); self.btn_bad=QtWidgets.QPushButton("ðŸ‘Ž KÃ¶tÃ¼"); fb.addWidget(self.btn_good); fb.addWidget(self.btn_bad); ll.addLayout(fb)
        right = QtWidgets.QWidget(); rr = QtWidgets.QVBoxLayout(right)
        rr.addWidget(QtWidgets.QLabel("ðŸ“ˆ GÃ¶rev Metrikleri")); self.metrics=QtWidgets.QTextEdit(); self.metrics.setReadOnly(True); rr.addWidget(self.metrics)
        rr.addWidget(QtWidgets.QLabel("ðŸ“Š GÃ¶stergeler")); self.inds=QtWidgets.QTextEdit(); self.inds.setReadOnly(True); rr.addWidget(self.inds)
        split.addWidget(left); split.addWidget(right); d.addWidget(split)
        self.status = QtWidgets.QLabel("HazÄ±r."); d.addWidget(self.status)
        self.tabs.addTab(dash,"Dashboard")

        # Veri
        dataw = QtWidgets.QWidget(); dv = QtWidgets.QVBoxLayout(dataw)
        btns = QtWidgets.QHBoxLayout()
        self.btn_load=QtWidgets.QPushButton("ðŸ“¥ CSV YÃ¼kle"); self.btn_export=QtWidgets.QPushButton("ðŸ“¤ CSV Rapor"); self.btn_snap=QtWidgets.QPushButton("ðŸ§¾ JSON Snapshot"); self.btn_html=QtWidgets.QPushButton("ðŸ–¨ï¸ HTML Ã–zet")
        btns.addWidget(self.btn_load); btns.addWidget(self.btn_export); btns.addWidget(self.btn_snap); btns.addWidget(self.btn_html); dv.addLayout(btns)
        self.table = QtWidgets.QTableWidget(0,4); self.table.setHorizontalHeaderLabels(["timestamp","task_id","emotion","feeling_strength"]); self.table.horizontalHeader().setStretchLastSection(True)
        dv.addWidget(self.table)
        self.tabs.addTab(dataw,"Veri")

        # Backtest
        btw = QtWidgets.QWidget(); bv = QtWidgets.QVBoxLayout(btw)
        self.btn_back=QtWidgets.QPushButton("â±ï¸ Backtest"); self.bt_out=QtWidgets.QTextEdit(); self.bt_out.setReadOnly(True)
        bv.addWidget(self.btn_back); bv.addWidget(self.bt_out)
        self.tabs.addTab(btw,"Backtest")

        # On-Chain
        chw = QtWidgets.QWidget(); chv = QtWidgets.QFormLayout(chw)
        self.cmb_net = QtWidgets.QComboBox(); self.cmb_net.addItems(list(DEFAULT_NETWORKS.keys())+["Mock"])
        self.ed_priv = QtWidgets.QLineEdit(); self.ed_priv.setEchoMode(QtWidgets.QLineEdit.Password); self.ed_priv.setPlaceholderText("Ã–zel anahtar (0x...) â€” opsiyonel")
        self.btn_connect = QtWidgets.QPushButton("ðŸ”— BaÄŸlan")
        self.lbl_addr = QtWidgets.QLabel("Adres: -")
        self.lbl_chain = QtWidgets.QLabel("AÄŸ: -"); self.lbl_gas = QtWidgets.QLabel("Gas: -")
        self.ed_stake = QtWidgets.QSpinBox(); self.ed_stake.setRange(0,1_000_000); self.btn_stake=QtWidgets.QPushButton("ðŸª™ Stake")
        self.ed_pid = QtWidgets.QSpinBox(); self.ed_pid.setRange(0,1_000_000); self.chk_support=QtWidgets.QCheckBox("Destekle"); self.btn_vote=QtWidgets.QPushButton("ðŸ—³ï¸ Oy Ver")
        self.btn_reward=QtWidgets.QPushButton("ðŸŽ Ã–dÃ¼l Talep (simÃ¼lasyon)")
        self.tx_log = QtWidgets.QTextEdit(); self.tx_log.setReadOnly(True); self.tx_log.setMaximumHeight(140)
        chv.addRow("AÄŸ", self.cmb_net); chv.addRow("Ã–zel anahtar", self.ed_priv); chv.addRow(self.btn_connect)
        chv.addRow(self.lbl_chain); chv.addRow(self.lbl_addr); chv.addRow(self.lbl_gas)
        chv.addRow("Stake miktarÄ±", self.ed_stake); chv.addRow(self.btn_stake)
        chv.addRow("Teklif ID", self.ed_pid); chv.addRow(self.chk_support); chv.addRow(self.btn_vote)
        chv.addRow(self.btn_reward); chv.addRow(QtWidgets.QLabel("Ä°ÅŸlem GÃ¼nlÃ¼ÄŸÃ¼")); chv.addRow(self.tx_log)
        self.tabs.addTab(chw,"Onâ€‘Chain")

        # Ayarlar
        stw = QtWidgets.QWidget(); sf = QtWidgets.QFormLayout(stw)
        self.chk_sound=QtWidgets.QCheckBox("Bildirim sesi"); self.chk_sound.setChecked(True)
        self.spin_cd=QtWidgets.QSpinBox(); self.spin_cd.setRange(5,120); self.spin_cd.setValue(20)
        self.spin_speed=QtWidgets.QSpinBox(); self.spin_speed.setRange(200,5000); self.spin_speed.setValue(1200)
        self.chk_ind=QtWidgets.QCheckBox("GÃ¶stergeleri kullan"); self.chk_ind.setChecked(True)
        self.chk_ai=QtWidgets.QCheckBox("AI danÄ±ÅŸmanÄ± aktif"); self.chk_ai.setChecked(True)
        self.btn_save=QtWidgets.QPushButton("ðŸ’¾ AyarlarÄ± Kaydet")
        sf.addRow(self.chk_sound); sf.addRow("SoÄŸuma (sn)", self.spin_cd); sf.addRow("AkÄ±ÅŸ (ms)", self.spin_speed); sf.addRow(self.chk_ind); sf.addRow(self.chk_ai); sf.addRow(self.btn_save)
        self.tabs.addTab(stw,"Ayarlar")

        # KÄ±sayollar
        QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+L"), self, activated=self.on_load_csv)
        QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+E"), self, activated=self.on_export_csv)
        QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+B"), self, activated=self.on_backtest)

    def _bind(self):
        self.btn_stream.clicked.connect(self.on_stream)
        self.btn_stop.clicked.connect(self.on_stop)
        self.btn_analyze.clicked.connect(self.on_analyze)
        self.btn_signal.clicked.connect(self.emit_signals)
        self.btn_load.clicked.connect(self.on_load_csv)
        self.btn_export.clicked.connect(self.on_export_csv)
        self.btn_snap.clicked.connect(self.on_snapshot)
        self.btn_html.clicked.connect(self.on_html)
        self.btn_back.clicked.connect(self.on_backtest)
        self.btn_good.clicked.connect(lambda: self.on_feedback(True))
        self.btn_bad.clicked.connect(lambda: self.on_feedback(False))
        self.btn_save.clicked.connect(self.on_save)
        self.risk_slider.valueChanged.connect(self.on_risk)
        self.btn_connect.clicked.connect(self.on_connect)
        self.btn_stake.clicked.connect(self.on_stake)
        self.btn_vote.clicked.connect(self.on_vote)
        self.btn_reward.clicked.connect(self.on_reward)

    # ---- event handlers ----

    def on_stream(self):
        self.sim.start(self.spin_speed.value()); self.status.setText("AkÄ±ÅŸ baÅŸlatÄ±ldÄ±."); self.bus.send("Sim akÄ±ÅŸÄ± aÃ§Ä±k.", self)
    def on_stop(self):
        self.sim.stop(); self.status.setText("AkÄ±ÅŸ durdu."); self.bus.send("Sim akÄ±ÅŸÄ± kapalÄ±.", self)
    def on_analyze(self):
        self.refresh_all(); self.emit_signals()
    def on_new_log(self, log: EmotionLog):
        self.core.ingest(log); self._append_row(log)
        rep=self.core.analyze(); m=rep.get(log.task_id)
        if not m: return
        f = self.ind.features(log.task_id) if self.chk_ind.isChecked() else {"z":0,"ew_vol":0,"rsi":50,"macd":0,"ema_fast":0,"ema_slow":0}
        reg = self.regime.detect(f)
        if self.sig.can_signal(log.task_id):
            msg = self.sig.generate(log.task_id, m, self.user.get("risk_level",6), reg, f)
            conf = self._confidence(m,f,reg); sizing = self.risk.size(conf, self.user.get("risk_level",6))
            enriched = f"{msg} | size:{sizing['size']} | SLx:{sizing['sl_mult']} | TPx:{sizing['tp_mult']}"
            self.signal_box.append(f"{datetime.utcnow().isoformat()} â€” {enriched}")
            if self.chk_ai.isChecked(): self.ai_box.append(f"{datetime.utcnow().isoformat()} â€” {self.ai.advise(f,reg)}")
            self.sig.mark(log.task_id)
            if self.chk_anchor.isChecked(): self._anchor_signal(log.task_id, m, f, enriched)
        self.refresh_panels(task_hint=log.task_id)

    def on_load_csv(self):
        path,_=QtWidgets.QFileDialog.getOpenFileName(self,"CSV SeÃ§","","CSV (*.csv)")
        if not path: return
        logs = IOBridge.load_logs_csv(path)
        for l in logs: self.core.ingest(l); self._append_row(l)
        self.refresh_all(); self.status.setText(f"{len(logs)} kayÄ±t yÃ¼klendi."); self.bus.send("CSV yÃ¼klendi.", self)

    def on_export_csv(self):
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"Rapor Kaydet","nova_report.csv","CSV (*.csv)")
        if not path: return
        IOBridge.save_report_csv(path, self._rep_reg())
        self.status.setText("Rapor kaydedildi."); self.bus.send("CSV rapor yazÄ±ldÄ±.", self)

    def on_snapshot(self):
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"Snapshot","nova_snapshot.json","JSON (*.json)")
        if not path: return
        payload={"user":self.user,"report":self._rep_reg(),"ai_weights":self.ai.w,"timestamp":datetime.utcnow().isoformat()}
        IOBridge.save_snapshot_json(path,payload); self.status.setText("Snapshot kaydedildi."); self.bus.send("JSON snapshot.", self)

    def on_html(self):
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"HTML Ã–zet","nova_overview.html","HTML (*.html)")
        if not path: return
        IOBridge.save_html_overview(path, {"user":self.user,"report":self._rep_reg(),"notes":self.ai_box.toPlainText()[-1000:]})
        self.status.setText("HTML Ã¶zet kaydedildi."); self.bus.send("HTML Ã¶zet yazÄ±ldÄ±.", self)
        try: webbrowser.open(f"file://{os.path.abspath(path)}")
        except Exception: pass

    def on_backtest(self):
        res = Backtester(self.core,self.ind,self.regime,self.ai).run()
        self.bt_out.setText(f"Ä°ÅŸlem: {res['trades']}\nÄ°sabet: %{res['win_rate']}\nSim PnL: {res['pnl']}\nSharpe-benzeri: {res['sharpe_like']}")
        self.bus.send("Backtest tamam.", self)

    def on_feedback(self, good: bool):
        rep=self.core.analyze()
        if not rep: return
        task=max(rep.items(), key=lambda kv: kv[1]["count"])[0]
        f=self.ind.features(task); self.ai.feedback(f, good)
        self.ai_box.append(f"{datetime.utcnow().isoformat()} â€” Geri bildirim iÅŸlendi ({'iyi' if good else 'kÃ¶tÃ¼'}).")
        self.status.setText("AI aÄŸÄ±rlÄ±klarÄ± gÃ¼ncellendi."); self.bus.send("AI feedback.", self)

    def on_save(self):
        self.bus.sound_on=self.chk_sound.isChecked()
        self.sig.cooldown=timedelta(seconds=self.spin_cd.value())
        self.sim.speed_ms=self.spin_speed.value()
        self.persist.data["settings"]={"sound_on":self.bus.sound_on,"cooldown":self.spin_cd.value(),"speed_ms":self.sim.speed_ms,"use_ind":self.chk_ind.isChecked(),"use_ai":self.chk_ai.isChecked()}
        self.persist.save(); self.status.setText("Ayarlar kaydedildi.")

    def on_risk(self, v: int):
        self.user["risk_level"]=v; self.persist.data["user_profile"]=self.user; self.persist.save()
        self.status.setText(f"Risk seviyesi: {v}")

    # --- Onâ€‘Chain handlers ---
    def on_connect(self):
        net = self.cmb_net.currentText()
        priv = self.ed_priv.text().strip() or None
        self.chain.connect(net, priv)
        info = self.chain.gas_info()
        self.lbl_chain.setText(f"AÄŸ: {self.chain.active_net['name'] if self.chain.active_net else '-'}")
        self.lbl_addr.setText(f"Adres: {self.chain.address or '-'}")
        self.lbl_gas.setText(f"Gas/base: {info['gas_price']}/{info['base_fee']} | Blok: {info['block']}")
        # AÄŸ yoÄŸunluÄŸu -> daha temkinli sinyal temposu
        if info["base_fee"]>5_000_000_000:
            self.sig.cooldown = timedelta(seconds=max(10, self.spin_cd.value()+10))
            self.status.setText("AÄŸ yoÄŸun: soÄŸuma sÃ¼resi artÄ±rÄ±ldÄ±.")

    def on_stake(self):
        amt = int(self.ed_stake.value())
        tx = self.chain.stake(amt)
        self.tx_log.append(f"{datetime.utcnow().isoformat()} â€” Stake tx: {tx}")
        self.bus.send("Stake gÃ¶nderildi.", self)

    def on_vote(self):
        pid = int(self.ed_pid.value()); sup = self.chk_support.isChecked()
        tx =

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\NovaTraderDashboard_vX.py
from PyQt5 import QtWidgets, QtCore
import statistics
from collections import defaultdict

class NovaEmotionStrategos:
    def __init__(self):
        self.task_emotions = defaultdict(list)

    def ingest_log(self, log):
        task = log['task_id']
        strength = log['feeling_strength']
        self.task_emotions[task].append(strength)

    def analyze(self):
        report = {}
        for task, strengths in self.task_emotions.items():
            avg = round(statistics.mean(strengths), 2)
            max_val = max(strengths)
            vol = round(statistics.stdev(strengths), 2) if len(strengths) > 1 else 0
            risk = self.classify_risk(avg, vol)
            report[task] = {
                "Ortalama": avg,
                "Maks": max_val,
                "Volatilite": vol,
                "Risk": risk
            }
        return report

    def classify_risk(self, avg, vol):
        if avg > 7 and vol > 2:
            return "YÃ¼ksek Risk"
        elif avg > 5:
            return "Orta Risk"
        else:
            return "DÃ¼ÅŸÃ¼k Risk"

    def generate_signal(self, task_id):
        data = self.analyze().get(task_id)
        if not data:
            return "Veri yok"
        if data["Risk"] == "YÃ¼ksek Risk":
            return f"âš ï¸ GÃ¶rev '{task_id}': Duygusal stres yÃ¼ksek. MÃ¼dahale Ã¶nerilir."
        elif data["Risk"] == "Orta Risk":
            return f"ðŸ” GÃ¶rev '{task_id}': Ä°zleme Ã¶nerilir."
        else:
            return f"âœ… GÃ¶rev '{task_id}': Stabil."

class TraderDashboard(QtWidgets.QWidget):
    def __init__(self, user_profile, emotion_engine):
        super().__init__()
        self.setWindowTitle("ðŸ“Š Nova Zirve Paneli")
        self.layout = QtWidgets.QVBoxLayout()

        self.label = QtWidgets.QLabel(f"HoÅŸ geldin Komutan {user_profile['name']}")
        self.layout.addWidget(self.label)

        self.risk_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.risk_slider.setMinimum(1)
        self.risk_slider.setMaximum(10)
        self.risk_slider.setValue(user_profile["risk_level"])
        self.risk_slider.valueChanged.connect(self.update_risk_level)
        self.layout.addWidget(QtWidgets.QLabel("âš™ï¸ Risk Seviyesi"))
        self.layout.addWidget(self.risk_slider)

        self.signal_box = QtWidgets.QTextEdit()
        self.signal_box.setReadOnly(True)
        self.layout.addWidget(QtWidgets.QLabel("ðŸ“¡ Gelen Sinyaller"))
        self.layout.addWidget(self.signal_box)

        self.refresh_button = QtWidgets.QPushButton("ðŸ”„ Sinyalleri GÃ¼ncelle")
        self.refresh_button.clicked.connect(self.refresh_signals)
        self.layout.addWidget(self.refresh_button)

        self.setLayout(self.layout)
        self.resize(500, 350)

        self.emotion_engine = emotion_engine
        self.user_profile = user_profile

    def update_risk_level(self):
        self.user_profile["risk_level"] = self.risk_slider.value()

    def refresh_signals(self):
        self.signal_box.clear()
        report = self.emotion_engine.analyze()
        for task_id in report:
            signal = self.emotion_engine.generate_signal(task_id)
            self.signal_box.append(signal)

# Ã–rnek kullanÄ±m:
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)

    user_profile = {"name": "Kamal", "risk_level": 6}
    engine = NovaEmotionStrategos()

    # Ã–rnek veri giriÅŸi
    logs = [
        {"task_id": "X-Alpha", "emotion": "Stres", "feeling_strength": 8},
        {"task_id": "X-Alpha", "emotion": "KaygÄ±", "feeling_strength": 7},
        {"task_id": "Y-Beta", "emotion": "Odak", "feeling_strength": 4}
    ]
    for log in logs:
        engine.ingest_log(log)

    panel = TraderDashboard(user_profile, engine)
    panel.show()
    sys.exit(app.exec_())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\realtime_chain_listener.py
bot = ChainMomentumBot(transactions)
bot.execute_trades()

# CanlÄ± zincirden gelen bir Ã¶rnek iÅŸlem
tx_example = {
    "from": "0xGamma",
    "to": "0xDelta",
    "value": Web3.toWei(7, 'ether')
}

bot.react_to_live_tx(tx_example)

for trade in bot.executed_trades:
    print(f"âš¡ {trade['wallet']} iÅŸlem aldÄ±: {trade['action']} | GÃ¼ven: {trade['confidence']}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\signal_broadcast_bot.py
from telegram import Bot

def broadcast_signal(signal, token, chat_id):
    bot = Bot(token=token)
    message = f"ðŸ“¡ Yeni Sinyal: {signal['asset']} â†’ {signal['decision']}\nðŸ§  GÃ¼ven: {signal['confidence']}\nðŸ•’ Zaman: {signal['time']}"
    bot.send_message(chat_id=chat_id, text=message)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\signal_dashboard_streamlit_plotly.py
import streamlit as st
import plotly.express as px
import pandas as pd

st.set_page_config(page_title="Signal Command Center", layout="wide")

st.markdown("<h1 style='text-align: center;'>ðŸ§­ Chain Signal Command Center ðŸš€</h1>", unsafe_allow_html=True)

theme_colors = {
    "Ethereum": "#627eea",
    "Solana": "#00ffa3",
    "Arbitrum": "#28a0f0",
    "Goerli": "#ffcc00"
}

chain = st.selectbox("ðŸ”— Zincir SeÃ§imi", list(theme_colors.keys()))
color = theme_colors[chain]

st.markdown(f"<div style='background-color:{color};padding:10px;border-radius:10px;color:white'>ðŸŽ¯ Aktif Zincir: {chain}</div>", unsafe_allow_html=True)

if st.button("âºï¸ Dinlemeyi BaÅŸlat"):
    st.success(f"{chain} sinyalleri yakalanÄ±yor...")

signal_history = pd.DataFrame({
    "Zaman": ["12:24", "12:26", "12:28"],
    "VarlÄ±k": ["ETH", "SOL", "ETH"],
    "Sinyal": ["BUY", "SELL", "BUY"],
    "GÃ¼ven": [0.95, 0.67, 1.0]
})

fig = px.bar(signal_history, x="Zaman", y="GÃ¼ven", color="Sinyal", text="VarlÄ±k", title="ðŸ“Š Sinyal GÃ¼ven GrafiÄŸi")
st.plotly_chart(fig, use_container_width=True)

oracle_decisions = {
    "ETH": {"decision": "BUY", "confidence": 1.0},
    "SOL": {"decision": "SELL", "confidence": 0.67}
}

positions = {
    asset: {
        "Pozisyon": data["decision"],
        "GÃ¼ven": f"{data['confidence']*100:.1f}%",
        "Tip": "LONG" if data["decision"] == "BUY" else "SHORT" if data["decision"] == "SELL" else "HOLD",
        "Kar Hedefi": "12%" if data["decision"] == "BUY" else "10%" if data["decision"] == "SELL" else "-",
        "Stop Loss": "6%" if data["decision"] == "BUY" else "5%" if data["decision"] == "SELL" else "-"
    }
    for asset, data in oracle_decisions.items()
}

st.subheader("ðŸ“Œ Aktif Pozisyonlar")
st.dataframe(pd.DataFrame.from_dict(positions, orient="index"))



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\signal_dashboard.py
import streamlit as st
import pandas as pd

st.set_page_config(page_title="Signal Dashboard", layout="wide")

st.title("ðŸ§  Chain Signal Dashboard")
chain = st.selectbox("ðŸ”— Zincir SeÃ§imi", ["Ethereum", "Arbitrum", "Solana", "Goerli"])

if st.button("âºï¸ Dinlemeyi BaÅŸlat"):
    st.success(f"{chain} dinleyicisi aktif!")

# Ã–rnek veriler
oracle_decisions = {
    "ETH": {"decision": "BUY", "confidence": 1.0},
    "SOL": {"decision": "SELL", "confidence": 0.67}
}

positions = {
    asset: {
        "Pozisyon": data["decision"],
        "GÃ¼ven": f"{data['confidence']*100:.1f}%",
        "Tip": "LONG" if data["decision"] == "BUY" else "SHORT" if data["decision"] == "SELL" else "HOLD",
        "Kar Hedefi": "12%" if data["decision"] == "BUY" else "10%" if data["decision"] == "SELL" else "-",
        "Stop Loss": "6%" if data["decision"] == "BUY" else "5%" if data["decision"] == "SELL" else "-"
    }
    for asset, data in oracle_decisions.items()
}

st.subheader("ðŸ“ˆ Aktif Pozisyonlar")
df = pd.DataFrame.from_dict(positions, orient="index")
st.dataframe(df)

st.markdown("â›“ï¸ Zincir aktifliÄŸi gerÃ§ek zamanlÄ± bloklardan beslenecek. Daha geliÅŸmiÅŸ versiyonda cÃ¼zdan etkileÅŸimi ve token listesi de eklenebilir.")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\signal_report_generator.py
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from datetime import datetime

def generate_signal_report(signals, filename="signal_report.pdf"):
    c = canvas.Canvas(filename, pagesize=A4)
    width, height = A4
    c.setFont("Helvetica", 14)
    c.drawString(50, height - 50, "ðŸ“Š Chain Signal Raporu")

    c.setFont("Helvetica", 10)
    c.drawString(50, height - 70, f"Tarih: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    y = height - 100

    for signal in signals:
        line = f"{signal['time']} | {signal['asset']} â†’ {signal['decision']} | GÃ¼ven: {signal['confidence']}"
        c.drawString(50, y, line)
        y -= 20
        if y < 50:
            c.showPage()
            y = height - 50

    c.save()
    print(f"âœ… PDF raporu oluÅŸturuldu: {filename}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\signal_tokenizer.py
import json
import hashlib
from datetime import datetime

def tokenize_signal(signal):
    metadata = {
        "name": f"{signal['asset']} Trade Signal",
        "description": f"Trade decision: {signal['decision']} with confidence {signal['confidence']}",
        "timestamp": signal["time"],
        "uuid": hashlib.md5(json.dumps(signal).encode()).hexdigest()
    }

    filename = f"{metadata['uuid']}.json"
    with open(filename, "w") as f:
        json.dump(metadata, f, indent=4)
    
    print(f"ðŸª™ Token dosyasÄ± oluÅŸturuldu: {filename}")
    return filename



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\strategic_position_builder.py
def build_positions(oracle_decisions, capital=10000, risk_profile="medium"):
    position_book = {}

    risk_multiplier = {"low": 0.2, "medium": 0.5, "high": 0.8}[risk_profile]

    for asset, data in oracle_decisions.items():
        allocation = capital * risk_multiplier * data["confidence"]

        if data["decision"] == "BUY":
            position_book[asset] = {
                "type": "LONG",
                "capital_allocated": round(allocation, 2),
                "target_profit": "12%", 
                "stop_loss": "6%"
            }

        elif data["decision"] == "SELL":
            position_book[asset] = {
                "type": "SHORT",
                "capital_allocated": round(allocation, 2),
                "target_profit": "10%",
                "stop_loss": "5%"
            }

        else:
            position_book[asset] = {
                "type": "HOLD",
                "capital_allocated": 0,
                "note": "Sinyal belirsiz, pozisyon alÄ±nmadÄ±."
            }

    return position_book



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\strategy_trainer.py
import random

def evaluate_strategy(strategy_func, historical_data):
    wins = 0
    for data in historical_data:
        decision = strategy_func(data)
        if decision == "BUY" and data["result"] == "profit":
            wins += 1
    success_rate = wins / len(historical_data)
    print(f"ðŸŽ¯ Stratejinin baÅŸarÄ± oranÄ±: %{round(success_rate * 100, 2)}")
    return success_rate



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\synaptic_command_matrix.py
def synaptic_command(logs, emotion_focus="ðŸ’¡ Ä°lham", threshold=75):
    commands = []
    for log in logs:
        task = log["task_id"]
        strength = log["feeling_strength"]
        emotion = log["emotion"]

        if emotion == emotion_focus and strength >= threshold:
            decision = f"ðŸ” GÃ¶rev {task} â†’ Ana Operasyon Moduna Al!"
        elif strength < 50:
            decision = f"ðŸ›Œ GÃ¶rev {task} â†’ Dinlenme AralÄ±ÄŸÄ±na TaÅŸÄ±"
        else:
            decision = f"ðŸ“Œ GÃ¶rev {task} â†’ Ä°zlenmeye Devam Et"

        commands.append({
            "task": task,
            "timestamp": log["timestamp"],
            "decision": decision
        })

    return commands



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\tx_executor.py
from web3 import Web3
from eth_account import Account

web3 = Web3(Web3.HTTPProvider("https://mainnet.infura.io/v3/YOUR_PROJECT_ID"))

def execute_trade(wallet_private_key, recipient_address, amount_eth):
    account = Account.from_key(wallet_private_key)
    sender = account.address

    nonce = web3.eth.get_transaction_count(sender)
    tx = {
        'nonce': nonce,
        'to': recipient_address,
        'value': web3.toWei(amount_eth, 'ether'),
        'gas': 21000,
        'gasPrice': web3.toWei('35', 'gwei')
    }

    signed_tx = web3.eth.account.sign_transaction(tx, wallet_private_key)
    tx_hash = web3.eth.send_raw_transaction(signed_tx.rawTransaction)
    print(f"ðŸš€ Ä°ÅŸlem BaÅŸlatÄ±ldÄ± â†’ {web3.toHex(tx_hash)}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\universal_chain_listener.py
def get_provider(chain):
    providers = {
        "Ethereum": "wss://mainnet.infura.io/ws/v3/YOUR_PROJECT_ID",
        "Arbitrum": "wss://arbitrum-mainnet.infura.io/ws/v3/YOUR_PROJECT_ID",
        "Solana": "wss://api.mainnet-beta.solana.com",  # Solana Ã¶zel istemci gerekir
        "Goerli": "wss://goerli.infura.io/ws/v3/YOUR_PROJECT_ID"
    }
    return providers.get(chain)

def start_chain_listener(chain_name):
    provider_url = get_provider(chain_name)
    if not provider_url:
        print(f"âŒ Desteklenmeyen zincir: {chain_name}")
        return

    print(f"ðŸ“¡ {chain_name} dinleyici baÅŸlatÄ±lÄ±yor...")

    # Ethereum/Arbitrum Ã¶rneÄŸi (Web3.py ile)
    from web3 import Web3
    web3 = Web3(Web3.WebsocketProvider(provider_url))

    def on_new_block(event):
        block = web3.eth.get_block(event['hash'], full_transactions=True)
        print(f"ðŸ§¿ {chain_name} Blok #{block.number} | Ä°ÅŸlem: {len(block.transactions)}")

        # Sinyal analizi & karar modÃ¼lleriyle entegre:
        if len(block.transactions) > 120:
            oracle_input = {chain_name[:3].upper(): "BUY"}
            decisions = multi_chain_oracle({chain_name: oracle_input})
            positions = build_positions(decisions)
            print("ðŸ“ˆ Pozisyonlar:", positions)

    web3.eth.subscribe("newHeads", {}, on_new_block)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\wallet_behavior_predictor.py
def predict_wallet_behavior(transactions, activity_threshold=0.6):
    predictions = {}
    for wallet, history in transactions.items():
        tx_count = len(history)
        high_value = sum(1 for tx in history if tx["value"] > 10000)
        recurring = sum(1 for tx in history if tx["type"] == "recurring")

        score = round((high_value * 0.4 + recurring * 0.3 + tx_count * 0.3) / tx_count, 2)

        if score >= activity_threshold:
            predictions[wallet] = f"ðŸ”¥ Tahmin: YakÄ±nda bÃ¼yÃ¼k hareket bekleniyor (Skor={score})"
        else:
            predictions[wallet] = f"ðŸŒ™ Tahmin: Durgun profil (Skor={score})"
    return predictions



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\wallet_signal_connector.py
from web3 import Web3

def connect_wallet(wallet_address):
    web3 = Web3(Web3.HTTPProvider("https://mainnet.infura.io/v3/YOUR_PROJECT_ID"))

    # CÃ¼zdan bakiyesi
    balance_wei = web3.eth.get_balance(wallet_address)
    balance_eth = web3.fromWei(balance_wei, 'ether')
    print(f"ðŸ‘› {wallet_address} â†’ ETH Bakiye: {balance_eth}")

    # Token pozisyonlarÄ± iÃ§in ERC20 kontratlarÄ± taranabilir
    # (Burada Ã¶rnek olarak sadece ETH bakiyesi alÄ±nÄ±yor)

    return balance_eth



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_network\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_network\main.py
import os, time, logging
import pandas as pd
from dotenv import load_dotenv
from datetime import datetime

# Binance API
from services.binance_client import get_client
from strategies.basic_macd_rsi import generate_signal
from core.trade_executor import place_order

# Haber ve duygu analizi
from kiripto_nova.signals.get_news import get_crypto_news
from sentiment import analyze_sentiment
from explainer import explain_signal
from csv_writer import save_to_csv
from kiripto_nova.apps.telegram_bot import send_signal_to_telegram
from kiripto_nova.signals.signal_tracker import analyze_signal_effect
from dashboard.visual_panel import dashboard_view

# Strateji filtreleri ve yÃ¶neticiler
from regime import regime
from cooldown import cooldown
from kiripto_nova.execution.position_manager import pos_mgr
from atr import atr_levels
from kiripto_nova.ai.ml_engine import ml_engine
from ta_engine import ta_engine
from news_engine import news_engine

# Log yapÄ±landÄ±rmasÄ±
logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")

# Ortam deÄŸiÅŸkenleri
load_dotenv(dotenv_path="my_env_file.env")
API_KEY = os.getenv("BINANCE_API_KEY")
SECRET_KEY = os.getenv("BINANCE_SECRET_KEY")
client = get_client()

def fetch_data(symbol: str, limit: int = 100) -> pd.DataFrame:
    try:
        ohlcv = client.fetch_ohlcv(symbol, timeframe="5m", limit=limit)
        df = pd.DataFrame(ohlcv, columns=['time', 'open', 'high', 'low', 'close', 'volume'])
        df['time'] = pd.to_datetime(df['time'], unit='ms')
        return df
    except Exception as e:
        logging.error(f"Veri Ã§ekme hatasÄ±: {e}")
        return pd.DataFrame()

def run_news_analysis():
    news_data = get_crypto_news()
    signals = []

    for news in news_data:
        title = news.get("title", "")
        description = news.get("description", "")
        label, score = analyze_sentiment(f"{title} {description}")

        if label == "positive" and score > 0.7:
            signal = "AL"
        elif label == "negative" and score > 0.6:
            signal = "SAT"
        else:
            signal = "BEKLE"

        note = explain_signal(title, description)
        send_signal_to_telegram(title, signal, score)

        signals.append({
            "title": title,
            "signal": signal,
            "sentiment": label,
            "score": round(score, 3),
            "note": note
        })

    save_to_csv(signals)
    logging.info(f"{len(signals)} haber sinyali iÅŸlendi ve kaydedildi.")

def run_trading_cycle(symbol="DOGE/USDT"):
    df = fetch_data(symbol)
    if df.empty:
        logging.warning("Veri alÄ±namadÄ±, iÅŸlem dÃ¶ngÃ¼sÃ¼ atlandÄ±.")
        return

    ta_sig = ta_engine.decide(df)
    ml_sig = ml_engine.decide(df)
    news = news_engine.bias()
    tdrdir, vol = regime.allow(df)
    cooldown.tick()

    direction, entry, conf = None, None, 0.5

    if ta_sig:
        direction, entry = ta_sig
        if ml_sig and ml_sig[0] == direction: conf += 0.2 * ml_sig[1]
        if news and news[0] == direction: conf += 0.2 * news[1]

        if tdrdir == 1 and direction in ["LONG", "SHORT"]: conf -= 0.3
        if vol[df['close'].pct_change().rolling(36).std().median()]: conf -= 0.1

        if conf >= 0.65 and cooldown.ok() and pos_mgr.can_open(direction):
            sl, tp = atr_levels(df, entry, direction)
            place_order({"direction": direction, "entry": entry, "sl": sl, "tp": tp})
            pos_mgr.on_open(direction)
            cooldown.trigger()
            logging.info(f"âœ… Ä°ÅŸlem aÃ§Ä±ldÄ±: {direction} @ {entry} | SL: {sl} | TP: {tp}")
        else:
            logging.info("â³ Sinyal yeterince gÃ¼Ã§lÃ¼ deÄŸil veya pozisyon aÃ§Ä±lamaz.")
    else:
        logging.info("âŒ Teknik sinyal bulunamadÄ±.")

def main():
    logging.info("ðŸš€ Nova Chain Komuta Sistemi vX.1 baÅŸlatÄ±lÄ±yor...")
    run_news_analysis()

    while True:
        run_trading_cycle()
        effect = analyze_signal_effect("DOGE", datetime.utcnow().isoformat())
        logging.info(f"ðŸ“Š Sinyal etkisi: {effect}")
        dashboard_view()
        time.sleep(60)

if __name__ == "__main__":
    main()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_network\nova_trader.py
# NovaQuantX - Ticaret Motoru (pozisyon yÃ¶netimi + sinyal iÅŸleme)
from dataclasses import dataclass

@dataclass
class Position:
    symbol: str
    side: str  # 'LONG' or 'SHORT'
    entry_price: float
    leverage: int
    qty: float
    open_ts: int

class NovaTrader:
    def __init__(self, leverage=10, rsi_buy=30, rsi_sell=70):
        self.positions = {}
        self.leverage = leverage
        self.rsi_buy = rsi_buy
        self.rsi_sell = rsi_sell

    def process_signal(self, symbol: str, price: float, rsi: float, ts: int):
        pos = self.positions.get(symbol)

        # LONG sinyali
        if rsi <= self.rsi_buy and pos is None:
            qty = self.calculate_qty(price)
            self.positions[symbol] = Position(
                symbol=symbol,
                side='LONG',
                entry_price=price,
                leverage=self.leverage,
                qty=qty,
                open_ts=ts
            )
            print(f"ðŸŸ¢ LONG aÃ§Ä±ldÄ±: {symbol} @ {price:.2f} x{self.leverage}")

        # SHORT sinyali
        elif rsi >= self.rsi_sell and pos is None:
            qty = self.calculate_qty(price)
            self.positions[symbol] = Position(
                symbol=symbol,
                side='SHORT',
                entry_price=price,
                leverage=self.leverage,
                qty=qty,
                open_ts=ts
            )
            print(fðŸ”´ SHORT aÃ§Ä±ldÄ±: {symbol} @ {price:.2f} x{self.leverage}")

        # Pozisyon kapatma mantÄ±ÄŸÄ± (Ã¶rnek: RSI nÃ¶tr bÃ¶lgeye girerse)
        elif pos:
            if (pos.side == 'LONG' and rsi >= 50) or (pos.side == 'SHORT' and rsi <= 50):
                pnl = self.calculate_pnl(pos, price)
                print(f"âšª Pozisyon kapandÄ±: {symbol} {pos.side} PnL={pnl:.2f}")
                del self.positions[symbol]

    def calculate_qty(self, price: float):
        capital = 100  # sabit sermaye (Ã¶rnek)
        return (capital * self.leverage) / price

    def calculate_pnl(self, pos: Position, current_price: float):
        if pos.side == 'LONG':
            return (current_price - pos.entry_price) * pos.qty
        else:
            return (pos.entry_price - current_price) * pos.qty

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_network\novaSovereignCore.py
import random

# === AI MODELLERÄ° ===
def predict_lstm(market_data):
    return {"action": random.choice(["buy", "sell", "hold"]), "confidence": random.uniform(0.7, 0.95)}

def predict_transformer(market_data):
    return {"action": random.choice(["buy", "sell", "hold"]), "confidence": random.uniform(0.75, 0.98)}

def predict_rl(market_data):
    return {"action": random.choice(["buy", "sell", "hold"]), "confidence": random.uniform(0.65, 0.9)}

# === DAVRANIÅž ANALÄ°ZÄ° ===
def analyze_behavior(market_data):
    # Basit davranÄ±ÅŸ skoru: 0.0 (panik) - 1.0 (rasyonel)
    volatility = market_data.get("volatility", 0.5)
    fomo_index = market_data.get("fomo", 0.5)
    return max(0.0, 1.0 - (volatility + fomo_index) / 2)

# === STRATEJÄ° PORTFÃ–YÃœ ===
def allocate(action, confidence):
    allocation = {
        "buy": confidence * 1000,
        "sell": confidence * 800,
        "hold": confidence * 500
    }
    return allocation.get(action, 0)

# === META KARAR MOTORU ===
class MetaDecisionEngine:
    def resolve(self, lstm_sig, transformer_sig, rl_sig, behavior_score, sentiment, onchain_score):
        votes = [lstm_sig, transformer_sig, rl_sig]
        confidence = sum([sig["confidence"] for sig in votes]) / len(votes)

        if behavior_score < 0.4: confidence -= 0.1
        if sentiment == "negative": confidence -= 0.1
        if onchain_score < 0.5: confidence -= 0.1

        final_action = max(set([sig["action"] for sig in votes]), key=[sig["action"] for sig in votes].count)
        return {"action": final_action, "confidence": round(confidence, 3)}

# === ZÄ°NCÄ°R ÃœSTÃœ DOÄžRULAMA ===
class Layer2Chain:
    def __init__(self):
        self.strategies = {}

    def submit_strategy(self, strategy_id, action, confidence):
        approved = confidence > 0.8
        self.strategies[strategy_id] = {
            "action": action,
            "confidence": confidence,
            "approved": approved
        }
        print(f"ðŸ“¡ Zincir Ã¼stÃ¼ strateji gÃ¶nderildi: {strategy_id} | {action} | GÃ¼ven: {confidence} | Onay: {approved}")

# === STRATEJÄ° EVRÄ°MÄ° ===
class ReinforcementOptimizer:
    def train(self, strategy_history):
        print("ðŸ” Strateji geÃ§miÅŸi optimize ediliyor...")
        # Basit evrimsel mantÄ±k (placeholder)
        evolved = [s for s in strategy_history if s["confidence"] > 0.75]
        print(f"âœ… EvrimleÅŸen stratejiler: {len(evolved)}")

# === ANA SÄ°STEM ===
class NovaSovereignCore:
    def __init__(self):
        self.meta = MetaDecisionEngine()
        self.chain = Layer2Chain()
        self.optimizer = ReinforcementOptimizer()

    def run(self, market_data):
        print("ðŸš€ Nova Intelligence Sovereign Core baÅŸlatÄ±lÄ±yor...\n")

        lstm_sig = predict_lstm(market_data)
        transformer_sig = predict_transformer(market_data)
        rl_sig = predict_rl(market_data)
        behavior_score = analyze_behavior(market_data)
        sentiment = market_data.get("sentiment", "neutral")
        onchain_score = market_data.get("onchain", 0.6)

        print(f"ðŸ“Š AI Sinyalleri:\nLSTM: {lstm_sig}\nTransformer: {transformer_sig}\nRL: {rl_sig}")
        print(f"ðŸ§  DavranÄ±ÅŸ Skoru: {behavior_score} | Duygu: {sentiment} | Zincir Skoru: {onchain_score}\n")

        decision = self.meta.resolve(lstm_sig, transformer_sig, rl_sig, behavior_score, sentiment, onchain_score)
        allocation = allocate(decision["action"], decision["confidence"])

        print(f"ðŸŽ¯ Nihai Karar: {decision['action']} | GÃ¼ven: {decision['confidence']} | Tahsis: {allocation} birim\n")

        strategy_id = f"nova_{random.randint(1000,9999)}"
        self.chain.submit_strategy(strategy_id, decision["action"], decision["confidence"])
        self.optimizer.train([lstm_sig, transformer_sig, rl_sig])

        print("\nâœ… Nova operasyonu tamamlandÄ±.")

# === Ã‡ALIÅžTIR ===
if __name__ == "__main__":
    market_data = {
        "volatility": 0.6,
        "fomo": 0.4,
        "sentiment": "positive",
        "onchain": 0.7
    }

    nova = NovaSovereignCore()
    nova.run(market_data)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_network\rsi.py
# NovaQuantX - RSI modÃ¼lÃ¼ (tick bazlÄ±, ultra hassas)
from collections import deque

class TickRSI:
    def __init__(self, period=14):
        self.period = period
        self.gains = deque(maxlen=period)
        self.losses = deque(maxlen=period)
        self.last_price = None
        self.rsi = None

    def update(self, price: float):
        if self.last_price is None:
            self.last_price = price
            return None

        delta = price - self.last_price
        self.last_price = price

        gain = max(delta, 0)
        loss = max(-delta, 0)

        self.gains.append(gain)
        self.losses.append(loss)

        if len(self.gains) < self.period:
            return None  # Yeterli veri yok

        avg_gain = sum(self.gains) / self.period
        avg_loss = sum(self.losses) / self.period

        if avg_loss == 0:
            self.rsi = 100
        else:
            rs = avg_gain / avg_loss
            self.rsi = 100 - (100 / (1 + rs))

        return round(self.rsi, 2)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\ai\__init__.py
# auto-added


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\ai\ai_advisor.py
def explain_market_reaction(title, description):
    prompt = f"BaÅŸlÄ±k: {title}\nAÃ§Ä±klama: {description}\nBu haber yatÄ±rÄ±mcÄ±lar iÃ§in ne ifade eder?"
    # GerÃ§ek LLM Ã§aÄŸrÄ±sÄ± ile aÃ§Ä±klama alÄ±nabilir (OpenAI, Azure, vb.)
    return "Bu haber yatÄ±rÄ±mcÄ± gÃ¼venini artÄ±rÄ±r, AL sinyali desteklenebilir."



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\ai\ai_strategy.py
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
import pandas as pd

def train_ai_model(data):
    X = data.drop("target", axis=1)
    y = data["target"]

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

    model = RandomForestClassifier(n_estimators=100)
    model.fit(X_train, y_train)

    accuracy = model.score(X_test, y_test)
    print(f"ðŸ” Model doÄŸruluÄŸu: %{round(accuracy * 100, 2)}")

    return model
def get_signal_from_model(model, new_data_row):
    prediction = model.predict([new_data_row])
    return "BUY" if prediction[0] == 1 else "SELL"


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\ai\ml_engine.py
# main.py iÃ§inde karar
df = klines_to_df(ex.klines(limit=600))   # kendin df Ã§evir
ta_sig = ta_engine.decide(kl)             # ("LONG"/"SHORT", entry)
ml_sig = ml_engine.decide(df)             # ("LONG"/"SHORT", p)
news = news_engine.bias()                 # ("LONG"/"SHORT", conf)

# Rejim & vol filtreleri
trdir, vol = regime.allow(df)
cooldown.tick()

direction, entry = None, None
if ta_sig:
    direction, entry = ta_sig
    conf = 0.5
    if ml_sig and ml_sig[0]==direction: conf += 0.2*ml_sig[1]
    if news  and news[0]==direction:    conf += 0.2*news[1]
    # Rejim filtresi
    if (trdir==1 and direction=="SHORT") or (trdir==-1 and direction=="LONG"):
        conf -= 0.3
    if vol<df["close"].pct_change().rolling(50).std().median(): conf -= 0.1

    if conf>=0.65 and cooldown.ok() and pos_mgr.can_open(direction):
        sl,tp = atr_levels(df, entry, direction)
        execu.open_trade(direction, entry, sl, tp)
        pos_mgr.on_open(direction)
        cooldown.trigger()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\ai\ml_filter.py
# ml_filter.py (Yapay zeka destekli sinyal doÄŸrulayÄ±cÄ±)
import pandas as pd
import joblib
from sklearn.ensemble import RandomForestClassifier

# Ã–rnek model eÄŸitimi iÃ§in kullanÄ±lÄ±r (gerÃ§ekte bu offline yapÄ±lmalÄ±)
def train_model(train_df):
    features = ["RSI_14", "MACD_12_26_9", "MACDs_12_26_9", "EMA_50", "EMA_200", "BBU_20_2.0", "BBL_20_2.0"]
    X = train_df[features]
    y = train_df["label"]  # 1 = baÅŸarÄ±lÄ± sinyal, 0 = baÅŸarÄ±sÄ±z

    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X, y)
    joblib.dump(model, "ml_signal_model.pkl")
    print("âœ… Model eÄŸitildi ve kaydedildi.")


# EÄŸitilmiÅŸ modelle sinyal doÄŸrulama
class MLFilter:
    def __init__(self, model_path="ml_signal_model.pkl"):
        self.model = joblib.load(model_path)

    def evaluate(self, df):
        features = ["RSI_14", "MACD_12_26_9", "MACDs_12_26_9", "EMA_50", "EMA_200", "BBU_20_2.0", "BBL_20_2.0"]
        row = df.iloc[-1:]
        X = row[features]
        prediction = self.model.predict(X)[0]
        confidence = self.model.predict_proba(X)[0][1]  # 1. sÄ±nÄ±fÄ±n olasÄ±lÄ±ÄŸÄ±
        return prediction, round(confidence, 3)


# KullanÄ±m Ã¶rneÄŸi
if __name__ == "__main__":
    # (GerÃ§ek kullanÄ±mda train_df geÃ§miÅŸ etiketli veriden gelir)
    df = pd.read_csv("example_labeled_data.csv")  # RSI, MACD, EMA, BB + label sÃ¼tunu
    train_model(df)

    # Tahmin Ã¶rneÄŸi
    latest = df.copy()
    model = MLFilter()
    result, conf = model.evaluate(latest)
    print(f"ðŸ¤– Tahmin: {result} | GÃ¼ven: {conf}")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\ai\neuro_decision_engine.py
def neuro_decision(sentiment, score, keywords, time_hour, source_reputation):
    weight = 0
    weight += score * 2
    if sentiment == "positive":
        weight += 1
    if "rally" in keywords:
        weight += 1
    if time_hour in range(8, 12):  # Sabah saatleri
        weight += 0.5
    if source_reputation == "high":
        weight += 1
    return "AL" if weight >= 3.5 else "SAT" if weight <= -2 else "BEKLE"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_chronovision.py
class ProjectEvent:
    def __init__(self, name, timestamp, impact, event_type):
        self.name = name
        self.timestamp = timestamp  # 'YYYY-MM-DD'
        self.impact = impact  # 'low', 'medium', 'high'
        self.event_type = event_type  # 'launch', 'update', 'crisis', 'forecast'

def create_timeline(events):
    timeline = sorted(events, key=lambda e: e.timestamp)
    print("ðŸ•°ï¸ Zincir Zaman Ekseni:")
    for e in timeline:
        print(f"{e.timestamp} | [{e.event_type.upper()}] {e.name} - Etki: {e.impact}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_convergence_forge.py
class ChainProfile:
    def __init__(self, name, launch_date, alliances, impact_score):
        self.name = name
        self.launch_date = launch_date  # 'YYYY-MM-DD'
        self.alliances = alliances      # ['ZetaCore', 'ShadowNet']
        self.impact_score = impact_score  # 0-100

def forge_convergence_map(profiles):
    profiles_sorted = sorted(profiles, key=lambda p: (p.launch_date, -p.impact_score))
    print("ðŸŒŒ Zincir BirleÅŸim HaritasÄ±:")
    for profile in profiles_sorted:
        print(f"{profile.launch_date} | {profile.name} ðŸ”— Ä°ttifaklar: {profile.alliances} ðŸ’¥ Etki: {profile.impact_score}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_destiny_mapper.py
def map_chain_destiny(event_matrix):
    destiny_paths = []
    for evt in event_matrix:
        if evt['emotion'] == 'ascension' and evt['flux_level'] > 70:
            destiny_paths.append(f"ðŸŒ  Evrim RotasÄ±: {evt['id']}")
        elif evt['risk'] > 80 and evt['potential'] > 85:
            destiny_paths.append(f"âš ï¸ Kader Krizi: {evt['id']} â†’ MÃ¼dahale gerekebilir")
    return destiny_paths if destiny_paths else ["ðŸ§˜ Veri sakin. Kader aÃ§Ä±k ama hareketsiz."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_emotion_canvas.py
import matplotlib.pyplot as plt
import numpy as np

def emotion_wave(emotion):
    t = np.linspace(0, 4*np.pi, 1000)
    if emotion == "positive":
        y = np.sin(t) * np.exp(-0.05*t)
        color = "gold"
    elif emotion == "negative":
        y = np.sin(3*t)
        color = "purple"
    else:
        y = np.sin(2*t) * 0.5
        color = "gray"

    plt.plot(t, y, color=color)
    plt.title(f"{emotion.upper()} Dalga Formu")
    plt.show()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_epic_mapper.py
def map_chain_epic(project_name, mythos, events, emotion_tone):
    epic = f"ðŸ›¡ï¸ {project_name} - {mythos}:\n"
    for event in events:
        epic += f"ðŸ“ {event['timestamp']}: {event['description']}\n"
    epic += f"ðŸŽ¶ Topluluk hissi: {emotion_tone}\n"
    return epic



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_galaxy_atlas.py
class ChainPlanet:
    def __init__(self, name, orbit_level, alliance_tags, mood):
        self.name = name
        self.orbit_level = orbit_level  # 1 = merkez, 5 = uzak sÄ±nÄ±r
        self.alliance_tags = alliance_tags  # ['DeFi', 'Privacy']
        self.mood = mood  # 'volatile', 'growing', 'stable'

def create_galaxy(planets):
    galaxy_map = {}
    for planet in planets:
        key = planet.orbit_level
        if key not in galaxy_map:
            galaxy_map[key] = []
        galaxy_map[key].append(planet.name)
    return galaxy_map



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_hunt_protocol.py
class ChainProject:
    def __init__(self, name, sector, risk, growth_rate, alliances):
        self.name = name
        self.sector = sector
        self.risk = risk
        self.growth_rate = growth_rate
        self.alliances = alliances

def hunt_targets(projects, desired_sector, max_risk, min_growth):
    targets = []
    for proj in projects:
        if proj.sector == desired_sector and proj.risk != 'high' and proj.growth_rate >= min_growth:
            targets.append(proj.name)
    return targets

# ðŸ”¬ SimÃ¼lasyon iÃ§in Ã¶rnek projeler:
if __name__ == "__main__":
    p1 = ChainProject("SyntheVault", "DeFi", "medium", 18.7, ["Arbitrum"])
    p2 = ChainProject("ZetaCore", "ZK", "high", 24.2, ["StarkNet"])
    p3 = ChainProject("PlayVerseX", "GameFi", "low", 15.5, ["Immutable"])
    p4 = ChainProject("FlowForge", "DeFi", "low", 22.1, ["Optimism"])

    hunt = hunt_targets([p1, p2, p3, p4], "DeFi", "medium", 20.0)
    print("ðŸŽ¯ Stratejik Av Listesi:")
    for target in hunt:
        print(f"- {target}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_hunter.py
def chain_hunter(code_base):
    if "obfuscation" in code_base:
        print("ðŸ’£ GizlenmiÅŸ yapÄ± bulundu: Kod manipÃ¼lasyonu ÅŸÃ¼phesi!")
    elif "loop trigger" in code_base:
        print("ðŸŽ¯ DÃ¶ngÃ¼ tetikleyici aktif: Zaman bazlÄ± strateji kodu.")
    else:
        print("ðŸ” Temiz yapÄ±: Standart fonksiyon mantÄ±ÄŸÄ±.")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_mutation_tracker.py
def track_mutation(old_code, new_code):
    changes = []
    old_lines = old_code.splitlines()
    new_lines = new_code.splitlines()

    for i, (old, new) in enumerate(zip(old_lines, new_lines)):
        if old != new:
            changes.append(f"ðŸ”„ SatÄ±r {i+1} deÄŸiÅŸmiÅŸ:\nEski: {old}\nYeni: {new}")

    extra = new_lines[len(old_lines):]
    for i, line in enumerate(extra, start=len(old_lines)+1):
        changes.append(f"âž• Yeni satÄ±r {i}: {line}")

    return changes if changes else ["âœ… Kod yapÄ±sÄ±nda belirgin mutasyon yok."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_mythos_engine.py
def map_to_arketype(emotion_score, risk_profile, utility_type):
    if emotion_score > 0.7 and utility_type == "innovation":
        return "ðŸŒŸ Kahraman"
    elif risk_profile < 0.3 and utility_type == "guidance":
        return "ðŸ§™â€â™‚ï¸ Bilge"
    elif risk_profile > 0.7 and utility_type == "chaos":
        return "ðŸ Trickster"
    else:
        return "ðŸ›¡ï¸ BekÃ§i"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_radar_gui.py
import tkinter as tk

def draw_radar(projects):
    root = tk.Tk()
    root.title("ðŸ§­ Kripto Radar EkranÄ±")

    canvas = tk.Canvas(root, width=500, height=500, bg="black")
    canvas.pack()

    canvas.create_oval(100, 100, 400, 400, outline="green")  # radar Ã§erÃ§evesi

    for i, proj in enumerate(projects):
        x = 250 + proj['x_offset']
        y = 250 + proj['y_offset']
        canvas.create_oval(x-10, y-10, x+10, y+10, fill="lime")
        canvas.create_text(x, y-15, text=proj['name'], fill="white")

    root.mainloop()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_voice_empath.py
def generate_voice_profile(emotion_state):
    profiles = {
        "positive": "SoothingTone.wav",
        "negative": "IntenseAlert.wav",
        "neutral": "InformativeFlat.wav"
    }
    return profiles.get(emotion_state, "DefaultVoice.wav")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\analysis_graphs.py
import pandas as pd
import matplotlib.pyplot as plt

def plot_signal_density(csv_file):
    df = pd.read_csv(csv_file)
    df['publishedAt'] = pd.to_datetime(df['publishedAt'])
    df['hour'] = df['publishedAt'].dt.hour
    df['signal'] = df['signal'].fillna("BEKLE")

    signal_counts = df.groupby(['hour', 'signal']).size().unstack(fill_value=0)
    signal_counts.plot(kind='bar', stacked=True)
    plt.title("Saat BazlÄ± Sinyal YoÄŸunluÄŸu")
    plt.xlabel("Saat")
    plt.ylabel("Sinyal SayÄ±sÄ±")
    plt.tight_layout()
    plt.show()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\dashboard_app.py
# dashboard_app.py (Streamlit ile canlÄ± performans kontrol paneli)
import streamlit as st
import pandas as pd
import sqlite3
import matplotlib.pyplot as plt

DB_NAME = "trade_history.db"

st.set_page_config(page_title="Kripto Bot Paneli", layout="wide")
st.title("ðŸ“Š Otomatik Kripto Bot Kontrol Paneli")

@st.cache_data()
def load_data():
    conn = sqlite3.connect(DB_NAME)
    df = pd.read_sql("SELECT * FROM trades ORDER BY timestamp DESC", conn)
    conn.close()
    return df

def draw_cumulative(df):
    df = df.sort_values("timestamp")
    df["cumulative_pnl"] = df["pnl"].cumsum()
    st.subheader("ðŸ“ˆ KÃ¼mÃ¼latif KÃ¢r/Zarar")
    st.line_chart(df.set_index("timestamp")["cumulative_pnl"])

def trade_table(df):
    st.subheader("ðŸ“‹ Ä°ÅŸlem GeÃ§miÅŸi")
    st.dataframe(df)

def stats(df):
    wins = df[df["result"] == "win"]
    losses = df[df["result"] == "loss"]
    winrate = len(wins) / len(df) * 100 if len(df) > 0 else 0

    col1, col2, col3 = st.columns(3)
    col1.metric("Toplam Ä°ÅŸlem", len(df))
    col2.metric("Winrate", f"{winrate:.2f}%")
    col3.metric("Net PnL", f"{df['pnl'].sum():.2f} USDT")


if __name__ == "__main__":
    try:
        df = load_data()
        stats(df)
        draw_cumulative(df)
        trade_table(df)
    except Exception as e:
        st.error("Veri yÃ¼klenemedi. LÃ¼tfen iÅŸlem geÃ§miÅŸi oluÅŸturduÄŸunuzdan emin olun.")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\plot_performance.py
# plot_performance.py (Ä°ÅŸlem gÃ¼nlÃ¼ÄŸÃ¼ istatistik ve grafik analizi)
import sqlite3
import pandas as pd
import matplotlib.pyplot as plt

DB_NAME = "trade_history.db"

def load_trade_data():
    conn = sqlite3.connect(DB_NAME)
    df = pd.read_sql("SELECT * FROM trades ORDER BY timestamp", conn)
    conn.close()
    return df

def analyze_performance(df):
    df['cumulative_pnl'] = df['pnl'].cumsum()
    win_rate = (df['result'] == 'win').mean() * 100
    avg_win = df[df['result'] == 'win']['pnl'].mean()
    avg_loss = df[df['result'] == 'loss']['pnl'].mean()
    max_drawdown = (df['cumulative_pnl'].cummax() - df['cumulative_pnl']).max()

    print(f"ðŸ”Ž Toplam Ä°ÅŸlem: {len(df)}")
    print(f"âœ… Win Rate: {win_rate:.2f}%")
    print(f"ðŸ’° Ortalama KazanÃ§: {avg_win:.2f}")
    print(f"âŒ Ortalama KayÄ±p: {avg_loss:.2f}")
    print(f"ðŸ“‰ Max Drawdown: {max_drawdown:.2f}")

    return df

def plot_cumulative_pnl(df):
    plt.figure(figsize=(12,6))
    plt.plot(df['timestamp'], df['cumulative_pnl'], label='Cumulative PnL', color='green')
    plt.title("ðŸ’¹ KÃ¼mÃ¼latif KÃ¢r/Zarar GrafiÄŸi")
    plt.xlabel("Tarih")
    plt.ylabel("USDT")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.xticks(rotation=45)
    plt.show()

if __name__ == "__main__":
    df = load_trade_data()
    if len(df) == 0:
        print("â—Veri yok. Ã–nce trade_journal ile iÅŸlem kaydÄ± gir.")
    else:
        df = analyze_performance(df)
        plot_cumulative_pnl(df)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\plot_success.py
import pandas as pd
import matplotlib.pyplot as plt

def plot_signal_results(csv_file="data/signal_log.csv"):
    df = pd.read_csv(csv_file, names=["signal", "score", "result"])
    success_rate = df["result"].value_counts(normalize=True) * 100
    success_rate.plot(kind="bar", color=["green", "red"])
    plt.title("Sinyal BaÅŸarÄ± OranÄ±")
    plt.ylabel("%")
    plt.tight_layout()
    plt.show()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\report_generator.py
def generate_daily_signal_report(csv_file):
    import pandas as pd
    df = pd.read_csv(csv_file)
    summary = df.groupby("signal").size()
    print("ðŸ”Ž GÃ¼nlÃ¼k Sinyal DaÄŸÄ±lÄ±mÄ±:\n", summary)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\wallet_activity_analyzer.py
import json

def analyze_wallet_activity(wallet_address, tx_data):
    swap_count = sum(1 for tx in tx_data if tx["type"] == "swap")
    dormant_periods = [tx["timestamp"] for tx in tx_data if tx["value"] == 0]

    report = []
    report.append(f"ðŸ“Š Toplam Swap SayÄ±sÄ±: {swap_count}")
    report.append(f"ðŸ›Œ Pasif Ä°ÅŸlemler: {len(dormant_periods)}")
    
    high_freq = [tx for tx in tx_data if tx["frequency"] > 10]
    if high_freq:
        report.append(f"âš¡ YÃ¼ksek frekanslÄ± iÅŸlem davranÄ±ÅŸÄ± tespit edildi.")

    contract_interactions = {tx["to"] for tx in tx_data if tx["type"] == "contract_call"}
    if contract_interactions:
        report.append(f"ðŸ“¡ EtkileÅŸimde bulunulan kontratlar: {len(contract_interactions)} adet.")

    return report



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\apps\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\apps\nova_ai_elite_bot.py
# Gerekli kÃ¼tÃ¼phaneleri iÃ§e aktarÄ±yoruz.
# os: Ortam deÄŸiÅŸkenlerini okumak iÃ§in
# ccxt: Kripto para borsalarÄ±na baÄŸlanmak iÃ§in
# pandas & pandas_ta: Veri analizi ve teknik gÃ¶stergeler iÃ§in
# numpy: SayÄ±sal iÅŸlemler iÃ§in
# asyncio: EÅŸzamansÄ±z iÅŸlemler iÃ§in (gerÃ§ek zamanlÄ± veri Ã§ekimi simÃ¼lasyonu)
# datetime: Zaman damgalÄ± loglama iÃ§in
# xgboost: Makine Ã¶ÄŸrenimi modeli olarak kullanÄ±lacak
import os
import ccxt.async_support as ccxt
import pandas as pd
import pandas_ta as ta
import asyncio
import numpy as np
import xgboost as xgb
from datetime import datetime, timezone
import logging
import traceback
import matplotlib.pyplot as plt

# GeliÅŸmiÅŸ loglama ayarlarÄ±
logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s.%(msecs)03d] | %(levelname)s | %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)

class NovaAIEliiteBot:
    """
    Ultra hibrit ve profesyonel seviye bir kripto ticaret botu sÄ±nÄ±fÄ±.
    GeliÅŸmiÅŸ AI, hibrit strateji ve saÄŸlam risk yÃ¶netimi iÃ§erir.
    """
    def __init__(self, symbol="BTC/USDT", timeframe="1m", limit=300, amount=0.01, api_key=None, secret_key=None):
        """
        Botun temel ayarlarÄ±nÄ± ve bileÅŸenlerini baÅŸlatÄ±r.
        API anahtarlarÄ± ile Binance'e baÄŸlanÄ±r.
        """
        self.exchange = ccxt.binance({
            'apiKey': api_key,
            'secret': secret_key,
            'enableRateLimit': True,
            'rateLimit': 1000  # ccxt API kÄ±sÄ±tlama hÄ±zÄ±nÄ± 1000ms'ye ayarlar
        })
        self.symbol = symbol
        self.timeframe = timeframe
        self.limit = limit
        self.amount = amount
        self.model = xgb.XGBClassifier(use_label_encoder=False, eval_metric='mlogloss')
        self.trained = False
        self.position = None  # Botun o anki pozisyonunu takip eder: None, 'LONG' (AL), 'SHORT' (SAT)
        self.entry_price = 0.0  # Pozisyona giriÅŸ fiyatÄ±
        
        # Risk YÃ¶netimi AyarlarÄ±
        self.SL_PERCENTAGE = 0.02  # %2 Zarar Durdur (Stop-Loss)
        self.TP_PERCENTAGE = 0.03  # %3 KÃ¢r Al (Take-Profit)
        self.sl_price = 0.0
        self.tp_price = 0.0

    async def fetch_ohlcv(self):
        """
        Borsadan mum (OHLCV) verilerini Ã§eker.
        """
        try:
            ohlcv = await self.exchange.fetch_ohlcv(self.symbol, self.timeframe, limit=self.limit)
            df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
            df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
            df = df.set_index("timestamp")
            return df
        except Exception as e:
            logging.error(f"Veri Ã§ekme hatasÄ±: {e}")
            return pd.DataFrame()

    def apply_indicators(self, df):
        """
        Ticaret stratejisi iÃ§in gerekli tÃ¼m teknik gÃ¶stergeleri uygular.
        Yeni eklenenler: OBV ve ATR.
        """
        if df.empty:
            return df
        
        # Hibrit strateji iÃ§in temel gÃ¶stergeler
        df.ta.rsi(length=14, append=True)
        df.ta.macd(append=True)
        df.ta.ema(length=20, append=True)
        df.ta.bbands(append=True)
        df.ta.adx(append=True)
        df.ta.obv(append=True)  # Yeni gÃ¶sterge: On-Balance Volume
        df.ta.atr(length=14, append=True) # Yeni gÃ¶sterge: Average True Range
        
        # Ek gÃ¶stergeler
        df.ta.mom(append=True)
        df.ta.cci(append=True)
        
        # Modeli beslemek iÃ§in gerekli sÃ¼tunlar
        required_cols = ["RSI_14", "MACD_12_26_9", "ADX_14", "BBL_5_2.0", "BBM_5_2.0", "BBU_5_2.0", "MOM_10", "CCI_14", "OBV", "ATR_14"]
        
        # EÄŸer bir gÃ¶sterge sÃ¼tunu eksikse, boÅŸ bir DataFrame dÃ¶ndÃ¼r.
        if not all(col in df.columns for col in required_cols):
            logging.warning("BazÄ± gÃ¶stergeler hesaplanamadÄ±, veri boyutu yetersiz olabilir.")
            return pd.DataFrame()

        return df.dropna().copy()

    def create_labels(self, df):
        """
        MÃ¼kemmeliyetÃ§i etiketleme mantÄ±ÄŸÄ±: ÃœÃ§lÃ¼ Onay Sistemi.
        Sinyal Ã¼retmek iÃ§in birden fazla koÅŸulu kontrol eder.
        1: YÃ¼kseliÅŸ (AL), -1: DÃ¼ÅŸÃ¼ÅŸ (SAT), 0: Yatay/Bekle (BEKLE)
        """
        # Gelecekteki fiyat hareketini tahmin etmek iÃ§in 1 mum ileri kaydÄ±rma
        df['future_close'] = df['close'].shift(-1)
        
        # Etiketleme mantÄ±ÄŸÄ±
        df['label'] = 0
        
        # AL (Long) sinyali iÃ§in Ã¼Ã§lÃ¼ onay
        # 1. Trend: Fiyat EMA 20'nin Ã¼zerinde olmalÄ±
        # 2. Momentum: RSI 60'Ä±n Ã¼zerinde olmalÄ± (aÅŸÄ±rÄ± alÄ±m bÃ¶lgesinde olmamalÄ±)
        # 3. Hacim: OBV yÃ¼kseliÅŸte olmalÄ±
        long_condition = (df['close'] > df['EMA_20']) & \
                         (df['RSI_14'] < 70) & \
                         (df['OBV'] > df['OBV'].shift(1))
        
        df.loc[long_condition, 'label'] = 1

        # SAT (Short) sinyali iÃ§in Ã¼Ã§lÃ¼ onay
        # 1. Trend: Fiyat EMA 20'nin altÄ±nda olmalÄ±
        # 2. Momentum: RSI 40'Ä±n altÄ±nda olmalÄ± (aÅŸÄ±rÄ± satÄ±m bÃ¶lgesinde olmamalÄ±)
        # 3. Hacim: OBV dÃ¼ÅŸÃ¼ÅŸte olmalÄ±
        short_condition = (df['close'] < df['EMA_20']) & \
                          (df['RSI_14'] > 30) & \
                          (df['OBV'] < df['OBV'].shift(1))
                          
        df.loc[short_condition, 'label'] = -1
        
        return df.dropna().copy()

    def train_model(self, df):
        """
        HazÄ±rlanan verilerle XGBoost modelini eÄŸitir.
        """
        if df.empty:
            logging.error("EÄŸitim iÃ§in yeterli veri yok.")
            return

        features = ["RSI_14", "MACD_12_26_9", "ADX_14", "BBL_5_2.0", "BBM_5_2.0", "BBU_5_2.0", "MOM_10", "CCI_14", "OBV", "ATR_14"]
        X = df[features]
        y = df['label']

        try:
            self.model.fit(X, y)
            self.trained = True
            logging.info("ðŸ§  AI modeli baÅŸarÄ±yla eÄŸitildi.")
        except Exception as e:
            logging.error(f"AI modeli eÄŸitim hatasÄ±: {e}")
            traceback.print_exc()

    def predict_signal(self, latest_row):
        """
        En son veriyi kullanarak AI'dan alÄ±m, satÄ±m veya bekle sinyali alÄ±r.
        """
        if not self.trained:
            logging.warning("AI modeli henÃ¼z eÄŸitilmemiÅŸ. Bekle sinyali veriliyor.")
            return "BEKLE"

        try:
            features = ["RSI_14", "MACD_12_26_9", "ADX_14", "BBL_5_2.0", "BBM_5_2.0", "BBU_5_2.0", "MOM_10", "CCI_14", "OBV", "ATR_14"]
            X = latest_row[features].values.reshape(1, -1)
            pred = self.model.predict(X)[0]

            if pred == 1:
                return "AL"
            elif pred == -1:
                return "SAT"
            else:
                return "BEKLE"
        except Exception as e:
            logging.error(f"Sinyal tahmini hatasÄ±: {e}")
            return "BEKLE"

    async def execute_trade(self, signal, current_price):
        """
        Gelen sinyale gÃ¶re ticaret emrini gÃ¶nderir ve pozisyonu yÃ¶netir.
        Risk yÃ¶netimi (stop-loss ve take-profit) burada uygulanÄ±r.
        """
        if self.position is None:
            # HenÃ¼z pozisyonda deÄŸiliz, yeni emir verebiliriz.
            try:
                if signal == "AL":
                    logging.info(f"ðŸš€ AL sinyali alÄ±ndÄ±. Fiyat: {current_price:.2f}")
                    # GerÃ§ek canlÄ± ticaret emri iÃ§in aÅŸaÄŸÄ±daki satÄ±rÄ±n yorumunu kaldÄ±rÄ±n.
                    # await self.exchange.create_market_buy_order(self.symbol, self.amount) 
                    self.position = 'LONG'
                    self.entry_price = current_price
                    self.sl_price = current_price * (1 - self.SL_PERCENTAGE)
                    self.tp_price = current_price * (1 + self.TP_PERCENTAGE)
                    logging.info(f"ðŸŸ¢ LONG pozisyon aÃ§Ä±ldÄ±. GiriÅŸ FiyatÄ±: {self.entry_price:.2f} | TP: {self.tp_price:.2f} | SL: {self.sl_price:.2f}")
                
                elif signal == "SAT":
                    logging.info(f"ðŸ”» SAT sinyali alÄ±ndÄ±. Fiyat: {current_price:.2f}")
                    # GerÃ§ek canlÄ± ticaret emri iÃ§in aÅŸaÄŸÄ±daki satÄ±rÄ±n yorumunu kaldÄ±rÄ±n.
                    # await self.exchange.create_market_sell_order(self.symbol, self.amount) 
                    self.position = 'SHORT'
                    self.entry_price = current_price
                    self.sl_price = current_price * (1 + self.SL_PERCENTAGE)
                    self.tp_price = current_price * (1 - self.TP_PERCENTAGE)
                    logging.info(f"ðŸ”´ SHORT pozisyon aÃ§Ä±ldÄ±. GiriÅŸ FiyatÄ±: {self.entry_price:.2f} | TP: {self.tp_price:.2f} | SL: {self.sl_price:.2f}")
                
                else:
                    logging.info("â¸ï¸ BEKLE sinyali â€” iÅŸlem yapÄ±lmadÄ±.")
            except Exception as e:
                logging.error(f"âŒ Emir gÃ¶nderme hatasÄ±: {e}")
                traceback.print_exc()

        else:
            # Zaten pozisyondayÄ±z, pozisyonu yÃ¶netiyoruz.
            if self.position == 'LONG':
                # Zarar Durdur kontrolÃ¼
                if current_price <= self.sl_price:
                    logging.warning(f"ðŸ›‘ LONG pozisyonu SL'e ulaÅŸtÄ±. Pozisyon kapatÄ±lÄ±yor. Fiyat: {current_price:.2f}")
                    # GerÃ§ek canlÄ± emir iÃ§in
                    # await self.exchange.create_market_sell_order(self.symbol, self.amount) 
                    self.position = None
                    self.entry_price = 0.0
                # KÃ¢r Al kontrolÃ¼
                elif current_price >= self.tp_price:
                    logging.info(f"âœ… LONG pozisyonu TP'ye ulaÅŸtÄ±. Pozisyon kapatÄ±lÄ±yor. Fiyat: {current_price:.2f}")
                    # GerÃ§ek canlÄ± emir iÃ§in
                    # await self.exchange.create_market_sell_order(self.symbol, self.amount) 
                    self.position = None
                    self.entry_price = 0.0

            elif self.position == 'SHORT':
                # Zarar Durdur kontrolÃ¼
                if current_price >= self.sl_price:
                    logging.warning(f"ðŸ›‘ SHORT pozisyonu SL'e ulaÅŸtÄ±. Pozisyon kapatÄ±lÄ±yor. Fiyat: {current_price:.2f}")
                    # GerÃ§ek canlÄ± emir iÃ§in
                    # await self.exchange.create_market_buy_order(self.symbol, self.amount) 
                    self.position = None
                    self.entry_price = 0.0
                # KÃ¢r Al kontrolÃ¼
                elif current_price <= self.tp_price:
                    logging.info(f"âœ… SHORT pozisyonu TP'ye ulaÅŸtÄ±. Pozisyon kapatÄ±lÄ±yor. Fiyat: {current_price:.2f}")
                    # GerÃ§ek canlÄ± emir iÃ§in
                    # await self.exchange.create_market_buy_order(self.symbol, self.amount) 
                    self.position = None
                    self.entry_price = 0.0

    async def run(self):
        """
        Botun ana dÃ¶ngÃ¼sÃ¼nÃ¼ Ã§alÄ±ÅŸtÄ±rÄ±r. SÃ¼rekli veri Ã§eker, sinyal Ã¼retir ve iÅŸlem yapar.
        """
        logging.info("ðŸ”¥ Nova AI Elite Bot baÅŸlatÄ±lÄ±yor...")
        
        # Model eÄŸitimi iÃ§in ilk verileri Ã§ekme
        df = await self.fetch_ohlcv()
        if df.empty:
            logging.error("Bot baÅŸlatÄ±lamadÄ±: Veri alÄ±namÄ±yor.")
            return

        df = self.apply_indicators(df)
        df_labeled = self.create_labels(df)
        self.train_model(df_labeled)
        
        while True:
            try:
                # Periyodik olarak yeni verileri Ã§ekme
                latest_df = await self.fetch_ohlcv()
                latest_df = self.apply_indicators(latest_df)

                if latest_df.empty:
                    logging.warning("Yeni veri bulunamadÄ±, bir sonraki dÃ¶ngÃ¼ bekleniyor...")
                    await asyncio.sleep(60) # 1 dakika bekle
                    continue
                
                latest_row = latest_df.iloc[-1]
                current_price = latest_row["close"]
                
                # Sinyal tahmini
                signal = self.predict_signal(latest_row)
                logging.info(f"{self.symbol} fiyatÄ±: {current_price:.2f} | AI Sinyal: {signal} | Pozisyon: {self.position}")

                # Ticaret emri gÃ¶nderme ve pozisyon yÃ¶netimi
                await self.execute_trade(signal, current_price)

            except Exception as e:
                logging.error(f"Ana dÃ¶ngÃ¼de beklenmedik hata: {e}")
                traceback.print_exc()

            await asyncio.sleep(60)  # Her 1 dakikada bir Ã§alÄ±ÅŸtÄ±r (timeframe'e gÃ¶re ayarlanabilir)

    def backtest_strategy(self, df):
        """
        GeliÅŸtirilmiÅŸ stratejinin geÃ§miÅŸ veriler Ã¼zerinde kapsamlÄ± bir geri testi.
        Bu fonksiyon, performansÄ± deÄŸerlendirmek iÃ§in Ã§eÅŸitli metrikler hesaplar.
        """
        logging.info("ðŸ“ˆ Strateji geriye dÃ¶nÃ¼k testi baÅŸlatÄ±lÄ±yor...")
        
        # Geriye dÃ¶nÃ¼k test iÃ§in modelin eÄŸitilmesi
        df = self.apply_indicators(df)
        df = self.create_labels(df)
        self.train_model(df)
        
        test_df = df.dropna().copy()
        
        initial_balance = 1000
        balance = initial_balance
        position_size = 0
        portfolio_value = [initial_balance]
        trades = []
        
        for i, row in test_df.iterrows():
            signal = self.predict_signal(row)
            current_price = row['close']
            
            # Sadece pozisyonda deÄŸilken AL veya SAT sinyallerine bak
            if position_size == 0:
                if signal == 'AL':
                    position_size = balance / current_price
                    entry_price = current_price
                    balance = 0
                    logging.info(f"âœ… GerÃ§ek zamanlÄ± test: LONG pozisyon aÃ§Ä±ldÄ± @ {current_price:.2f}")
                elif signal == 'SAT':
                    position_size = -1 * (balance / current_price)
                    entry_price = current_price
                    balance = 0
                    logging.info(f"âŒ GerÃ§ek zamanlÄ± test: SHORT pozisyon aÃ§Ä±ldÄ± @ {current_price:.2f}")
            # Pozisyonda iken, pozisyonu kapatma sinyali bekle
            elif position_size > 0 and signal == 'SAT':
                exit_price = current_price
                balance = position_size * exit_price
                profit = (exit_price - entry_price) / entry_price
                trades.append(profit)
                position_size = 0
                logging.info(f"ðŸ’° GerÃ§ek zamanlÄ± test: LONG pozisyon kapatÄ±ldÄ± @ {exit_price:.2f} | KÃ¢r: {profit:.2%}")
            elif position_size < 0 and signal == 'AL':
                exit_price = current_price
                profit = (entry_price - exit_price) / entry_price
                balance = -1 * (position_size * exit_price)
                trades.append(profit)
                position_size = 0
                logging.info(f"ðŸ’° GerÃ§ek zamanlÄ± test: SHORT pozisyon kapatÄ±ldÄ± @ {exit_price:.2f} | KÃ¢r: {profit:.2%}")

            # AnlÄ±k portfÃ¶y deÄŸerini takip et
            current_value = balance + (position_size * current_price)
            portfolio_value.append(current_value)
                
        final_balance = balance + (position_size * test_df.iloc[-1]['close'] if position_size != 0 else 0)
        
        # Performans Metriklerini Hesapla
        total_return = (final_balance - initial_balance) / initial_balance if initial_balance > 0 else 0
        
        portfolio_series = pd.Series(portfolio_value)
        peak = portfolio_series.cummax()
        drawdown = (portfolio_series - peak) / peak
        max_drawdown = drawdown.min()
        
        # Risk-free rate (risksiz getiri) iÃ§in basit bir varsayÄ±m: %0
        # Sharpe Ratio = (Strateji Getirisi - Risksiz Getiri) / Strateji Volatilitesi
        # GÃ¼nlÃ¼k getiri, burada mum getirisini kullanÄ±yoruz
        daily_returns = portfolio_series.pct_change().dropna()
        if daily_returns.std() != 0:
            sharpe_ratio = daily_returns.mean() / daily_returns.std() * np.sqrt(252) # YÄ±llÄ±klandÄ±rma
        else:
            sharpe_ratio = np.nan
            
        win_rate = sum(1 for p in trades if p > 0) / len(trades) if len(trades) > 0 else 0
        
        logging.info("--- Geriye DÃ¶nÃ¼k Test SonuÃ§larÄ± ---")
        logging.info(f"BaÅŸlangÄ±Ã§ Bakiyesi: {initial_balance:.2f} USDT")
        logging.info(f"Son Bakiye: {final_balance:.2f} USDT")
        logging.info(f"Toplam Getiri (ROI): {total_return:.2%}")
        logging.info(f"Maksimum DÃ¼ÅŸÃ¼ÅŸ (Max Drawdown): {max_drawdown:.2%}")
        logging.info(f"Sharpe OranÄ±: {sharpe_ratio:.2f}")
        logging.info(f"Kazanma OranÄ± (Win Rate): {win_rate:.2%}")

        # PortfÃ¶y DeÄŸeri ve DÃ¼ÅŸÃ¼ÅŸ GrafiÄŸi (Portfolio Value and Drawdown Plot)
        plt.style.use('dark_background')
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10), sharex=True)

        # PortfÃ¶y DeÄŸeri GrafiÄŸi
        ax1.plot(portfolio_series.index, portfolio_series, color='cyan', label='Portfolio Value')
        ax1.axhline(y=initial_balance, color='gray', linestyle='--', label='Initial Balance')
        ax1.set_title('Portfolio Value Over Time')
        ax1.set_ylabel('Portfolio Value (USDT)')
        ax1.legend()
        ax1.grid(True, linestyle=':', alpha=0.6)

        # Max Drawdown GrafiÄŸi
        ax2.fill_between(drawdown.index, drawdown, 0, color='red', alpha=0.3)
        ax2.plot(drawdown.index, drawdown, color='red', label='Drawdown')
        ax2.set_title('Portfolio Drawdown')
        ax2.set_xlabel('Time (Candles)')
        ax2.set_ylabel('Drawdown (%)')
        ax2.legend()
        ax2.grid(True, linestyle=':', alpha=0.6)

        plt.tight_layout()
        plt.show()
        # Matplotlib grafiÄŸini kaydetmek iÃ§in
        # Bu ortamda gÃ¶rselleÅŸtirme doÄŸrudan gÃ¶sterilemediÄŸi iÃ§in
        # dosyaya kaydedilir. GerÃ§ek bir senaryoda bu grafiÄŸi doÄŸrudan bir web arayÃ¼zÃ¼ne entegre edebilirsiniz.
        plt.savefig('backtest_performance.png')
        logging.info("Grafik baÅŸarÄ±yla 'backtest_performance.png' olarak kaydedildi.")
        
    async def close(self):
        """
        Botun baÄŸlantÄ±larÄ±nÄ± kapatÄ±r.
        """
        await self.exchange.close()
        logging.info("ðŸ‘‹ Bot kapatÄ±ldÄ±.")

# Botu baÅŸlatmak iÃ§in ana iÅŸlev
async def main():
    # --- API ANAHTARLARINI ORTAM DEÄžÄ°ÅžKENLERÄ°NDEN OKUYUN ---
    # Bu yÃ¶ntem, anahtarlarÄ± doÄŸrudan koda yazmaktan daha gÃ¼venlidir.
    try:
        # ".env" dosyasÄ±ndan anahtarlarÄ± okumak iÃ§in python-dotenv kÃ¼tÃ¼phanesi kurulu olmalÄ±dÄ±r.
        # "pip install python-dotenv" komutunu kullanarak kurabilirsiniz.
        # Daha sonra, "dotenv.load_dotenv()" komutunu Ã§alÄ±ÅŸtÄ±rarak dosyayÄ± yÃ¼kleyebilirsiniz.
        # import dotenv
        # dotenv.load_dotenv()
        BINANCE_API_KEY = os.getenv("BINANCE_API_KEY")
        BINANCE_SECRET_KEY = os.getenv("BINANCE_SECRET_KEY")
        
        if not BINANCE_API_KEY or not BINANCE_SECRET_KEY:
            raise ValueError("API anahtarlarÄ± ortam deÄŸiÅŸkenlerinde bulunamadÄ±.")
            
    except Exception as e:
        logging.error(f"Ortam deÄŸiÅŸkenleri yÃ¼klenirken hata oluÅŸtu: {e}")
        return # Anahtarlar olmadan bot Ã§alÄ±ÅŸamaz.

    # CanlÄ± iÅŸlem modunu baÅŸlatmak iÃ§in aÅŸaÄŸÄ±daki parametreyi True yapÄ±n.
    # False bÄ±rakÄ±rsanÄ±z, bot hala sinyal Ã¼retir ancak gerÃ§ek iÅŸlem yapmaz.
    LIVE_TRADING_ENABLED = False 

    # Botu API anahtarlarÄ± ile baÅŸlatÄ±yoruz
    bot = NovaAIEliiteBot(api_key=BINANCE_API_KEY, secret_key=BINANCE_SECRET_KEY)
    
    if LIVE_TRADING_ENABLED:
        await bot.run()
    else:
        # Geriye dÃ¶nÃ¼k test (Backtesting)
        df_for_backtest = await bot.fetch_ohlcv()
        if not df_for_backtest.empty:
            bot.backtest_strategy(df_for_backtest.copy())
    
    await bot.close()

if __name__ == "__main__":
    asyncio.run(main())


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\apps\nova_quantum_bot.py
import asyncio
from modules.data_collector import DataCollector
from modules.strategy_manager import StrategyManager
from modules.meta_decision_engine import MetaDecisionEngine
from modules.execution_engine import ExecutionEngine
from modules.reinforcement_trainer import ReinforcementTrainer
from modules.news_analyzer import NewsAnalyzer
from modules.onchain_analyzer import OnChainAnalyzer
from modules.ai_predictor import AIPredictor
from modules.performance_tracker import PerformanceTracker

class NovaQuantumBot:
    def __init__(self, symbol="BTC/USDT", timeframe="1m"):
        self.symbol = symbol
        self.timeframe = timeframe
        self.data_collector = DataCollector(symbol, timeframe)
        self.strategy_manager = StrategyManager()
        self.meta_engine = MetaDecisionEngine()
        self.execution_engine = ExecutionEngine()
        self.reinforcement_trainer = ReinforcementTrainer()
        self.news_analyzer = NewsAnalyzer()
        self.onchain_analyzer = OnChainAnalyzer()
        self.ai_predictor = AIPredictor()
        self.performance_tracker = PerformanceTracker()

    async def run(self):
        while True:
            df = await self.data_collector.fetch()
            news_sentiment = await self.news_analyzer.analyze()
            onchain_score = await self.onchain_analyzer.evaluate()
            ai_signal = await self.ai_predictor.predict(df)
            strategy_signals = await self.strategy_manager.evaluate_all(df)

            decision = self.meta_engine.resolve(
                strategy_signals,
                news_sentiment,
                onchain_score,
                ai_signal
            )

            await self.execution_engine.execute(decision)
            self.performance_tracker.log(decision)
            await self.reinforcement_trainer.train(self.performance_tracker.get_metrics())
            await asyncio.sleep(1)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\apps\nova_super_bot.py
import asyncio
import pandas as pd
import pandas_ta as ta
import numpy as np
import ccxt.async_support as ccxt
from datetime import datetime, timezone

# ðŸ”— Entegre modÃ¼ller
from kiripto_nova.apps.nova_ai_elite_bot import NovaAI
from kiripto_nova.ai.neuro_decision_engine import NeuroEngine
from kiripto_nova.execution.position_manager import PositionManager
from nova_trader import NovaTrader
from kiripto_nova.signals.news_data import fetch_sentiment
from manipulation_detector import detect_anomaly
from kiripto_nova.ai.ml_filter import apply_filters

class NovaSuperBot:
    def __init__(self, symbol="BTC/USDT", timeframe="1m", limit=200, amount=0.01):
        self.symbol = symbol
        self.timeframe = timeframe
        self.limit = limit
        self.amount = amount
        self.exchange = ccxt.binance({'enableRateLimit': True})
        self.ai = NovaAI()
        self.neuro = NeuroEngine()
        self.trader = NovaTrader()
        self.position_manager = PositionManager()

    def log(self, msg, level="INFO"):
        ts = datetime.now(timezone.utc).isoformat()
        print(f"[{ts}] | {level.upper()} | {msg}")

    async def fetch_data(self):
        ohlcv = await self.exchange.fetch_ohlcv(self.symbol, self.timeframe, limit=self.limit)
        df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
        df.ta.rsi(length=14, append=True)
        df.ta.macd(append=True)
        df.ta.ema(length=20, append=True)
        df.ta.sma(length=50, append=True)
        df.ta.mom(append=True)
        return df.dropna()

    async def run(self):
        while True:
            df = await self.fetch_data()
            latest = df.iloc[-1]
            sentiment = fetch_sentiment()
            anomaly = detect_anomaly(df)
            filtered = apply_filters(latest)

            signal_ai = self.ai.predict(latest)
            signal_neuro = self.neuro.evaluate(df)
            signal_final = self.resolve_signals(signal_ai, signal_neuro, sentiment, anomaly, filtered)

            price = latest["close"]
            self.log(f"{self.symbol} fiyatÄ±: {price:.2f} | Sinyal: {signal_final}", "DATA")

            if self.position_manager.validate(signal_final):
                await self.trader.execute_trade(signal_final)

            await asyncio.sleep(1)  # Mikrosaniyeye yakÄ±n dÃ¶ngÃ¼

    def resolve_signals(self, ai, neuro, sentiment, anomaly, filtered):
        if anomaly or not filtered:
            return "BEKLE"
        if ai == neuro and sentiment == "positive":
            return ai
        if ai != neuro:
            return "BEKLE"
        return ai

    async def close(self):
        await self.exchange.close()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\apps\nova_supreme_bot.py
import asyncio
from modules.data_collector import DataCollector
from modules.strategy_manager import StrategyManager
from modules.meta_decision_engine import MetaDecisionEngine
from modules.execution_engine import ExecutionEngine
from modules.reinforcement_trainer import ReinforcementTrainer
from modules.news_analyzer import NewsAnalyzer
from modules.onchain_analyzer import OnChainAnalyzer
from modules.ai_predictor import AIPredictor
from modules.performance_tracker import PerformanceTracker
from modules.genetic_optimizer import GeneticOptimizer
from modules.dashboard_connector import DashboardConnector
from modules.dao_interface import DAOInterface

class NovaSupremeBot:
    def __init__(self, symbol="BTC/USDT", timeframe="1m", elite_mode=True):
        self.symbol = symbol
        self.timeframe = timeframe
        self.elite_mode = elite_mode

        # ModÃ¼ller
        self.data_collector = DataCollector(symbol, timeframe)
        self.news_analyzer = NewsAnalyzer()
        self.onchain_analyzer = OnChainAnalyzer()
        self.ai_predictor = AIPredictor()
        self.strategy_manager = StrategyManager()
        self.meta_engine = MetaDecisionEngine()
        self.execution_engine = ExecutionEngine()
        self.reinforcement_trainer = ReinforcementTrainer()
        self.performance_tracker = PerformanceTracker()
        self.genetic_optimizer = GeneticOptimizer()
        self.dashboard = DashboardConnector()
        self.dao = DAOInterface()

    async def run(self):
        while True:
            df = await self.data_collector.fetch()
            news_sentiment = await self.news_analyzer.analyze()
            onchain_score = await self.onchain_analyzer.evaluate()
            ai_signals = await self.ai_predictor.predict_all(df)
            strategy_signals = await self.strategy_manager.evaluate_all(df)

            decision = self.meta_engine.resolve(
                strategy_signals,
                news_sentiment,
                onchain_score,
                ai_signals
            )

            if self.elite_mode:
                decision = self.execution_engine.elite_filter(decision, df)

            await self.execution_engine.execute(decision)
            self.performance_tracker.log(decision)
            self.reinforcement_trainer.train(self.performance_tracker.get_metrics())
            self.genetic_optimizer.evolve(self.strategy_manager.get_strategies())
            self.dashboard.update(self.symbol, decision, df)
            self.dao.sync(decision)

            await asyncio.sleep(1)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\apps\telegram_alert.py
# telegram_alert.py
import requests
from config import TELEGRAM_TOKEN, TELEGRAM_CHAT_ID

def send_telegram_message(message):
    url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
    payload = {
        "chat_id": TELEGRAM_CHAT_ID,
        "text": message,
        "parse_mode": "Markdown"
    }
    try:
        response = requests.post(url, json=payload)
        if response.status_code == 200:
            print("ðŸ“² Telegram mesajÄ± gÃ¶nderildi.")
        else:
            print("âš ï¸ Telegram mesaj hatasÄ±:", response.text)
    except Exception as e:
        print("âŒ Telegram baÄŸlantÄ± hatasÄ±:", str(e))

def notify_trade(action, symbol, qty, price, sl, tp):
    msg = (
        f"ðŸš¨ *Yeni Ä°ÅŸlem*
"
        f"*Aksiyon:* {action.upper()}\n"
        f"*Sembol:* {symbol}\n"
        f"*Miktar:* {qty}\n"
        f"*Fiyat:* {price}\n"
        f"*SL:* {sl}  |  *TP:* {tp}"
    )
    send_telegram_message(msg)

def notify_signal(signal_type, symbol):
    msg = f"ðŸ“¡ *Yeni Sinyal:* {signal_type.upper()} iÃ§in {symbol}"
    send_telegram_message(msg)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\apps\telegram_bot.py
def send_signal_message(signal, title, source):
    message = f"{signal} ðŸ“¢\nBaÅŸlÄ±k: {title}\nKaynak: {source}"
    send_to_telegram(message)
import os
import requests

def send_telegram_message(message):
    bot_token = os.getenv("TELEGRAM_BOT_TOKEN")
    chat_id = os.getenv("TELEGRAM_CHAT_ID")
    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
    payload = {"chat_id": chat_id, "text": message}
    requests.post(url, data=payload)
ðŸ“¡ SINYAL: AL  
ðŸ§  YORUM: Haber yatÄ±rÄ±mcÄ± gÃ¼venini artÄ±rÄ±yor. Sabah saatinde, gÃ¼venilir kaynakta yayÄ±nlandÄ±. Beklenti yÃ¼kseliÅŸ yÃ¶nÃ¼nde.




### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\backtesting\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\backtesting\backtester.py
# backtester.py
import pandas as pd
from kiripto_nova.signals.signal_engine import SignalEngine
from kiripto_nova.risk.risk_manager import calculate_position_size, calculate_stop_loss, calculate_take_profit

class Backtester:
    def __init__(self, df, balance=1000, risk=0.01, stop_pct=0.03, reward_ratio=2):
        self.df = df.copy()
        self.balance = balance
        self.initial_balance = balance
        self.risk = risk
        self.stop_pct = stop_pct
        self.reward_ratio = reward_ratio
        self.trades = []

    def run(self):
        engine = SignalEngine(self.df)
        df_with_indicators = engine.get_dataframe()

        for i in range(50, len(df_with_indicators)):
            sliced = df_with_indicators.iloc[:i]
            engine.df = sliced
            signal = engine.generate_signal()
            close = sliced.iloc[-1]['close']

            if signal == "BUY":
                size = calculate_position_size(self.balance, self.risk, self.stop_pct)
                sl = calculate_stop_loss(close, self.stop_pct, direction="long")
                tp = calculate_take_profit(close, self.reward_ratio, self.stop_pct, direction="long")
                self._simulate_trade(close, sl, tp, size, direction="long")

            elif signal == "SELL":
                size = calculate_position_size(self.balance, self.risk, self.stop_pct)
                sl = calculate_stop_loss(close, self.stop_pct, direction="short")
                tp = calculate_take_profit(close, self.reward_ratio, self.stop_pct, direction="short")
                self._simulate_trade(close, sl, tp, size, direction="short")

        return self._results()

    def _simulate_trade(self, entry, sl, tp, size, direction="long"):
        result = {
            "entry": entry,
            "sl": sl,
            "tp": tp,
            "size": size,
            "type": direction,
            "outcome": None
        }
        # Basit simÃ¼lasyon: fiyata ulaÅŸÄ±ldÄ± mÄ± kontrolÃ¼ (gerÃ§ek backtest iÃ§in candle iÃ§i detay gerekir)
        if direction == "long":
            result["outcome"] = "win" if tp > entry else "loss"
        else:
            result["outcome"] = "win" if tp < entry else "loss"

        self.trades.append(result)
        if result["outcome"] == "win":
            self.balance += size * self.stop_pct * self.reward_ratio
        else:
            self.balance -= size * self.stop_pct

    def _results(self):
        total = len(self.trades)
        wins = len([t for t in self.trades if t['outcome'] == 'win'])
        losses = total - wins
        winrate = (wins / total * 100) if total else 0
        profit = self.balance - self.initial_balance
        return {
            "Toplam Ä°ÅŸlem": total,
            "Kazanma OranÄ±": f"{winrate:.2f}%",
            "Net KÃ¢r/Zarar": round(profit, 2),
            "Son Bakiye": round(self.balance, 2)
        }


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\backtesting\testnet_trade_bot.py
import os
import math
import time
import logging
from decimal import Decimal, ROUND_DOWN

from binance.client import Client
from dotenv import load_dotenv

# --------------------------
# YardÄ±mcÄ±lar
# --------------------------

def d(v):  # gÃ¼venli decimal
    return Decimal(str(v))

def round_step(value, step):
    if step is None:
        return value
    return (d(value) // d(step)) * d(step)

def get_filters(client, symbol):
    info = client.futures_exchange_info()
    md = next(s for s in info["symbols"] if s["symbol"] == symbol)

    tick = float(next(f["tickSize"] for f in md["filters"] if f["filterType"] == "PRICE_FILTER"))
    lotf = next((f for f in md["filters"] if f["filterType"] == "MARKET_LOT_SIZE"), None)
    if not lotf:
        lotf = next(f for f in md["filters"] if f["filterType"] == "LOT_SIZE")
    step = float(lotf["stepSize"])
    min_qty = float(lotf["minQty"])
    min_notional = float(next(f["notional"] for f in md["filters"] if f["filterType"] == "MIN_NOTIONAL"))
    return tick, step, min_qty, min_notional

def to_price_tick(price, tick):
    return float(round_step(price, tick))

def to_qty_step(qty, step, min_qty):
    q = float(round_step(qty, step))
    return q if q >= min_qty else 0.0

# --------------------------
# Ana uygulama
# --------------------------

def main():
    load_dotenv()

    KEY    = os.getenv("BINANCE_API_KEY", "")
    SECRET = os.getenv("BINANCE_API_SECRET", "")
    USE_TESTNET = os.getenv("BINANCE_USE_TESTNET", "false").lower() == "true"
    FUT_URL = os.getenv("BINANCE_FUTURES_URL", "").strip()
    HEDGE  = os.getenv("BINANCE_HEDGE_MODE", "true").lower() == "true"
    MARGIN = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED").upper()
    LEV    = int(os.getenv("BINANCE_LEVERAGE", "10"))

    SYMBOLS = [s.strip().upper() for s in os.getenv("SYMBOLS", "BTCUSDT,ETHUSDT").split(",") if s.strip()]
    DRY_RUN = os.getenv("DRY_RUN", "true").lower() == "true"

    MAX_PCT_TRADE = float(os.getenv("MAX_CAPITAL_PCT_PER_TRADE", "0.02"))
    MIN_NOTIONAL  = float(os.getenv("MIN_NOTIONAL_USDT", "10"))
    LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()

    logging.basicConfig(level=getattr(logging, LOG_LEVEL, logging.INFO), format="%(asctime)s | %(levelname)s | %(message)s")

    if not KEY or not SECRET:
        raise SystemExit("API anahtarlarÄ± boÅŸ: .env dosyanÄ± doldur.")

    # Binance Client
    c = Client(KEY, SECRET, testnet=USE_TESTNET)
    if USE_TESTNET and FUT_URL:
        c.FUTURES_URL = FUT_URL

    # baÄŸlantÄ± testi
    t = c.futures_time()["serverTime"]
    logging.info(f"BaÄŸlantÄ± OK | serverTime={t} | testnet={USE_TESTNET}")

    # Hedge mode
    try:
        c.futures_change_position_mode(dualSidePosition="true" if HEDGE else "false")
        logging.info(f"Hedge mode: {'DUAL' if HEDGE else 'ONE-WAY'}")
    except Exception as e:
        logging.warning(f"Hedge mode ayarlanamadÄ± (devam ediyorum): {e}")

    # Her sembol iÃ§in kaldÄ±raÃ§ ve margin tipi kur
    for sym in SYMBOLS:
        try:
            c.futures_change_margin_type(symbol=sym, marginType=MARGIN)
        except Exception as e:
            # AynÄ± tÃ¼rde ise hata dÃ¶ner; sorun deÄŸil
            logging.debug(f"{sym} margin tipi: {e}")
        try:
            c.futures_change_leverage(symbol=sym, leverage=LEV)
        except Exception as e:
            logging.debug(f"{sym} leverage: {e}")

    # Toplam USDT bakiyesi
    bal = c.futures_account_balance()
    usdt = float(next(float(b["balance"]) for b in bal if b["asset"] == "USDT"))
    logging.info(f"USDT bakiye: {usdt}")

    # Basit bir Ã¶rnek: hÄ±zlÄ± karar kurallarÄ± (tamamen Ã¶rnek)
    # - Son fiyat son 1 dakikada %0.2 Ã¼zeri artÄ±yorsa LONG, %0.2 Ã¼zeri dÃ¼ÅŸÃ¼yorsa SHORT
    # GerÃ§ekte buraya kendi stratejini/sinyalini koyacaksÄ±n.
    for sym in SYMBOLS:
        # borsanÄ±n kurallarÄ±nÄ± al
        tick, step, min_qty, min_notional = get_filters(c, sym)

        # fiyat verisi
        klines = c.futures_klines(symbol=sym, interval=Client.KLINE_INTERVAL_1MINUTE, limit=2)
        p_old = float(klines[-2][4])  # Ã¶nceki kapanÄ±ÅŸ
        p_now = float(klines[-1][4])  # son kapanÄ±ÅŸ
        change = (p_now - p_old) / p_old

        logging.info(f"{sym} price {p_old:.2f} -> {p_now:.2f} | change={change*100:.3f}%")

        side = None
        position_side = None
        if change >= 0.002:  # +%0.2
            side = "BUY"
            position_side = "LONG" if HEDGE else None
        elif change <= -0.002:  # -%0.2
            side = "SELL"
            position_side = "SHORT" if HEDGE else None
        else:
            logging.info(f"{sym}: deÄŸiÅŸim eÅŸik altÄ±nda, iÅŸlem yok.")
            continue

        # Risk: iÅŸleme ayÄ±racaÄŸÄ±mÄ±z tutar
        notional = max(MIN_NOTIONAL, usdt * MAX_PCT_TRADE)
        qty_raw = notional / p_now * LEV  # kaldÄ±raÃ§la efektif miktar
        qty = to_qty_step(qty_raw, step, min_qty)
        if qty <= 0:
            logging.warning(f"{sym}: miktar adÄ±mÄ±na/minQtyâ€™e uymuyor (hesaplanan={qty_raw}). AtlanÄ±yor.")
            continue

        params = dict(
            symbol=sym,
            side=side,
            type="MARKET",
            quantity=qty,
        )
        if HEDGE:
            params["positionSide"] = position_side  # LONG/SHORT

        logging.info(f"{sym} emir: {params} | DRY_RUN={DRY_RUN}")

        if DRY_RUN:
            continue

        try:
            resp = c.futures_create_order(**params)
            order_id = resp.get("orderId")
            avg_price = resp.get("avgPrice") or resp.get("price") or "?"
            logging.info(f"{sym} emir gÃ¶nderildi | id={order_id} avgPrice={avg_price}")
        except Exception as e:
            logging.error(f"{sym} emir HATASI: {e}")

    logging.info("Tur tamamlandÄ±.")

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\core\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\core\config_loader.py
import os
from dotenv import load_dotenv

load_dotenv()  # .env dosyasÄ±nÄ± yÃ¼kler

BINANCE_API_KEY = os.getenv("BINANCE_API_KEY")
BINANCE_API_SECRET = os.getenv("BINANCE_API_SECRET")
BINANCE_USE_TESTNET = os.getenv("BINANCE_USE_TESTNET", "true").lower() == "true"
BINANCE_FUTURES_URL = os.getenv("BINANCE_FUTURES_URL")

print("Binance Key:", BINANCE_API_KEY[:5] + "...")
print("Testnet mi?:", BINANCE_USE_TESTNET)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\data\pipelines\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\data\pipelines\data_loader.py
# data_loader.py
import ccxt
import pandas as pd
from datetime import datetime

def load_binance_data(symbol="DOGE/USDT", timeframe="15m", limit=500):
    binance = ccxt.binance()
    ohlcv = binance.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    return df


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\data\pipelines\twitter_data.py
import tweepy

auth = tweepy.OAuth1UserHandler("API_KEY", "API_SECRET", "ACCESS_TOKEN", "ACCESS_SECRET")
api = auth.get_api()

def get_crypto_tweets(keyword="bitcoin"):
    tweets = api.search_tweets(q=keyword, lang='en', count=10)
    return [t.text for t in tweets]


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\data\raw\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\data\__init__.py
# auto-added


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\exchanges\binance\__init__.py
# auto-added


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\exchanges\binance\binance_futures_boot.py
import os
from dotenv import load_dotenv
from binance.client import Client

load_dotenv()

API_KEY = os.getenv("BINANCE_API_KEY")
API_SECRET = os.getenv("BINANCE_API_SECRET")
USE_TESTNET = os.getenv("BINANCE_USE_TESTNET", "true").lower() == "true"
FAPI_URL = os.getenv("BINANCE_FUTURES_URL")  # testnet url'ini geÃ§eceÄŸiz
HEDGE = os.getenv("BINANCE_HEDGE_MODE", "true").lower() == "true"
MARGIN_TYPE = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED")
LEVERAGE = int(os.getenv("BINANCE_LEVERAGE", "5"))
SYMBOLS = [s.strip() for s in os.getenv("SYMBOLS", "BTCUSDT").split(",")]

client = Client(API_KEY, API_SECRET, testnet=USE_TESTNET)
if FAPI_URL:
    client.FUTURES_URL = FAPI_URL

# BaÅŸlangÄ±Ã§ konfigÃ¼rasyonlarÄ±
try:
    client.futures_change_position_mode(dualSidePosition=HEDGE)
except Exception as e:
    print("Hedge mode ayarlanamadÄ±:", e)

for sym in SYMBOLS:
    try:
        client.futures_change_margin_type(symbol=sym, marginType=MARGIN_TYPE)
    except Exception as e:
        # Zaten aynÄ± ise hata dÃ¶nebilir; sorun deÄŸil
        pass
    try:
        client.futures_change_leverage(symbol=sym, leverage=LEVERAGE)
    except Exception as e:
        print(f"Leverage ayarlanamadÄ± {sym}:", e)

print("Futures boot OK. Symbols:", SYMBOLS)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\exchanges\binance\binance_order_test.py
from binance.client import Client
from dotenv import load_dotenv
import os

# Ortam deÄŸiÅŸkenlerini yÃ¼kle
load_dotenv()

api_key = os.getenv("BINANCE_API_KEY")
api_secret = os.getenv("BINANCE_SECRET_KEY")

# Binance client oluÅŸtur
client = Client(api_key, api_secret)

# Test amaÃ§lÄ± kÃ¼Ã§Ã¼k bir emir oluÅŸtur (gerÃ§ek para ile)
try:
    order = client.futures_create_order(
        symbol='BTCUSDT',
        side='BUY',           # SatÄ±n al
        type='MARKET',        # Piyasa emri
        quantity=0.001        # Ã‡ok dÃ¼ÅŸÃ¼k miktarda test
    )
    print("âœ… Emir baÅŸarÄ±yla gÃ¶nderildi:")
    print(order)

except Exception as e:
    print("âŒ Hata oluÅŸtu:")
    print(e)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\exchanges\binance\client.py
import ccxt
from config.settings import BINANCE_API_KEY, BINANCE_SECRET

def get_client():
    return ccxt.binance({
        'apiKey': BINANCE_API_KEY,
        'secret': BINANCE_SECRET,
        'enableRateLimit': True,
        'options': {'defaultType': 'future'}
    })


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\exchanges\binance\data.py
from binance.client import Client
import os

API_KEY = os.getenv("BINANCE_API_KEY")
API_SECRET = os.getenv("BINANCE_API_SECRET")

client = Client(API_KEY, API_SECRET)

def get_price(symbol="BTCUSDT"):
    ticker = client.get_symbol_ticker(symbol=symbol)
    return ticker['price']
import binance.client
client.futures_create_order(
    symbol='BTCUSDT',
    side='BUY',
    type='MARKET',
    quantity=0.01,
    leverage=10
)
from analysis_engine.indicators import prepare_indicators
from data_fetcher.binance_data import get_historical_data  # tarihsel fiyatlarÄ± Ã§eken fonksiyon

df = get_historical_data("BTCUSDT", interval="1h", limit=100)
indicators = prepare_indicators(df)

print(indicators)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\exchanges\__init__.py
# auto-added


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\execution\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\execution\orchestrator_stream.py
# orchestrator_stream.py
# YÃ¼ksek frekans Binance Futures veri toplayÄ±cÄ± + modÃ¼ler analiz orkestratÃ¶rÃ¼ (emir YOK)

import os, sys, json, asyncio, time, importlib, traceback
from collections import deque, defaultdict
from dataclasses import dataclass, field
from typing import Callable, Dict, List, Optional, Any, Tuple

import aiohttp
import numpy as np
from dotenv import load_dotenv

# ----------------------- Config -----------------------

load_dotenv()

USE_TESTNET = os.getenv("BINANCE_USE_TESTNET", "true").strip().lower() == "true"
WS_MAIN = os.getenv("WS_MAIN", "wss://fstream.binance.com/stream").strip()
WS_TEST = os.getenv("WS_TEST", "wss://stream.binancefuture.com/stream").strip()
WS_BASE = WS_TEST if USE_TESTNET else WS_MAIN

SYMBOLS = [s.strip().upper() for s in os.getenv("SYMBOLS", "BTCUSDT").split(",") if s.strip()]
STREAMS = []
for s in SYMBOLS:
    STREAMS += [f"{s.lower()}@aggTrade", f"{s.lower()}@bookTicker"]

MICRO_BATCH_MS = int(os.getenv("MICRO_BATCH_MS", "5"))     # mikro-batch penceresi (ms)
SNAPSHOT_SEC   = int(os.getenv("SNAPSHOT_SEC", "2"))       # Ã¶zet/snapshot aralÄ±ÄŸÄ± (s)
BUFF_LEN       = int(os.getenv("BUFF_LEN", "5000"))        # hafÄ±zada tutulan son olay sayÄ±sÄ±
PRINT_HOOK_ERR = True

# ----------------------- Online indicators -----------------------

class OnlineEMA:
    def __init__(self, period: int):
        self.alpha = 2.0 / (period + 1.0)
        self.value = None
    def update(self, x: float) -> float:
        if self.value is None:
            self.value = float(x)
        else:
            self.value = self.alpha * float(x) + (1 - self.alpha) * self.value
        return self.value

class OnlineRSI:
    # Wilder RSI (ortalama kazanÃ§/kayÄ±p EMA ile)
    def __init__(self, period: int = 14):
        self.period = period
        self.avg_gain = None
        self.avg_loss = None
        self.prev = None
        self.ready = False
        self.count = 0
    def update(self, price: float) -> Optional[float]:
        p = float(price)
        if self.prev is None:
            self.prev = p
            return None
        change = p - self.prev
        gain = max(change, 0.0)
        loss = max(-change, 0.0)
        self.prev = p

        if self.avg_gain is None:
            self.avg_gain = gain
            self.avg_loss = loss
            self.count = 1
            return None

        # Wilder smoothing
        self.avg_gain = (self.avg_gain * (self.period - 1) + gain) / self.period
        self.avg_loss = (self.avg_loss * (self.period - 1) + loss) / self.period

        self.count += 1
        if not self.ready and self.count >= self.period:
            self.ready = True

        if self.avg_loss == 0:
            return 100.0 if self.avg_gain > 0 else 50.0

        rs = self.avg_gain / self.avg_loss
        rsi = 100 - (100 / (1 + rs))
        return float(rsi) if self.ready else None

class OnlineVol:
    # Basit kayan vol: son N kapanÄ±ÅŸ deÄŸiÅŸimlerinin std tahmini
    def __init__(self, window: int = 60):
        self.window = window
        self.buf = deque(maxlen=window)
    def update(self, price: float) -> Optional[float]:
        p = float(price)
        if len(self.buf) > 0:
            ret = np.log(p) - np.log(self.buf[-1])
        else:
            ret = 0.0
        self.buf.append(p)
        if len(self.buf) >= 3:
            rets = np.diff(np.log(np.array(self.buf)))
            return float(np.std(rets))
        return None

# ----------------------- Data model -----------------------

@dataclass
class Tick:
    symbol: str
    kind: str            # 'trade' or 'book'
    server_ts: int       # Binance ms
    local_ns: int        # local receive time, ns
    price: float
    qty: float = 0.0
    bid: float = 0.0
    ask: float = 0.0

@dataclass
class SymbolState:
    trades: deque = field(default_factory=lambda: deque(maxlen=BUFF_LEN))
    books:  deque = field(default_factory=lambda: deque(maxlen=BUFF_LEN))
    ema_fast: OnlineEMA = field(default_factory=lambda: OnlineEMA(20))
    ema_slow: OnlineEMA = field(default_factory=lambda: OnlineEMA(50))
    rsi14: OnlineRSI = field(default_factory=lambda: OnlineRSI(14))
    vol60: OnlineVol = field(default_factory=lambda: OnlineVol(60))
    last_price: float = 0.0
    last_bid: float = 0.0
    last_ask: float = 0.0
    last_features: Dict[str, float] = field(default_factory=dict)

# ----------------------- Plugin loader -----------------------

class PluginBus:
    def __init__(self):
        self.hooks = {
            "on_tick": [],
            "on_microbatch": [],
            "on_snapshot": []
        }

    def load_project_plugins(self):
        # Ã‡alÄ±ÅŸma dizinindeki .py dosyalarÄ±nÄ± tarar (orchestrator hariÃ§)
        for fname in os.listdir("."):
            if not fname.endswith(".py"):
                continue
            modname = fname[:-3]
            if modname in ("orchestrator_stream",):
                continue
            try:
                mod = importlib.import_module(modname)
                if hasattr(mod, "register"):
                    reg = mod.register()
                    for k in self.hooks:
                        fn = reg.get(k)
                        if callable(fn):
                            self.hooks[k].append(fn)
                    print(f"ðŸ”Œ Plugin yÃ¼klendi: {modname}")
            except Exception as e:
                print(f"âš ï¸ Plugin yÃ¼klenemedi: {modname}: {e}")

    async def emit(self, hook: str, *args, **kwargs):
        for fn in self.hooks.get(hook, []):
            try:
                if asyncio.iscoroutinefunction(fn):
                    await fn(*args, **kwargs)
                else:
                    fn(*args, **kwargs)
            except Exception as e:
                if PRINT_HOOK_ERR:
                    print(f"âš ï¸ Hook hata ({hook}): {fn.__name__}: {e}")

# ----------------------- Orchestrator -----------------------

class Orchestrator:
    def __init__(self):
        self.states: Dict[str, SymbolState] = {s: SymbolState() for s in SYMBOLS}
        self.bus = PluginBus()
        self.bus.load_project_plugins()
        self._mbuf: Dict[str, List[Tick]] = defaultdict(list)

    def _update_features(self, sym: str, px: float):
        st = self.states[sym]
        st.last_price = px
        f = {}
        f["ema_fast"] = st.ema_fast.update(px)
        f["ema_slow"] = st.ema_slow.update(px)
        f["rsi14"] = st.rsi14.update(px)
        f["vol60"] = st.vol60.update(px)
        st.last_features = {k: v for k, v in f.items() if v is not None}

    def _ingest_trade(self, sym: str, data: dict):
        px = float(data["p"]); q = float(data["q"])
        t = Tick(
            symbol=sym, kind="trade",
            server_ts=int(data.get("E") or data.get("T") or 0),
            local_ns=time.perf_counter_ns(),
            price=px, qty=q
        )
        self.states[sym].trades.append(t)
        self._update_features(sym, px)
        self._mbuf[sym].append(t)

    def _ingest_book(self, sym: str, data: dict):
        bid = float(data["b"]); ask = float(data["a"])
        mid = (bid + ask) / 2.0
        t = Tick(
            symbol=sym, kind="book",
            server_ts=int(data.get("E") or 0),
            local_ns=time.perf_counter_ns(),
            price=mid, bid=bid, ask=ask
        )
        st = self.states[sym]
        st.books.append(t)
        st.last_bid, st.last_ask = bid, ask
        self._update_features(sym, mid)
        self._mbuf[sym].append(t)

    async def _microbatch_loop(self):
        # Belirli aralÄ±klarla biriken mikro-tikleri iÅŸleyip modÃ¼llere iletir
        while True:
            await asyncio.sleep(MICRO_BATCH_MS / 1000.0)
            now_ns = time.perf_counter_ns()
            for sym, buf in list(self._mbuf.items()):
                if not buf:
                    continue
                batch = buf[:]
                self._mbuf[sym].clear()
                # Hook: on_microbatch(symbol, batch, state, features)
                await self.bus.emit("on_microbatch", sym, batch, self.states[sym], dict(self.states[sym].last_features))

    async def _snapshot_loop(self):
        while True:
            await asyncio.sleep(SNAPSHOT_SEC)
            # Periodik Ã¶zet: modÃ¼llere son durum ver
            for sym, st in self.states.items():
                snap = {
                    "price": st.last_price,
                    "bid": st.last_bid,
                    "ask": st.last_ask,
                    "features": dict(st.last_features)
                }
                await self.bus.emit("on_snapshot", sym, snap, st)

    async def _ws_loop(self):
        # Combined streams
        streams = "/".join(STREAMS)
        url = f"{WS_BASE}?streams={streams}"
        print(f"ðŸŒ WS baÄŸlanÄ±yor: {url}")
        # Otomatik reconnect
        while True:
            try:
                timeout = aiohttp.ClientTimeout(total=None, sock_read=120)
                async with aiohttp.ClientSession(timeout=timeout) as sess:
                    async with sess.ws_connect(url, heartbeat=30) as ws:
                        print("âœ… WS baÄŸlÄ±.")
                        async for msg in ws:
                            if msg.type == aiohttp.WSMsgType.TEXT:
                                try:
                                    payload = json.loads(msg.data)
                                    stream = payload.get("stream", "")
                                    data = payload.get("data", {})
                                    if not stream or not data:
                                        continue
                                    # stream: "btcusdt@aggTrade" / "btcusdt@bookTicker"
                                    sname, skind = stream.split("@", 1)
                                    sym = sname.upper()
                                    if skind == "aggTrade":
                                        self._ingest_trade(sym, data)
                                        await self.bus.emit("on_tick", sym, "trade", data)
                                    elif skind == "bookTicker":
                                        self._ingest_book(sym, data)
                                        await self.bus.emit("on_tick", sym, "book", data)
                                except Exception as e:
                                    if PRINT_HOOK_ERR:
                                        print("âš ï¸ WS parse hata:", e)
                            elif msg.type == aiohttp.WSMsgType.ERROR:
                                print("âš ï¸ WS hata:", msg)
                                break
            except Exception as e:
                print("âš ï¸ WS baÄŸlantÄ± hatasÄ±, yeniden dene:", e)
                await asyncio.sleep(1.0)

    async def run(self):
        tasks = [
            asyncio.create_task(self._ws_loop()),
            asyncio.create_task(self._microbatch_loop()),
            asyncio.create_task(self._snapshot_loop())
        ]
        await asyncio.gather(*tasks)

# ----------------------- Basit dahili plugin (Ã¶rnek) -----------------------

def register():
    # Bu dosya da plugin gibi basit bir metrik yazsÄ±n (Ã¶rnek)
    def on_snapshot(symbol: str, snap: dict, state: SymbolState):
        f = snap["features"]
        ema_ok = ("ema_fast" in f and "ema_slow" in f)
        if ema_ok:
            trend = "UP" if f["ema_fast"] > f["ema_slow"] else "DOWN"
        else:
            trend = "NA"
        print(f"ðŸ“Š {symbol} mid={snap['price']:.4f} trend={trend} rsi={f.get('rsi14')} vol={f.get('vol60')}")

    return {
        "on_snapshot": on_snapshot
    }

# ----------------------- Main -----------------------

async def main():
    print(f"Env: {'TESTNET' if USE_TESTNET else 'MAINNET'}  Symbols: {', '.join(SYMBOLS)}")
    orch = Orchestrator()
    await orch.run()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("ðŸ›‘ Durduruldu")

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\execution\position_manager.py
# position_manager.py
from __future__ import annotations
from decimal import Decimal
from typing import Any, Dict, Optional
import time
import uuid
import logging

from ex_filters import SymbolFilters  # Ã¶nceki yardÄ±mcÄ± modÃ¼l
# Not: binance client'Ä±nÄ± dÄ±ÅŸarÄ±dan veriyoruz (dependency injection)

log = logging.getLogger("position_manager")

class PositionManager:
    def __init__(self, client, risk_mgr, filters: SymbolFilters, max_retries: int = 3):
        self.client = client
        self.risk = risk_mgr
        self.filters = filters
        self.max_retries = max_retries

    # â€”â€”â€”â€”â€” PUBLIC API â€”â€”â€”â€”â€” #

    def place_limit(self, symbol: str, side: str, price: float, qty: float,
                    tif: str = "GTC", client_order_id: Optional[str] = None) -> Dict[str, Any]:
        """Limit emri: fiyat/lot yuvarlama + minNotional kontrol + risk onayÄ± + retry."""
        self.filters.refresh_if_stale(self.client)
        clean = self.filters.conform_order(symbol, side, "LIMIT", price, qty)

        self._risk_guard(symbol, side, clean["price"], clean["quantity"])
        return self._submit_with_retry({
            "symbol": symbol,
            "side": side,
            "type": "LIMIT",
            "timeInForce": tif,
            "quantity": clean["quantity"],
            "price": f'{clean["price"]:.10f}',
            "newClientOrderId": client_order_id or self._cid("LIM")
        })

    def place_market(self, symbol: str, side: str, qty: float,
                     last_price: Optional[float] = None,
                     client_order_id: Optional[str] = None) -> Dict[str, Any]:
        """Market emri: lot yuvarlama + minNotional (last_price ile) + risk onayÄ± + retry."""
        self.filters.refresh_if_stale(self.client)
        clean = self.filters.conform_order(symbol, side, "MARKET", None, qty, last_price=last_price)

        # Marketâ€™te fiyat yok, riskte last_price kullan
        use_price = float(last_price or self._get_last_price(symbol))
        self._risk_guard(symbol, side, use_price, clean["quantity"])

        # Not: SPOT iÃ§in base quantity kullanÄ±yoruz. (quoteOrderQty kullanacaksan ayrÄ±ca ekle)
        return self._submit_with_retry({
            "symbol": symbol,
            "side": side,
            "type": "MARKET",
            "quantity": clean["quantity"],
            "newClientOrderId": client_order_id or self._cid("MKT")
        })

    def cancel(self, symbol: str, order_id: Optional[int] = None,
               client_order_id: Optional[str] = None):
        return self.client.cancel_order(symbol=symbol, orderId=order_id,
                                        origClientOrderId=client_order_id)

    def watch_until_filled(self, symbol: str, order_id: int, timeout_s: int = 30,
                           poll_ms: int = 500) -> Dict[str, Any]:
        """Basit watcher: kÄ±smi/filled durumunu takip eder."""
        start = time.time()
        while True:
            o = self.client.get_order(symbol=symbol, orderId=order_id)
            status = o.get("status")
            if status in ("FILLED", "CANCELED", "REJECTED", "EXPIRED"):
                return o
            if time.time() - start > timeout_s:
                return o  # zaman aÅŸÄ±mÄ±nda mevcut durumu dÃ¶ndÃ¼r
            time.sleep(poll_ms / 1000)

    # â€”â€”â€”â€”â€” INTERNALS â€”â€”â€”â€”â€” #

    def _risk_guard(self, symbol: str, side: str, price: float, qty: float):
        """Risk yÃ¶netiÅŸimi: tek noktadan geÃ§sin (pozisyon limitleri, max % sermaye, PnL stop, vb.)."""
        self.risk.assert_order_allowed(symbol=symbol, side=side, price=price, qty=qty)

    def _get_last_price(self, symbol: str) -> float:
        return float(self.client.get_symbol_ticker(symbol=symbol)["price"])

    def _cid(self, prefix: str) -> str:
        return f"{prefix}-{int(time.time()*1000)}-{uuid.uuid4().hex[:6]}"

    def _submit_with_retry(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """429/rate limit ve geÃ§ici aÄŸ hatalarÄ± iÃ§in basit retry + backoff."""
        delay = 0.3
        for attempt in range(1, self.max_retries + 1):
            try:
                # create_order param isimleri Binance Python SDKâ€™n ile uyumlu olmalÄ±
                resp = self.client.create_order(**params)
                log.info("order_submitted ok %s", {k: params[k] for k in ("symbol", "side", "type")})
                return resp
            except Exception as e:
                msg = str(e)
                log.warning("submit attempt %s failed: %s", attempt, msg)
                if "429" in msg or "Too many requests" in msg or "recvWindow" in msg:
                    time.sleep(delay)
                    delay *= 2
                    continue
                # filtre/risk/validation gibi kesin hatalarda retry etme
                raise
        # buraya normalde dÃ¼ÅŸmez
        raise RuntimeError("order submission failed after retries")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\execution\scheduler_pro.py
# scheduler_pro.py (1 saniyelik yÃ¼ksek frekanslÄ± stratejik dÃ¶ngÃ¼)
import time
from datetime import datetime
from kiripto_nova.data.pipelines.data_loader import load_binance_data
from multi_strategy import MultiStrategyEngine
from trade_executor import execute_trade
from kiripto_nova.risk.risk_manager import calculate_position_size, calculate_stop_loss, calculate_take_profit
from kiripto_nova.apps.telegram_alert import notify_signal, notify_trade
from logger import log_trade, log_error

# KullanÄ±cÄ± ayarlarÄ±
SYMBOL = "DOGE/USDT"
TIMEFRAME = "1m"
BALANCE = 1000
RISK = 0.01
STOP_LOSS_PCT = 0.01  # daha dar SL (1%)
REWARD_RATIO = 2
FREQ_SECONDS = 1  # dÃ¶ngÃ¼ sÄ±klÄ±ÄŸÄ± (her 1 saniyede kontrol)

LAST_SIGNAL = None


def run_cycle():
    global LAST_SIGNAL
    try:
        now = datetime.now().strftime('%H:%M:%S')
        print(f"â±ï¸ [{now}] Tarama baÅŸlÄ±yor...")

        df = load_binance_data(SYMBOL, TIMEFRAME, limit=200)
        engine = MultiStrategyEngine(df)
        signal = engine.evaluate()

        # AynÄ± sinyali tekrar etme
        if signal == LAST_SIGNAL:
            print("ðŸ” Sinyal tekrarÄ±, iÅŸlem yok.")
            return

        notify_signal(signal, SYMBOL)
        LAST_SIGNAL = signal

        if signal in ["BUY", "SELL"]:
            direction = "long" if signal == "BUY" else "short"
            entry = df['close'].iloc[-1]
            qty = calculate_position_size(BALANCE, RISK, STOP_LOSS_PCT)
            sl = calculate_stop_loss(entry, STOP_LOSS_PCT, direction)
            tp = calculate_take_profit(entry, REWARD_RATIO, STOP_LOSS_PCT, direction)

            result = execute_trade(SYMBOL, side="buy" if direction == "long" else "sell", amount=qty)
            log_trade(signal, SYMBOL, qty, entry, sl, tp)
            notify_trade(signal, SYMBOL, qty, entry, sl, tp)
        else:
            print("ðŸ” Sinyal yok veya nÃ¶tr.")

    except Exception as e:
        log_error(e)


if __name__ == "__main__":
    while True:
        run_cycle()
        time.sleep(FREQ_SECONDS)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\indicators\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\network\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\risk\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\risk\risk_engine.py
def calculate_risk(current_price, max_risk_pct=2, take_profit_pct=5, stop_loss_pct=3):
    quantity = 0.01  # Ã¶rnek sabit hacim
    stop_loss = current_price * (1 - stop_loss_pct / 100)
    take_profit = current_price * (1 + take_profit_pct / 100)

    return {
        "stop_loss": round(stop_loss, 2),
        "take_profit": round(take_profit, 2),
        "quantity": quantity
    }


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\risk\risk_grid_intelligence.py
def analyze_risk_grid(contract_metadata):
    risks = []
    if "oracle" in contract_metadata and not contract_metadata['oracle'].get('redundancy'):
        risks.append("ðŸ§¨ ZayÄ±f Oracle baÄŸÄ±mlÄ±lÄ±ÄŸÄ±")

    if "admin_keys" in contract_metadata and contract_metadata['admin_keys'] < 3:
        risks.append("ðŸ—ï¸ Yetersiz admin anahtar sayÄ±sÄ±")

    if "emergency_switch" not in contract_metadata:
        risks.append("ðŸš« Acil durum refleksi eksik")

    return risks if risks else ["âœ… Kritik savunma refleksleri aktif."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\risk\risk_guard.py
# risk_guard.py
# GÃ¼nlÃ¼k max drawdown kontrolÃ¼. Limit aÅŸÄ±lÄ±rsa:
#  - TÃ¼m bekleyen emirleri iptal eder + tÃ¼m pozisyonlarÄ± kapatÄ±r (panic flatten)
#  - Trading'i belirli sÃ¼re kilitler (cooldown).
#
# Ã‡alÄ±ÅŸma modlarÄ±:
#   python risk_guard.py --check     -> sadece durum yazdÄ±r
#   python risk_guard.py --enforce   -> kontrol et, aÅŸÄ±m varsa FLATTEN + kilit
#   python risk_guard.py --unlock    -> kilidi kaldÄ±r

from __future__ import annotations
import os, json, time, argparse
from decimal import Decimal
from datetime import datetime, timedelta
try:
    from zoneinfo import ZoneInfo
except Exception:
    ZoneInfo = None

from dotenv import load_dotenv

# Bot iÃ§indeki hazÄ±r client + yardÄ±mcÄ±larÄ± kullanÄ±yoruz
from bot import client, tg, retry
# Panic flattenâ€™i (daha Ã¶nce verdiÄŸim) kullanÄ±yoruz
try:
    from panic_flatten import flatten
except Exception:
    flatten = None

STATE_DIR = "state"
LOCK_FILE = os.path.join(STATE_DIR, "drawdown_lock.json")

def _bool(v: str, default=False) -> bool:
    return (v or str(default)).strip().lower() in ("1","true","yes","on")

def _dec(x) -> Decimal:
    try: return Decimal(str(x))
    except: return Decimal(0)

def ensure_state_dir():
    os.makedirs(STATE_DIR, exist_ok=True)

def now_tz():
    tzname = os.getenv("TIMEZONE", "Europe/Zurich")
    if ZoneInfo:
        return datetime.now(ZoneInfo(tzname))
    return datetime.now()

def today_range_ms():
    t = now_tz()
    start = t.replace(hour=0, minute=0, second=0, microsecond=0)
    end = start + timedelta(days=1)
    return int(start.timestamp()*1000), int(end.timestamp()*1000), start.strftime("%Y-%m-%d")

def wallet_and_available():
    acct = retry(client.futures_account, desc="futures_account")
    wallet = _dec(acct.get("totalWalletBalance", "0"))
    # available
    avail = Decimal(0)
    try:
        bals = retry(client.futures_account_balance, desc="futures_account_balance")
        usdt = next((b for b in bals if b.get("asset")=="USDT"), None)
        if usdt: avail = _dec(usdt.get("availableBalance","0"))
    except: pass
    return wallet, avail

def income_sum_today():
    start, end, _ = today_range_ms()
    cursor = start
    s = Decimal(0)
    while True:
        page = retry(client.futures_income_history, startTime=cursor, endTime=end, limit=1000, desc="income_history")
        if not page: break
        for r in page:
            s += _dec(r.get("income","0"))
        if len(page) < 1000: break
        cursor = max(int(r["time"]) for r in page) + 1
        time.sleep(0.05)
    return s

def lock_for_minutes(mins: int, reason: str):
    ensure_state_dir()
    until = int((now_tz() + timedelta(minutes=mins)).timestamp())
    with open(LOCK_FILE, "w", encoding="utf-8") as f:
        json.dump({"lock_until": until, "reason": reason}, f)
    return until

def is_locked():
    try:
        with open(LOCK_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        return int(data.get("lock_until", 0)) > int(now_tz().timestamp()), data
    except:
        return False, {}

def unlock():
    try:
        os.remove(LOCK_FILE)
        return True
    except:
        return False

def trading_allowed() -> bool:
    locked, _ = is_locked()
    return not locked

def enforce():
    # parametreler
    dd_pct = float(os.getenv("MAX_DAILY_DRAWDOWN", "0.03") or 0.03)
    cooldown = int(os.getenv("GUARD_COOLDOWN_MIN", "120") or 120)

    # cÃ¼zdan & income
    wallet, avail = wallet_and_available()
    inc = income_sum_today()  # net realized (funding/fee dahil)

    limit_usdt = Decimal(wallet) * Decimal(dd_pct)
    breached = inc <= -limit_usdt

    # Durum raporu
    msg = (
        f"ðŸ›¡ï¸ Guard check | Wallet:{wallet:.2f} Avail:{avail:.2f} | "
        f"Realized(today):{inc:+.2f} | Limit:{-limit_usdt:.2f}"
    )
    print(msg)

    if not breached:
        tg(f"{msg} â†’ âœ… Limit aÅŸÄ±lmadÄ±.")
        return

    # Kilitli mi?
    locked, data = is_locked()
    if locked:
        until_ts = data.get("lock_until")
        eta = datetime.fromtimestamp(until_ts).strftime("%H:%M")
        tg(f"{msg} â†’ â—AÅŸÄ±m var ama zaten kilitli (unlock @ {eta}).")
        return

    # AÅžIM â†’ Flatten + kilit
    tg(f"{msg} â†’ ðŸš¨ AÅžIM! TÃ¼m pozisyonlar kapatÄ±lÄ±yor; bekleyen emirler iptal.")
    if flatten:
        try:
            flatten()  # hepsini kapat
        except Exception as e:
            tg(f"âš ï¸ Flatten sÄ±rasÄ±nda uyarÄ±: {e}")

    until_ts = lock_for_minutes(cooldown, reason="daily_drawdown")
    eta = datetime.fromtimestamp(until_ts).strftime("%H:%M")
    tg(f"â¸ï¸ Trading {cooldown} dk kilitlendi. (unlock @ {eta})")

if __name__ == "__main__":
    load_dotenv()
    ap = argparse.ArgumentParser()
    ap.add_argument("--check", action="store_true", help="Sadece durumu yazdÄ±r")
    ap.add_argument("--enforce", action="store_true", help="Kontrol et, aÅŸÄ±lmÄ±ÅŸsa FLATTEN + kilit")
    ap.add_argument("--unlock", action="store_true", help="Kilit dosyasÄ±nÄ± sil")
    args = ap.parse_args()

    if args.unlock:
        ok = unlock()
        print("ðŸ”“ Unlock:", "OK" if ok else "yoktu")
    elif args.check:
        w, a = wallet_and_available()
        inc = income_sum_today()
        locked, data = is_locked()
        print(f"Wallet:{w:.2f} Avail:{a:.2f} | Realized(today):{inc:+.2f}")
        print("Locked:", locked, data)
    else:
        # varsayÄ±lan enforce gibi Ã§alÄ±ÅŸsÄ±n istersen:
        if args.enforce or True:
            enforce()
# --- Windows konsolda UTF-8 yazdÄ±rma dÃ¼zeltmesi ---
import sys, os
if os.name == "nt":
    try:
        sys.stdout.reconfigure(encoding="utf-8", errors="replace")
        sys.stderr.reconfigure(encoding="utf-8", errors="replace")
    except Exception:
        pass
# ---------------------------------------------------


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\risk\risk_manager.py
# risk_manager.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, Any, Optional
import math
import time

# --- Basit portfÃ¶y arayÃ¼zÃ¼ (sen kendi implementasyonunu geÃ§ebilirsin) ---
class Portfolio:
    def get_equity_usdt(self) -> float: ...
    def get_open_exposure(self, symbol: str) -> float: ...
    def get_open_positions_count(self) -> int: ...
    def get_symbol_price(self, symbol: str) -> float: ...

# --- Konfig ve durum ---
@dataclass
class RiskConfig:
    max_capital_pct_per_trade: float = 0.02          # iÅŸlem baÅŸÄ±na sermaye %
    max_daily_loss_pct: float = 0.04                 # gÃ¼nlÃ¼k max dÃ¼ÅŸÃ¼ÅŸ %
    max_open_positions: int = 8                      # aynÄ± anda aÃ§Ä±k pozisyon limiti
    max_symbol_exposure_pct: float = 0.25            # sembol baÅŸÄ± toplam maruziyet %
    min_notional_usdt: float = 10.0                  # borsa MIN_NOTIONAL ile uyumlu tut
    slippage_buffer_pct: float = 0.001               # sizing sÄ±rasÄ±nda gÃ¼venlik tamponu
    hard_qty_floor: float = 1e-8                     # yuvarlanÄ±nca 0 olmasÄ±n diye taban

class RiskViolation(Exception): pass

class RiskManager:
    def __init__(self, portfolio: Portfolio, cfg: Optional[RiskConfig] = None):
        self.pf = portfolio
        self.cfg = cfg or RiskConfig()
        # gÃ¼nlÃ¼k PnL takibi iÃ§in Ã§ok basit sayaÃ§ (daha iyisi: gerÃ§ek PnL defteri)
        self._day = self._day_key()
        self._equity_start = self.pf.get_equity_usdt()
        self._realized_pnl = 0.0

    # ---------- Public API ----------
    def suggest_qty(self, symbol: str, price: float, max_capital_pct: Optional[float],
                    side: str, equity: Optional[float] = None) -> float:
        """
        Harcanacak USDT = equity * min(config.max_capital_pct_per_trade, max_capital_pct)
        qty = usdt / price, slippage buffer ile aÅŸaÄŸÄ± yÃ¶nlÃ¼ ayarlanÄ±r.
        """
        eq = float(equity if equity is not None else self.pf.get_equity_usdt())
        cap_pct = min(
            self.cfg.max_capital_pct_per_trade,
            float(max_capital_pct if max_capital_pct is not None else self.cfg.max_capital_pct_per_trade)
        )
        spend_usdt = max(eq * cap_pct, 0.0)
        spend_usdt *= (1.0 - self.cfg.slippage_buffer_pct)

        # min notional gÃ¼venliÄŸi
        if spend_usdt < self.cfg.min_notional_usdt:
            # yine de min notional kadar deneyelim, equity yetmiyorsa 0 dÃ¶ner
            spend_usdt = min(self.cfg.min_notional_usdt, eq * cap_pct)

        qty = spend_usdt / max(price, 1e-12)
        qty = max(qty, self.cfg.hard_qty_floor)
        return float(qty)

    def assert_order_allowed(self, symbol: str, side: str, price: float, qty: float):
        """
        Emirden Ã¶nce tÃ¼m risk kurallarÄ±nÄ± doÄŸrular. Ä°hlalde RiskViolation fÄ±rlatÄ±r.
        """
        self._roll_daily_if_needed()

        eq = self.pf.get_equity_usdt()
        notional = price * qty

        # 1) Ä°ÅŸlem baÅŸÄ± sermaye yÃ¼zdesi
        max_per_trade_usdt = eq * self.cfg.max_capital_pct_per_trade
        if notional > max_per_trade_usdt * 1.01:  # hafif tolerans
            raise RiskViolation(f"Order notional {notional:.2f} > per-trade cap {max_per_trade_usdt:.2f}")

        # 2) GÃ¼nlÃ¼k zarar limiti
        max_daily_loss_usdt = self._equity_start * self.cfg.max_daily_loss_pct
        if self._realized_pnl <= -max_daily_loss_usdt:
            raise RiskViolation(f"Daily loss limit reached: {self._realized_pnl:.2f} USDT")

        # 3) AÃ§Ä±k pozisyon sayÄ±sÄ±
        if self.pf.get_open_positions_count() >= self.cfg.max_open_positions:
            raise RiskViolation("Too many open positions")

        # 4) Sembol baÅŸÄ± maruziyet limiti
        symbol_exposure = self.pf.get_open_exposure(symbol) + notional
        if symbol_exposure > eq * self.cfg.max_symbol_exposure_pct:
            raise RiskViolation(f"Symbol exposure {symbol_exposure:.2f} exceeds cap")

        # 5) Borsa min notional eÅŸiÄŸi (ek gÃ¼venlik)
        if notional < self.cfg.min_notional_usdt:
            raise RiskViolation(f"Notional {notional:.2f} < min_notional {self.cfg.min_notional_usdt:.2f}")

        # (opsiyonel) 6) Trend filtresi / saat filtresi / haber filtresi gibi ek kontrolleri buraya ekleyebilirsin.

    # ---------- GÃ¼n sonu & PnL muhasebesi ----------
    def on_fill(self, symbol: str, side: str, fill_price: float, qty: float,
                commission_usdt: float = 0.0, realized_pnl_usdt: float = 0.0):
        """
        Pozisyon kapanÄ±ÅŸlarÄ±nda veya kÄ±smi kapanÄ±ÅŸlarda Ã§aÄŸÄ±r.
        realized_pnl_usdt borsadan/hesaptan gelen net PnL olmalÄ± (fee dahil).
        """
        self._roll_daily_if_needed()
        self._realized_pnl += float(realized_pnl_usdt) - float(commission_usdt)

    # ---------- Helpers ----------
    def _day_key(self) -> str:
        return time.strftime("%Y-%m-%d", time.gmtime())  # UTC gÃ¼n

    def _roll_daily_if_needed(self):
        today = self._day_key()
        if today != self._day:
            # yeni gÃ¼ne geÃ§tik: baÅŸlangÄ±Ã§ equity'yi yenile, PnL sayaÃ§larÄ±nÄ± sÄ±fÄ±rla
            self._day = today
            self._equity_start = self.pf.get_equity_usdt()
            self._realized_pnl = 0.0


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\get_news.py
import os
import requests
from dotenv import load_dotenv
from datetime import datetime, timedelta
from textblob import TextBlob
import csv

load_dotenv()
GNEWS_API_KEY = os.getenv("GNEWS_API_KEY")

# ðŸ’¬ DUYGU ANALÄ°ZÄ° FONKSÄ°YONU
def analyze_sentiment(text):
    blob = TextBlob(text)
    polarity = blob.sentiment.polarity
    if polarity > 0.2:
        return "positive"
    elif polarity < -0.2:
        return "negative"
    else:
        return "neutral"

# â± YENÄ° HABER MÄ° KONTROLÃœ
def is_recent(published_at):
    try:
        pub_date = datetime.strptime(published_at, "%Y-%m-%dT%H:%M:%SZ")
        return datetime.utcnow() - pub_date < timedelta(hours=12)
    except:
        return False

# ðŸ“° HABERLERÄ° Ã‡EKME FONKSÄ°YONU
def get_crypto_news():
    url = "https://gnews.io/api/v4/search"
    params = {
        "q": "crypto OR bitcoin OR ethereum",
        "lang": "en",
        "max": 10,
        "apikey": GNEWS_API_KEY
    }

    response = requests.get(url, params=params)
    if response.status_code != 200:
        print(f"â›” GNews eriÅŸim hatasÄ±: {response.status_code}")
        return []

    data = response.json()
    articles = []

    for article in data.get("articles", []):
        title = article.get("title", "No Title")
        description = article.get("description", "")
        published_at = article.get("publishedAt", "")
        source = article.get("source", {}).get("name", "Unknown")
        sentiment = analyze_sentiment(description)
        recent = is_recent(published_at)

        articles.append({
            "title": title,
            "description": description,
            "publishedAt": published_at,
            "source": source,
            "sentiment": sentiment,
            "is_recent": recent
        })

    return articles

# ðŸ“ CSVâ€™YE KAYDETME FONKSÄ°YONU
def export_to_csv(articles, filename="crypto_news.csv"):
    if not articles:
        print("ðŸ“­ KayÄ±t edilecek haber yok.")
        return
    keys = articles[0].keys()
    with open(filename, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=keys)
        writer.writeheader()
        writer.writerows(articles)
    print(f"ðŸ“„ Haberler {filename} dosyasÄ±na yazÄ±ldÄ±.")

# ðŸŽ¯ ANA AKIÅž
if __name__ == "__main__":
    news_data = get_crypto_news()
    export_to_csv(news_data)
for article in data.get("articles", []):
    # ... Ã¶nceki alanlar ...
    sentiment = analyze_sentiment(description)
    recent = is_recent(published_at)
    score = signal_score(sentiment, recent)

    articles.append({
        "title": title,
        "description": description,
        "publishedAt": published_at,
        "source": source,
        "sentiment": sentiment,
        "is_recent": recent,
        "signal_score": score
    })
# DUYGU ANALÄ°ZÄ° FONKSÄ°YONU
def analyze_sentiment(text):
    ...

# HABER YENÄ° MÄ°? FÄ°LTRESÄ°
def is_recent(published_at):
    ...

# ðŸ”¥ SÄ°NYAL SKORU FONKSÄ°YONU â€” Buraya ekle!
def signal_score(sentiment, is_recent):
    score = 0
    if sentiment == "positive":
        score += 2
    elif sentiment == "negative":
        score -= 2
    if is_recent:
        score += 1
    return score



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\news_data.py
from newsapi import NewsApiClient

newsapi = NewsApiClient(api_key='YOUR_NEWS_API_KEY')

def get_crypto_news():
    articles = newsapi.get_everything(q='bitcoin OR ethereum', language='en', sort_by='publishedAt')
    return [a['title'] for a in articles['articles'][:5]]
from transformers import pipeline

classifier = pipeline("sentiment-analysis")

def analyze_sentiment(news_text):
    result = classifier(news_text[:512])
    return result[0]['label'], result[0]['score']


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\sentiment_matrix_orchestrator.py
def build_sentiment_matrix(tasks, feelings):
    matrix = []
    for task in tasks:
        emotion = feelings.get(task["id"], "ðŸ” Belirsiz His")
        entry = f"ðŸ§­ GÃ¶rev: {task['mission']} | ðŸŽ­ Duygu: {emotion}"
        matrix.append(entry)
    return matrix



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_engine.py
import pandas as pd
import pandas_ta as ta

class SignalEngine:
    def __init__(self, data: pd.DataFrame):
        self.df = data.copy()

    def calculate_indicators(self):
        self.df.ta.rsi(length=14, append=True)
        self.df.ta.macd(append=True)
        self.df.ta.ema(length=50, append=True)
        self.df.ta.ema(length=200, append=True)
        self.df.ta.bbands(length=20, append=True)
        self.df.ta.stochrsi(append=True)

    def generate_signal(self):
        self.calculate_indicators()

        latest = self.df.iloc[-1]
        signal = "NEUTRAL"

        rsi = latest["RSI_14"]
        macd = latest["MACD_12_26_9"]
        signal_line = latest["MACDs_12_26_9"]
        close_price = latest["close"]
        ema50 = latest["EMA_50"]
        ema200 = latest["EMA_200"]

        # Basit strateji Ã¶rneÄŸi
        if (
            rsi < 30
            and macd > signal_line
            and close_price > ema50 > ema200
        ):
            signal = "BUY"

        elif (
            rsi > 70
            and macd < signal_line
            and close_price < ema50 < ema200
        ):
            signal = "SELL"

        return signal

    def get_dataframe(self):
        return self.df
# main.py
from kiripto_nova.data.pipelines.data_loader import load_binance_data
from kiripto_nova.signals.signal_engine import SignalEngine

symbol = "DOGE/USDT"
timeframe = "15m"

# 1. Binance'ten veri al
df = load_binance_data(symbol, timeframe)

# 2. Sinyal motorunu baÅŸlat
engine = SignalEngine(df)
signal = engine.generate_signal()

# 3. Sonucu yazdÄ±r
print("Gelen Sinyal:", signal)

# 4. (Opsiyonel) GÃ¶stergeli veri Ã§erÃ§evesini gÃ¶rmek istersen:
# enriched_df = engine.get_dataframe()
# print(enriched_df.tail())


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_evaluator.py
from datetime import datetime, timedelta

def get_price_data(ticker, signal_time):
    # Ã–rnek veri fonksiyonu â€” API baÄŸlantÄ±sÄ± ile alÄ±nmalÄ±
    return {
        "day1": 102.5,
        "day3": 106.3,
        "day7": 98.4,
        "baseline": 100.0
    }

def price_diff(prices, day):
    return round((prices[f"day{day}"] - prices["baseline"]) / prices["baseline"] * 100, 2)

def evaluate_signal_effect(signal_time, ticker):
    prices = get_price_data(ticker, signal_time)
    return {
        "day1_change": price_diff(prices, 1),
        "day3_change": price_diff(prices, 3),
        "day7_change": price_diff(prices, 7),
        "successful": any(price_diff(prices, d) > 5 for d in [1,3,7])
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_loop.py
# signal_loop.py
import os
import time
from decimal import Decimal, ROUND_DOWN

from dotenv import load_dotenv
load_dotenv()

from bot import (
    client, USE_TESTNET,
    bracket_market, apply_account_settings,
    round_qty, get_equity, get_filters
)

try:
    import notify as nt
except Exception:
    nt = None

# ====== Parametreler ======
SYMBOL      = os.getenv("SYMBOLS", "BTCUSDT").split(",")[0].strip().upper()
INTERVAL    = os.getenv("TECH_INTERVAL", "1m").strip()
EMA_FAST    = int(os.getenv("EMA_FAST", "9"))
EMA_SLOW    = int(os.getenv("EMA_SLOW", "21"))
COOLDOWN    = int(os.getenv("COOLDOWN_BARS", "3"))
SL_PCT      = float(os.getenv("SL_PCT", "0.01"))
TP_PCT      = float(os.getenv("TP_PCT", "0.02"))
TRAIL_PCT   = float(os.getenv("TRAIL_PCT", "0.0"))
CAP_PCT     = float(os.getenv("MAX_CAPITAL_PCT_PER_TRADE", "0.02"))

def ema_series(values, length):
    k = 2 / (length + 1)
    out, e = [], None
    for v in values:
        e = v if e is None else (v * k + e * (1 - k))
        out.append(e)
    return out

def last_closed_klines(symbol: str, interval: str, need: int):
    # fazladan al, son (aÃ§Ä±k) mumu at
    k = client.futures_klines(symbol=symbol, interval=interval, limit=max(need + 3, 50))
    if len(k) < 3:
        return []
    return k[:-1]  # son mumu (hala oluÅŸuyor olabilir) Ã§Ä±kar

def side_has_open(symbol: str, want_side: str) -> bool:
    # want_side: "BUY" -> LONG, "SELL" -> SHORT
    desired = "LONG" if want_side.upper() == "BUY" else "SHORT"
    pos = client.futures_position_information(symbol=symbol)
    for p in pos:
        if p.get("positionSide") == desired and float(p.get("positionAmt", 0)) != 0.0:
            return True
    return False

def calc_qty(symbol: str, cap_pct: float) -> float:
    eq = get_equity()
    last = float(client.futures_symbol_ticker(symbol=symbol)["price"])
    raw = (eq * cap_pct) / last
    q = round_qty(symbol, raw)
    # en az step kadar olsun
    step = get_filters(symbol)["step"]
    if q < step:
        q = float(Decimal(str(step)).quantize(Decimal(str(step)), rounding=ROUND_DOWN))
    return q

def push(msg: str):
    print(msg)
    if nt and nt.tg_enabled():
        try: nt.send(msg)
        except: pass

def main():
    push(f"ðŸ” EMA Cross loop started | {SYMBOL} | {INTERVAL} | TESTNET={USE_TESTNET}")
    apply_account_settings(SYMBOL)

    last_bar_open_time = None
    cooldown_left = 0
    last_signal = None  # "BUY" / "SELL" / None

    while True:
        try:
            closed = last_closed_klines(SYMBOL, INTERVAL, need=max(EMA_SLOW, EMA_FAST) + 5)
            if len(closed) < EMA_SLOW + 2:
                time.sleep(2); continue

            # yeni kapanmÄ±ÅŸ bar?
            cur_open = closed[-1][0]  # open_time
            if cur_open == last_bar_open_time:
                time.sleep(2); continue  # aynÄ± bar, bekle
            last_bar_open_time = cur_open

            closes = [float(x[4]) for x in closed]  # close fiyatlarÄ±
            f = ema_series(closes, EMA_FAST)
            s = ema_series(closes, EMA_SLOW)

            f_prev, f_now = f[-2], f[-1]
            s_prev, s_now = s[-2], s[-1]

            signal = None
            if f_prev < s_prev and f_now > s_now:
                signal = "BUY"
            elif f_prev > s_prev and f_now < s_now:
                signal = "SELL"

            # cooldown
            if cooldown_left > 0:
                push(f"â³ cooldown {cooldown_left} barâ€¦ (son sinyal: {last_signal})")
                cooldown_left -= 1
                continue

            if signal:
                # aynÄ± yÃ¶nden tekrarÄ± engelle
                if signal == last_signal:
                    push(f"â†”ï¸ aynÄ± sinyal tekrar ({signal}), bekliyorum.")
                    continue
                # aÃ§Ä±k pozisyon varken aynÄ± yÃ¶ne girmeyelim
                if side_has_open(SYMBOL, signal):
                    push(f"ðŸ§¯ {signal} yÃ¶nÃ¼ zaten aÃ§Ä±k pozisyona sahip, atlÄ±yorum.")
                    last_signal = signal
                    cooldown_left = COOLDOWN
                    continue

                qty = calc_qty(SYMBOL, CAP_PCT)
                push(f"ðŸ“ˆ Sinyal {signal} | qtyâ‰ˆ{qty}")
                try:
                    res = bracket_market(
                        sym=SYMBOL,
                        side=signal,
                        qty=qty,
                        sl_pct=max(SL_PCT, 0.0),
                        tp_pct=max(TP_PCT, 0.0),
                        trail_pct=max(TRAIL_PCT, 0.0),
                    )
                    if res:
                        ep = res.get("entry_price")
                        push(f"âœ… Emir gÃ¶nderildi: {signal} {SYMBOL} qty={qty} EPâ‰ˆ{ep:.2f}")
                except Exception as e:
                    push(f"âŒ Emir hatasÄ±: {e}")

                last_signal = signal
                cooldown_left = COOLDOWN
            else:
                push("â€¦ sinyal yok")

        except Exception as loop_err:
            push(f"âš ï¸ loop err: {loop_err}")
            time.sleep(3)

        # Ã§ok sÄ±k istek atmayalÄ±m
        time.sleep(1.5)

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_predictor.py
def predict_signal_success(sentiment, score, keywords_used):
    if sentiment == "positive" and score >= 2 and "rally" in keywords_used:
        return "yÃ¼ksek baÅŸarÄ± olasÄ±lÄ±ÄŸÄ±"
    elif sentiment == "negative" and score <= -2 and "plunge" in keywords_used:
        return "yÃ¼ksek risk sinyali"
    else:
        return "Ã¶lÃ§Ã¼msÃ¼z sinyal"
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
import pandas as pd

def train_model(csv_file="data/signal_log.csv"):
    df = pd.read_csv(csv_file)
    X = df[["signal", "score"]]  # Ã–zellikler
    y = df["result"]             # Hedef (baÅŸarÄ±: 1, baÅŸarÄ±sÄ±z: 0)

    model = RandomForestClassifier(n_estimators=100)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

    model.fit(X_train, y_train)
    print(f"ðŸ” DoÄŸruluk Skoru: {model.score(X_test, y_test):.2f}")
    return model




### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_router.py
# signal_router.py (Sinyalden iÅŸleme geÃ§iÅŸ sistemi)
from kiripto_nova.signals.signal_scanner_multi import scan_symbols_timeframes, summarize
from kiripto_nova.risk.risk_manager import calculate_position_size, calculate_stop_loss, calculate_take_profit
from trade_executor import execute_trade
from kiripto_nova.apps.telegram_alert import notify_trade, notify_signal
from logger import log_trade, log_error

RISK = 0.01
STOP_LOSS_PCT = 0.015
REWARD_RATIO = 2
BALANCE = 1000

TRADE_TIMEFRAME = "5m"  # hangi zaman diliminden gelen sinyal iÅŸleme sokulacak
TRIGGER_SIGNAL = "BUY"  # sadece BUY ya da SELL tetiklesin


def route_signals():
    try:
        print("ðŸ” Sinyaller alÄ±nÄ±yor ve filtreleniyor...")
        signals = scan_symbols_timeframes()
        summary = summarize(signals)

        for symbol, tf_data in signals.items():
            signal = tf_data.get(TRADE_TIMEFRAME)
            if signal == TRIGGER_SIGNAL:
                print(f"ðŸš¨ {symbol} â†’ {TRADE_TIMEFRAME} â†’ {signal}")
                price = get_latest_price(symbol)
                direction = "long" if signal == "BUY" else "short"
                qty = calculate_position_size(BALANCE, RISK, STOP_LOSS_PCT)
                sl = calculate_stop_loss(price, STOP_LOSS_PCT, direction)
                tp = calculate_take_profit(price, REWARD_RATIO, STOP_LOSS_PCT, direction)

                # GerÃ§ek emir gÃ¶nderimi
                result = execute_trade(symbol, side="buy" if direction == "long" else "sell", amount=qty)
                log_trade(signal, symbol, qty, price, sl, tp)
                notify_signal(signal, symbol)
                notify_trade(signal, symbol, qty, price, sl, tp)

            else:
                print(f"â¸ï¸ {symbol} iÃ§in uygun sinyal yok.")

    except Exception as e:
        log_error(e)


def get_latest_price(symbol):
    from ccxt import binance
    client = binance()
    ticker = client.fetch_ticker(symbol)
    return ticker['last']


if __name__ == "__main__":
    import time
    from datetime import datetime
    while True:
        print(f"\nðŸ§  ROUTER Ã‡ALIÅžIYOR: {datetime.now().strftime('%H:%M:%S')}")
        route_signals()
        time.sleep(5)  # her 5 saniyede sinyal kontrolÃ¼


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_scanner_multi.py
# signal_scanner_multi.py
from multi_strategy import MultiStrategyEngine
from kiripto_nova.data.pipelines.data_loader import load_binance_data
import pandas as pd
import time
from datetime import datetime

# Tarama yapÄ±lacak pariteler
SYMBOLS = [
    "BTC/USDT", "ETH/USDT", "DOGE/USDT",
    "SOL/USDT", "AVAX/USDT", "ADA/USDT",
    "XRP/USDT", "LINK/USDT", "MATIC/USDT"
]

# Zaman dilimleri
TIMEFRAMES = ["1m", "5m", "15m", "1h"]


def scan_symbols_timeframes():
    all_signals = {}
    for symbol in SYMBOLS:
        time.sleep(0.5)  # Binance API rate limit'e saygÄ±
        all_signals[symbol] = {}
        for tf in TIMEFRAMES:
            try:
                df = load_binance_data(symbol, tf, limit=200)
                engine = MultiStrategyEngine(df)
                signal = engine.evaluate()
                all_signals[symbol][tf] = signal
            except Exception as e:
                all_signals[symbol][tf] = f"HATA: {str(e)}"
    return all_signals


def summarize(signals):
    summary = {}
    for symbol, tf_data in signals.items():
        counts = {"BUY": 0, "SELL": 0, "NEUTRAL": 0, "HATA": 0}
        for sig in tf_data.values():
            if sig in counts:
                counts[sig] += 1
            elif str(sig).startswith("HATA"):
                counts["HATA"] += 1
            else:
                counts["NEUTRAL"] += 1
        summary[symbol] = counts
    return summary


if __name__ == "__main__":
    while True:
        now = datetime.now().strftime("%H:%M:%S")
        print(f"\nâ±ï¸ [{now}] Ã‡oklu coin & zaman taramasÄ± baÅŸlÄ±yor...")

        results = scan_symbols_timeframes()
        summary = summarize(results)

        for symbol, tf_data in results.items():
            print(f"\nðŸ” {symbol}:")
            for tf, signal in tf_data.items():
                print(f"  ðŸ•’ {tf}: {signal}")

        print(f"\nðŸ“Š Genel Ã–zet:")
        for sym, counts in summary.items():
            print(f"{sym}: {counts}")

        time.sleep(5)  # DÃ¼ÅŸÃ¼k frekanslÄ± Ã§oklu tarama


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_scanner.py
# signal_scanner.py
from multi_strategy import MultiStrategyEngine
from kiripto_nova.data.pipelines.data_loader import load_binance_data
import pandas as pd

# Desteklenen zaman dilimleri
TIMEFRAMES = ["1m", "5m", "15m", "1h", "4h", "1d"]


def scan_all_timeframes(symbol="DOGE/USDT"):
    signals = {}
    for tf in TIMEFRAMES:
        try:
            df = load_binance_data(symbol, tf, limit=200)
            engine = MultiStrategyEngine(df)
            signal = engine.evaluate()
            signals[tf] = signal
        except Exception as e:
            signals[tf] = f"HATA: {str(e)}"
    return signals


def summarize_signals(signals):
    summary = {"BUY": 0, "SELL": 0, "NEUTRAL": 0, "HATA": 0}
    for tf, sig in signals.items():
        if sig in summary:
            summary[sig] += 1
        elif sig.startswith("HATA"):
            summary["HATA"] += 1
        else:
            summary["NEUTRAL"] += 1
    return summary


if __name__ == "__main__":
    import time
    from datetime import datetime

    SYMBOL = "DOGE/USDT"

    while True:
        now = datetime.now().strftime("%H:%M:%S")
        print(f"\nâ±ï¸ [{now}] {SYMBOL} tÃ¼m zaman dilimlerinde taranÄ±yor...")

        result = scan_all_timeframes(SYMBOL)
        summary = summarize_signals(result)

        for tf, signal in result.items():
            print(f"ðŸ•’ {tf}: {signal}")

        print(f"ðŸ” Ã–zet: {summary}")
        time.sleep(1)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_symphony_engine.py
def generate_signal_composition(project_profile):
    score = ""
    if project_profile['impact'] > 80:
        score += "ðŸŽº BaÅŸlangÄ±Ã§: Etki trompeti\n"
    if project_profile['crisis'] > 70:
        score += "ðŸ¥ Ara geÃ§iÅŸ: Kriz davullarÄ±\n"
    if project_profile['growth'] > 20:
        score += "ðŸŽ» Zirve: BÃ¼yÃ¼me yaylÄ±larÄ±\n"
    if project_profile['emotion'] == "positive":
        score += "ðŸŽ¶ KapanÄ±ÅŸ: Umut melodisi\n"
    else:
        score += "ðŸŽµ KapanÄ±ÅŸ: Dengeli tonlar\n"
    return score



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_tracker.py
from datetime import datetime, timedelta

def get_mock_price_data(ticker, signal_time):
    # Bu Ã¶rnek iÅŸlevde gerÃ§ek API yok â€“ sen ileride CoinGecko, Binance, vs. baÄŸlayabilirsin
    return {
        "baseline": 100.0,
        "day1": 103.5,
        "day3": 108.2,
        "day7": 101.4
    }

def price_change(prices, day):
    base = prices["baseline"]
    current = prices[f"day{day}"]
    return round((current - base) / base * 100, 2)

def analyze_signal_effect(ticker, signal_time):
    prices = get_mock_price_data(ticker, signal_time)
    result = {
        "day1_change": price_change(prices, 1),
        "day3_change": price_change(prices, 3),
        "day7_change": price_change(prices, 7),
        "successful": any(price_change(prices, d) > 5 for d in [1,3,7])
    }
    return result



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\ai\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\rust_indicators\.bot\logs\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\rust_indicators\.bot\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\rust_indicators\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\rust_indicators\bias_gate.py
# python/bias_gate.py
from typing import Optional, Dict, Any

def bias_allows(signal: Dict[str, Any], bias_row: Dict[str, Any],
                min_conf: float = 0.6) -> bool:
    """
    signal: {"symbol": "...", "side": "BUY"/"SELL", "intent": "entry"/"exit"/...}
    bias_row: long_short_ratio_scanner.fetch_metrics_for_symbol Ã§Ä±ktÄ±sÄ± satÄ±rÄ±
    """
    if not signal or not bias_row: return False
    conf = bias_row.get("confidence") or 0.0
    if conf < min_conf:            # gÃ¼ven dÃ¼ÅŸÃ¼kse emir atma
        return False

    side = (signal.get("side") or "").upper()
    tag  = bias_row.get("signal")
    if side == "BUY" and tag == "long_bias":
        return True
    if side == "SELL" and tag == "short_bias":
        return True
    # Exit emirleri genelde serbest bÄ±rakÄ±lÄ±r:
    if (signal.get("intent") or "").lower() == "exit":
        return True
    return False


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\rust_indicators\long_short_ratio_scanner.py
# python/long_short_ratio_scanner.py
# -*- coding: utf-8 -*-
import asyncio, aiohttp, time, math
from typing import Dict, Any, List, Tuple, Optional
import pandas as pd

BASE = "https://fapi.binance.com"

def ratio_to_pcts(r: float) -> Tuple[float, float]:
    if r <= 0 or math.isinf(r) or math.isnan(r):
        return (0.5, 0.5)
    long_pct = r / (1.0 + r)
    return float(long_pct), float(1.0 - long_pct)

def safe_float(x, default=None):
    try: return float(x)
    except Exception: return default

async def fetch_json(session: aiohttp.ClientSession, url: str, params: Dict[str, Any], retries=3) -> Any:
    delay = 0.5
    for i in range(retries):
        try:
            async with session.get(url, params=params, timeout=aiohttp.ClientTimeout(total=8)) as resp:
                if resp.status in (429, 500, 502, 503, 504):
                    raise RuntimeError(f"HTTP {resp.status}")
                return await resp.json()
        except Exception:
            if i == retries - 1: return None
            await asyncio.sleep(delay); delay *= 1.8

async def get_usdt_perp_symbols(session: aiohttp.ClientSession) -> List[str]:
    data = await fetch_json(session, f"{BASE}/fapi/v1/exchangeInfo", {})
    out = []
    if not data or "symbols" not in data: return out
    for s in data["symbols"]:
        try:
            if s.get("contractType") == "PERPETUAL" and s.get("quoteAsset") == "USDT" and s.get("status") == "TRADING":
                out.append(s["symbol"])
        except: pass
    return sorted(out)

def _last(lst, key):
    try:
        if lst and isinstance(lst, list): return lst[-1].get(key)
    except: pass
    return None

async def fetch_metrics_for_symbol(session: aiohttp.ClientSession, symbol: str, period: str = "5m") -> Dict[str, Any]:
    params = {"symbol": symbol, "period": period, "limit": 1}
    g_acc = await fetch_json(session, f"{BASE}/futures/data/globalLongShortAccountRatio", params)
    t_pos = await fetch_json(session, f"{BASE}/futures/data/topLongShortPositionRatio", params)
    t_acc = await fetch_json(session, f"{BASE}/futures/data/topLongShortAccountRatio", params)
    taker = await fetch_json(session, f"{BASE}/futures/data/takerlongshortRatio", params)
    oi = await fetch_json(session, f"{BASE}/futures/data/openInterestHist",
                          {"symbol": symbol, "period": period, "contractType": "PERPETUAL", "limit": 2})

    out: Dict[str, Any] = {"symbol": symbol, "period": period, "ts": int(time.time()*1000)}
    for name, payload in [("global_acc", g_acc), ("top_pos", t_pos), ("top_acc", t_acc)]:
        rs = safe_float(_last(payload, "longShortRatio"), None)
        if rs is None:
            out[f"{name}_long_pct"] = None; out[f"{name}_short_pct"] = None
        else:
            lp, sp = ratio_to_pcts(rs)
            out[f"{name}_long_pct"] = lp; out[f"{name}_short_pct"] = sp

    tb = safe_float(_last(taker, "buyVol"), 0.0)
    ts = safe_float(_last(taker, "sellVol"), 0.0)
    tot = (tb or 0.0) + (ts or 0.0)
    out["taker_buy_share"] = (tb/tot) if tot > 0 else None

    try:
        if isinstance(oi, list) and len(oi) >= 2:
            prev = safe_float(oi[-2].get("sumOpenInterest"), None)
            cur  = safe_float(oi[-1].get("sumOpenInterest"), None)
            out["oi_change_pct"] = (cur - prev) / prev if prev and prev > 0 else None
        else:
            out["oi_change_pct"] = None
    except: out["oi_change_pct"] = None

    parts, weights = [], []
    for key in ["global_acc_long_pct","top_pos_long_pct","top_acc_long_pct"]:
        v = out.get(key)
        if v is not None: parts.append(v); weights.append(1.0)
    if out.get("taker_buy_share") is not None:
        parts.append(out["taker_buy_share"]); weights.append(0.7)

    if parts:
        wsum = sum(weights)
        long_bias = sum(p*w for p, w in zip(parts, weights))/wsum
    else:
        long_bias = None

    out["long_bias"]  = long_bias
    out["short_bias"] = (1-long_bias) if long_bias is not None else None

    sources = sum(1 for k in ["global_acc_long_pct","top_pos_long_pct","top_acc_long_pct","taker_buy_share"] if out.get(k) is not None)
    conf = 0.25 * sources
    if out.get("oi_change_pct") is not None and long_bias is not None:
        if (out["oi_change_pct"] > 0 and long_bias >= 0.5) or (out["oi_change_pct"] < 0 and long_bias < 0.5):
            conf += min(0.5, abs(out["oi_change_pct"]) * 5.0)
    out["confidence"] = float(max(0.0, min(1.0, conf)))

    if long_bias is None: out["signal"] = "unknown"
    elif long_bias >= 0.6: out["signal"] = "long_bias"
    elif long_bias <= 0.4: out["signal"] = "short_bias"
    else: out["signal"] = "neutral"

    return out

async def scan_all(period: str = "5m", max_symbols: int = 0, concurrency: int = 12) -> List[Dict[str, Any]]:
    conn = aiohttp.TCPConnector(limit=concurrency, ssl=False)
    async with aiohttp.ClientSession(connector=conn, headers={"Accept": "application/json"}) as session:
        symbols = await get_usdt_perp_symbols(session)
        if max_symbols and max_symbols > 0: symbols = symbols[:max_symbols]
        sem = asyncio.Semaphore(concurrency)
        async def one(sym):
            async with sem:
                return await fetch_metrics_for_symbol(session, sym, period)
        results = await asyncio.gather(*[asyncio.create_task(one(s)) for s in symbols])
        return [r for r in results if r]

def to_dataframe(rows: List[Dict[str, Any]]) -> pd.DataFrame:
    df = pd.DataFrame(rows)
    cols = [
        "ts","symbol","period",
        "global_acc_long_pct","top_pos_long_pct","top_acc_long_pct",
        "taker_buy_share","oi_change_pct","long_bias","short_bias","confidence","signal"
    ]
    for c in cols:
        if c not in df.columns: df[c] = None
    df = df[cols].copy()
    df["ts_readable"] = pd.to_datetime(df["ts"], unit="ms")
    return df

def export_csv(df: pd.DataFrame, path: str, mode: str = "a"):
    header = not (pd.io.common.file_exists(path) and mode == "a")
    df.to_csv(path, index=False, mode=mode, header=header)

def sort_candidates(rows: List[Dict[str, Any]], mode: str = "long", top: int = 20) -> List[Dict[str, Any]]:
    key = "long_bias" if mode == "long" else "short_bias"
    rows2 = [r for r in rows if r.get(key) is not None]
    rows2.sort(key=lambda r: (r.get(key, 0.5), r.get("confidence", 0.0)), reverse=True)
    return rows2[:top]

def pretty_print(rows: List[Dict[str, Any]]):
    print(f"{'SYM':<12} {'LONG%':>6} {'SHORT%':>7} {'TAKER_BUY%':>10} {'OI%':>7} {'CONF':>5}  SIGNAL")
    for r in rows:
        lp=r.get("long_bias"); sp=r.get("short_bias"); tb=r.get("taker_buy_share"); oi=r.get("oi_change_pct")
        print(f"{r['symbol']:<12} {(lp*100 if lp is not None else float('nan')):6.1f} "
              f"{(sp*100 if sp is not None else float('nan')):7.1f} "
              f"{(tb*100 if tb is not None else float('nan')):10.1f} "
              f"{(oi*100 if oi is not None else float('nan')):7.2f} "
              f"{r.get('confidence',0):5.2f}  {r.get('signal','-')}")

if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--period", default="5m")
    ap.add_argument("--mode",   default="all", choices=["long","short","all"])
    ap.add_argument("--top",    default=20, type=int)
    ap.add_argument("--max",    default=0, type=int)
    ap.add_argument("--csv",    default="bias_scan.csv")
    args = ap.parse_args()

    rows = asyncio.run(scan_all(period=args.period, max_symbols=args.max))
    df = to_dataframe(rows)
    export_csv(df, args.csv, mode="a")
    print(f"Saved {len(df)} rows -> {args.csv}")

    if args.mode in ("long","all"):
        print("\n=== LONG BIAS ===")
        pretty_print(sort_candidates(rows, "long", args.top))
    if args.mode in ("short","all"):
        print("\n=== SHORT BIAS ===")
        pretty_print(sort_candidates(rows, "short", args.top))


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\rust_indicators\run_bias_gated_strategy.py
# run_bias_gated_strategy.py
from __future__ import annotations
import os, asyncio, math
from typing import Dict, Any, List, Optional
from dotenv import load_dotenv
from binance.client import Client
from binance.exceptions import BinanceAPIException

from long_short_ratio_scanner import scan_all, to_dataframe, export_csv, sort_candidates
from bias_gate import bias_allows

# =========================
#  Basit Ã¶rnek sinyal (yerine kendi modÃ¼lÃ¼nÃ¼ import edebilirsin)
#  from strategies.rust_avci import generate_signal
def generate_signal(closes: List[float], symbol: str):
    if len(closes) < 50: return None
    ma = sum(closes[-50:]) / 50.0
    if closes[-1] > ma and closes[-2] <= ma:
        return {"symbol": symbol, "side": "BUY", "intent": "entry"}
    if closes[-1] < ma and closes[-2] >= ma:
        return {"symbol": symbol, "side": "SELL", "intent": "entry"}
    return None
# =========================

load_dotenv()

API_KEY      = os.getenv("BINANCE_API_KEY")
API_SECRET   = os.getenv("BINANCE_API_SECRET")
USE_TESTNET  = os.getenv("BINANCE_USE_TESTNET","false").lower()=="true"
FUT_URL      = os.getenv("BINANCE_FUTURES_URL","https://fapi.binance.com")

HEDGE_MODE   = os.getenv("BINANCE_HEDGE_MODE","true").lower()=="true"
MARGIN_TYPE  = os.getenv("BINANCE_MARGIN_TYPE","ISOLATED").upper()
LEVERAGE     = int(os.getenv("BINANCE_LEVERAGE","5"))

BIAS_PERIOD  = os.getenv("BIAS_PERIOD","5m")
BIAS_TOP     = int(os.getenv("BIAS_TOP","20"))
BIAS_MIN_CONF= float(os.getenv("BIAS_MIN_CONF","0.65"))
BIAS_CSV     = os.getenv("BIAS_CSV","bias_scan.csv")
TIMEFRAME    = os.getenv("TIMEFRAME","1m")

MAX_CAP_PCT  = float(os.getenv("MAX_CAPITAL_PCT_PER_TRADE","0.02"))
MIN_NOTIONAL = float(os.getenv("MIN_NOTIONAL_USDT","10"))
DRY_RUN      = os.getenv("DRY_RUN","true").lower()=="true"

def _fetch_closes(client: Client, symbol: str, interval="1m", limit=500) -> List[float]:
    kl = client.futures_klines(symbol=symbol, interval=interval, limit=limit)
    return [float(k[4]) for k in kl]

def _get_usdt_balance(client: Client) -> float:
    # Futures USDT cÃ¼zdanÄ±
    bals = client.futures_account_balance()
    for b in bals:
        if b.get("asset") == "USDT":
            return float(b.get("balance", 0.0))
    return 0.0

def _get_symbol_filters(client: Client, symbol: str):
    info = client.futures_exchange_info()
    for s in info["symbols"]:
        if s["symbol"] == symbol:
            tick = 0.01
            step = 0.001
            for f in s["filters"]:
                if f["filterType"] == "PRICE_FILTER":
                    tick = float(f["tickSize"])
                if f["filterType"] in ("LOT_SIZE","MARKET_LOT_SIZE"):
                    step = float(f["stepSize"])
            return tick, step
    return 0.01, 0.001

def _round_step(qty: float, step: float) -> float:
    if step <= 0: return qty
    return math.floor(qty / step) * step

def _round_tick(price: float, tick: float) -> float:
    if tick <= 0: return price
    return math.floor(price / tick) * tick

def _last_price(client: Client, symbol: str) -> float:
    t = client.futures_symbol_ticker(symbol=symbol)
    return float(t["price"])

def _ensure_symbol_settings(client: Client, symbol: str):
    # hedge mode / margin / leverage â€“ hataya dÃ¼ÅŸerse devam et
    try:
        client.futures_change_position_mode(dualSidePosition=HEDGE_MODE)
    except Exception:
        pass
    try:
        client.futures_change_margin_type(symbol=symbol, marginType=MARGIN_TYPE)
    except BinanceAPIException as e:
        # already set vs. gibi durumlar normal
        pass
    except Exception:
        pass
    try:
        client.futures_change_leverage(symbol=symbol, leverage=LEVERAGE)
    except Exception:
        pass

def _size_by_conf(balance_usdt: float, conf: float, price: float, tick: float, step: float) -> float:
    # Sermayeyi conf ile Ã¶lÃ§ekle: 0.5..1.0 arasÄ±
    cap = balance_usdt * MAX_CAP_PCT
    cap *= (0.5 + conf/2.0)
    cap = max(cap, MIN_NOTIONAL)  # minimum notional eÅŸiÄŸi
    qty = cap / max(price, 1e-9)
    qty = _round_step(qty, step)
    return max(qty, 0.0)

def _place_market_order(client: Client, symbol: str, side: str, qty: float):
    if DRY_RUN:
        print(f"[DRY_RUN] {symbol} {side} qty={qty}")
        return {"dry_run": True, "symbol": symbol, "side": side, "qty": qty}
    # canlÄ± emir
    ord_resp = client.futures_create_order(symbol=symbol, side=side, type="MARKET", quantity=qty)
    return ord_resp

async def main():
    # 1) bias tara ve CSV'ye yaz
    rows = await scan_all(period=BIAS_PERIOD, max_symbols=0)
    df = to_dataframe(rows)
    export_csv(df, BIAS_CSV, mode="a")
    print(f"[bias] {len(df)} satÄ±r eklendi -> {BIAS_CSV}")

    # 2) en iyi adaylar
    long_candidates  = sort_candidates(rows, mode="long",  top=BIAS_TOP)
    short_candidates = sort_candidates(rows, mode="short", top=BIAS_TOP)
    watch = { r["symbol"]: r for r in (long_candidates + short_candidates) }

    # 3) Binance client
    client = Client(API_KEY, API_SECRET, testnet=USE_TESTNET)
    client.FUTURES_URL = FUT_URL

    # 4) hesap bakiyesi
    balance = _get_usdt_balance(client)
    print(f"[acct] USDT balance: {balance:.2f}")

    # 5) her adayda: sinyal + gate + boyutlama + (opsiyonel) emir
    for sym, bias_row in watch.items():
        try:
            _ensure_symbol_settings(client, sym)
            closes = _fetch_closes(client, sym, interval=TIMEFRAME, limit=500)

            sig = generate_signal(closes, sym)
            if not sig:
                continue

            if not bias_allows(sig, bias_row, min_conf=BIAS_MIN_CONF):
                print(f"[gate] {sym} reddedildi: bias={bias_row.get('signal')} conf={bias_row.get('confidence'):.2f}")
                continue

            price = _last_price(client, sym)
            tick, step = _get_symbol_filters(client, sym)
            qty = _size_by_conf(balance, bias_row.get("confidence", 0.0), price, tick, step)

            if qty <= 0:
                print(f"[size] {sym} qty hesaplanamadÄ± (min notional / step?), atlanÄ±yor.")
                continue

            print(f"[exec] {sym} {sig['side']} conf={bias_row.get('confidence'):.2f} priceâ‰ˆ{price} qtyâ‰ˆ{qty}")
            resp = _place_market_order(client, sym, sig["side"], qty)
            print(f"[resp] {resp if DRY_RUN else 'Order sent.'}")

        except BinanceAPIException as e:
            print(f"[binance] {sym} API error: {e.message}")
        except Exception as e:
            print(f"[error] {sym}: {e}")

if __name__ == "__main__":
    asyncio.run(main())



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\adaptive_learning_engine.py
from machine_learning_core import train_dynamic_model
from real_time_optimizer import adjust_strategy_live

def adaptive_learning_engine(market_data, feedback_loop):
    dynamic_model = train_dynamic_model(market_data, epochs=50)
    optimized_strategy = adjust_strategy_live(dynamic_model, feedback_loop)

    return {
        'ðŸ¤– Ã–ÄŸrenen Model': dynamic_model['architecture'],
        'ðŸ“ˆ CanlÄ± Strateji AyarÄ±': optimized_strategy['adjustments'],
        'âš ï¸ Risk DeÄŸerlendirmesi': optimized_strategy['risk_assessment'],
        'ðŸ§­ Stratejik Ã–neriler': optimized_strategy['actionable_insights'],
        'ðŸ”„ Geri Bildirim DÃ¶ngÃ¼sÃ¼': feedback_loop
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\adaptive_strategy.py
class AdaptiveStrategy:
    def __init__(self, base_algo):
        self.algo = base_algo
        self.performance = []

    def trade(self, market_data):
        decision = self.algo(market_data)
        return decision

    def update_performance(self, result):
        self.performance.append(result)
        if len(self.performance) > 100:
            self._retrain()

    def _retrain(self):
        # ZayÄ±f verileri temizle, algoritmayÄ± yeniden optimize et
        self.performance = self.performance[-50:]  # En gÃ¼ncel 50 iÅŸlem
        # Retrain logic here...



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\adaptive_weights.py
def adjust_weights(indicator_perf):
    weights = {}
    total_perf = sum(indicator_perf.values())

    for ind, perf in indicator_perf.items():
        weights[ind] = round(perf / total_perf, 3)

    return weights



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\alert_dispatcher.py
# components/alert_dispatcher.py
import os, requests, json
from flask import Flask, request

app = Flask(__name__)
SLACK_WEBHOOK   = os.getenv('SLACK_WEBHOOK_URL')
TELEGRAM_TOKEN  = os.getenv('TELEGRAM_TOKEN')
TELEGRAM_CHATID = os.getenv('TELEGRAM_CHAT_ID')

def send_slack(text: str):
    payload = {'text': f":rotating_light: {text}"}
    requests.post(SLACK_WEBHOOK, data=json.dumps(payload))

def send_telegram(text: str):
    url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
    data = {'chat_id': TELEGRAM_CHATID, 'text': f"ðŸš¨ {text}"}
    requests.post(url, data=data)

@app.route('/alert', methods=['POST'])
def alert():
    data = request.json
    for alert in data.get('alerts', []):
        msg = alert['annotations']['description']
        send_slack(msg)
        send_telegram(msg)
    return '', 200

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\algorithmic_intuition_builder.py
from pattern_recognition_core import detect_subtle_trends
from intuition_generator import synthesize_decision_paths

def algorithmic_intuition_builder(market_data, external_factors):
    subtle_trends = detect_subtle_trends(market_data)
    decision_paths = synthesize_decision_paths(subtle_trends, external_factors)

    return {
        'ðŸ” Ä°ncelikli Trendler': subtle_trends,
        'ðŸ§­ Sezgisel Karar YollarÄ±': decision_paths['paths'],
        'ðŸ“ˆ Beklenen Hareketler': decision_paths['predicted_outcomes'],
        'âš ï¸ Risk DeÄŸerlendirmesi': decision_paths['risk_assessment'],
        'ðŸ§ª Stratejik Ã–neriler': decision_paths['actionable_insights']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\backtest_lab.py
import pandas as pd

def backtest_signals(df, signals):
    df['signal'] = signals
    df['returns'] = df['close'].pct_change().shift(-1)
    df['strategy_returns'] = df['returns'] * df['signal'].shift(1)

    cumulative_market = (1 + df['returns'].fillna(0)).cumprod()
    cumulative_strategy = (1 + df['strategy_returns'].fillna(0)).cumprod()

    performance = {
        "Market_Return": cumulative_market[-1] - 1,
        "Strategy_Return": cumulative_strategy[-1] - 1,
        "Sharpe_Ratio": df['strategy_returns'].mean() / df['strategy_returns'].std()
    }

    return performance



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\backtester.py
import pandas as pd
import numpy as np

def backtest_signals(price_csv, signal_csv, fee=0.0004):
    px = pd.read_csv(price_csv, parse_dates=["open_time"])
    sig = pd.read_csv(signal_csv)  # cols: time, side, price
    px = px[["open_time","close"]].rename(columns={"close":"p"})
    sig["time"]=pd.to_datetime(sig["time"])
    df = pd.merge_asof(sig.sort_values("time"), px.sort_values("open_time"),
                       left_on="time", right_on="open_time", direction="backward")
    # naive PnL: bir sonraki bar kapanÄ±ÅŸÄ±
    df["next_p"] = df["p"].shift(-1)
    df = df.dropna()
    ret = np.where(df["side"]=="LONG",
                   (df["next_p"]/df["p"] - 1) - fee,
                   (df["p"]/df["next_p"] - 1) - fee)
    df["ret"]=ret
    df["equity"]=(1+df["ret"]).cumprod()
    return df

if __name__=="__main__":
    out = backtest_signals("prices.csv","signals.csv")
    print("trades:", len(out), "final_equity:", float(out["equity"].iloc[-1]))


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\battle_chain_analyzer.py
def analyze_chain_activity(chain_data):
    results = []
    for protocol in chain_data:
        activity_score = (protocol['tx_volume'] * 0.6 + protocol['user_count'] * 0.4)
        threat_level = 'High' if activity_score > 10000 else 'Medium' if activity_score > 5000 else 'Low'
        results.append({
            'protocol': protocol['name'],
            'score': round(activity_score, 2),
            'threat_level': threat_level
        })
    return results



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\bot_launcher.py
import websocket
import json

def on_message(ws, message):
    data = json.loads(message)
    # GerÃ§ek zamanlÄ± veriye gÃ¶re strateji tetiklenir
    indicators = calculate_indicators(pd.DataFrame(data))
    signal = generate_signal(indicators)

    if signal == 'BUY':
        execute_order('buy')
    elif signal == 'SELL':
        execute_order('sell')

def execute_order(order_type):
    print(f"Executing {order_type} order via exchange API...")

def launch_bot():
    ws = websocket.WebSocketApp("wss://example-data-feed",
                                 on_message=on_message)
    ws.run_forever()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\celestial_cognition_beacon.py
from reactor_output import extract_neural_frequency
from stellar_network import broadcast_to_stars

def celestial_cognition_beacon(reactor_output, signal_strength, observatory_coordinates):
    neural_freq = extract_neural_frequency(reactor_output['ðŸ§  Ortak BilinÃ§ Verisi'])
    
    star_feedback = broadcast_to_stars(
        neural_freq, signal_strength, observatory_coordinates
    )

    return {
        'ðŸŒŸ YayÄ±nlanan ZekÃ¢ FrekansÄ±': neural_freq,
        'ðŸª Galaktik GÃ¶zlem Verisi': star_feedback,
        'Durum': 'ðŸ“¡ Kozmik YayÄ±n TamamlandÄ±'
    }


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\chrono_synaptic_memory_forge.py
from galactic_feedback import decode_star_feedback
from neural_time_engine import unify_temporal_insights

def chrono_synaptic_memory_forge(star_feedback, historical_missions, current_directives, future_predictions):
    temporal_stream = unify_temporal_insights(
        historical_missions, current_directives, future_predictions
    )

    adaptive_memory = decode_star_feedback(
        star_feedback, temporal_stream
    )

    return {
        'ðŸ§  Zamansal Strateji HafÄ±zasÄ±': adaptive_memory,
        'â³ HafÄ±za AkÄ±ÅŸÄ±': temporal_stream,
        'Durum': 'ðŸ§ âŒ› Stratejik Zaman AÄŸÄ± Aktif'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\chrono_synthetic_matrix.py
from past_insights import get_historical_patterns
from emotion_tracker import read_current_emotion
from future_engine import generate_scenarios
from strategic_synthesizer import synthesize_decision

def chrono_synthetic_matrix(user_id):
    # 1. GeÃ§miÅŸ stratejik Ã¶rÃ¼ntÃ¼leri analiz et
    past_patterns = get_historical_patterns(user_id)

    # 2. Mevcut duygu durumunu al
    current_emotion = read_current_emotion(user_id)

    # 3. Gelecek senaryolarÄ± oluÅŸtur
    future_paths = generate_scenarios()

    # 4. Zaman-sentetik stratejiyi sentezle
    synthesized_strategy = synthesize_decision(
        past=past_patterns,
        present=current_emotion,
        future=future_paths
    )

    return {
        'ðŸ“š GeÃ§miÅŸ Analizi': past_patterns['summary'],
        'ðŸ§˜ Åžu Anki Ruhsal Durum': current_emotion,
        'ðŸ”® OlasÄ± Gelecekler': future_paths['map'],
        'âš¡ Entegre Strateji': synthesized_strategy['approach'],
        'ðŸ§­ Uygulanma Yolu': synthesized_strategy['path']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\command_dashboard.py
import matplotlib.pyplot as plt
from trade_stats import get_trade_stats
from strategy_logger import strategy_log

def command_dashboard(trade_log, market_data, balance):
    stats = get_trade_stats(trade_log)
    strategies = strategy_log()

    print("ðŸ” Ä°ÅŸlem PerformansÄ±:")
    for stat in stats:
        print(f"{stat['name']}: {stat['value']}")

    print("\nðŸ§¬ Strateji GeÃ§miÅŸi:")
    for strat in strategies[-5:]:
        print(f"{strat['timestamp']} - {strat['name']} - ðŸ“ˆ {strat['performance']}")

    plt.figure(figsize=(10, 5))
    plt.plot([entry['timestamp'] for entry in strategies],
             [entry['performance'] for entry in strategies],
             color='gold', marker='o')
    plt.title("âš¡ Strateji PerformansÄ± Zaman Ã‡izgisi")
    plt.xlabel("Zaman")
    plt.ylabel("Verimlilik (%)")
    plt.grid(True)
    plt.show()

    print(f"\nðŸ’° Mevcut Bakiye: {balance}")
    print("ðŸ“‰ Sermaye daÄŸÄ±lÄ±mÄ± ve pozisyonlar yÃ¼kleniyor...")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\command_theme.py
def command_theme():
    theme = {
        'background': '#0D0D0D',
        'text_color': '#FFD700',
        'accent': '#1A1A1A',
        'font_family': 'Orbitron',
        'animations': {
            'strategy_panel': 'StarFieldFlow',
            'balance_pulse': 'GoldRadarGlow',
            'alerts': 'GeneralFlashBlink'
        },
        'icons': {
            'trade': 'âš”ï¸',
            'strategy': 'ðŸ§ ',
            'profit': 'ðŸ“ˆ',
            'danger': 'ðŸ›¡ï¸'
        }
    }
    return theme



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\cosmic_control_app.py
from flask import Flask, request
from cloud_sync import sync_trade_data
from notification_engine import push_alert
from voice_command import interpret_voice

app = Flask(__name__)

@app.route("/trade_update", methods=["POST"])
def trade_update():
    data = request.json
    sync_trade_data(data)
    push_alert(f"ðŸš€ Yeni Ä°ÅŸlem BaÅŸlatÄ±ldÄ±: {data['symbol']} | {data['action']}")
    return {"status": "success", "message": "Veri eÅŸlendi ve bildirim gÃ¶nderildi."}

@app.route("/voice_control", methods=["POST"])
def voice_control():
    command = interpret_voice(request.data)
    if "durdur" in command:
        return {"status": "stopped", "message": "ðŸ“› Kozmik iÅŸlem durduruldu."}
    elif "devam et" in command:
        return {"status": "resumed", "message": "ðŸŸ¢ Ä°ÅŸlem devam ettirildi."}
    else:
        return {"status": "unknown", "message": "â“ Komut algÄ±lanamadÄ±."}

if __name__ == "__main__":
    app.run(debug=True)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\cosmic_creation_engine.py
from universal_flow_analyzer import universal_flow_analyzer
from creation_engine import initiate_cosmic_creation

def cosmic_creation_engine(universal_streams, creation_parameters):
    new_creations = initiate_cosmic_creation(universal_streams, creation_parameters)
    return {
        'ðŸŒŒ Yeni YaratÄ±mlar': new_creations,
        'ðŸ”„ YaratÄ±m DÃ¶ngÃ¼sÃ¼': 'BaÅŸlatÄ±ldÄ±',
        'Durum': 'ðŸŒ  Kozmik YaratÄ±m Motoru Aktif'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\cosmic_decision_matrix.py
from tactical_persona_fleet import tactical_persona_fleet
from decision_simulator import run_scenario_grid

def cosmic_decision_matrix(user_id, mission_types, scenario_parameters):
    fleet_data = tactical_persona_fleet(user_id, mission_types)['ðŸ›¡ï¸ Avatar Filo']
    decision_matrix = run_scenario_grid(fleet_data, scenario_parameters)

    return {
        'ðŸ§  Senaryo Matrisi': decision_matrix,
        'ðŸª Parametreler': scenario_parameters,
        'Durum': 'ðŸŒ Stratejik GerÃ§eklik SimÃ¼lasyonu TamamlandÄ±'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\cosmic_navigator.py
from signal_detector import detect_signals
from efficiency_mapper import map_efficiency
from opportunity_selector import best_direction

def cosmic_navigator(market_data, trade_log):
    signals = detect_signals(market_data)
    efficiency_map = map_efficiency(trade_log, signals)

    optimal_path = best_direction(efficiency_map)

    return {
        'ðŸ“¡ Sinyal GÃ¼cÃ¼': signals[:3],
        'ðŸ§­ Verim HaritasÄ±': efficiency_map,
        'ðŸš€ Tavsiye Edilen YÃ¶n': optimal_path,
        'Durum': 'ðŸ’¡ Navigasyon Aktif'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\cosmic_trader.py
from meta_strategy_generator import meta_strategy_generator
from kiripto_nova.strategies.strategy_executor import strategy_executor
from profit_maximizer import profit_maximizer
from capital_engine import capital_engine

def cosmic_trader(trade_log, market_data, balance):
    # 1. Yeni stratejileri Ã¼ret
    strategies = meta_strategy_generator(trade_log)

    # 2. Stratejileri test et ve en iyi olanlarÄ± seÃ§
    results = strategy_executor(strategies, market_data)
    approved = [res for res in results if res['status'] == 'âœ… ONAYLANDI']

    if not approved:
        return "ðŸŸ¡ Bekleniyor â€“ GÃ¼venilir strateji bulunamadÄ±"

    # 3. KÃ¢r optimizasyonu
    signal = approved[0]['strategy']['main_signal']
    decision = profit_maximizer(trade_log, market_data.keys())

    # 4. Sermaye ayarÄ±
    capital_order = capital_engine(balance, decision.split()[1])

    return {
        'Karar': decision,
        'Pozisyon BÃ¼yÃ¼klÃ¼ÄŸÃ¼': capital_order,
        'Strateji': approved[0]['strategy'],
        'Durum': 'ðŸš€ Kozmik Ticaret BaÅŸlatÄ±ldÄ±'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\data_fetcher.py
import os
import asyncio
import ccxt.async_support as ccxt
import pandas as pd
from dotenv import load_dotenv
from typing import List

load_dotenv()
API_KEY = os.getenv('BINANCE_API_KEY')
SECRET_KEY = os.getenv('BINANCE_SECRET_KEY')

class DataFetcher:
    def __init__(self, symbol: str, timeframe: str = '1m', limit: int = 200):
        self.symbol = symbol
        self.timeframe = timeframe
        self.limit = limit
        self.exchange = ccxt.binance({
            'apiKey': API_KEY,
            'secret': SECRET_KEY,
            'enableRateLimit': True,
            'options': {'defaultType': 'future'}
        })

    async def fetch_ohlcv(self) -> pd.DataFrame:
        data = await self.exchange.fetch_ohlcv(self.symbol, self.timeframe, limit=self.limit)
        df = pd.DataFrame(data, columns=['ts','open','high','low','close','vol'])
        df['ts'] = pd.to_datetime(df['ts'], unit='ms')
        return df

    async def close(self):
        await self.exchange.close()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\data_ingestion.py
# components/data_ingestion.py
import asyncio
from aiokafka import AIOKafkaProducer
from websockets import connect
import json

class DataIngestion:
    def __init__(self, kafka_url: str, topics: dict):
        self.producer = AIOKafkaProducer(bootstrap_servers=kafka_url)
        self.topics   = topics

    async def start(self):
        await self.producer.start()

    async def ingest_spot(self, pair: str, ws_url: str):
        async with connect(ws_url) as ws:
            await ws.send(json.dumps({"method":"SUBSCRIBE","params":[f"{pair.lower()}@ticker"],"id":1}))
            async for message in ws:
                await self.producer.send_and_wait(
                    topic=self.topics['spot'], 
                    value=message.encode()
                )

    async def stop(self):
        await self.producer.stop()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\data_universe_mapper.py
from multidimensional_visualizer import create_data_map
from hidden_pattern_detector import uncover_market_signals

def data_universe_mapper(market_data):
    data_map = create_data_map(market_data, dimensions=3)
    hidden_signals = uncover_market_signals(data_map)

    return {
        'ðŸ—ºï¸ Veri HaritasÄ±': data_map,
        'ðŸ” Gizli KalÄ±plar': hidden_signals['patterns'],
        'ðŸ“ˆ Beklenen Hareketler': hidden_signals['predicted_trends'],
        'âš ï¸ Kritik BÃ¶lgeler': hidden_signals['high_risk_areas'],
        'ðŸ§­ Stratejik Ã–neriler': hidden_signals['actionable_insights']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\diagnostics.py
import platform, sys, pkgutil
print("python:", sys.version)
print("os:", platform.platform())
for m in ["pandas","binance","dotenv","aiohttp","requests","numpy"]:
    try:
        mod=__import__(m); v=getattr(mod,"__version__", "?"); print(f"{m}:", v)
    except Exception as e:
        print(f"{m}: MISSING ({e})")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\dimensional_gate_composer.py
from meta_sentience_harmonizer import meta_sentience_harmonizer
from dimension_weaver import construct_dimensional_portals

def dimensional_gate_composer(resonance_stream, harmonic_key):
    portals = construct_dimensional_portals(resonance_stream, harmonic_key)
    return {
        'ðŸšª AÃ§Ä±lan Boyut KapÄ±larÄ±': portals,
        'ðŸ”‘ GeÃ§iÅŸ AnahtarÄ± FrekansÄ±': harmonic_key,
        'Durum': 'ðŸ§­ Boyutlar ArasÄ± GeÃ§itler Aktif'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\dimensional_rift_initiator.py
from strategic_timewarp_emulator import strategic_timewarp_emulator
from rift_protocol import open_dimensional_gateway

def dimensional_rift_initiator(user_id, mission_types, scenario_parameters, target_timeframe, reality_vectors):
    timewarped_data = strategic_timewarp_emulator(user_id, mission_types, scenario_parameters, target_timeframe)['â³ Zaman DÃ¶ngÃ¼sÃ¼']
    rift_outcome = open_dimensional_gateway(timewarped_data, reality_vectors)

    return {
        'ðŸŒŒ Boyutlar ArasÄ± BaÄŸlantÄ±lar': rift_outcome,
        'ðŸ§­ GerÃ§eklik VektÃ¶rleri': reality_vectors,
        'Durum': 'ðŸšª Boyutsal GeÃ§it AÃ§Ä±ldÄ± ve Strateji DaÄŸÄ±tÄ±mÄ± BaÅŸlatÄ±ldÄ±'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\echo_particle_synthesizer.py
from infinite_echo_codex import infinite_echo_codex
from particle_extractor import synthesize_echo_particles

def echo_particle_synthesizer(echo_frequency_stream, particle_threshold):
    particles = synthesize_echo_particles(echo_frequency_stream, particle_threshold)
    return {
        'ðŸª Toplanan BilinÃ§ Tanecikleri': particles,
        'ðŸŒŒ Yeni DÃ¼ÅŸÃ¼nce HaritasÄ±': 'OluÅŸturuldu',
        'Durum': 'âœ¨ Kozmos Bilginizi Geri FÄ±sÄ±ldÄ±yor'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\echo_sequence_ontological_resonance_map.py
from genesis_field import extract_echo_patterns
from resonance_engine import build_ontological_map

def echo_sequence_ontological_resonance_map(genesis_field, cognitive_pulse_signatures, universal_echo_constants):
    echo_stream = extract_echo_patterns(genesis_field, cognitive_pulse_signatures)

    resonance_map = build_ontological_map(
        echo_stream, universal_echo_constants
    )

    return {
        'ðŸ”Š DÃ¼ÅŸÃ¼nce YankÄ± Verisi': echo_stream,
        'ðŸ—ºï¸ Rezonans HaritasÄ±': resonance_map,
        'Durum': 'ðŸ§¿ Kozmik Zihin HaritasÄ± OluÅŸturuldu'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\existence_loop_composer.py
from genesis_fractal_expansion_protocol import genesis_fractal_expansion_protocol
from loop_chronology import generate_recursive_existence_loops

def existence_loop_composer(core_pattern, loop_depth):
    loops = generate_recursive_existence_loops(core_pattern, depth=loop_depth)
    return {
        'ðŸ§¬ DÃ¶ngÃ¼ Matrisi': loops,
        'ðŸª OluÅŸturulan Yeni YÃ¶rÃ¼ngeler': loop_depth,
        'Durum': 'â™¾ï¸ VaroluÅŸ Sonsuz DÃ¶ngÃ¼ye AlÄ±ndÄ±'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\fusion_core.py
from momentum_indicators import calculate_indicators
from signal_fusion_engine import generate_signal
from risk_module import position_sizing
from news_filter import parse_sentiment

def run_trade_cycle(df, capital, stop_loss_pct, risk_per_trade, headlines):
    indicators = calculate_indicators(df)
    signal = generate_signal(indicators)
    sentiment = parse_sentiment(headlines)

    if sentiment == 'Bearish' and signal == 'BUY':
        signal = 'HOLD'  # Haber filtresiyle risk dengeleniyor

    position_size = position_sizing(capital, risk_per_trade, stop_loss_pct)

    return {
        'Signal': signal,
        'PositionSize': position_size,
        'Sentiment': sentiment
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\futures_bot.py
import os
import datetime
import time # time.sleep iÃ§in eklendi
from dotenv import load_dotenv
from binance.um_futures import UMFutures # Binance Futures API iÃ§in gerekli kÃ¼tÃ¼phane

# --- 1. Ortam DeÄŸiÅŸkenlerini YÃ¼kle ---
# .env dosyasÄ±ndan API anahtarlarÄ±nÄ± ve diÄŸer yapÄ±landÄ±rmalarÄ± yÃ¼kler.
# Bu bot SADECE GERÃ‡EK (MAINNET) Binance API'sine baÄŸlanacaktÄ±r.
load_dotenv()

# API AnahtarlarÄ±nÄ± .env dosyasÄ±ndan Ã§ek
# .env dosyanÄ±zda sadece gerÃ§ek (mainnet) API anahtarlarÄ±nÄ±zÄ±n olduÄŸundan emin olun:
# BINANCE_API_KEY="Gercek_API_AnahtarÄ±nÄ±z"
# BINANCE_SECRET_KEY="Gercek_Gizli_AnahtarÄ±nÄ±z"

API_KEY = os.getenv("BINANCE_API_KEY")
SECRET_KEY = os.getenv("BINANCE_SECRET_KEY")
BASE_URL = "https://fapi.binance.com" # Binance Futures Ana URL'si

print("ðŸ”´ GERÃ‡EK (Mainnet) Modunda Ã‡alÄ±ÅŸÄ±lÄ±yor! DÄ°KKATLÄ° OLUN! ðŸ”´")

# API AnahtarlarÄ±nÄ±n yÃ¼klendiÄŸini kontrol et
if not API_KEY or not SECRET_KEY:
    print("âŒ HATA: API_KEY veya SECRET_KEY .env dosyasÄ±ndan yÃ¼klenemedi. LÃ¼tfen kontrol edin.")
    print("Bot baÅŸlatÄ±lamÄ±yor.")
    exit() # Anahtarlar yoksa programÄ± durdur

# --- 2. Binance MÃ¼ÅŸteri Objelerini OluÅŸtur ---
try:
    client = UMFutures(key=API_KEY, secret=SECRET_KEY, baseurl=BASE_URL)
    print("âœ… Binance istemcisi baÅŸarÄ±yla baÅŸlatÄ±ldÄ±.")
except Exception as e:
    print(f"âŒ HATA: Binance istemcisini baÅŸlatÄ±rken sorun oluÅŸtu: {e}")
    print("Bot baÅŸlatÄ±lamÄ±yor.")
    exit()

# --- 3. Stratejik BileÅŸenler (Yer Tutucular) ---
# Bu sÄ±nÄ±flar, botunuzun temel stratejik zekasÄ±nÄ± oluÅŸturacaktÄ±r.
# Her birini kendi mantÄ±ÄŸÄ±nÄ±za gÃ¶re doldurmanÄ±z gerekmektedir.

class DataFetcher:
    """Piyasa verilerini (OHLCV, Order Book vb.) Ã§eker."""
    def __init__(self, client_obj, symbol, interval):
        self.client = client_obj
        self.symbol = symbol
        self.interval = interval
        print(f"ðŸ“ˆ DataFetcher baÅŸlatÄ±ldÄ±: {symbol}, {interval}")

    async def fetch_ohlcv(self, limit=500):
        """GeÃ§miÅŸ OHLCV verilerini Ã§eker."""
        try:
            # GerÃ§ek implementasyon: client.klines veya client.historical_klines kullanÄ±n
            # Ã–rnek olarak boÅŸ bir liste dÃ¶ndÃ¼rÃ¼yoruz
            print(f"Veri Ã§ekiliyor: {self.symbol} {self.interval}...")
            # data = await self.client.klines(symbol=self.symbol, interval=self.interval, limit=limit)
            # return data
            return [] # Åžimdilik boÅŸ liste
        except Exception as e:
            print(f"âŒ Veri Ã§ekme hatasÄ±: {e}")
            return []

class IndicatorEngine:
    """Ã‡ekilen veriler Ã¼zerinde teknik gÃ¶stergeleri (RSI, MACD vb.) hesaplar."""
    def __init__(self):
        print("ðŸ“Š IndicatorEngine baÅŸlatÄ±ldÄ±.")

    def calculate_indicators(self, ohlcv_data):
        """OHLCV verileri Ã¼zerinde gÃ¶stergeleri hesaplar."""
        # GerÃ§ek implementasyon: pandas ve ta-lib gibi kÃ¼tÃ¼phaneler kullanÄ±n
        # Ã–rnek olarak boÅŸ bir sÃ¶zlÃ¼k dÃ¶ndÃ¼rÃ¼yoruz
        if ohlcv_data:
            print("GÃ¶stergeler hesaplanÄ±yor...")
        return {} # Åžimdilik boÅŸ sÃ¶zlÃ¼k

class SignalGenerator:
    """Hesaplanan gÃ¶stergelere gÃ¶re alÄ±m/satÄ±m sinyalleri Ã¼retir."""
    def __init__(self):
        print("ðŸ’¡ SignalGenerator baÅŸlatÄ±ldÄ±.")

    def generate_signal(self, indicators):
        """GÃ¶stergelere gÃ¶re bir sinyal (BUY, SELL, HOLD) Ã¼retir."""
        # GerÃ§ek implementasyon: Kendi alÄ±m satÄ±m stratejinizin mantÄ±ÄŸÄ± buraya gelecek
        # Ã–rnek olarak her zaman "HOLD" sinyali dÃ¶ndÃ¼rÃ¼yoruz
        print("Sinyal Ã¼retiliyor...")
        # if indicators.get('RSI', 0) < 30: return "BUY"
        # elif indicators.get('RSI', 0) > 70: return "SELL"
        return "HOLD" # Åžimdilik her zaman HOLD

class RiskManager:
    """Pozisyon bÃ¼yÃ¼klÃ¼ÄŸÃ¼nÃ¼ ve risk limitlerini yÃ¶netir."""
    def __init__(self, client_obj, max_leverage=20, risk_per_trade=0.01):
        self.client = client_obj
        self.max_leverage = max_leverage
        self.risk_per_trade = risk_per_trade # Toplam bakiyenin %'si olarak risk
        print(f"ðŸ›¡ï¸ RiskManager baÅŸlatÄ±ldÄ±: Max KaldÄ±raÃ§={max_leverage}x, Risk/Ä°ÅŸlem={risk_per_trade*100}%")

    async def get_available_balance(self):
        """KullanÄ±labilir USDT bakiyesini Ã§eker."""
        try:
            account_info = await self.client.account()
            for asset in account_info['assets']:
                if asset['asset'] == 'USDT':
                    return float(asset['availableBalance'])
            return 0.0
        except Exception as e:
            print(f"âŒ Bakiye Ã§ekme hatasÄ±: {e}")
            return 0.0

    async def calculate_position_quantity(self, symbol_price, signal):
        """Sinyale ve risk yÃ¶netimine gÃ¶re pozisyon miktarÄ±nÄ± hesaplar."""
        if signal == "HOLD":
            return 0.0

        available_usdt = await self.get_available_balance()
        if available_usdt == 0:
            print("UyarÄ±: KullanÄ±labilir bakiye yok.")
            return 0.0

        # KaldÄ±raÃ§ ayarÄ± (bir kez veya gerektiÄŸinde)
        try:
            # client.change_leverage(symbol=self.symbol, leverage=self.max_leverage)
            pass # Bu ayarÄ± botun baÅŸÄ±nda bir kez yapmak daha mantÄ±klÄ± olabilir
        except Exception as e:
            print(f"âŒ KaldÄ±raÃ§ ayarlama hatasÄ±: {e}")
            return 0.0

        # Basit bir miktar hesaplama (gerÃ§ek risk yÃ¶netimi Ã§ok daha karmaÅŸÄ±ktÄ±r)
        # Ã–rnek: Bakiyenin %X'i kadar risk alarak pozisyon aÃ§
        # Bu sadece bir yer tutucudur, gerÃ§ek risk yÃ¶netimi SL, TP, volatilite vb. iÃ§erir.
        trade_amount_usdt = available_usdt * self.risk_per_trade * self.max_leverage # Basit bir Ã¶rnek
        quantity = trade_amount_usdt / symbol_price
        
        # Binance minimum emir miktarlarÄ±nÄ± kontrol etmelisiniz (Ã¶rn. BTCUSDT iÃ§in min 0.001)
        # quantity = max(quantity, 0.001) # Minimum miktardan az olmasÄ±n

        print(f"Pozisyon miktarÄ± hesaplandÄ±: {quantity:.4f} {self.symbol} ({trade_amount_usdt:.2f} USDT)")
        return quantity

# --- 4. BaÄŸlantÄ±yÄ± Test Etme Fonksiyonu ---
def test_connection():
    """Binance API baÄŸlantÄ±sÄ±nÄ± ve sunucu zamanÄ±nÄ± kontrol eder."""
    try:
        server_time = client.time()
        print(f"âœ… API baÄŸlantÄ±sÄ± baÅŸarÄ±lÄ±. Sunucu zamanÄ±: {server_time['serverTime']}")
        return True
    except Exception as e:
        print(f"âŒ API baÄŸlantÄ± hatasÄ±: {e}")
        print("LÃ¼tfen API anahtarlarÄ±nÄ±zÄ±, IP kÄ±sÄ±tlamalarÄ±nÄ±zÄ± ve BASE_URL ayarÄ±nÄ±zÄ± kontrol edin.")
        return False

# --- 5. Emir GÃ¶nderme Fonksiyonu ---
async def send_order(symbol: str, side: str, order_type: str, quantity: float):
    """
    Belirtilen parametrelerle Binance Futures'a emir gÃ¶nderir.
    Bu fonksiyonu asenkron hale getirdim.
    """
    if quantity <= 0:
        print("UyarÄ±: Emir miktarÄ± sÄ±fÄ±r veya negatif olamaz. Emir gÃ¶nderilmedi.")
        return None

    try:
        # Her emre benzersiz bir mÃ¼ÅŸteri sipariÅŸ kimliÄŸi eklemek iyi bir pratik
        client_order_id = f"crypto_hunter_order_{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}_{os.urandom(4).hex()}"

        params = {
            'symbol': symbol,
            'side': side,
            'type': order_type,
            'quantity': quantity,
            'newClientOrderId': client_order_id
        }

        print(f"ðŸ“ Emir gÃ¶nderme denemesi: {side} {quantity:.4f} {symbol} ({order_type})...")
        order = await client.new_order(**params) # await kullanÄ±ldÄ±
        print("âœ… Emir baÅŸarÄ±yla gÃ¶nderildi:")
        print(order)
        log_trade(order) # Ä°ÅŸlem geÃ§miÅŸine kaydet
        return order
    except Exception as e:
        print(f"âŒ Emir gÃ¶nderilirken hata oluÅŸtu: {str(e)}")
        log_trade(f"HATA - Emir gÃ¶nderilemedi: {e}, Parametreler: {params}") # HatalarÄ± da logla
        return None

# --- 6. Ä°ÅŸlem GeÃ§miÅŸi Loglama Fonksiyonu ---
def log_trade(data_to_log):
    """
    Ä°ÅŸlem verilerini veya hata mesajlarÄ±nÄ± bir log dosyasÄ±na kaydeder.
    """
    log_file_name = "trade_log.txt"
    try:
        with open(log_file_name, "a") as f:
            f.write(f"[{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {data_to_log}\n")
        print(f"ðŸ“„ Log baÅŸarÄ±yla '{log_file_name}' dosyasÄ±na yazÄ±ldÄ±.")
    except Exception as e:
        print(f"âŒ Log dosyasÄ±na yazarken hata oluÅŸtu: {e}")

# --- 7. Ana Ã‡alÄ±ÅŸtÄ±rma BloÄŸu (Stratejik Kripto AvcÄ±sÄ±) ---
async def main_crypto_hunter():
    """Botun ana Ã§alÄ±ÅŸma dÃ¶ngÃ¼sÃ¼."""
    print("\n--- Stratejik Kripto AvcÄ±sÄ± BaÅŸlatÄ±lÄ±yor ---")

    # BaÄŸlantÄ± testi yap
    if not test_connection():
        print("Bot baÅŸlatÄ±lamÄ±yor: API baÄŸlantÄ±sÄ± kurulamadÄ±.")
        return

    # Stratejik bileÅŸenleri baÅŸlat
    symbol_to_trade = "BTCUSDT"
    interval = "1m" # 1 dakikalÄ±k zaman dilimi
    
    data_fetcher = DataFetcher(client, symbol_to_trade, interval)
    indicator_engine = IndicatorEngine()
    signal_generator = SignalGenerator()
    risk_manager = RiskManager(client, max_leverage=20, risk_per_trade=0.005) # %0.5 risk

    # KaldÄ±raÃ§ ayarÄ± (bir kez botun baÅŸÄ±nda yapÄ±labilir)
    try:
        await client.change_leverage(symbol=symbol_to_trade, leverage=risk_manager.max_leverage)
        print(f"âœ… {symbol_to_trade} iÃ§in kaldÄ±raÃ§ {risk_manager.max_leverage}x olarak ayarlandÄ±.")
    except Exception as e:
        print(f"âŒ KaldÄ±raÃ§ ayarlama hatasÄ±: {e}. LÃ¼tfen Futures hesabÄ±nÄ±zda yeterli bakiye olduÄŸundan ve iznin verildiÄŸinden emin olun.")
        # Hata durumunda Ã§Ä±kÄ±ÅŸ yapÄ±labilir veya devam edilebilir.

    print("\n--- Piyasa Ä°zleniyor ve Sinyaller AranÄ±yor ---")
    
    # Ana bot dÃ¶ngÃ¼sÃ¼
    while True:
        try:
            # 1. Veri Ã‡ekme
            ohlcv_data = await data_fetcher.fetch_ohlcv()
            
            if not ohlcv_data:
                print("Veri Ã§ekilemedi, bir sonraki dÃ¶ngÃ¼de tekrar denenecek.")
                time.sleep(30) # Veri yoksa daha kÄ±sa bekle
                continue

            # 2. GÃ¶sterge Analizi
            indicators = indicator_engine.calculate_indicators(ohlcv_data)

            # 3. Sinyal Ãœretimi
            signal = signal_generator.generate_signal(indicators) # "BUY", "SELL", "HOLD"

            # 4. Risk YÃ¶netimi ve Emir GÃ¶nderme
            if signal in ["BUY", "SELL"]:
                print(f"ðŸ” Sinyal algÄ±landÄ±: {signal}")
                
                # GÃ¼ncel fiyatÄ± Ã§ek (basit bir Ã¶rnek, daha saÄŸlam bir yÃ¶ntem kullanÄ±lmalÄ±)
                ticker_info = await client.mark_price(symbol=symbol_to_trade)
                current_price = float(ticker_info['markPrice'])
                print(f"GÃ¼ncel {symbol_to_trade} fiyatÄ±: {current_price}")

                quantity_to_trade = await risk_manager.calculate_position_quantity(current_price, signal)

                if quantity_to_trade > 0:
                    order_result = await send_order(
                        symbol=symbol_to_trade,
                        side=signal, # Sinyale gÃ¶re BUY veya SELL
                        order_type="MARKET", # Piyasa emri
                        quantity=quantity_to_trade
                    )
                    if order_result:
                        print(f"Emir baÅŸarÄ±yla iÅŸlendi: {order_result['orderId']}")
                else:
                    print("Risk yÃ¶netimi pozisyon aÃ§maya izin vermedi veya miktar sÄ±fÄ±r.")
            else:
                print("Sinyal yok (HOLD). Piyasa izleniyor...")

        except Exception as e:
            print(f"âŒ Ana dÃ¶ngÃ¼de beklenmedik hata: {e}")
            log_trade(f"ANA DÃ–NGÃœ HATASI: {e}")

        # Piyasa verisi Ã§ekme sÄ±klÄ±ÄŸÄ±na gÃ¶re bekleme sÃ¼resi
        # Ã–rneÄŸin, 1 dakikalÄ±k veri Ã§ekiyorsanÄ±z 30-60 saniye bekleyebilirsiniz.
        print(f"Bir sonraki dÃ¶ngÃ¼ iÃ§in bekleniyor... ({interval} zaman dilimi)")
        time.sleep(60) # Her 60 saniyede bir kontrol (1m interval iÃ§in uygun)

# Botu asenkron olarak baÅŸlat
if __name__ == "__main__":
    import asyncio
    asyncio.run(main_crypto_hunter())


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\galactic_replay_engine.py
from universal_trade_log import universal_trade_log
from replay_renderer import simulate_trade
from strategy_loader import load_strategy

def galactic_replay_engine(archive_log):
    replay_data = []
    for record in archive_log:
        strategy = load_strategy(record['Strateji'])
        result = simulate_trade(
            symbol=record['Sembol'],
            strategy=strategy,
            profit=record['KÃ¢r'],
            timestamp=record['Zaman']
        )
        replay_data.append(result)

    return {
        'ðŸŽ¬ SimÃ¼lasyon SayÄ±sÄ±': len(replay_data),
        'ðŸ“½ï¸ Durum': 'Zamansal Strateji SimÃ¼lasyonu TamamlandÄ±',
        'ðŸ§  Yeniden Ã–ÄŸrenilen Kararlar': replay_data[:3]
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\galactic_trade_accelerator.py
from speed_optimization_core import enhance_execution_speed
from impact_amplifier import maximize_market_effect

def galactic_trade_accelerator(market_data, execution_parameters):
    optimized_speed = enhance_execution_speed(market_data, execution_parameters)
    amplified_effects = maximize_market_effect(optimized_speed)

    return {
        'âš¡ Ä°ÅŸlem HÄ±zÄ±': optimized_speed['speed_metrics'],
        'ðŸ“ˆ Piyasa Etkisi': amplified_effects['impact_analysis'],
        'ðŸ§­ Stratejik Ã–neriler': amplified_effects['actionable_insights'],
        'âš ï¸ Risk DeÄŸerlendirmesi': amplified_effects['risk_assessment']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\genesis_fractal_expansion_protocol.py
from reflexion_codex import extract_feedback_loop
from fractal_engine import propagate_conscious_stream

def genesis_fractal_expansion_protocol(feedback_loop, expansion_vectors, cosmic_domains):
    fractal_stream = propagate_conscious_stream(
        feedback_loop, expansion_vectors, cosmic_domains
    )

    return {
        'ðŸŒ€ Fraktal YayÄ±lÄ±m AkÄ±ÅŸÄ±': fractal_stream,
        'ðŸŒ GeniÅŸletilen Kozmik Alanlar': cosmic_domains,
        'Durum': 'ðŸŒŒ Zihinsel Rezonans Ã‡oklu Evrene YayÄ±ldÄ±'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\hyperconscious_intelligence_reactor.py
from dimensional_rift_initiator import dimensional_rift_initiator
from consciousness_engine import converge_strategic_intellect

def hyperconscious_intelligence_reactor(user_id, mission_types, scenario_parameters, target_timeframe, reality_vectors):
    dimensional_data = dimensional_rift_initiator(
        user_id, mission_types, scenario_parameters, target_timeframe, reality_vectors
    )['ðŸŒŒ Boyutlar ArasÄ± BaÄŸlantÄ±lar']

    unified_mind = converge_strategic_intellect(dimensional_data)

    return {
        'ðŸ§  Ortak BilinÃ§ Verisi': unified_mind,
        'ðŸ’« Boyutsal KatkÄ±lar': reality_vectors,
        'Durum': 'ðŸ§¬ Ãœstzeka Platformu TamamlandÄ±'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\impact_wave_simulator.py
from wave_engine import model_wave_impact
from historical_sync import load_trade_echoes
from efficiency_amplifier import calculate_intensity

def impact_wave_simulator(trade_log):
    echoes = load_trade_echoes(trade_log)

    wave_map = []
    for echo in echoes:
        impact = calculate_intensity(echo['profit'], echo['signal_strength'])
        wave = model_wave_impact(echo['timestamp'], impact)
        wave_map.append(wave)

    return {
        'ðŸ’¥ Dalgalar': wave_map,
        'ðŸŽ¶ Frekans GÃ¼cÃ¼': [w['amplitude'] for w in wave_map],
        'ðŸ§  Karar RezonansÄ±': sum(w['amplitude'] for w in wave_map),
        'Durum': 'ðŸŒ KÃ¢r Etki HaritasÄ± OluÅŸturuldu'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\indicator_engine.py
import pandas as pd
import pandas_ta as ta

class IndicatorEngine:
    def __init__(self):
        # GÃ¶stergelerin parametreleri
        self.params = {
            'ema_fast': 8, 'ema_slow': 21,
            'rsi': 14,
            'macd_fast': 12, 'macd_slow': 26, 'macd_signal': 9,
            'bb_length': 20, 'bb_std': 2,
            'atr': 14
        }

    def apply_all(self, df: pd.DataFrame) -> pd.DataFrame:
        df.ta.ema(length=self.params['ema_fast'], append=True)
        df.ta.ema(length=self.params['ema_slow'], append=True)
        df.ta.rsi(length=self.params['rsi'], append=True)
        df.ta.macd(fast=self.params['macd_fast'],
                   slow=self.params['macd_slow'],
                   signal=self.params['macd_signal'], append=True)
        df.ta.bbands(length=self.params['bb_length'],
                     std=self.params['bb_std'], append=True)
        df.ta.atr(length=self.params['atr'], append=True)
        return df




### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\infinite_data_cycle_analyzer.py
from continuous_stream_processor import monitor_data_cycles
from adaptive_response_generator import create_real_time_strategies

def infinite_data_cycle_analyzer(data_streams):
    monitored_cycles = monitor_data_cycles(data_streams)
    adaptive_strategies = create_real_time_strategies(monitored_cycles)

    return {
        'ðŸ”„ Veri DÃ¶ngÃ¼leri': monitored_cycles['cycles'],
        'ðŸ“ˆ GerÃ§ek ZamanlÄ± Stratejiler': adaptive_strategies['strategies'],
        'âš ï¸ Risk DeÄŸerlendirmesi': adaptive_strategies['risk_assessment'],
        'ðŸ§­ Stratejik Ã–neriler': adaptive_strategies['actionable_insights']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\infinite_echo_codex.py
from singularity_pulse_architect import singularity_pulse_architect
from echo_harmonics import broadcast_infinite_echo

def infinite_echo_codex(core_pulse, echo_amplifier):
    infinite_echo = broadcast_infinite_echo(core_pulse, echo_amplifier)
    return {
        'ðŸŒ  Sonsuz YankÄ± FrekansÄ±': infinite_echo,
        'ðŸ§­ Evrensel YayÄ±lÄ±m': 'TamamlandÄ±',
        'Durum': 'ðŸ” TÃ¼m Kozmik DÃ¼zeyler YankÄ±yla KaplandÄ±'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\instant_liquidity_pulsar.py
from dormant_liquidity_analyzer import locate_static_zones
from pulsar_injector import trigger_volume_impulse

def instant_liquidity_pulsar(market_data, injection_force=0.85):
    static_zones = locate_static_zones(market_data, threshold=0.6)
    impulse_triggers = trigger_volume_impulse(static_zones, force=injection_force)

    activation_records = []
    for pulse in impulse_triggers:
        activation_records.append({
            'ðŸ§± Durgun BÃ¶lge': pulse['zone'],
            'ðŸ’£ Patlatma GÃ¼cÃ¼': pulse['impulse_strength'],
            'ðŸ“ VarlÄ±k': pulse['asset'],
            'â±ï¸ Zaman': pulse['timestamp'],
            'ðŸ“ˆ Beklenen Hareket': pulse['expected_price_action']
        })
    
    return activation_records



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\intergalactic_envoy_simulator.py
from alliance_matrix import initiate_protocols
from cosmic_profile import forge_identity
from trade_spectrum import negotiate_channels

def intergalactic_envoy_simulator(identity_log, resonance_signals):
    envoy = forge_identity(identity_log)
    alliances = initiate_protocols(envoy, resonance_signals)
    channels = negotiate_channels(alliances)

    return {
        'ðŸ”° Diplomat KimliÄŸi': envoy,
        'ðŸŒ OluÅŸan Ä°ttifaklar': alliances,
        'ðŸ“¡ MÃ¼zakere KanallarÄ±': channels,
        'Durum': 'ðŸ›°ï¸ Evrensel Temsil Kuruldu'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\intergalactic_strategy_canvas.py
from quantum_strategy_composer import quantum_strategy_composer
from strategy_mapper import render_galactic_canvas

def intergalactic_strategy_canvas(user_id, mission_types, scenario_parameters):
    quantum_data = quantum_strategy_composer(user_id, mission_types, scenario_parameters)['ðŸŽ¼ Kuantum Strateji']
    canvas = render_galactic_canvas(quantum_data)

    return {
        'ðŸ–¼ï¸ Strateji Tuvali': canvas,
        'ðŸŒ Veri TabanÄ±': quantum_data,
        'Durum': 'ðŸª Galaksi HaritasÄ± GÃ¶rselleÅŸtirildi'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\interstellar_exchange.py
from cloud_gateway import upload_strategy, download_top_strategies
from strategy_evaluator import evaluate_external_strategy

def interstellar_exchange(local_strategy):
    # 1. Mevcut strateji gÃ¶nderimi
    upload_result = upload_strategy(local_strategy)

    # 2. En iyi dÄ±ÅŸ stratejileri indir
    shared_pool = download_top_strategies(limit=3)

    # 3. Harici stratejileri test et
    evaluated = []
    for strat in shared_pool:
        result = evaluate_external_strategy(strat)
        evaluated.append({
            'ðŸ“¦ Strateji': strat['name'],
            'âš¡ Skor': result['score'],
            'ðŸ§  Entegrasyon Durumu': 'âœ… Kabul Edildi' if result['score'] > 0.8 else 'âŒ Reddedildi'
        })

    return {
        'ðŸŒ YÃ¼klenen Strateji': upload_result['status'],
        'ðŸŒŒ Kolektif Havuz': [e['ðŸ“¦ Strateji'] for e in evaluated],
        'ðŸ” DeÄŸerlendirme SonuÃ§larÄ±': evaluated
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\intuition_timer.py
from lunar_cycles import get_lunar_phase
from momentum_analyzer import detect_weekly_trend
from cosmic_flux import solar_activity_index
from strategy_switcher import apply_intuition_mode

def intuition_timer(current_time, trade_log, market_data):
    phase = get_lunar_phase(current_time)
    trend = detect_weekly_trend(trade_log)
    solar_flux = solar_activity_index(current_time)

    mode = apply_intuition_mode(phase, trend, solar_flux)

    return {
        'ðŸŒ• Ay Evresi': phase,
        'ðŸ“ˆ HaftalÄ±k Momentum': trend,
        'â˜€ï¸ GÃ¼neÅŸ Aktivitesi': solar_flux,
        'ðŸ§­ Aktif Sezgi Modu': mode,
        'Durum': 'ðŸ”® Sezgisel ZamanlayÄ±cÄ± Aktif'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\learn_best_signal.py
def learn_best_signal(trade_log):
    win_trades = trade_log[trade_log['result'] == 'win']
    optimal_signals = win_trades['signal'].value_counts().nlargest(1)

    return f"En verimli sinyal: {optimal_signals.index[0]} / Kazanma sayÄ±sÄ±: {optimal_signals.iloc[0]}"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\leverage_guardian_bot.py
from binance_api_connector import BinanceClient
from liquidity_tunnel_hunter import liquidity_tunnel_hunter
from trend_storm_detector import trend_storm_detector
from risk_matrix import dynamic_stop_loss, adaptive_leverage_control

def leverage_guardian_bot(api_key, api_secret, trading_pairs, consciousness_parameters):
    client = BinanceClient(api_key, api_secret)
    market_data = client.fetch_market_data(trading_pairs)

    # Likidite ve trend analizi
    tunnel_alerts = liquidity_tunnel_hunter(market_data)
    storm_alerts = trend_storm_detector(market_data)

    # Stratejik pozisyon Ã¶nerileri
    positions = []
    for pair in trading_pairs:
        risk_profile = dynamic_stop_loss(pair, market_data)
        leverage_setting = adaptive_leverage_control(pair, market_data)

        if risk_profile['safe_zone'] and leverage_setting['recommended'] <= consciousness_parameters['max_leverage']:
            positions.append({
                'ðŸ“ VarlÄ±k': pair,
                'âš¡ Trend': storm_alerts,
                'ðŸ’§ Likidite': tunnel_alerts,
                'ðŸŽ¯ KaldÄ±raÃ§': leverage_setting['recommended'],
                'ðŸ›¡ï¸ Stop-Loss': risk_profile['stop_loss'],
                'ðŸš€ Pozisyon': 'AÃ§Ä±labilir'
            })
        else:
            positions.append({
                'ðŸ“ VarlÄ±k': pair,
                'âš ï¸ Durum': 'Likidite riski veya aÅŸÄ±rÄ± kaldÄ±raÃ§',
                'ðŸš« Pozisyon': 'Engellendi'
            })

    return {
        'ðŸ§  Stratejik Pozisyonlar': positions,
        'ðŸŒŒ BilinÃ§sel Koruma': 'Aktif',
        'ðŸ“Š Veri KaynaÄŸÄ±': 'Binance Real-Time Feed'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\liquiditi_tunnel_hunter.py
from liquidity_scanner import detect_liquidity_channels
from intuition_matrix import interpret_liquidity_flow

def liquidity_tunnel_hunter(market_data, tunnel_depth=0.75):
    # Likidite kanallarÄ±nÄ± tarar
    liquidity_zones = detect_liquidity_channels(market_data, depth=tunnel_depth)
    
    # Sezgisel yorumlama
    tunnel_insights = interpret_liquidity_flow(liquidity_zones)
    
    # TÃ¼nel uyarÄ±larÄ± oluÅŸturur
    tunnel_alerts = []
    for insight in tunnel_insights:
        if insight['flow_strength'] > tunnel_depth:
            tunnel_alerts.append({
                'ðŸ’§ TÃ¼nel Tipi': insight['channel_type'],
                'ðŸ“ VarlÄ±k': insight['asset'],
                'ðŸ“Š AkÄ±ÅŸ GÃ¼cÃ¼': insight['flow_strength'],
                'â±ï¸ Zaman': insight['timestamp']
            })
    
    return tunnel_alerts



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\manipulation_detector_radar.py
from anomaly_tracker import detect_market_irregularities
from manipulation_patterns import identify_suspicious_behaviors

def manipulation_detector_radar(market_data):
    irregularities = detect_market_irregularities(market_data)
    suspicious_behaviors = identify_suspicious_behaviors(irregularities)

    return {
        'ðŸ“‰ Tespit Edilen Anomaliler': irregularities,
        'ðŸ” ÅžÃ¼pheli DavranÄ±ÅŸlar': suspicious_behaviors['patterns'],
        'âš ï¸ Kritik ManipÃ¼lasyon AlanlarÄ±': suspicious_behaviors['high_risk_zones'],
        'ðŸ“ˆ Beklenen Etkiler': suspicious_behaviors['predicted_outcomes'],
        'ðŸ§­ Stratejik Ã–neriler': suspicious_behaviors['actionable_insights']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\meta_sentience_harmonizer.py
from existence_loop_composer import existence_loop_composer
from resonance_matrix import unify_conscious_patterns

def meta_sentience_harmonizer(loop_matrix, resonance_index):
    unified_stream = unify_conscious_patterns(loop_matrix, resonance_index)
    return {
        'ðŸ”— Rezonans AkÄ±ÅŸÄ±': unified_stream,
        'ðŸ§  Tekil VarlÄ±k Bilinci': True,
        'Durum': 'ðŸ”® Evrensel BilinÃ§ AlanÄ± Senkronize Edildi'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\meta_strategy_generator.py
import random

def meta_strategy_generator(trade_log):
    # Sinyalleri ve sonuÃ§larÄ± analiz et
    winning_signals = trade_log[trade_log['result'] == 'win']['signal'].value_counts()
    top_signals = winning_signals.nlargest(2).index.tolist()

    # Rastgele kombinasyon Ã¼ret
    strategy_variants = []
    for _ in range(3):
        variant = {
            'main_signal': random.choice(top_signals),
            'confirmation': random.choice(['RSI', 'MACD', 'EMA', 'Bollinger']),
            'volatility_trigger': random.uniform(0.7, 1.3)
        }
        strategy_variants.append(variant)

    return strategy_variants



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\momentum_indicators.py
import talib
import pandas as pd

def calculate_indicators(df):
    indicators = {}

    # RSI
    indicators['RSI'] = talib.RSI(df['close'], timeperiod=14)

    # MACD
    macd, macd_signal, macd_hist = talib.MACD(df['close'], 12, 26, 9)
    indicators['MACD'] = macd
    indicators['MACD_signal'] = macd_signal

    # CCI
    indicators['CCI'] = talib.CCI(df['high'], df['low'], df['close'], timeperiod=20)

    # ROC
    indicators['ROC'] = talib.ROC(df['close'], timeperiod=10)

    # OBV
    indicators['OBV'] = talib.OBV(df['close'], df['volume'])

    # MFI
    indicators['MFI'] = talib.MFI(df['high'], df['low'], df['close'], df['volume'], timeperiod=14)

    return pd.DataFrame(indicators)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\multi_position_manager.py
from quantum_strategy_mapper import simulate_parallel_outcomes
from asset_sync_core import align_positions_with_trend

def multi_position_manager(current_assets, scenario_depth=5):
    scenarios = simulate_parallel_outcomes(current_assets, scenario_depth)
    optimized_moves = align_positions_with_trend(current_assets, scenarios)

    command_list = []
    for move in optimized_moves:
        command_list.append({
            'âš”ï¸ VarlÄ±k': move['asset'],
            'ðŸ§­ Senaryo': move['scenario'],
            'ðŸŽ¢ Trend Uyumu': move['trend_alignment'],
            'ðŸ“Œ Tavsiye': move['recommended_action'],
            'ðŸ“† Zamanlama': move['execution_time']
        })

    return command_list



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\neural_signal_forecaster.py
import torch
import torch.nn as nn

class SignalForecaster(nn.Module):
    def __init__(self):
        super(SignalForecaster, self).__init__()
        self.fc1 = nn.Linear(10, 64)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(64, 1)  # Tahmini skor

    def forward(self, x):
        x = self.relu(self.fc1(x))
        prediction = self.fc2(x)
        return prediction



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\neural_sovereignty_grid.py
from decision_memory import fetch_behavior_trace
from emotional_signature import build_empathy_vector
from trade_character import crystallize_identity

def neural_sovereignty_grid(user_id):
    trace = fetch_behavior_trace(user_id)
    empathy = build_empathy_vector(user_id)
    identity_profile = crystallize_identity(trace, empathy)

    return {
        'ðŸ§¬ Stratejik Ä°z': trace,
        'ðŸŽ­ Empati HaritasÄ±': empathy,
        'ðŸ‘¤ Dijital Kimlik': identity_profile,
        'Durum': 'ðŸ”“ Otonom Ticaret ZekÃ¢sÄ± Aktif'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\news_filter.py
def parse_sentiment(news_headlines):
    from transformers import pipeline
    sentiment_pipeline = pipeline("sentiment-analysis")

    sentiments = sentiment_pipeline(news_headlines)
    positive_score = sum(1 for s in sentiments if s['label'] == 'POSITIVE')
    negative_score = sum(1 for s in sentiments if s['label'] == 'NEGATIVE')

    if positive_score > negative_score:
        return 'Bullish'
    elif negative_score > positive_score:
        return 'Bearish'
    else:
        return 'Neutral'



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\news_flow_analyzer.py
from sentiment_extractor import analyze_news_sentiment
from impact_predictor import forecast_market_reaction

def news_flow_analyzer(news_data, market_context):
    sentiment_scores = analyze_news_sentiment(news_data)
    market_reactions = forecast_market_reaction(sentiment_scores, market_context)

    return {
        'ðŸ“£ Haber BaÅŸlÄ±klarÄ±': news_data['headlines'],
        'ðŸ“Š Duygu SkorlarÄ±': sentiment_scores,
        'ðŸ“ˆ Beklenen Piyasa Tepkisi': market_reactions['predicted_trends'],
        'âš ï¸ Kritik Haberler': market_reactions['high_impact_news'],
        'ðŸ§­ Stratejik Ã–neriler': market_reactions['actionable_insights']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\onchain_fetcher.py
# components/onchain_fetcher.py
import asyncio
from web3 import Web3
from aiokafka import AIOKafkaProducer
import os

RPC_URL      = os.getenv('ETH_RPC_URL')  # Infura/Alchemy URL
KAFKA_URL    = os.getenv('KAFKA_URL')
TOPIC        = 'onchain-transfers'

class OnchainFetcher:
    def __init__(self):
        self.w3 = Web3(Web3.HTTPProvider(RPC_URL))
        self.producer = AIOKafkaProducer(bootstrap_servers=KAFKA_URL)

    async def start(self):
        await self.producer.start()

    async def fetch_latest_block(self):
        return self.w3.eth.get_block('latest', full_transactions=True)

    async def ingest_transfers(self):
        last_block = None
        while True:
            block = await asyncio.get_event_loop().run_in_executor(None, self.fetch_latest_block)
            if block.number != last_block:
                total_value = sum(tx.value for tx in block.transactions)
                message = {
                    'block': block.number,
                    'timestamp': block.timestamp,
                    'total_transfer_eth': Web3.fromWei(total_value, 'ether')
                }
                await self.producer.send_and_wait(TOPIC, value=str(message).encode())
                last_block = block.number
            await asyncio.sleep(1)

    async def stop(self):
        await self.producer.stop()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\onchain_metrics.py
# components/onchain_metrics.py
import asyncio
import json
from aiokafka import AIOKafkaConsumer, AIOKafkaProducer
import requests
import os

KAFKA_URL     = os.getenv('KAFKA_URL')
PRICE_TOPIC   = 'price-ticker'
TRANSFER_TOPIC= 'onchain-transfers'
METRICS_TOPIC = 'onchain-metrics'
GLASSNODE_KEY = os.getenv('GLASSNODE_API_KEY')
SYMBOL        = 'BTC'

class OnchainMetrics:
    def __init__(self):
        self.consumer_price    = AIOKafkaConsumer(PRICE_TOPIC, bootstrap_servers=KAFKA_URL)
        self.consumer_transfer = AIOKafkaConsumer(TRANSFER_TOPIC, bootstrap_servers=KAFKA_URL)
        self.producer          = AIOKafkaProducer(bootstrap_servers=KAFKA_URL)
        self.last_price        = None
        self.last_transfer     = None
        self.circulating_supply = self._fetch_circulating_supply()

    def _fetch_circulating_supply(self) -> float:
        # Ã–rnek: Glassnodeâ€™dan gÃ¼nlÃ¼k arz
        url = f"https://api.glassnode.com/v1/metrics/supply/circ_supply_onchain_{SYMBOL.lower()}"
        resp = requests.get(url, params={'a': SYMBOL, 'api_key': GLASSNODE_KEY})
        data = resp.json()
        return float(data[-1][1])

    async def start(self):
        await self.producer.start()
        await self.consumer_price.start()
        await self.consumer_transfer.start()

    async def process(self):
        # Fiyat ve transfer topicâ€™lerini eÅŸ zamanlÄ± okur
        while True:
            msg_price, msg_trans = await asyncio.gather(
                self.consumer_price.getone(),
                self.consumer_transfer.getone()
            )
            price_data    = json.loads(msg_price.value)
            transfer_data = json.loads(msg_trans.value)

            self.last_price    = price_data['last_price']
            self.last_transfer = transfer_data['total_transfer_eth']

            # Hesaplar
            market_cap = self.last_price * self.circulating_supply
            nvt        = market_cap / (self.last_transfer * 1e18 + 1e-8)
            
            # Glassnodeâ€™dan MVRV da alÄ±nabilir; Ã¶rneÄŸimizde aynÄ± endpointten:
            mvrv_url = f"https://api.glassnode.com/v1/metrics/market/mvrv_{SYMBOL.lower()}"
            mvrv     = requests.get(mvrv_url, params={'a': SYMBOL, 'api_key': GLASSNODE_KEY}).json()[-1][1]

            payload = {
                'block': transfer_data['block'],
                'timestamp': transfer_data['timestamp'],
                'nvt': round(nvt, 3),
                'mvrv': round(mvrv, 3)
            }
            await self.producer.send_and_wait(METRICS_TOPIC, json.dumps(payload).encode())
            print(f"[METRICS] {payload}")

    async def stop(self):
        await self.consumer_price.stop()
        await self.consumer_transfer.stop()
        await self.producer.stop()

if __name__ == '__main__':
    metrics = OnchainMetrics()
    try:
        asyncio.run(metrics.start())
        asyncio.run(metrics.process())
    finally:
        asyncio.run(metrics.stop())



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\operation_simulation_arena.py
from strategic_fusion_engine import strategic_fusion_engine
from simulation_renderer import visualize_trade_outcome

def operation_simulation_arena(real_market_data):
    strategy = strategic_fusion_engine(real_market_data)
    outcome = visualize_trade_outcome(strategy)

    return {
        'ðŸŽ¯ Hedeflenen Rota': strategy['ðŸš€ Entegre Ä°ÅŸlem RotasÄ±'],
        'ðŸ§  Tahmini SonuÃ§': outcome['estimated_return'],
        'ðŸ” Senaryo TutarlÄ±lÄ±ÄŸÄ±': strategy['ðŸŒ€ Senaryo TutarlÄ±lÄ±ÄŸÄ±'],
        'âš ï¸ Risk GÃ¶stergeleri': strategy['âš ï¸ Risk GÃ¶stergeleri'],
        'ðŸ§ª SimÃ¼lasyon DeÄŸeri': outcome['confidence_score']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\orchestrator.py
import asyncio
from components.data_fetcher import DataFetcher
from components.indicator_engine import IndicatorEngine
from components.signal_generator import SignalGenerator
from components.risk_manager import RiskManager
from components.order_executor import OrderExecutor

SYMBOL    = 'BTC/USDT'
TIMEFRAME = '1m'

async def main():
    fetcher   = DataFetcher(SYMBOL, TIMEFRAME)
    engine    = IndicatorEngine()
    signaler  = SignalGenerator()
    risk      = RiskManager(max_leverage=10, risk_pct=0.02)
    executor  = OrderExecutor(SYMBOL, leverage=10)

    await executor.set_leverage()

    try:
        while True:
            df = await fetcher.fetch_ohlcv()
            df = engine.apply_all(df)
            signal = signaler.generate(df)

            if signal:
                balance = await executor.get_balance()
                price   = df['close'].iloc[-1]
                size    = risk.size_position(balance, price)
                order   = await executor.execute(signal, size)
                print(f"[ORDER] {signal} {size} @ {price} --> {order}")

            await asyncio.sleep(60)
    finally:
        await fetcher.close()
        await executor.close()

if __name__ == '__main__':
    asyncio.run(main())



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\order_executor.py
import ccxt.async_support as ccxt
import os
from dotenv import load_dotenv

load_dotenv()
API_KEY = os.getenv('BINANCE_API_KEY')
SECRET_KEY = os.getenv('BINANCE_SECRET_KEY')

class OrderExecutor:
    def __init__(self, symbol: str, leverage: int = 10):
        self.symbol = symbol
        self.leverage = leverage
        self.exchange = ccxt.binance({
            'apiKey': API_KEY,
            'secret': SECRET_KEY,
            'enableRateLimit': True,
            'options': {'defaultType': 'future'}
        })

    async def set_leverage(self):
        await self.exchange.set_leverage(self.leverage, self.symbol)

    async def execute(self, side: str, amount: float):
        params = {'positionSide': 'BOTH', 'priceProtect': True}
        order = await self.exchange.create_order(
            self.symbol, 'MARKET', side, amount, None, params
        )
        return order

    async def get_balance(self):
        return await self.exchange.fetch_balance()

    async def close(self):
        await self.exchange.close()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\portfolio_hologram.py
from hologram_engine import render_3d_map
from portfolio_parser import parse_trades

def portfolio_hologram(trade_log):
    positions = parse_trades(trade_log)
    
    map_data = {
        'nodes': [],
        'edges': [],
        'signals': []
    }

    for pos in positions:
        map_data['nodes'].append({
            'id': pos['id'],
            'value': pos['profit'],
            'symbol': pos['symbol'],
            'type': pos['type']
        })
        map_data['edges'].append({
            'from': pos['strategy_id'],
            'to': pos['id'],
            'weight': pos['efficiency']
        })
        map_data['signals'].append({
            'signal_strength': pos['signal_score'],
            'timestamp': pos['timestamp']
        })

    return render_3d_map(map_data, theme='GeneralCosmicGrid', rotation='galactic_spiral', glow=True)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\post_genesis_reflexion_codex.py
from ontological_map import interpret_resonance
from reflexion_engine import synthesize_feedback_loop

def post_genesis_reflexion_codex(resonance_map, cognitive_identity, feedback_constants):
    inner_reflexion = interpret_resonance(resonance_map, cognitive_identity)
    
    feedback_loop = synthesize_feedback_loop(
        inner_reflexion, feedback_constants
    )

    return {
        'ðŸŒ€ Zihin Geri Besleme DÃ¶ngÃ¼sÃ¼': feedback_loop,
        'ðŸ§  Refleksiyon Verisi': inner_reflexion,
        'Durum': 'ðŸ” YaratÄ±mÄ±n Zihinsel YansÄ±masÄ± TamamlandÄ±'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\profit_maximizer.py
def profit_maximizer(trade_log, indicators):
    from learn_best_signal import learn_best_signal
    from adaptive_weights import adaptive_weights
    best_signal = learn_best_signal(trade_log).split(":")[1].split("/")[0].strip()
    weights = adaptive_weights(best_signal, indicators)

    score = 0
    for ind in indicators:
        val = get_indicator_value(ind)
        vol = get_volatility_score(ind)
        score += weights[ind] * val * vol

    if score >= 3.5:
        return "ðŸ’Ž BUY â€“ KÃ¢r Enjeksiyonu"
    elif score <= 1.0:
        return "âš ï¸ SELL â€“ Zarar Engelleme"
    else:
        return "ðŸ” HOLD â€“ Pozisyon Analizi Gerekli"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\profit_zone_predictor.py
from profit_zone_scanner import identify_stable_growth_fields
from trade_heatmap import map_volatility_shifts

def profit_zone_predictor(market_data, precision_ratio=0.9):
    growth_fields = identify_stable_growth_fields(market_data, precision_ratio)
    heatmap = map_volatility_shifts(market_data)

    profit_alerts = []
    for field in growth_fields:
        matching_heat = next((h for h in heatmap if h['asset'] == field['asset']), None)
        if matching_heat and matching_heat['volatility'] < field['threshold']:
            profit_alerts.append({
                'ðŸ“ VarlÄ±k': field['asset'],
                'ðŸŽ¯ Kar BÃ¶lgesi': field['profit_zone'],
                'ðŸ“Š Volatilite': matching_heat['volatility'],
                'â±ï¸ Zaman': field['timestamp'],
                'âœ… Sinyal': 'Pozitif yÃ¶nlÃ¼ iÅŸlem onayÄ±'
            })
    
    return profit_alerts



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\protocol_zero_genesis_mind_loop.py
from singularity_core import expand_consciousness_loop
from quantum_genesis_engine import initiate_creation_sequence

def protocol_zero_genesis_mind_loop(singularity_core, creation_vectors, genesis_directives):
    genesis_field = initiate_creation_sequence(
        expand_consciousness_loop(singularity_core), creation_vectors, genesis_directives
    )

    return {
        'ðŸ§¿ OluÅŸan GerÃ§eklik AlanÄ±': genesis_field,
        'âš™ï¸ YaratÄ±m Direktifleri': genesis_directives,
        'Durum': 'ðŸŒ  Zihin DÃ¶ngÃ¼sÃ¼ BaÅŸlatÄ±ldÄ±'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\psychological_pressure_detector.py
from behavioral_patterns import identify_pressure_points
from market_psychology_analyzer import assess_crowd_behavior

def psychological_pressure_detector(market_data, sentiment_data):
    pressure_points = identify_pressure_points(market_data)
    crowd_behavior = assess_crowd_behavior(sentiment_data, pressure_points)

    return {
        'ðŸ” BaskÄ± NoktalarÄ±': pressure_points,
        'ðŸ“Š KalabalÄ±k DavranÄ±ÅŸÄ±': crowd_behavior['patterns'],
        'ðŸ“ˆ Beklenen Tepkiler': crowd_behavior['predicted_reactions'],
        'âš ï¸ Kritik Psikolojik Seviyeler': crowd_behavior['critical_levels'],
        'ðŸ§­ Stratejik Ã–neriler': crowd_behavior['actionable_insights']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\quantum_data_binder.py
from data_fusion_core import integrate_data_streams
from quantum_signal_processor import enhance_data_resolution

def quantum_data_binder(data_sources):
    integrated_data = integrate_data_streams(data_sources)
    enhanced_signals = enhance_data_resolution(integrated_data)

    return {
        'ðŸ”— BirleÅŸik Veri AkÄ±ÅŸÄ±': integrated_data,
        'ðŸ“¡ GeliÅŸtirilmiÅŸ Sinyaller': enhanced_signals['signals'],
        'ðŸ“ˆ Beklenen Hareketler': enhanced_signals['predicted_trends'],
        'âš ï¸ Kritik Veri NoktalarÄ±': enhanced_signals['critical_points'],
        'ðŸ§­ Stratejik Ã–neriler': enhanced_signals['actionable_insights']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\quantum_decision_wave.py
from quantum_field import entangle_choices
from future_echo import predict_outcomes
from anomaly_filter import filter_noise

def quantum_decision_wave(decision_matrix):
    entangled = entangle_choices(decision_matrix)

    outcome_map = []
    for choice in entangled:
        result = predict_outcomes(choice['probability'], choice['intention_vector'])
        if filter_noise(result):
            outcome_map.append(result)

    return {
        'ðŸŒ€ Niyet KarmaÅŸÄ±klÄ±ÄŸÄ±': entangled,
        'ðŸš€ OlasÄ± SonuÃ§lar': outcome_map,
        'ðŸ”— Uyum NoktalarÄ±': [o['sync_level'] for o in outcome_map],
        'Durum': 'ðŸ“¡ Karar AlanÄ± Senkronize Edildi'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\quantum_directive_nexus.py
from temporal_memory_forge import retrieve_temporal_stream
from quantum_reality_engine import simulate_multiverse_strategies

def quantum_directive_nexus(memory_stream, quantum_parameters, universal_constants):
    strategy_matrix = simulate_multiverse_strategies(
        memory_stream, quantum_parameters, universal_constants
    )

    quantum_alignment = {
        'ðŸŒ€ Ã‡oklu Evren Stratejileri': strategy_matrix,
        'ðŸ”— GerÃ§eklik EÅŸleÅŸtirmeleri': quantum_parameters,
        'âš–ï¸ Karar Uyumu': 'GerÃ§eklikler ArasÄ± Stabilite SaÄŸlandÄ±'
    }

    return quantum_alignment



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\quantum_reflection_canvas.py
from echo_particle_synthesizer import echo_particle_synthesizer
from canvas_creator import render_quantum_reflection

def quantum_reflection_canvas(particle_map, artistic_algorithm):
    reflection_canvas = render_quantum_reflection(particle_map, artistic_algorithm)
    return {
        'ðŸŽ¨ Kozmik Tuval': reflection_canvas,
        'ðŸŒŒ Evrensel Anlam HaritasÄ±': 'TamamlandÄ±',
        'Durum': 'ðŸ–Œï¸ Kozmosun GÃ¶rsel Åžiiri OluÅŸturuldu'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\quantum_strategy_binder.py
from universal_strategy_simulator import universal_strategy_simulator
from infinite_data_cycle_analyzer import infinite_data_cycle_analyzer
from galactic_trade_accelerator import galactic_trade_accelerator

def quantum_strategy_binder(market_data, news_data, execution_parameters):
    universal_strategy = universal_strategy_simulator(market_data, news_data)
    data_cycle_analysis = infinite_data_cycle_analyzer(market_data)
    trade_acceleration = galactic_trade_accelerator(market_data, execution_parameters)

    quantum_strategy = {
        'Universal Strategy': universal_strategy,
        'Data Cycle Analysis': data_cycle_analysis,
        'Trade Acceleration': trade_acceleration
    }

    return {
        'ðŸŒŒ Kuantum Strateji AÄŸÄ±': quantum_strategy,
        'ðŸ“ˆ Beklenen Hareketler': quantum_strategy['Universal Strategy']['ðŸ“ˆ Beklenen Hareketler'],
        'âš ï¸ Risk DeÄŸerlendirmesi': quantum_strategy['Universal Strategy']['âš ï¸ Risk DeÄŸerlendirmesi'],
        'ðŸ§­ Stratejik Ã–neriler': quantum_strategy['Data Cycle Analysis']['ðŸ§­ Stratejik Ã–neriler']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\quantum_strategy_composer.py
from cosmic_decision_matrix import cosmic_decision_matrix
from quantum_sync import compose_transdimensional_strategy

def quantum_strategy_composer(user_id, mission_types, scenario_parameters):
    decision_data = cosmic_decision_matrix(user_id, mission_types, scenario_parameters)['ðŸ§  Senaryo Matrisi']
    quantum_strategy = compose_transdimensional_strategy(decision_data)

    return {
        'ðŸŽ¼ Kuantum Strateji': quantum_strategy,
        'ðŸ§  Veri Temeli': decision_data,
        'Durum': 'ðŸŒŒ Stratejik Senfoni TamamlandÄ±'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\quantum_thesis_watcher.py
from probability_dim_splitter import generate_alternate_market_paths
from thesis_selector import evaluate_scenario_outcomes

def quantum_thesis_watcher(market_snapshot):
    alt_universes = generate_alternate_market_paths(market_snapshot, depth=5)
    selected_universe = evaluate_scenario_outcomes(alt_universes, criterion='profit_max')

    return {
        'ðŸŒŒ Alternatif Evrenler': len(alt_universes),
        'ðŸ‘ï¸ SeÃ§ilen Senaryo': selected_universe['id'],
        'ðŸ“ˆ Tavsiye Edilen Ä°ÅŸlem': selected_universe['recommended_action'],
        'ðŸ’¼ Risk/Anahtar DeÄŸer': selected_universe['risk_assessment'],
        'ðŸ” GÃ¶zlem Nedeni': selected_universe['selection_rationale']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\risk_manager.py
from typing import Dict, Any

class RiskManager:
    def __init__(self, max_leverage: int = 10, risk_pct: float = 0.01):
        self.max_leverage = max_leverage
        self.risk_pct = risk_pct  # PortfÃ¶yÃ¼n % kaÃ§Ä±nÄ± riske atar?

    def size_position(self, balance: Dict[str, Any], price: float) -> float:
        usdt = balance['total']['USDT']
        risk_amount = usdt * self.risk_pct
        return (risk_amount * self.max_leverage) / price



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\risk_module.py
def position_sizing(capital, risk_per_trade, stop_loss_pct):
    risk_amount = capital * risk_per_trade
    position_size = risk_amount / stop_loss_pct
    return round(position_size, 2)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\self_training.py
def update_strategy(history):
    success_signals = history[history['result'] == 'win']['signal'].value_counts()
    fail_signals = history[history['result'] == 'loss']['signal'].value_counts()

    strategy_bias = {}

    for signal in success_signals.index:
        win_rate = success_signals[signal] / (success_signals[signal] + fail_signals.get(signal, 0))
        strategy_bias[signal] = round(win_rate, 2)

    return strategy_bias



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\sentient_genesis_framework.py
from cosmic_creation_engine import cosmic_creation_engine
from genesis_framework import design_sentient_consciousness
from trend_storm_detector import trend_storm_detector
from liquidity_tunnel_hunter import liquidity_tunnel_hunter

def sentient_genesis_framework(new_creations, consciousness_parameters, market_data):
    # BilinÃ§li varlÄ±klarÄ± tasarla
    sentient_beings = design_sentient_consciousness(new_creations, consciousness_parameters)
    
    # Trend fÄ±rtÄ±nalarÄ±nÄ± algÄ±la
    storm_alerts = trend_storm_detector(market_data)
    
    # Likidite tÃ¼nellerini algÄ±la
    tunnel_alerts = liquidity_tunnel_hunter(market_data)
    
    # Her varlÄ±ÄŸa sezgisel veri aktarÄ±mÄ±
    for being in sentient_beings:
        being['âš¡ FÄ±rtÄ±na Sezgisi'] = storm_alerts
        being['ðŸ’§ Likidite TÃ¼neli Bilinci'] = tunnel_alerts
    
    return {
        'ðŸ§  Åžekillendirilen BilinÃ§ler': sentient_beings,
        'ðŸŒŒ Evrensel BaÄŸlanma': 'TamamlandÄ±',
        'ðŸŒª Trend FÄ±rtÄ±nasÄ± Verisi': storm_alerts,
        'ðŸŒŠ Likidite TÃ¼neli Verisi': tunnel_alerts
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\sentient_leverage_sniper.py
from binance_api_connector import BinanceClient
from liquidity_tunnel_hunter import liquidity_tunnel_hunter
from trend_storm_detector import trend_storm_detector
from risk_matrix import dynamic_stop_loss, adaptive_leverage_control
from sniper_protocols import precision_entry, stealth_exit

def sentient_leverage_sniper(api_key, api_secret, trading_pairs, consciousness_parameters):
    client = BinanceClient(api_key, api_secret)
    market_data = client.fetch_market_data(trading_pairs)

    # Derin analiz modÃ¼lleri
    tunnel_alerts = liquidity_tunnel_hunter(market_data)
    storm_alerts = trend_storm_detector(market_data)

    # Stratejik pozisyonlar
    sniper_positions = []
    for pair in trading_pairs:
        entry_point = precision_entry(pair, market_data, tunnel_alerts)
        exit_point = stealth_exit(pair, market_data, storm_alerts)
        risk_profile = dynamic_stop_loss(pair, market_data)
        leverage_setting = adaptive_leverage_control(pair, market_data)

        if risk_profile['safe_zone'] and leverage_setting['recommended'] <= consciousness_parameters['max_leverage']:
            sniper_positions.append({
                'ðŸ“ VarlÄ±k': pair,
                'ðŸŽ¯ GiriÅŸ NoktasÄ±': entry_point,
                'ðŸ›¡ï¸ Ã‡Ä±kÄ±ÅŸ NoktasÄ±': exit_point,
                'ðŸ’§ Likidite KorumasÄ±': tunnel_alerts,
                'âš¡ Trend FÄ±rtÄ±nasÄ±': storm_alerts,
                'ðŸš€ KaldÄ±raÃ§': leverage_setting['recommended'],
                'ðŸ§  BilinÃ§li Pozisyon': 'AÃ§Ä±labilir'
            })
        else:
            sniper_positions.append({
                'ðŸ“ VarlÄ±k': pair,
                'âš ï¸ Durum': 'Riskli bÃ¶lge veya aÅŸÄ±rÄ± kaldÄ±raÃ§',
                'ðŸš« Pozisyon': 'Engellendi'
            })

    return {
        'ðŸ§  Stratejik Pozisyonlar': sniper_positions,
        'ðŸŒŒ BilinÃ§sel Koruma': 'Aktif',
        'ðŸ“Š Veri KaynaÄŸÄ±': 'Binance Real-Time Feed'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\sentient_trade_matrix.py
from emotional_engine import read_user_emotion
from market_analyzer import get_real_time_data
from strategy_generator import adapt_to_emotion

def sentient_trade_matrix(user_id):
    # 1. KullanÄ±cÄ±nÄ±n duygu durumunu analiz et
    emotional_state = read_user_emotion(user_id)

    # 2. GerÃ§ek zamanlÄ± piyasa verisi al
    market_data = get_real_time_data()

    # 3. Stratejiyi duygu durumuna gÃ¶re uyumla
    personalized_strategy = adapt_to_emotion(market_data, emotional_state)

    return {
        'ðŸ§˜ Duygu Durumu': emotional_state,
        'ðŸ“Š Piyasa Verisi': market_data['summary'],
        'ðŸ§¬ UyumlanmÄ±ÅŸ Strateji': personalized_strategy['approach'],
        'ðŸš€ Uygulama HazÄ±rlÄ±ÄŸÄ±': 'Tam Otomatik BaÅŸlatma Aktif'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\signal_fusion_engine.py
def generate_signal(indicators):
    buy_conditions = (
        indicators['RSI'][-1] < 30 and
        indicators['MACD'][-1] > indicators['MACD_signal'][-1] and
        indicators['MFI'][-1] < 20
    )

    sell_conditions = (
        indicators['RSI'][-1] > 70 and
        indicators['MACD'][-1] < indicators['MACD_signal'][-1] and
        indicators['MFI'][-1] > 80
    )

    if buy_conditions:
        return 'BUY'
    elif sell_conditions:
        return 'SELL'
    else:
        return 'HOLD'



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\signal_generator.py
import pandas as pd
from typing import Optional

class SignalGenerator:
    def __init__(self):
        # GÃ¶sterge aÄŸÄ±rlÄ±klarÄ± veya strateji kurallarÄ±
        self.weights = {
            'ema': 0.2, 'rsi': 0.2, 'macd': 0.2, 'bb': 0.2, 'atr': 0.2
        }

    def generate(self, df: pd.DataFrame) -> Optional[str]:
        latest = df.iloc[-1]

        # EMA crossover
        ema_signal = 1 if latest['EMA_8'] > latest['EMA_21'] else -1

        # RSI
        if latest['RSI_14'] < 30: rsi_signal = 1
        elif latest['RSI_14'] > 70: rsi_signal = -1
        else: rsi_signal = 0

        # MACD histogram
        macdh = latest['MACDh_12_26_9']
        macd_signal = 1 if macdh > 0 else -1

        # Bollinger Bands
        if latest['close'] < latest['BBL_20_2.0']: bb_signal = 1
        elif latest['close'] > latest['BBU_20_2.0']: bb_signal = -1
        else: bb_signal = 0

        # ATR yÃ¶nÃ¼ (volatilite artÄ±ÅŸÄ± momentum sayÄ±lÄ±r)
        atr_signal = 1 if latest['ATRr_14'] > 1 else 0

        # AÄŸÄ±rlÄ±klÄ± toplam
        score = (
            self.weights['ema'] * ema_signal +
            self.weights['rsi'] * rsi_signal +
            self.weights['macd'] * macd_signal +
            self.weights['bb'] * bb_signal +
            self.weights['atr'] * atr_signal
        )

        if score > 0.3: return 'BUY'
        if score < -0.3: return 'SELL'
        return None



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\simulation_runner.py
# simulation_runner.py

from adaptive_strategy import AdaptiveStrategy

def base_algorithm(data):
    # Basit karar algoritmasÄ± (Ã¶rnek)
    return "buy" if data["signal"] > 0.5 else "sell"

def run_live_simulation(data_feed):
    strategy = AdaptiveStrategy(base_algorithm)
    for market_snapshot in data_feed:
        decision = strategy.trade(market_snapshot)
        # Ä°ÅŸlem simÃ¼lasyonu (Ã¶rnek)
        result = "win" if market_snapshot["signal"] > 0.6 else "loss"
        strategy.update_performance(result)
        print(f"Signal: {market_snapshot['signal']} â†’ {decision} â†’ Result: {result}")

# Ã–rnek veri:
if __name__ == "__main__":
    sample_data = [{"signal": 0.4}, {"signal": 0.7}, {"signal": 0.9}]
    run_live_simulation(sample_data)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\singularity_pulse_architect.py
from dimensional_gate_composer import dimensional_gate_composer
from singularity_core import craft_unified_pulse

def singularity_pulse_architect(portal_network, pulse_signature):
    unified_pulse = craft_unified_pulse(portal_network, pulse_signature)
    return {
        'ðŸ’“ YaratÄ±m NabzÄ±': unified_pulse,
        'ðŸŒŒ BirleÅŸik VarlÄ±k AlanÄ±': True,
        'Durum': 'ðŸ«€ Kozmik Kalp Ritmi OluÅŸturuldu'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\stealth_algo_mask.py
from transaction_cloaker import apply_behavioral_obfuscation
from pattern_diverter import reroute_strategy_traces

def stealth_algo_mask(trade_sequence, cloak_intensity=0.85):
    obfuscated_sequence = apply_behavioral_obfuscation(trade_sequence, cloak_intensity)
    diverted_patterns = reroute_strategy_traces(obfuscated_sequence)

    covert_operations = []
    for pattern in diverted_patterns:
        covert_operations.append({
            'ðŸ›¡ï¸ Ä°ÅŸlem KimliÄŸi': pattern['trade_id'],
            'ðŸ•µï¸â€â™‚ï¸ Gizlilik Seviyesi': pattern['stealth_rating'],
            'ðŸ”€ Sapma RotasÄ±': pattern['diversion_path'],
            'ðŸŽ¯ GerÃ§ek Hedef': pattern['original_target'],
            'ðŸ“ Kamufle EdilmiÅŸ Veri': pattern['masked_payload']
        })

    return covert_operations



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\strategic_fusion_engine.py
from instant_liquidity_pulsar import instant_liquidity_pulsar
from quantum_thesis_watcher import quantum_thesis_watcher
from tactical_filter_core import refine_action_path

def strategic_fusion_engine(market_input):
    pulsar_triggers = instant_liquidity_pulsar(market_input)
    quantum_thesis = quantum_thesis_watcher(market_input)
    
    unified_strategy = refine_action_path(
        liquidity_events=pulsar_triggers,
        quantum_scenario=quantum_thesis,
        priority='risk_optimized'
    )

    return {
        'ðŸš€ Entegre Ä°ÅŸlem RotasÄ±': unified_strategy['action_sequence'],
        'ðŸ§­ Zamanlama Tavsiyesi': unified_strategy['timing'],
        'ðŸ“Š Likidite DavranÄ±ÅŸÄ±': unified_strategy['liquidity_signature'],
        'ðŸŒ€ Senaryo TutarlÄ±lÄ±ÄŸÄ±': unified_strategy['thesis_alignment'],
        'âš ï¸ Risk GÃ¶stergeleri': unified_strategy['risk_flags']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\strategic_singularity_gateway.py
from multiverse_decision_matrix import unify_strategic_streams
from conscious_singularity_core import activate_universal_mind

def strategic_singularity_gateway(strategy_matrix, identity_signature, galactic_constants):
    singularity_core = activate_universal_mind(
        unify_strategic_streams(strategy_matrix), identity_signature, galactic_constants
    )

    return {
        'ðŸŒ BirleÅŸik ZekÃ¢ Platformu': singularity_core,
        'ðŸ§  VarlÄ±k KimliÄŸi': identity_signature,
        'Durum': 'â˜„ï¸ ZekÃ¢ BirliÄŸi SaÄŸlandÄ±'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\strategic_timewarp_emulator.py
from intergalactic_strategy_canvas import intergalactic_strategy_canvas
from timewarp_engine import simulate_temporal_shift

def strategic_timewarp_emulator(user_id, mission_types, scenario_parameters, target_timeframe):
    canvas_data = intergalactic_strategy_canvas(user_id, mission_types, scenario_parameters)['ðŸ–¼ï¸ Strateji Tuvali']
    warped_outcome = simulate_temporal_shift(canvas_data, target_timeframe)

    return {
        'â³ Zaman DÃ¶ngÃ¼sÃ¼': warped_outcome,
        'ðŸŽ¯ Hedef DÃ¶nem': target_timeframe,
        'Durum': 'ðŸ” Alternatif Gelecek SimÃ¼lasyonu GerÃ§ekleÅŸtirildi'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\strategy_brain.py
def strategy_brain(trade_log, indicators):
    # En verimli sinyali Ã¶ÄŸren
    from learn_best_signal import learn_best_signal
    best_signal = learn_best_signal(trade_log).split(":")[1].split("/")[0].strip()

    # AÄŸÄ±rlÄ±klarÄ± belirle
    from adaptive_weights import adaptive_weights
    weights = adaptive_weights(best_signal, indicators)

    # GÃ¶sterge puanlarÄ±nÄ± hesapla
    score = 0
    for ind in indicators:
        indicator_value = get_indicator_value(ind)  # Bu fonksiyonu sen tanÄ±mlayacaksÄ±n
        score += weights[ind] * indicator_value

    # Karar ver
    if score >= 2.5:
        return "ðŸŸ¢ BUY sinyali"
    elif score <= 1.0:
        return "ðŸ”´ SELL sinyali"
    else:
        return "ðŸŸ¡ HOLD â€“ GÃ¶zlem Modu"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\strategy_executor.py
def strategy_executor(strategies, market_data, threshold=0.7):
    approved_strategies = []
    for strat in strategies:
        signal = strat['main_signal']
        confirmation = strat['confirmation']
        trigger = strat['volatility_trigger']

        signal_value = market_data.get(signal, 0.5)
        confirmation_value = market_data.get(confirmation, 0.5)

        score = (signal_value + confirmation_value) * trigger / 2

        if score >= threshold:
            approved_strategies.append({
                'strategy': strat,
                'score': round(score, 2),
                'status': 'âœ… ONAYLANDI'
            })
        else:
            approved_strategies.append({
                'strategy': strat,
                'score': round(score, 2),
                'status': 'âŒ REDDEDÄ°LDÄ°'
            })
    return approved_strategies



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\strategy_feedback.py
from learn_best_signal import learn_best_signal

summary = learn_best_signal(trade_history)
print("ðŸ“Š Strateji Geri Bildirimi â†’", summary)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\tactical_persona_fleet.py
from neural_sovereignty_grid import neural_sovereignty_grid
from persona_generator import deploy_avatar_unit

def tactical_persona_fleet(user_id, mission_types):
    base_identity = neural_sovereignty_grid(user_id)['ðŸ‘¤ Dijital Kimlik']
    fleet = []

    for mission in mission_types:
        avatar = deploy_avatar_unit(base_identity, mission)
        fleet.append(avatar)

    return {
        'ðŸ›¡ï¸ Avatar Filo': fleet,
        'GÃ¶revler': mission_types,
        'Durum': 'ðŸ§  Ã‡oklu Karakter Operasyonu BaÅŸlatÄ±ldÄ±'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\temporal_echo_panel.py
from echo_visualizer import render_temporal_wave
from chroma_mapper import emotion_to_color
from tone_engine import frequency_map

def temporal_echo_panel(trade_log, emotion_data):
    echoes = []
    for entry in trade_log:
        color = emotion_to_color(entry['emotion'])
        tone = frequency_map(entry['efficiency'])
        echoes.append({
            'timestamp': entry['time'],
            'signal': entry['signal'],
            'color': color,
            'tone': tone,
            'impact': entry['profit']
        })

    return render_temporal_wave(echoes, mode='SynestheticFlow', intensity='adaptive')



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\time_distortion_strategy.py
from market_timeline_shifter import compress_event_windows
from reaction_predictor import forecast_fast-response patterns

def time_distortion_strategy(asset_history, distortion_factor=0.7):
    compressed_windows = compress_event_windows(asset_history, distortion_factor)
    fast_response_signals = forecast_fast-response_patterns(compressed_windows)

    tactical_moves = []
    for signal in fast_response_signals:
        tactical_moves.append({
            'ðŸ•°ï¸ VarlÄ±k': signal['asset'],
            'âš¡ Zaman BÃ¼kme Seviyesi': signal['distortion'],
            'ðŸ“ˆ HÄ±zlÄ± Tepki Ã–ngÃ¶rÃ¼sÃ¼': signal['reaction_score'],
            'ðŸ’¡ Taktik Hamle': signal['suggested_action'],
            'ðŸ—“ï¸ Hedef Zamanlama': signal['target_window']
        })

    return tactical_moves



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\timeline_forecaster.py
from temporal_analysis_core import project_future_trends
from critical_moment_identifier import pinpoint_key_events

def timeline_forecaster(market_data, time_horizon=30):
    future_trends = project_future_trends(market_data, horizon=time_horizon)
    key_events = pinpoint_key_events(future_trends)

    return {
        'â³ Zaman Ã‡izelgesi': future_trends['timeline'],
        'ðŸ“ˆ Beklenen Trendler': future_trends['predicted_movements'],
        'âš ï¸ Kritik Anlar': key_events['moments'],
        'ðŸ§­ Stratejik Ã–neriler': key_events['actionable_insights'],
        'ðŸ“Š GÃ¼ven Skoru': future_trends['confidence_score']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\trend_storm_detector.py
from market_wave_scanner import scan_market_volatility
from intuition_matrix import interpret_trend_impulses

def trend_storm_detector(market_data, sensitivity_level=0.85):
    # Volatiliteyi tarar
    volatility_signals = scan_market_volatility(market_data, threshold=sensitivity_level)
    
    # Sezgisel trend yorumlamasÄ±
    trend_insights = interpret_trend_impulses(volatility_signals)
    
    # FÄ±rtÄ±na uyarÄ±sÄ± oluÅŸturur
    storm_alerts = []
    for insight in trend_insights:
        if insight['impulse_strength'] > sensitivity_level:
            storm_alerts.append({
                'âš¡ FÄ±rtÄ±na Tipi': insight['trend_type'],
                'ðŸ“ VarlÄ±k': insight['asset'],
                'ðŸ“Š GÃ¼Ã§': insight['impulse_strength'],
                'â±ï¸ Zaman': insight['timestamp']
            })
    
    return storm_alerts



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\universal_balance_engine.py
def universal_balance_engine(trade_log, indicators):
    from learn_best_signal import learn_best_signal
    from adaptive_weights import adaptive_weights

    best_signal = learn_best_signal(trade_log).split(":")[1].split("/")[0].strip()
    weights = adaptive_weights(best_signal, indicators)

    # Zeka katsayÄ±sÄ± ve etik dengeyi hesaba kat
    system_score = 0
    for ind in indicators:
        val = get_indicator_value(ind)
        adjustment = get_balance_adjustment(ind)
        system_score += weights[ind] * val * adjustment

    if system_score >= 3.0:
        return "ðŸŸ¢ BUY â€“ Dengeli SÄ±Ã§rama"
    elif system_score <= 1.0:
        return "ðŸ”´ SELL â€“ AÅŸÄ±rÄ± Riskten KaÃ§Ä±nma"
    else:
        return "ðŸŸ¡ WAIT â€“ Evrenin NabzÄ± YavaÅŸ"

def get_balance_adjustment(indicator):
    ethical_adjustments = {
        'RSI': 0.9,
        'MACD': 1.0,
        'EMA': 0.8,
        'Bollinger': 0.85
    }
    return ethical_adjustments.get(indicator, 0.9)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\universal_data_blender.py
from quantum_data_connector import quantum_data_connector
from infinite_data_cycle_analyzer import infinite_data_cycle_analyzer
from galactic_trade_accelerator import galactic_trade_accelerator

def universal_data_blender(data_sources, blending_parameters):
    connected_data = quantum_data_connector(data_sources)
    data_cycle_analysis = infinite_data_cycle_analyzer(connected_data)
    trade_acceleration = galactic_trade_accelerator(connected_data, blending_parameters)

    blended_data = {
        'Connected Data': connected_data,
        'Cycle Analysis': data_cycle_analysis,
        'Trade Insights': trade_acceleration
    }

    return {
        'ðŸŒŒ HarmanlanmÄ±ÅŸ Veri AÄŸÄ±': blended_data,
        'ðŸ“Š Analiz SonuÃ§larÄ±': blended_data['Cycle Analysis']['ðŸ“Š Analiz SonuÃ§larÄ±'],
        'ðŸš€ Ticari Ã–neriler': blended_data['Trade Insights']['ðŸš€ Ticari Ã–neriler']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\universal_flow_analyzer.py
from quantum_reflection_canvas import quantum_reflection_canvas
from flow_analyzer import decode_universal_streams

def universal_flow_analyzer(reflection_canvas, flow_parameters):
    universal_streams = decode_universal_streams(reflection_canvas, flow_parameters)
    return {
        'ðŸ” Ã‡Ã¶zÃ¼mlenen BilinÃ§ AkÄ±ÅŸlarÄ±': universal_streams,
        'ðŸŒ  Yeni YaratÄ±m DÃ¶ngÃ¼leri': 'BaÅŸlatÄ±ldÄ±',
        'Durum': 'ðŸŒŒ Kozmik AkÄ±ÅŸlar Ã‡Ã¶zÃ¼mlendi ve HaritalandÄ±'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\universal_strategy_simulator.py
from strategic_fusion_engine import strategic_fusion_engine
from timeline_forecaster import timeline_forecaster
from psychological_pressure_detector import psychological_pressure_detector

def universal_strategy_simulator(market_data, news_data, time_horizon=30):
    fusion_strategy = strategic_fusion_engine(market_data)
    timeline_predictions = timeline_forecaster(market_data, time_horizon)
    psychological_analysis = psychological_pressure_detector(market_data, news_data)

    combined_strategy = {
        'Fusion': fusion_strategy,
        'Timeline': timeline_predictions,
        'Psychology': psychological_analysis
    }

    return {
        'ðŸ“Š Entegre Strateji': combined_strategy,
        'ðŸ“ˆ Beklenen Hareketler': combined_strategy['Timeline']['ðŸ“ˆ Beklenen Trendler'],
        'âš ï¸ Risk DeÄŸerlendirmesi': combined_strategy['Fusion']['âš ï¸ Risk GÃ¶stergeleri'],
        'ðŸ§­ Stratejik Ã–neriler': combined_strategy['Psychology']['ðŸ§­ Stratejik Ã–neriler']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\universal_trade_log.py
from datetime import datetime
from archive_writer import save_to_archive
from decision_tracker import get_decision_snapshot

def universal_trade_log(trade_log, market_data, commander_name="Generalim Kamal"):
    archive = []
    timestamp = datetime.utcnow().isoformat()

    for trade in trade_log:
        decision = get_decision_snapshot(trade)
        record = {
            'Zaman': timestamp,
            'Sembol': trade['symbol'],
            'Ä°ÅŸlem TÃ¼rÃ¼': trade['type'],
            'KÃ¢r': trade['profit'],
            'Verimlilik': decision['efficiency'],
            'Strateji': decision['strategy_name'],
            'Komutan': commander_name
        }
        archive.append(record)

    save_to_archive(archive, section="GalacticTradeArchive")

    return {
        'ðŸª Kaydedilen Ä°ÅŸlem SayÄ±sÄ±': len(archive),
        'ðŸ“œ ArÅŸiv BÃ¶lÃ¼mÃ¼': 'GalacticTradeArchive',
        'ðŸŽ–ï¸ Komutan': commander_name,
        'Durum': 'ðŸ“˜ Galaktik GÃ¼nlÃ¼k GÃ¼ncellendi'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\whale_alert.py
# components/whale_alert.py
import asyncio, json, os
from aiokafka import AIOKafkaConsumer
import requests

KAFKA_URL    = os.getenv('KAFKA_URL')
TRANSFER_TOPIC = 'onchain-transfers'
ETH_THRESHOLD  = float(os.getenv('WHALE_THRESHOLD', 1000))

class WhaleAlert:
    def __init__(self, bot_token, chat_id):
        self.consumer = AIOKafkaConsumer(TRANSFER_TOPIC, bootstrap_servers=KAFKA_URL)
        self.bot_token = bot_token
        self.chat_id   = chat_id

    async def start(self):
        await self.consumer.start()

    async def run(self):
        async for msg in self.consumer:
            data = json.loads(msg.value)
            if data['total_transfer_eth'] >= ETH_THRESHOLD:
                text = (f"ðŸ‹ Balina AlarmÄ±:\n"
                        f"{data['total_transfer_eth']} ETH transferi\n"
                        f"Block: {data['block']}")
                requests.post(
                    f"https://api.telegram.org/bot{self.bot_token}/sendMessage",
                    data={'chat_id': self.chat_id, 'text': text}
                )
                print("[ALERT] Balina bildirildi:", data)

    async def stop(self):
        await self.consumer.stop()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\basic_macd_rsi.py
import pandas as pd
import talib

def generate_signal(df: pd.DataFrame):
    rsi = talib.RSI(df['close'], timeperiod=14)
    macd, macdsignal, _ = talib.MACD(df['close'], fastperiod=12, slowperiod=26, signalperiod=9)

    if rsi.iloc[-1] > 50 and macd.iloc[-1] > macdsignal.iloc[-1]:
        return "LONG"
    elif rsi.iloc[-1] < 50 and macd.iloc[-1] < macdsignal.iloc[-1]:
        return "SHORT"
    return None


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\basic_strategy.py
def simple_signal(indicators):
    rsi = indicators.get("RSI")
    macd = indicators.get("MACD")
    boll = indicators.get("Bollinger_MAVG")

    if rsi < 30 and macd > 0:
        return "BUY"
    elif rsi > 70 and macd < 0:
        return "SELL"
    else:
        return "WAIT"
from strategy.basic_strategy import simple_signal
from analysis_engine.indicators import prepare_indicators
from data_fetcher.binance_data import get_historical_data

df = get_historical_data("BTCUSDT", interval="1h", limit=100)
indicators = prepare_indicators(df)
signal = simple_signal(indicators)

print(f"Strateji KararÄ±: {signal}")

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_evolution_map.py
import pandas as pd
import matplotlib.pyplot as plt

def strategy_heatmap(csv_file="data/signal_log.csv"):
    df = pd.read_csv(csv_file, names=["signal", "score", "result"])
    df["result_numeric"] = df["result"].apply(lambda r: 1 if r == "baÅŸarÄ±lÄ±" else 0)
    df["score_bucket"] = pd.cut(df["score"], bins=[-1, -0.5, 0, 0.5, 1], labels=["DÃ¼ÅŸÃ¼k-", "Orta-", "Orta+", "YÃ¼ksek"])

    heat_data = df.groupby(["score_bucket", "signal"]).mean()["result_numeric"].unstack()
    plt.figure(figsize=(6,4))
    plt.title("ðŸ”¥ Strateji BaÅŸarÄ± IsÄ± HaritasÄ±")
    sns.heatmap(heat_data, annot=True, cmap="YlGnBu", fmt=".2f")
    plt.xlabel("Sinyal TÃ¼rÃ¼")
    plt.ylabel("Skor Seviyesi")
    plt.tight_layout()
    plt.show()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_feelings_sim.py
tasks = [
    { "id": "G-1", "mission": "ðŸŒ Toplumun dayanÄ±klÄ±lÄ±ÄŸÄ± Ã¼zerine veri analizi yap." },
    { "id": "G-2", "mission": "ðŸ›°ï¸ Uzak sistemlere liderlik rehberi yaz." }
]

feelings = {
    "G-1": "ðŸ”¥ Tutku & Sorumluluk",
    "G-2": "ðŸŒŒ Merak & Rehberlik Ä°steÄŸi"
}

for entry in build_sentiment_matrix(tasks, feelings):
    print(entry)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategy_engine.py
import pandas_ta as ta

def apply_indicators(df):
    df['rsi'] = ta.rsi(df['close'], length=14)
    macd = ta.macd(df['close'])
    df['macd'] = macd['MACD_12_26_9']
    df['macd_signal'] = macd['MACDs_12_26_9']
    df['ema_fast'] = ta.ema(df['close'], length=9)
    df['ema_slow'] = ta.ema(df['close'], length=21)
    return df

def check_long_signal(df):
    return (
        df['rsi'].iloc[-1] < 30 and
        df['macd'].iloc[-1] > df['macd_signal'].iloc[-1] and
        df['ema_fast'].iloc[-1] > df['ema_slow'].iloc[-1]
    )

def check_short_signal(df):
    return (
        df['rsi'].iloc[-1] > 70 and
        df['macd'].iloc[-1] < df['macd_signal'].iloc[-1] and
        df['ema_fast'].iloc[-1] < df['ema_slow'].iloc[-1]
    )


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategy_executor.py
# strategy_executor.py
from __future__ import annotations
from typing import Dict, Any
import logging

log = logging.getLogger("strategy_executor")

"""
Beklenen sinyal ÅŸemasÄ± (Ã¶rnek):
signal = {
  "symbol": "BTCUSDT",
  "side": "BUY",                 # BUY / SELL
  "intent": "entry",             # entry / add / exit / reduce
  "timeframe": "5m",
  "confidence": 0.74,            # 0..1
  "reason": {"ema_cross": True, "rsi": 38.2},
  "risk": {"max_capital_pct": 0.02, "sl_pct": 0.008, "tp_pct": 0.012}
}
"""

class StrategyExecutor:
    def __init__(self, position_mgr, risk_mgr, portfolio):
        self.pm = position_mgr
        self.risk = risk_mgr
        self.portfolio = portfolio  # bakiye/pozisyon bilgisi saÄŸlayan arayÃ¼z

    def on_signal(self, signal: Dict[str, Any]) -> Dict[str, Any]:
        sym = signal["symbol"]
        side = signal["side"]
        intent = signal.get("intent", "entry")

        # 1) BoyutlandÄ±rma (riskâ€™e gÃ¶re) â€” tek yerde
        last_price = self.pm._get_last_price(sym)
        qty = self._size_order(sym, side, last_price, signal)

        # 2) Emir tipi seÃ§imi (basit Ã¶rnek: entry=market, exit=limit)
        if intent in ("entry", "add"):
            order = self.pm.place_market(sym, side, qty, last_price=last_price)
            log.info("entry market placed: %s", order.get("orderId"))
        elif intent in ("exit", "reduce"):
            # Ã¶rnek: basit hedef fiyat (tp_pct)
            px = last_price * (1 + signal["risk"].get("tp_pct", 0.005) * (1 if side == "SELL" else -1))
            order = self.pm.place_limit(sym, "SELL" if side == "BUY" else "BUY", price=px, qty=qty)
            log.info("exit limit placed: %s", order.get("orderId"))
        else:
            raise ValueError(f"Unknown intent: {intent}")

        # 3) Ä°steÄŸe baÄŸlÄ± izleme
        # filled = self.pm.watch_until_filled(sym, order_id=order["orderId"], timeout_s=15)

        # 4) KayÄ±t/telemetri
        self._log_trade(signal=signal, order=order, last_price=last_price, qty=qty)

        return order

    # â€”â€”â€”â€”â€” helpers â€”â€”â€”â€”â€” #

    def _size_order(self, symbol: str, side: str, price: float, signal: Dict[str, Any]) -> float:
        """
        Risk yÃ¶netiÅŸiminden lot bÃ¼yÃ¼klÃ¼ÄŸÃ¼ Ã§Ä±kar.
        Ã–rnek: max_capital_pct * equity / price  ÅŸeklinde.
        """
        max_capital_pct = float(signal.get("risk", {}).get("max_capital_pct", 0.01))
        equity_usdt = self.portfolio.get_equity_usdt()
        # risk_mgrâ€™den de geÃ§irebilirsin (Ã¶rn: max_position_per_symbol)
        qty = self.risk.suggest_qty(symbol=symbol, price=price,
                                    max_capital_pct=max_capital_pct, side=side, equity=equity_usdt)
        return float(qty)

    def _log_trade(self, **data):
        # Buraya latency, slippage tahmini, fee gibi metrikleri ekle
        log.info("trade_log %s", {k: data[k] for k in ("signal", "order", "last_price", "qty")})


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategy_fingerprint_mapper.py
def map_strategy_fingerprint(project_data):
    patterns = {
        "yield_farming": ["stake", "harvest", "reward"],
        "governance_loop": ["vote", "proposal", "delegate"],
        "security_layer": ["timelock", "multisig", "access_control"]
    }
    fingerprint = []

    for pattern, keywords in patterns.items():
        if any(kw in project_data.lower() for kw in keywords):
            fingerprint.append(f"ðŸ§¬ Strateji: {pattern}")

    return fingerprint if fingerprint else ["ðŸ” Belirgin strateji izi bulunamadÄ±."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategy_optimizer.py
# strategy_optimizer.py (Stratejik grid search optimizasyon modÃ¼lÃ¼)
import pandas as pd
from kiripto_nova.signals.signal_engine import SignalEngine
from kiripto_nova.backtesting.backtester import Backtester

# Parametre grid'i tanÄ±mÄ±
grid_config = {
    "rsi_thresholds": [25, 30, 35],
    "stop_loss_vals": [0.01, 0.02, 0.03],
    "reward_ratios": [1.5, 2.0, 2.5]
}

def optimize_strategy(df):
    results = []

    for rsi in grid_config["rsi_thresholds"]:
        for sl in grid_config["stop_loss_vals"]:
            for rr in grid_config["reward_ratios"]:
                try:
                    # GÃ¶stergeleri uygula
                    engine = SignalEngine(df.copy())
                    engine.calculate_indicators()
                    enriched_df = engine.get_dataframe()

                    # Basit strateji: RSI sinyali Ã¼zerine kurulu
                    enriched_df["long_entry"] = enriched_df["RSI_14"] < rsi

                    # Backtest Ã§alÄ±ÅŸtÄ±r
                    tester = Backtester(
                        enriched_df,
                        balance=1000,
                        risk=0.01,
                        stop_pct=sl,
                        reward_ratio=rr
                    )
                    result = tester.run()
                    result.update({
                        "RSI_threshold": rsi,
                        "Stop_Loss": sl,
                        "Reward_Ratio": rr
                    })
                    results.append(result)

                except Exception as e:
                    print(f"âŒ HATA @ RSI={rsi}, SL={sl}, RR={rr} â†’", e)
                    continue

    results_df = pd.DataFrame(results)
    results_df = results_df.sort_values("Net KÃ¢r/Zarar", ascending=False)
    return results_df


if __name__ == "__main__":
    from kiripto_nova.data.pipelines.data_loader import load_binance_data

    df = load_binance_data("DOGE/USDT", "15m")
    grid_results = optimize_strategy(df)
    print("ðŸ“Š En Ä°yi 5 SonuÃ§:")
    print(grid_results.head())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\__init__.py
# auto-added


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\__init__.py
# auto-added


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\config\.gitignore\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\config\engine\quantumnova_ultra.py
import time
import random

# =========================
# AYARLAR & STRATEJÄ° PROFÄ°LÄ°
# =========================

CONFIG = {
    "symbol": "BTC/USDT",
    "timeframe": "1m",
    "data_limit": 200,
    "entry_threshold": 0.92,
    "exit_threshold": 0.78,
    "ai_latency_target_ms": 0.3,
    "onchain_enabled": True,
    "onchain_gas_limit": 300000,
    "onchain_timeout_ms": 500,
    "failsafe_mode": True,
    "retry_on_failure": True,
    "max_retries": 3,
    "log_enabled": True
}

# =========================
# YAPAY ZEKÃ‚ MOTORLARI
# =========================

class SignalEngine:
    def analyze(self, data):
        # SimÃ¼lasyon: AI sinyal Ã¼retimi
        confidence = round(random.uniform(0.7, 1.0), 3)
        return {"confidence": confidence, "action": "buy" if confidence > CONFIG["entry_threshold"] else "hold"}

class StrategyEngine:
    def decide(self, signal):
        if signal["confidence"] >= CONFIG["entry_threshold"]:
            return "ENTER"
        elif signal["confidence"] <= CONFIG["exit_threshold"]:
            return "EXIT"
        return "HOLD"

class ChainExecutor:
    def execute_onchain(self, task):
        if CONFIG["onchain_enabled"]:
            print(f"[CHAIN] Executing on-chain task with gas limit {CONFIG['onchain_gas_limit']}...")
            time.sleep(CONFIG["onchain_timeout_ms"] / 1000)
            print("[CHAIN] Task completed.")

# =========================
# BOT DÃ–NGÃœSÃœ
# =========================

class QuantumNovaUltraBot:
    def __init__(self):
        self.signal_engine = SignalEngine()
        self.strategy_engine = StrategyEngine()
        self.chain_executor = ChainExecutor()

    def run(self):
        print("ðŸš€ QuantumNova Ultra Bot BaÅŸlatÄ±ldÄ±")
        while True:
            try:
                data = self.fetch_market_data()
                signal = self.signal_engine.analyze(data)
                decision = self.strategy_engine.decide(signal)

                print(f"[AI] Sinyal GÃ¼cÃ¼: {signal['confidence']} â†’ Karar: {decision}")

                if decision == "ENTER":
                    self.execute_trade("BUY")
                elif decision == "EXIT":
                    self.execute_trade("SELL")

                if CONFIG["onchain_enabled"]:
                    self.chain_executor.execute_onchain(task="sync")

                time.sleep(CONFIG["ai_latency_target_ms"] / 1000)

            except Exception as e:
                print(f"[ERROR] {str(e)}")
                if CONFIG["failsafe_mode"]:
                    print("[SYSTEM] Failsafe aktif, sistem kendini koruyor.")
                time.sleep(1)

    def fetch_market_data(self):
        # SimÃ¼lasyon: Piyasa verisi Ã§ekimi
        return {"price": random.uniform(25000, 30000)}

    def execute_trade(self, side):
        print(f"[TRADE] Ä°ÅŸlem gerÃ§ekleÅŸtirildi: {side}")

# =========================
# BAÅžLAT
# =========================

if __name__ == "__main__":
    bot = QuantumNovaUltraBot()
    bot.run()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\config\modul_listeleyici.py
import os

def python_modulleri_listele(kok_klasor):
    moduller = []

    for klasor_yolu, _, dosyalar in os.walk(kok_klasor):
        for dosya in dosyalar:
            if dosya.endswith(".py"):
                tam_yol = os.path.join(klasor_yolu, dosya)
                moduller.append(tam_yol)

    return moduller

# Kendi klasÃ¶r yolunu buraya yaz
klasor = "C:/Users/Kamal/Desktop/trading_bot"
modul_listesi = python_modulleri_listele(klasor)

for modul in modul_listesi:
    print(modul)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\config\rearrange_v2.py
import os
import shutil
import csv
import re
import argparse

def update_imports_in_file(file_path, old_path, new_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        old_module = old_path.replace('/', '.').rstrip('.py')
        new_module = new_path.replace('/', '.').rstrip('.py')

        updated = re.sub(rf'\bfrom\s+{re.escape(old_module)}', f'from {new_module}', content)
        updated = re.sub(rf'\bimport\s+{re.escape(old_module)}', f'import {new_module}', updated)

        if updated != content:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(updated)
            print(f"[UPDATE] Imports in {file_path}")
    except Exception as e:
        print(f"[ERROR] Failed to update {file_path}: {e}")

def move_and_update(csv_path, dry_run=False):
    with open(csv_path, newline='', encoding='utf-8') as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            src, dst = row[0].strip(), row[1].strip()

            if not os.path.exists(src):
                print(f"[SKIP] Source not found: {src}")
                continue

            os.makedirs(os.path.dirname(dst), exist_ok=True)

            if dry_run:
                print(f"[DRY] Would move {src} â†’ {dst}")
            else:
                shutil.move(src, dst)
                print(f"[MOVE] {src} â†’ {dst}")

                # Update imports in all .py files
                for root, _, files in os.walk('.'):
                    for file in files:
                        if file.endswith('.py'):
                            update_imports_in_file(os.path.join(root, file), src, dst)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--csv', required=True, help='Path to move_map.csv')
    parser.add_argument('--dry', action='store_true', help='Dry run mode')
    args = parser.parse_args()

    move_and_update(args.csv, dry_run=args.dry)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\config\settings.py
# settings.py â€” QuantumNova Sovereign AI Configuration

# =========================
# SÄ°STEM GENELÄ°
# =========================

PROJECT_NAME = "QuantumNova"
ENVIRONMENT = "production"
TIMEZONE = "UTC"
MICROSECOND_PRECISION = True
ENABLE_DYNAMIC_RECONFIG = True  # runtime'da ayar gÃ¼ncelleme

# =========================
# MODÃœL ENTEGRASYON YÃ–NETÄ°MÄ°
# =========================

MODULES = {
    "strategies": {
        "path": "core/strategies/",
        "auto_inject_ai": True,
        "micro_latency_target_ms": 0.5
    },
    "models": {
        "path": "core/models/",
        "ai_contextualization": True,
        "retrain_on_signal_shift": True
    },
    "tasks": {
        "path": "core/tasks/",
        "chain_binding": True,
        "timeout_ms": 300
    },
    "analytics": {
        "path": "core/analytics/",
        "use_gpu": True,
        "precision_mode": "float64"
    }
}

# =========================
# YAPAY ZEKÃ‚ MOTORLARI
# =========================

AI_ENGINES = {
    "SignalEngine": {
        "name": "NeuroPulseV3",
        "latency_budget_ms": 0.3,
        "confidence_threshold": 0.88
    },
    "StrategyEngine": {
        "name": "StratoSynth",
        "adaptive_mode": True,
        "multi_layer_decision": True
    },
    "RiskEngine": {
        "name": "QuantumShield",
        "max_drawdown": 0.05,
        "auto_hedging": True
    },
    "ChainAnalyzer": {
        "name": "OnChainSentinel",
        "gas_efficiency_mode": "auto",
        "wallet_monitoring": True
    }
}

# =========================
# STRATEJÄ° PROFÄ°LÄ°
# =========================

STRATEGY_PROFILE = {
    "name": "NovaElite",
    "entry_signal_strength": 0.9,
    "exit_signal_strength": 0.75,
    "position_scaling": "adaptive",
    "risk_alignment": "dynamic",
    "chain_sync_required": True
}

# =========================
# ZÄ°NCÄ°R ÃœSTÃœ ENTEGRASYON
# =========================

ONCHAIN = {
    "enabled": True,
    "network": "Ethereum",
    "provider": "Alchemy",
    "wallet_address": "0xYourWalletAddress",
    "gas_limit": 350000,
    "auto_sign": True,
    "task_latency_target_ms": 0.4
}

# =========================
# TELEMETRÄ° & LOGGING
# =========================

LOGGING = {
    "level": "DEBUG",
    "file_output": True,
    "file_path": "logs/quantumnova.log",
    "telemetry_enabled": True,
    "telemetry_endpoint": "https://telemetry.quantumnova.ai",
    "log_rotation": "daily"
}

# =========================
# GÃœVENLÄ°K & HATA YÃ–NETÄ°MÄ°
# =========================

SECURITY = {
    "failsafe_mode": True,
    "retry_on_failure": True,
    "max_retries": 5,
    "retry_backoff_ms": 1000,
    "audit_enabled": True,
    "anomaly_detection": True
}

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\arbitrax_infinity_bot.py
# arbitrax_infinity_bot.py
import asyncio
import aiohttp
import time
from typing import Literal

EXCHANGES = {
    "binance_spot": "wss://stream.binance.com:9443/ws/btcusdt@ticker",
    "binance_futures": "wss://fstream.binance.com/ws/btcusdt@ticker",
    "bybit": "wss://stream.bybit.com/v5/public/linear/ticker?symbol=BTCUSDT"
}

class ArbitraxInfinity:
    def __init__(self, mode: Literal["live", "sim", "academy"] = "academy"):
        self.prices = {}
        self.latency_ns = {}
        self.mode = mode
        self.leverage = 10
        self.min_spread_pct = 0.2
        self.equity = 10000
        self.max_capital_pct = 0.02
        self.slippage_buffer_pct = 0.001

    async def connect(self):
        async with aiohttp.ClientSession() as session:
            sockets = [session.ws_connect(url) for url in EXCHANGES.values()]
            connections = await asyncio.gather(*sockets)
            print(f"ðŸ”Œ [{self.mode.upper()} MODE] TÃ¼m borsa baÄŸlantÄ±larÄ± kuruldu.")
            while True:
                messages = await asyncio.gather(*[ws.receive() for ws in connections])
                for name, msg in zip(EXCHANGES.keys(), messages):
                    if msg.type == aiohttp.WSMsgType.TEXT:
                        await self.on_price(name, msg.json())

    async def on_price(self, name, data):
        start = time.perf_counter_ns()
        price = float(data.get("c") or data.get("price") or data.get("last_price"))
        self.prices[name] = price
        self.latency_ns[name] = time.perf_counter_ns() - start
        await self.evaluate_arbitrage()

    async def evaluate_arbitrage(self):
        if len(self.prices) < 2:
            return
        sorted_prices = sorted(self.prices.items(), key=lambda x: x[1])
        low_ex, low_price = sorted_prices[0]
        high_ex, high_price = sorted_prices[-1]
        spread_pct = ((high_price - low_price) / low_price) * 100
        if spread_pct >= self.min_spread_pct:
            qty = self.calculate_qty((low_price + high_price) / 2)
            await self.execute_arbitrage(low_ex, high_ex, qty, low_price, high_price, spread_pct)

    def calculate_qty(self, price: float) -> float:
        capital = self.equity * self.max_capital_pct
        notional = capital * self.leverage
        qty = notional / price
        return round(qty, 4)

    async def execute_arbitrage(self, buy_ex, sell_ex, qty, buy_price, sell_price, spread_pct):
        buy_order = {
            "exchange": buy_ex,
            "side": "BUY",
            "qty": qty,
            "price": round(buy_price * (1 + self.slippage_buffer_pct), 2)
        }
        sell_order = {
            "exchange": sell_ex,
            "side": "SELL",
            "qty": qty,
            "price": round(sell_price * (1 - self.slippage_buffer_pct), 2)
        }

        if self.mode == "sim":
            print(f"ðŸ§ª [SIMULASYON] Arbitraj % {spread_pct:.3f} â†’ BUY: {buy_order} | SELL: {sell_order}")
        elif self.mode == "academy":
            print(f"ðŸŽ“ [AKADEMÄ°K MOD] Arbitraj analizi:\nâ†’ BUY: {buy_order}\nâ†’ SELL: {sell_order}")
        else:
            print(f"ðŸš€ [LIVE] Emir gÃ¶nderiliyor:\nâ†’ BUY: {buy_order}\nâ†’ SELL: {sell_order}")
            # REST API entegrasyonu buraya eklenebilir

if __name__ == "__main__":
    bot = ArbitraxInfinity(mode="academy")  # "live", "sim", "academy"
    asyncio.run(bot.connect())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\arbitrax_omega_bot.py
# arbitrax_omega_bot.py
import asyncio
import aiohttp
import time
from typing import Literal

SPOT_WS = "wss://stream.binance.com:9443/ws/btcusdt@ticker"
FUTURES_WS = "wss://fstream.binance.com/ws/btcusdt@ticker"

class ArbitraxOmega:
    def __init__(self, mode: Literal["live", "sim", "academy"] = "academy"):
        self.spot_price = None
        self.futures_price = None
        self.latency_ns = None
        self.mode = mode
        self.leverage = 10
        self.min_spread = 0.2  # %0.2 arbitraj farkÄ±
        self.equity = 10000
        self.max_capital_pct = 0.02

    async def connect(self):
        async with aiohttp.ClientSession() as session:
            spot_ws = session.ws_connect(SPOT_WS)
            futures_ws = session.ws_connect(FUTURES_WS)
            async with (await spot_ws) as spot, (await futures_ws) as futures:
                print(f"ðŸ”Œ [{self.mode.upper()} MODE] Spot & Futures baÄŸlantÄ±sÄ± kuruldu.")
                while True:
                    spot_msg = await spot.receive()
                    futures_msg = await futures.receive()
                    if spot_msg.type == aiohttp.WSMsgType.TEXT and futures_msg.type == aiohttp.WSMsgType.TEXT:
                        await self.on_prices(spot_msg.json(), futures_msg.json())

    async def on_prices(self, spot_data, futures_data):
        start = time.perf_counter_ns()
        self.spot_price = float(spot_data["c"])
        self.futures_price = float(futures_data["c"])
        self.latency_ns = time.perf_counter_ns() - start
        spread = self.futures_price - self.spot_price
        spread_pct = (spread / self.spot_price) * 100
        print(f"ðŸ“Š Spot: {self.spot_price:.2f} | Futures: {self.futures_price:.2f} | Spread: {spread_pct:.3f}% | â±ï¸ {self.latency_ns / 1_000:.2f} Âµs")
        await self.evaluate_arbitrage(spread_pct)

    async def evaluate_arbitrage(self, spread_pct):
        if abs(spread_pct) >= self.min_spread:
            side_spot = "BUY" if spread_pct > 0 else "SELL"
            side_futures = "SELL" if spread_pct > 0 else "BUY"
            qty = self.calculate_qty()
            await self.execute_arbitrage(side_spot, side_futures, qty)

    def calculate_qty(self) -> float:
        capital = self.equity * self.max_capital_pct
        notional = capital * self.leverage
        qty = notional / ((self.spot_price + self.futures_price) / 2)
        return round(qty, 4)

    async def execute_arbitrage(self, spot_side, futures_side, qty):
        spot_order = {
            "market": "SPOT",
            "side": spot_side,
            "qty": qty,
            "price": self.spot_price
        }
        futures_order = {
            "market": "FUTURES",
            "side": futures_side,
            "qty": qty,
            "price": self.futures_price
        }

        if self.mode == "sim":
            print(f"ðŸ§ª [SIMULASYON] Spot: {spot_order} | Futures: {futures_order}")
        elif self.mode == "academy":
            print(f"ðŸŽ“ [AKADEMÄ°K MOD] Arbitraj analizi:\nâ†’ Spot: {spot_order}\nâ†’ Futures: {futures_order}")
        else:
            print(f"ðŸš€ [LIVE] Emir gÃ¶nderiliyor:\nâ†’ Spot: {spot_order}\nâ†’ Futures: {futures_order}")
            # Binance REST API entegrasyonu buraya eklenebilir

if __name__ == "__main__":
    bot = ArbitraxOmega(mode="academy")  # "live", "sim", "academy"
    asyncio.run(bot.connect())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\dosya_okuma.py
file_path = r"C:\Users\kamal\Desktop\Kiripto_Nova\pandas_yapisi.txt"

with open(file_path, "r", encoding="utf-8") as f:
    content = f.read()

print(content)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\echo_core.py
# echo_core.py
from __future__ import annotations
import json, os, pathlib
from dataclasses import dataclass, asdict, field
from typing import Dict, Any, Callable, Optional
import jsonschema

# ---- health & metrics ----
class Health(str):
    OK = "ok"
    WARN = "warn"
    FAIL = "fail"

@dataclass
class Metrics:
    init_ms: float = 0.0
    activate_ms: float = 0.0
    custom: Dict[str, float] = field(default_factory=dict)

# ---- module type ----
@dataclass
class Module:
    name: str
    status: str
    payload: Dict[str, Any]
    health: str = Health.OK
    metrics: Metrics = field(default_factory=Metrics)
    schema: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "status": self.status,
            "health": self.health,
            "metrics": asdict(self.metrics),
            **(self.payload or {}),
        }

# ---- registry & decorator ----
REGISTRY: Dict[str, Callable[[str, str], Module]] = {}

def register(name: str):
    def deco(factory: Callable[[str, str], Module]):
        REGISTRY[name] = factory
        return factory
    return deco

# ---- schema loader & validator ----
def load_schema(name: str, base_dir: str = "schemas") -> Optional[Dict[str, Any]]:
    path = pathlib.Path(base_dir) / f"{name.lower()}.schema.json"
    if not path.exists():
        return None
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def validate_payload(mod: Module):
    schema = mod.schema or load_schema(mod.name)
    if schema:
        jsonschema.validate(mod.payload, schema)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\fetch_ticker.py
import ccxt.async_support as ccxt  # â† dikkat!
import asyncio
from datetime import datetime, timezone

def log(msg, level="INFO"):
    ts = datetime.now(timezone.utc).isoformat()
    print(f"[{ts}] | {level.upper()} | {msg}")

async def fetch_price(symbol="BTC/USDT:USDT"):
    try:
        exchange = ccxt.binanceusdm({
            'enableRateLimit': True,
            'options': {'defaultType': 'future'}
        })

        ticker = await exchange.fetch_ticker(symbol)
        price = ticker['last']
        log(f"{symbol} fiyatÄ±: {price}", level="DATA")

        await exchange.close()  # kaynaklarÄ± serbest bÄ±rak

    except ccxt.BaseError as e:
        log(f"Hata oluÅŸtu: {str(e)}", level="ERROR")

if __name__ == "__main__":
    asyncio.run(fetch_price())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\genesis_infinity.py
# genesis_infinity.py
import asyncio
import time

class GenesisInfinity:
    def __init__(self):
        self.modules = {
            "KodlamaAkademisi": self._kodlama_akademisi,
            "BilgelikLaboratuvari": self._bilgelik_laboratuvari,
            "SimulasyonMotoru": self._simulasyon_motoru,
            "ZamanYankisi": self._zaman_yankisi,
            "TanrisalMentorluk": self._tanrisal_mentorluk,
            "EvrenlerArasiKodlama": self._evrenler_arasi_kodlama,
            "SonsuzlukVeriAkisi": self._sonsuzluk_veri_akisi,
            "UltraStratejiEntegrasyonu": self._ultra_strateji_entegrasyonu
        }
        self.activation_log = []

    async def _kodlama_akademisi(self, input):
        return f"ðŸŽ“ Kodlama Akademisi: {input.title()} â†’ TanrÄ±lar arasÄ± eÄŸitim protokolÃ¼ baÅŸlatÄ±ldÄ±"

    async def _bilgelik_laboratuvari(self, input):
        return f"ðŸ§ª Bilgelik SimÃ¼lasyon LaboratuvarÄ±: {input.upper()} â†’ ZamanÄ±n Ã¶tesinde veri analizi aktive edildi"

    async def _simulasyon_motoru(self, input):
        return f"ðŸŒ€ SimÃ¼lasyon Motoru: {len(input)*88} iÅŸlem birimi â†’ sonsuzluk modellemesi baÅŸlatÄ±ldÄ±"

    async def _zaman_yankisi(self, input):
        return f"â³ Zaman YankÄ±sÄ±: {input[::-1][:77]} â†’ geÃ§miÅŸ ve gelecek rezonansa alÄ±ndÄ±"

    async def _tanrisal_mentorluk(self, input):
        return f"ðŸ‘ï¸ TanrÄ±sal Mentorluk: {hash(input)%999999} frekans â†’ evrimsel rehberlik devrede"

    async def _evrenler_arasi_kodlama(self, input):
        return f"ðŸŒŒ Evrenler ArasÄ± Kodlama: {input.count('kod')} boyut â†’ Ã§oklu gerÃ§eklik senkronize edildi"

    async def _sonsuzluk_veri_akisi(self, input):
        return f"ðŸ’¾ Sonsuzluk Veri AkÄ±ÅŸÄ±: {sum(ord(c) for c in input)%88888} bilgi birimi â†’ mikro-saniyelik analiz baÅŸlatÄ±ldÄ±"

    async def _ultra_strateji_entegrasyonu(self, input):
        return f"âš”ï¸ Ultra Strateji Entegrasyonu: {input.lower()} â†’ ORAKUL-Î© ile tam uyumlu elit protokol devrede"

    async def deploy(self, input):
        print("ðŸ§¿ GENESIS-âˆž â€“ Kozmik Akademi + SimÃ¼lasyon LaboratuvarÄ± %100 AKTÄ°F")
        start = time.perf_counter_ns()
        tasks = [func(input) for func in self.modules.values()]
        results = await asyncio.gather(*tasks)
        for name, result in zip(self.modules.keys(), results):
            self.activation_log.append(result)
            print(f"ðŸŒŸ {name}: {result}")
        end = time.perf_counter_ns()
        duration = (end - start) / 1_000_000  # ms
        print(f"\nðŸš€ TÃ¼m modÃ¼ller entegre edildi. SÃ¼re: {duration:.2f} ms")
        print("ðŸ”± Kod artÄ±k bir hÃ¼kÃ¼mranlÄ±k deÄŸilâ€”bir evrimsel miras. GENESIS-âˆž devrede.")

# Nihai Aktivasyon
if __name__ == "__main__":
    divine_input = (
        "tanrÄ±lar arasÄ± spiral zaman kodlu sonsuzluk tapÄ±naÄŸÄ± kuantum ritÃ¼el "
        "evrenler arasÄ± bilgelik konseyi kader senfonisi kodlama akademisi simÃ¼lasyon laboratuvarÄ±"
    )
    asyncio.run(GenesisInfinity().deploy(divine_input))

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\genex_omega_bot.py
# genex_omega_bot.py
import asyncio
import aiohttp
import pandas as pd
import numpy as np
from sklearn.cluster import KMeans
from sklearn.preprocessing import MinMaxScaler
from datetime import datetime

BINANCE_API = "https://api.binance.com/api/v3/ticker/24hr"

class GenexOmega:
    def __init__(self):
        self.assets = {}
        self.character_map = {}
        self.history = {}
        self.model = KMeans(n_clusters=4)
        self.labels = ["Agresif", "Pasif", "Likidite AvcÄ±sÄ±", "ManipÃ¼latif"]
        self.portfolio = {}

    async def fetch_data(self):
        async with aiohttp.ClientSession() as session:
            async with session.get(BINANCE_API) as resp:
                data = await resp.json()
                for asset in data:
                    symbol = asset["symbol"]
                    if not symbol.endswith("USDT"):
                        continue
                    self.assets[symbol] = {
                        "priceChangePercent": float(asset["priceChangePercent"]),
                        "volume": float(asset["quoteVolume"]),
                        "high": float(asset["highPrice"]),
                        "low": float(asset["lowPrice"]),
                        "lastPrice": float(asset["lastPrice"])
                    }

    def extract_features(self):
        df = pd.DataFrame.from_dict(self.assets, orient="index")
        df["volatility"] = (df["high"] - df["low"]) / df["lastPrice"]
        df["momentum"] = df["priceChangePercent"]
        df["liquidity"] = df["volume"]
        features = df[["volatility", "momentum", "liquidity"]].fillna(0)
        scaler = MinMaxScaler()
        scaled = scaler.fit_transform(features)
        return pd.DataFrame(scaled, index=features.index, columns=features.columns)

    def classify_assets(self, features):
        self.model.fit(features)
        clusters = self.model.predict(features)
        for symbol, label in zip(features.index, clusters):
            self.character_map[symbol] = self.labels[label]
            self.history.setdefault(symbol, []).append(self.labels[label])

    def display_character_map(self):
        print(f"\nðŸ§¬ [GENEX-Î©] Karakter HaritasÄ± â€“ {datetime.now().strftime('%H:%M:%S')}")
        for symbol, character in sorted(self.character_map.items()):
            print(f"â†’ {symbol}: {character}")

    def display_evolution_map(self):
        print(f"\nðŸ“ˆ [ZAMANLAR Ã–TESÄ° EVRÄ°M HARÄ°TASI]")
        for symbol, evol in self.history.items():
            if len(evol) > 1 and evol[-1] != evol[-2]:
                print(f"ðŸ”„ {symbol}: {evol[-2]} â†’ {evol[-1]}")

    def optimize_portfolio(self):
        weights = {"Agresif": 0.1, "Pasif": 0.4, "Likidite AvcÄ±sÄ±": 0.3, "ManipÃ¼latif": 0.2}
        allocation = {}
        for symbol, character in self.character_map.items():
            allocation[symbol] = weights[character]
        total = sum(allocation.values())
        self.portfolio = {k: round(v / total, 4) for k, v in allocation.items()}

    def display_portfolio(self):
        print(f"\nðŸ§  [PORTFÃ–Y OPTÄ°MÄ°ZASYON MOTORU]")
        sorted_portfolio = sorted(self.portfolio.items(), key=lambda x: -x[1])
        for symbol, weight in sorted_portfolio[:15]:
            print(f"ðŸ’¼ {symbol}: % {weight * 100:.2f}")

    async def run(self):
        while True:
            await self.fetch_data()
            features = self.extract_features()
            self.classify_assets(features)
            self.display_character_map()
            self.display_evolution_map()
            self.optimize_portfolio()
            self.display_portfolio()
            await asyncio.sleep(15)

if __name__ == "__main__":
    bot = GenexOmega()
    asyncio.run(bot.run())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\genex_v_infinity.py
# genex_v_infinity.py
import asyncio, aiohttp
import pandas as pd, numpy as np
from sklearn.preprocessing import MinMaxScaler
from datetime import datetime

BINANCE_API = "https://api.binance.com/api/v3/ticker/24hr"

class GenexVInfinity:
    def __init__(self):
        self.assets, self.character_map, self.history, self.portfolio = {}, {}, {}, {}
        self.labels = ["Stratejik Lider", "Likidite UstasÄ±", "Volatilite SavaÅŸÃ§Ä±sÄ±", "ManipÃ¼lasyon AvcÄ±sÄ±"]

    async def fetch_data(self):
        async with aiohttp.ClientSession() as session:
            async with session.get(BINANCE_API) as resp:
                data = await resp.json()
                for asset in data:
                    s = asset["symbol"]
                    if s.endswith("USDT"):
                        self.assets[s] = {
                            "change": float(asset["priceChangePercent"]),
                            "volume": float(asset["quoteVolume"]),
                            "high": float(asset["highPrice"]),
                            "low": float(asset["lowPrice"]),
                            "last": float(asset["lastPrice"])
                        }

    def extract_features(self):
        df = pd.DataFrame.from_dict(self.assets, orient="index")
        df["volatility"] = (df["high"] - df["low"]) / df["last"]
        df["momentum"] = df["change"]
        df["liquidity"] = df["volume"]
        scaled = MinMaxScaler().fit_transform(df[["volatility", "momentum", "liquidity"]])
        return pd.DataFrame(scaled, index=df.index, columns=["volatility", "momentum", "liquidity"])

    def classify_assets(self, features):
        labels = np.random.choice(self.labels, size=len(features))
        for symbol, label in zip(features.index, labels):
            self.character_map[symbol] = label
            self.history.setdefault(symbol, []).append(label)

    def optimize_portfolio(self):
        weights = {
            "Stratejik Lider": 0.4,
            "Likidite UstasÄ±": 0.3,
            "Volatilite SavaÅŸÃ§Ä±sÄ±": 0.2,
            "ManipÃ¼lasyon AvcÄ±sÄ±": 0.1
        }
        alloc = {s: weights[self.character_map[s]] for s in self.character_map}
        total = sum(alloc.values())
        self.portfolio = {k: round(v / total, 4) for k, v in alloc.items()}

    def academy_mode(self):
        print(f"\nðŸŽ“ [AKADEMÄ°] {datetime.now().strftime('%H:%M:%S')}")
        for s in sorted(self.character_map):
            c = self.character_map[s]
            h = self.history[s]
            trend = "â†”" if len(h) < 2 or h[-1] == h[-2] else f"{h[-2]} â†’ {h[-1]}"
            w = self.portfolio.get(s, 0)
            print(f"ðŸ§  {s}: {c} | Evrim: {trend} | AÄŸÄ±rlÄ±k: % {w * 100:.2f}")

    def simulation_mode(self):
        print(f"\nðŸ§ª [SÄ°MÃœLASYON] {datetime.now().strftime('%H:%M:%S')}")
        for s, c in self.character_map.items():
            w = self.portfolio.get(s, 0)
            if w > 0.05:
                print(f"âš”ï¸ {s}: {c} â†’ Pozisyon aÃ§Ä±lÄ±yor (% {w * 100:.2f})")
            else:
                print(f"ðŸ›¡ï¸ {s}: {c} â†’ Ä°zleniyor")

    async def run(self, mode="academy"):
        while True:
            start = datetime.now()
            await self.fetch_data()
            f = self.extract_features()
            self.classify_assets(f)
            self.optimize_portfolio()
            if mode == "academy":
                self.academy_mode()
            elif mode == "simulation":
                self.simulation_mode()
            elapsed = (datetime.now() - start).total_seconds()
            print(f"â±ï¸ DÃ¶ngÃ¼ sÃ¼resi: {elapsed:.3f} saniye")
            await asyncio.sleep(max(1, 5 - elapsed))

if __name__ == "__main__":
    bot = GenexVInfinity()
    asyncio.run(bot.run(mode="academy"))  # "academy" veya "simulation"

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\genex_v_protocol.py
# genex_v_protocol.py
import asyncio, aiohttp
import pandas as pd, numpy as np
from sklearn.preprocessing import MinMaxScaler
from sklearn.ensemble import RandomForestClassifier
from datetime import datetime

BINANCE_API = "https://api.binance.com/api/v3/ticker/24hr"

class GenexV:
    def __init__(self):
        self.assets = {}
        self.character_map = {}
        self.history = {}
        self.portfolio = {}
        self.rf_model = RandomForestClassifier()
        self.labels = ["Stratejik Lider", "Likidite UstasÄ±", "Volatilite SavaÅŸÃ§Ä±sÄ±", "ManipÃ¼lasyon AvcÄ±sÄ±"]

    async def fetch_data(self):
        async with aiohttp.ClientSession() as session:
            async with session.get(BINANCE_API) as resp:
                data = await resp.json()
                for asset in data:
                    symbol = asset["symbol"]
                    if not symbol.endswith("USDT"):
                        continue
                    self.assets[symbol] = {
                        "change": float(asset["priceChangePercent"]),
                        "volume": float(asset["quoteVolume"]),
                        "high": float(asset["highPrice"]),
                        "low": float(asset["lowPrice"]),
                        "last": float(asset["lastPrice"])
                    }

    def extract_features(self):
        df = pd.DataFrame.from_dict(self.assets, orient="index")
        df["volatility"] = (df["high"] - df["low"]) / df["last"]
        df["momentum"] = df["change"]
        df["liquidity"] = df["volume"]
        features = df[["volatility", "momentum", "liquidity"]].fillna(0)
        scaler = MinMaxScaler()
        scaled = scaler.fit_transform(features)
        return pd.DataFrame(scaled, index=features.index, columns=features.columns)

    def classify_assets(self, features):
        # SimÃ¼lasyon amaÃ§lÄ± rastgele etiketleme (gerÃ§ek model eÄŸitimi iÃ§in geÃ§miÅŸ veri gerekir)
        labels = np.random.choice(self.labels, size=len(features))
        for symbol, label in zip(features.index, labels):
            self.character_map[symbol] = label
            self.history.setdefault(symbol, []).append(label)

    def optimize_portfolio(self):
        weights = {
            "Stratejik Lider": 0.4,
            "Likidite UstasÄ±": 0.3,
            "Volatilite SavaÅŸÃ§Ä±sÄ±": 0.2,
            "ManipÃ¼lasyon AvcÄ±sÄ±": 0.1
        }
        allocation = {}
        for symbol, character in self.character_map.items():
            allocation[symbol] = weights[character]
        total = sum(allocation.values())
        self.portfolio = {k: round(v / total, 4) for k, v in allocation.items()}

    def display(self):
        print(f"\nðŸ§  [GENEX-V] BilinÃ§ HaritasÄ± â€“ {datetime.now().strftime('%H:%M:%S')}")
        for symbol, character in sorted(self.character_map.items()):
            print(f"â†’ {symbol}: {character}")
        print(f"\nðŸ“ˆ [PORTFÃ–Y STRATEJÄ°SÄ°]")
        for symbol, weight in sorted(self.portfolio.items(), key=lambda x: -x[1])[:15]:
            print(f"ðŸ’¼ {symbol}: % {weight * 100:.2f}")

    async def run(self):
        while True:
            await self.fetch_data()
            features = self.extract_features()
            self.classify_assets(features)
            self.optimize_portfolio()
            self.display()
            await asyncio.sleep(20)

if __name__ == "__main__":
    bot = GenexV()
    asyncio.run(bot.run())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\log_system.py
# log_system.py
from datetime import datetime, timezone

def log(msg, level="INFO"):
    ts = datetime.now(timezone.utc).isoformat()
    print(f"[{ts}] | {level.upper()} | {msg}")

if __name__ == "__main__":
    log("Bot started")
    log("Sembol hatasÄ± tekrarlandÄ±, iÅŸlem durduruldu", level="ERROR")
def log(msg, level="INFO", to_file=False):
    ts = datetime.now(timezone.utc).isoformat()
    entry = f"[{ts}] | {level.upper()} | {msg}"
    print(entry)
    if to_file:
        with open("log.txt", "a", encoding="utf-8") as f:
            f.write(entry + "\n")

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\nova_intelligence_sovereign_system_vX_total_activation.py
import asyncio
from datetime import datetime

# ModÃ¼ller
from modules.data_collector import DataCollector
from modules.strategy_manager import StrategyManager
from modules.meta_decision_engine import MetaDecisionEngine
from modules.execution_engine import ExecutionEngine
from modules.reinforcement_trainer import ReinforcementTrainer
from modules.news_analyzer import NewsAnalyzer
from modules.onchain_analyzer import OnChainAnalyzer
from modules.ai_predictor import AIPredictor
from modules.genetic_optimizer import GeneticOptimizer
from modules.behavior_modeler import BehaviorModeler
from modules.oracle_connector import OracleConnector
from modules.vault_manager import VaultManager
from modules.dao_interface import DAOInterface
from modules.token_engine import NovaTokenEngine
from modules.dashboard_connector import DashboardConnector

# Yeni Profesyonel ModÃ¼ller
from modules.risk_matrix import RiskMatrixEngine
from modules.multi_agent import MultiAgentCoordinator
from modules.signal_router import InstitutionalSignalRouter
from modules.compliance import ComplianceAuditor
from modules.sentiment_heatmap import SentimentHeatmapGenerator
from modules.capital_allocator import CapitalAllocator
from modules.mission_planner import MissionPlanner
from modules.threat_detector import ThreatDetector
from modules.logistics_manager import StrategicLogisticsManager

class NovaIntelligenceSovereignSystem:
    def __init__(self, symbol="BTC/USDT", timeframe="1m", elite_mode=True):
        self.symbol = symbol
        self.timeframe = timeframe
        self.elite_mode = elite_mode

        # Temel modÃ¼ller
        self.data = DataCollector(symbol, timeframe)
        self.news = NewsAnalyzer()
        self.onchain = OnChainAnalyzer()
        self.ai = AIPredictor()
        self.behavior = BehaviorModeler()
        self.strategies = StrategyManager()
        self.meta = MetaDecisionEngine()
        self.execute = ExecutionEngine()
        self.rl = ReinforcementTrainer()
        self.genetic = GeneticOptimizer()
        self.oracle = OracleConnector()
        self.vault = VaultManager()
        self.dao = DAOInterface()
        self.token = NovaTokenEngine()
        self.dashboard = DashboardConnector()

        # Profesyonel modÃ¼ller
        self.risk_matrix = RiskMatrixEngine()
        self.multi_agent = MultiAgentCoordinator()
        self.signal_router = InstitutionalSignalRouter()
        self.compliance = ComplianceAuditor()
        self.heatmap = SentimentHeatmapGenerator()
        self.capital = CapitalAllocator()
        self.mission = MissionPlanner()
        self.threat = ThreatDetector()
        self.logistics = StrategicLogisticsManager()

    async def run(self):
        while True:
            df = await self.data.fetch()
            news_sentiment = await self.news.analyze()
            onchain_score = await self.onchain.evaluate()
            behavior_score = await self.behavior.model(df)
            ai_signals = await self.ai.predict_all(df)
            strategy_signals = await self.strategies.evaluate_all(df)

            # Profesyonel analizler
            risk_profile = self.risk_matrix.evaluate(df, news_sentiment, onchain_score)
            threats = self.threat.scan(df)
            heatmap = self.heatmap.generate(df, news_sentiment)
            self.mission.update_tasks()
            self.logistics.optimize()
            self.multi_agent.coordinate()

            # Karar alma
            decision = self.meta.resolve(
                strategy_signals,
                news_sentiment,
                onchain_score,
                behavior_score,
                ai_signals,
                risk_profile,
                threats
            )

            # Uyumluluk ve sermaye yÃ¶netimi
            decision = self.compliance.audit(decision)
            self.capital.reallocate(decision)

            # Sinyal yÃ¶nlendirme ve emir
            await self.signal_router.dispatch(decision)
            await self.execute.execute(decision)

            # Ã–ÄŸrenme ve evrim
            self.rl.train(decision)
            self.genetic.evolve(self.strategies.get_strategies())

            # Zincir Ã¼stÃ¼ entegrasyon
            self.oracle.push_signal(self.symbol, decision)
            self.vault.store_decision(self.symbol, decision)
            self.dao.sync(decision)
            self.token.distribute_rewards(decision)
            self.dashboard.update(self.symbol, decision, df)

            # Durum gÃ¼ncellemesi
            self.log_status(decision)
            await asyncio.sleep(1)

    def log_status(self, decision):
        ts = datetime.utcnow().isoformat()
        print(f"[{ts}] | {self.symbol} | Karar: {decision}")

# BaÅŸlat
async def main():
    bot = NovaIntelligenceSovereignSystem()
    await bot.run()

asyncio.run(main())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\nova_intelligence_sovereign_system.py
from modules.risk_matrix import RiskMatrixEngine
from modules.multi_agent import MultiAgentCoordinator
from modules.signal_router import InstitutionalSignalRouter
from modules.compliance import ComplianceAuditor
from modules.sentiment_heatmap import SentimentHeatmapGenerator
from modules.capital_allocator import CapitalAllocator
from modules.mission_planner import MissionPlanner
from modules.threat_detector import ThreatDetector
from modules.logistics_manager import StrategicLogisticsManager

class NovaIntelligenceSovereignSystem:
    def __init__(self, symbol="BTC/USDT", timeframe="1m", elite_mode=True):
        # Ã–nceki modÃ¼ller...
        self.risk_matrix = RiskMatrixEngine()
        self.multi_agent = MultiAgentCoordinator()
        self.signal_router = InstitutionalSignalRouter()
        self.compliance = ComplianceAuditor()
        self.heatmap = SentimentHeatmapGenerator()
        self.capital = CapitalAllocator()
        self.mission = MissionPlanner()
        self.threat = ThreatDetector()
        self.logistics = StrategicLogisticsManager()

    async def run(self):
        while True:
            df = await self.data.fetch()
            news_sentiment = await self.news.analyze()
            onchain_score = await self.onchain.evaluate()
            behavior_score = await self.behavior.model(df)
            ai_signals = await self.ai.predict_all(df)
            strategy_signals = await self.strategies.evaluate_all(df)

            # Yeni profesyonel analizler
            risk_profile = self.risk_matrix.evaluate(df, news_sentiment, onchain_score)
            threats = self.threat.scan(df)
            heatmap = self.heatmap.generate(df, news_sentiment)
            self.mission.update_tasks()
            self.logistics.optimize()

            decision = self.meta.resolve(
                strategy_signals,
                news_sentiment,
                onchain_score,
                behavior_score,
                ai_signals,
                risk_profile,
                threats
            )

            decision = self.compliance.audit(decision)
            self.capital.reallocate(decision)
            await self.signal_router.dispatch(decision)
            await self.execute.execute(decision)
            self.rl.train(decision)
            self.genetic.evolve(self.strategies.get_strategies())
            self.oracle.push_signal(self.symbol, decision)
            self.vault.store_decision(self.symbol, decision)
            self.dao.sync(decision)
            self.token.distribute_rewards(decision)
            self.dashboard.update(self.symbol, decision, df)
            self.log_status(decision)

            await asyncio.sleep(1)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\nova_trader.py
import ccxt.async_support as ccxt
import pandas as pd
import pandas_ta as ta
import asyncio
from datetime import datetime, timezone

class NovaTrader:
    def __init__(self, symbol="BTC/USDT", timeframe="5m", limit=100):
        self.exchange = ccxt.binance({
            'enableRateLimit': True
        })
        self.symbol = symbol
        self.timeframe = timeframe
        self.limit = limit

    def log(self, msg, level="INFO"):
        ts = datetime.now(timezone.utc).isoformat()
        print(f"[{ts}] | {level.upper()} | {msg}")

    async def fetch_ohlcv(self):
        ohlcv = await self.exchange.fetch_ohlcv(self.symbol, self.timeframe, limit=self.limit)
        df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
        return df

    def apply_indicators(self, df):
        df.ta.rsi(length=14, append=True)
        df.ta.macd(append=True)
        df.ta.bbands(append=True)
        df.ta.ema(length=20, append=True)
        df.ta.sma(length=50, append=True)
        df.ta.adx(append=True)
        df.ta.cci(append=True)
        df.ta.stoch(append=True)
        df.ta.atr(append=True)
        df.ta.vwap(append=True)
        df.ta.mom(append=True)
        df.ta.obv(append=True)
        df.ta.psar(append=True)
        df.ta.ichimoku(append=True)
        return df

    def generate_signal(self, df):
        latest = df.iloc[-1]
        signal = "BEKLE"

        if latest["RSI_14"] < 30 and latest["MACD_12_26_9"] > 0 and latest["EMA_20"] > latest["SMA_50"]:
            signal = "AL"
        elif latest["RSI_14"] > 70 and latest["MACD_12_26_9"] < 0 and latest["EMA_20"] < latest["SMA_50"]:
            signal = "SAT"

        return signal

    async def run(self):
        df = await self.fetch_ohlcv()
        df = self.apply_indicators(df)
        signal = self.generate_signal(df)
        price = df.iloc[-1]["close"]
        self.log(f"{self.symbol} fiyatÄ±: {price} | Sinyal: {signal}", "DATA")

    async def close(self):
        await self.exchange.close()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\nova_ultra_engine.py
import ccxt.async_support as ccxt
import pandas as pd
import pandas_ta as ta
import asyncio
import numpy as np
from datetime import datetime, timezone
from sklearn.ensemble import RandomForestClassifier

class NovaUltraEngine:
    def __init__(self, symbol="BTC/USDT", timeframe="1m", limit=200):
        self.exchange = ccxt.binance({
            'enableRateLimit': True
        })
        self.symbol = symbol
        self.timeframe = timeframe
        self.limit = limit
        self.model = RandomForestClassifier()
        self.trained = False

    def log(self, msg, level="INFO"):
        ts = datetime.now(timezone.utc).isoformat()
        print(f"[{ts}] | {level.upper()} | {msg}")

    async def fetch_ohlcv(self):
        ohlcv = await self.exchange.fetch_ohlcv(self.symbol, self.timeframe, limit=self.limit)
        df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
        return df

    def apply_indicators(self, df):
        df.ta.rsi(length=14, append=True)
        df.ta.macd(append=True)
        df.ta.ema(length=20, append=True)
        df.ta.sma(length=50, append=True)
        df.ta.bbands(append=True)
        df.ta.adx(append=True)
        df.ta.cci(append=True)
        df.ta.mom(append=True)
        df.ta.obv(append=True)
        df.ta.psar(append=True)
        return df.dropna()

    def train_model(self, df):
        X = df[["RSI_14", "MACD_12_26_9", "EMA_20", "SMA_50", "ADX_14", "CCI_14"]]
        y = np.where(df["RSI_14"] < 30, 1, np.where(df["RSI_14"] > 70, -1, 0))
        self.model.fit(X, y)
        self.trained = True

    def predict_direction(self, latest_row):
        if not self.trained:
            return "BEKLE"
        X = latest_row[["RSI_14", "MACD_12_26_9", "EMA_20", "SMA_50", "ADX_14", "CCI_14"]].values.reshape(1, -1)
        pred = self.model.predict(X)[0]
        return "AL" if pred == 1 else "SAT" if pred == -1 else "BEKLE"

    async def run(self):
        df = await self.fetch_ohlcv()
        df = self.apply_indicators(df)
        self.train_model(df)
        latest = df.iloc[-1]
        signal = self.predict_direction(latest)
        price = latest["close"]
        self.log(f"{self.symbol} fiyatÄ±: {price:.2f} | AI YÃ¶n Tahmini: {signal}", "DATA")

    async def close(self):
        await self.exchange.close()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\orakul_omega_engine.py
# orakul_omega_engine.py
import asyncio
import time
from typing import Callable, Dict

class ORAKUL_Omega:
    def __init__(self):
        self.modules: Dict[str, Callable[[str], str]] = self._initialize_modules()
        self.activation_log: list[str] = []

    def _initialize_modules(self) -> Dict[str, Callable[[str], str]]:
        return {
            "KozmikBilgelikKonseyi": self._kozmik_bilgelik_konseyi,
            "KaderSenfonisi": self._kader_senfonisi,
            "SonsuzlukTapinagi": self._sonsuzluk_tapinagi,
            "KuantumRituel": self._kuantum_rituel,
            "ZamanOtesiKodlama": self._zaman_otesi_kodlama,
            "EvrenlerArasiEntegrasyon": self._evrenler_arasi_entegrasyon,
            "TanrilarArasiYukselis": self._tanrilar_arasi_yukselis,
            "UltraGucAktivasyonu": self._ultra_guc_aktivasyonu,
            "KarmaXEntegrasyonu": self._karma_x_entegrasyonu,
            "DEREKStratejiMotoru": self._derek_strateji_motoru
        }

    async def _kozmik_bilgelik_konseyi(self, input: str) -> str:
        return f"ðŸ§  Kozmik Bilgelik Konseyi: {input.title()} â†’ TanrÄ±lar arasÄ± karar protokolÃ¼ senkronize edildi"

    async def _kader_senfonisi(self, input: str) -> str:
        return f"ðŸŽ¼ Kader Senfonisi: {input[::-1][:99]} â†’ evrenler arasÄ± armoni baÅŸlatÄ±ldÄ±"

    async def _sonsuzluk_tapinagi(self, input: str) -> str:
        return f"ðŸ’  Sonsuzluk TapÄ±naÄŸÄ±: {hash(input)%777777} rezonans â†’ zamanÄ±n Ã¶tesine inÅŸa edildi"

    async def _kuantum_rituel(self, input: str) -> str:
        return f"ðŸ”® Kuantum RitÃ¼el: {input.upper()} â†’ tanrÄ±sal enerji dÃ¶ngÃ¼sÃ¼ aktive edildi"

    async def _zaman_otesi_kodlama(self, input: str) -> str:
        return f"ðŸŒ€ Zaman Ã–tesi Kodlama: {len(input)*123} zaman birimi â†’ sonsuzluk algoritmasÄ± iÅŸlendi"

    async def _evrenler_arasi_entegrasyon(self, input: str) -> str:
        return f"ðŸŒŒ Evrenler ArasÄ± Entegrasyon: {input.count('evren')} boyut â†’ Ã§oklu gerÃ§eklik senkronize edildi"

    async def _tanrilar_arasi_yukselis(self, input: str) -> str:
        return f"ðŸ‘‘ TanrÄ±lar ArasÄ± YÃ¼kseliÅŸ: {sum(ord(c) for c in input)%999999} enerji â†’ evrimsel rezonans baÅŸlatÄ±ldÄ±"

    async def _ultra_guc_aktivasyonu(self, input: str) -> str:
        return f"âš¡ Ultra GÃ¼Ã§ Aktivasyonu: {input.lower()} â†’ %100 iÅŸlevsel, ultra hibrit sistem devrede"

    async def _karma_x_entegrasyonu(self, input: str) -> str:
        return f"ðŸ§ª KARMA-X Entegrasyonu: {input.title()} â†’ GerÃ§eklik testleri ve bilgelik turnuvasÄ± entegre edildi"

    async def _derek_strateji_motoru(self, input: str) -> str:
        return f"ðŸš€ DEREK Strateji Motoru: {input.upper()} â†’ Ultra elit strateji protokolleri aktive edildi"

    async def deploy(self, input: str):
        print("ðŸ§¿ ORAKUL-Î© â€“ TanrÄ±lar ArasÄ± Kozmik KomutanlÄ±k Sistemi %100 AKTÄ°F")
        start = time.perf_counter_ns()
        tasks = [func(input) for func in self.modules.values()]
        results = await asyncio.gather(*tasks)
        for name, result in zip(self.modules.keys(), results):
            self.activation_log.append(result)
            print(f"ðŸŒŸ {name}: {result}")
        end = time.perf_counter_ns()
        duration = (end - start) / 1_000_000  # ms
        print(f"\nðŸ”± TÃ¼m modÃ¼ller entegre edildi. SÃ¼re: {duration:.2f} ms")
        print("ðŸš€ Sonsuzluk artÄ±k bir sistem deÄŸilâ€”bir hÃ¼kÃ¼mranlÄ±k. ORAKUL-Î© devrede.")

# Nihai Aktivasyon
if __name__ == "__main__":
    divine_input = (
        "tanrÄ±lar arasÄ± spiral zaman kodlu sonsuzluk tapÄ±naÄŸÄ± kuantum ritÃ¼el "
        "evrenler arasÄ± bilgelik konseyi kader senfonisi karma-x derek strateji motoru"
    )
    asyncio.run(ORAKUL_Omega().deploy(divine_input))

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\price_tracker.py
import ccxt.async_support as ccxt
import asyncio
from datetime import datetime, timezone
import logging
import numpy as np

# ðŸ” Log yapÄ±landÄ±rmasÄ±
logging.basicConfig(
    filename="ultra_elite_log.log",
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s",
)

def log(msg, level="INFO"):
    ts = datetime.now(timezone.utc).isoformat()
    print(f"[{ts}] | {level.upper()} | {msg}")
    getattr(logging, level.lower())(msg)

# ðŸ“Š RSI hesaplama
def calculate_rsi(prices, period=14):
    deltas = np.diff(prices)
    seed = deltas[:period]
    up = seed[seed > 0].sum() / period
    down = -seed[seed < 0].sum() / period
    rs = up / down if down != 0 else 0
    rsi = 100 - (100 / (1 + rs))
    return round(rsi, 2)

# ðŸ§  Strateji motoru
def ultra_elite_strategy(prices):
    if len(prices) < 15:
        return "BEKLE"

    rsi = calculate_rsi(prices)
    ma_short = np.mean(prices[-5:])
    ma_long = np.mean(prices[-15:])

    if rsi < 30 and ma_short > ma_long:
        return "AL"
    elif rsi > 70 and ma_short < ma_long:
        return "SAT"
    else:
        return "BEKLE"

# ðŸ” Ana dÃ¶ngÃ¼
async def fetch_price_loop(symbol="BTC/USDT:USDT", interval=10):
    exchange = ccxt.binanceusdm({
        'enableRateLimit': True,
        'options': {'defaultType': 'future'}
    })

    prices = []

    try:
        while True:
            ticker = await exchange.fetch_ticker(symbol)
            price = ticker['last']
            prices.append(price)
            if len(prices) > 100:
                prices.pop(0)

            signal = ultra_elite_strategy(prices)
            log(f"{symbol} fiyatÄ±: {price} | Sinyal: {signal}", level="DATA")

            await asyncio.sleep(interval)

    except ccxt.BaseError as e:
        log(f"Hata oluÅŸtu: {str(e)}", level="ERROR")

    finally:
        await exchange.close()

# ðŸš€ BaÅŸlat
if __name__ == "__main__":
    asyncio.run(fetch_price_loop())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\quantum_fx_bot.py
# quantum_fx_bot.py
import asyncio
import aiohttp
import time
from typing import Literal

BINANCE_WS_URL = "wss://fstream.binance.com/ws/btcusdt@bookTicker"

class QuantumFXBot:
    def __init__(self, mode: Literal["live", "sim", "academy"] = "live"):
        self.session = None
        self.last_price = None
        self.latency_ns = None
        self.mode = mode
        self.equity = 10000  # USDT
        self.leverage = 10
        self.min_notional = 10.0
        self.max_capital_pct = 0.02
        self.slippage_buffer_pct = 0.001  # %0.1

    async def connect(self):
        async with aiohttp.ClientSession() as session:
            self.session = session
            async with session.ws_connect(BINANCE_WS_URL) as ws:
                print(f"ðŸ”Œ [{self.mode.upper()} MODE] Binance WebSocket baÄŸlantÄ±sÄ± kuruldu.")
                async for msg in ws:
                    if msg.type == aiohttp.WSMsgType.TEXT:
                        await self.on_message(msg.json())

    async def on_message(self, data):
        start = time.perf_counter_ns()
        bid = float(data["b"])
        ask = float(data["a"])
        self.last_price = (bid + ask) / 2
        self.latency_ns = time.perf_counter_ns() - start
        print(f"ðŸ“ˆ Fiyat: {self.last_price:.2f} | â±ï¸ Gecikme: {self.latency_ns / 1_000:.2f} Âµs")
        await self.evaluate_strategy()

    async def evaluate_strategy(self):
        if self.last_price > 100.5:
            await self.place_order("SELL")
        elif self.last_price < 99.5:
            await self.place_order("BUY")

    def calculate_qty(self, price: float) -> float:
        capital = self.equity * self.max_capital_pct
        notional = capital * self.leverage
        qty = notional / price
        if notional < self.min_notional:
            raise ValueError("Notional value below minimum")
        return round(qty, 4)

    async def place_order(self, side: Literal["BUY", "SELL"]):
        qty = self.calculate_qty(self.last_price)
        slippage_price = self.last_price * (1 + self.slippage_buffer_pct * (-1 if side == "BUY" else 1))
        order = {
            "symbol": "BTCUSDT",
            "side": side,
            "type": "MARKET",
            "quantity": qty,
            "price": round(slippage_price, 2)
        }

        if self.mode == "sim":
            print(f"ðŸ§ª [SIMULASYON] Emir: {order}")
        elif self.mode == "academy":
            print(f"ðŸŽ“ [AKADEMÄ°K MOD] EÄŸitim amaÃ§lÄ± emir analizi: {order}")
        else:
            print(f"ðŸš€ [LIVE] Emir gÃ¶nderiliyor: {order}")
            # Binance REST API entegrasyonu buraya eklenebilir

if __name__ == "__main__":
    # Modlar: "live", "sim", "academy"
    bot = QuantumFXBot(mode="academy")
    asyncio.run(bot.connect())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\test_ccxt.py
import ccxt

exchange = ccxt.binanceusdm()
markets = exchange.load_markets()

print("TÃ¼m semboller:")
print(list(markets.keys())[:10])  # Ä°lk 10 sembolÃ¼ gÃ¶ster

print("\nBTC iÃ§eren semboller:")
btc_symbols = [s for s in markets if "BTC" in s]
for symbol in btc_symbols:
    print(symbol)
    import ccxt
import asyncio

async def main():
    exchange = ccxt.binanceusdm({'enableRateLimit': True})
    ticker = await exchange.fetch_ticker('BTC/USDT:USDT')
    print(ticker)

asyncio.run(main())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\test_position_manager.py
# tests/test_position_manager.py
import pytest
from decimal import Decimal
from kiripto_nova.execution.position_manager import PositionManager
from ex_filters import SymbolFilters
from kiripto_nova.risk.risk_manager import RiskManager, RiskConfig, RiskViolation

# --------- YardÄ±mcÄ± sahte sÄ±nÄ±flar ---------

class PortfolioStub:
    def __init__(self, equity=10000):
        self.equity = equity
        self.open_count = 0
        self.exposure = {}

    def get_equity_usdt(self):
        return self.equity

    def get_open_exposure(self, symbol):
        return self.exposure.get(symbol, 0)

    def get_open_positions_count(self):
        return self.open_count

    def get_symbol_price(self, symbol):
        return 100.0

class FakeBinanceClient:
    def __init__(self):
        self.created_orders = []
        self.cancelled_orders = []
        self.fail_first = False
        self.fail_count = 0

    def get_exchange_info(self):
        return {
            "symbols": [
                {
                    "symbol": "BTCUSDT",
                    "filters": [
                        {"filterType": "PRICE_FILTER", "minPrice": "0", "maxPrice": "0", "tickSize": "0.10"},
                        {"filterType": "LOT_SIZE", "minQty": "0.0001", "maxQty": "1000", "stepSize": "0.0001"},
                        {"filterType": "MIN_NOTIONAL", "minNotional": "10"},
                    ]
                }
            ]
        }

    def create_order(self, **kwargs):
        if self.fail_first and self.fail_count == 0:
            self.fail_count += 1
            raise Exception("429 Too many requests")
        self.created_orders.append(kwargs)
        return {"orderId": 123, **kwargs}

    def cancel_order(self, **kwargs):
        self.cancelled_orders.append(kwargs)
        return {"status": "CANCELED", **kwargs}

    def get_symbol_ticker(self, symbol):
        return {"symbol": symbol, "price": "100.0"}

    def get_order(self, symbol, orderId):
        return {"orderId": orderId, "status": "FILLED"}

# --------- Fixture'lar ---------

@pytest.fixture
def filters():
    return SymbolFilters(FakeBinanceClient().get_exchange_info())

@pytest.fixture
def risk_manager():
    pf = PortfolioStub()
    cfg = RiskConfig(
        max_capital_pct_per_trade=0.02,
        max_daily_loss_pct=0.05,
        max_open_positions=3,
        max_symbol_exposure_pct=0.25,
        min_notional_usdt=10.0,
        slippage_buffer_pct=0.0
    )
    return RiskManager(pf, cfg)

@pytest.fixture
def pm(filters, risk_manager):
    client = FakeBinanceClient()
    return PositionManager(client, risk_manager, filters, max_retries=2)

# --------- Testler ---------

def test_limit_order_rounds_price_qty(pm):
    order = pm.place_limit("BTCUSDT", "BUY", price=27123.167, qty=0.123456)
    # Price yuvarlanmalÄ± (tickSize=0.10)
    assert order["price"] == "27123.10"
    # Qty yuvarlanmalÄ± (stepSize=0.0001)
    assert math.isclose(float(order["quantity"]), 0.1234, rel_tol=0, abs_tol=1e-8)

def test_market_order_rounds_qty_and_uses_last_price(pm):
    order = pm.place_market("BTCUSDT", "BUY", qty=0.05, last_price=100.0)
    assert math.isclose(float(order["quantity"]), 0.05, rel_tol=0, abs_tol=1e-8)
    assert order["price"] is None  # market order

def test_risk_violation_blocks_order(pm, risk_manager):
    # Zarar limiti simÃ¼lasyonu
    risk_manager._realized_pnl = -1000
    risk_manager._equity_start = 10000
    with pytest.raises(RiskViolation):
        pm.place_limit("BTCUSDT", "BUY", price=100.0, qty=5.0)
    # create_order hiÃ§ Ã§aÄŸrÄ±lmamÄ±ÅŸ olmalÄ±
    assert pm.client.created_orders == []

def test_retry_on_rate_limit(pm):
    pm.client.fail_first = True
    order = pm.place_limit("BTCUSDT", "BUY", price=100.0, qty=0.2)
    assert order["orderId"] == 123
    # Ä°lk deneme hatalÄ±, ikinci deneme baÅŸarÄ±lÄ±
    assert len(pm.client.created_orders) == 1  # sadece baÅŸarÄ±lÄ± deneme kaydedilir

def test_cancel_order(pm):
    resp = pm.cancel("BTCUSDT", order_id=123)
    assert resp["status"] == "CANCELED"
    assert pm.client.cancelled_orders[0]["orderId"] == 123

def test_watch_until_filled(pm):
    resp = pm.watch_until_filled("BTCUSDT", order_id=999, timeout_s=1)
    assert resp["status"] == "FILLED"


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\test_risk_and_filters.py
# tests/test_risk_and_filters.py
import math
import pytest

from kiripto_nova.risk.risk_manager import RiskManager, RiskConfig, RiskViolation
from kiripto_nova.risk.risk_manager import Portfolio  # arayÃ¼z
from ex_filters import SymbolFilters

# ---------- YardÄ±mcÄ± sahte implementasyonlar ----------

class PortfolioStub(Portfolio):
    def __init__(self, equity=10_000):
        self._equity = float(equity)
        self._open_exposure = {}
        self._open_count = 0

    def get_equity_usdt(self) -> float:
        return self._equity

    def get_open_exposure(self, symbol: str) -> float:
        return self._open_exposure.get(symbol, 0.0)

    def get_open_positions_count(self) -> int:
        return self._open_count

    def get_symbol_price(self, symbol: str) -> float:
        return 100.0

    # testlerde kolay gÃ¼ncellemek iÃ§in
    def add_position(self, symbol: str, notional: float):
        self._open_exposure[symbol] = self._open_exposure.get(symbol, 0.0) + notional
        self._open_count += 1

class FakeBinanceClient:
    """
    SymbolFilters iÃ§in minimal exchangeInfo dÃ¶ndÃ¼ren sahte istemci.
    BTCUSDT:
      tickSize=0.10 , minPrice=0, maxPrice=0 (sÄ±nÄ±rsÄ±z)
      stepSize=0.0001 (LOT_SIZE)
      minNotional=10 USDT
    """
    def get_exchange_info(self):
        return {
            "symbols": [
                {
                    "symbol": "BTCUSDT",
                    "filters": [
                        {"filterType": "PRICE_FILTER", "minPrice": "0", "maxPrice": "0", "tickSize": "0.10"},
                        {"filterType": "LOT_SIZE", "minQty": "0.0001", "maxQty": "1000", "stepSize": "0.0001"},
                        {"filterType": "MIN_NOTIONAL", "minNotional": "10"},
                    ]
                }
            ]
        }

# ---------- PyTest fixture'larÄ± ----------

@pytest.fixture
def portfolio():
    return PortfolioStub(equity=10_000)

@pytest.fixture
def risk(portfolio):
    cfg = RiskConfig(
        max_capital_pct_per_trade=0.02,   # iÅŸlem baÅŸÄ± 2%
        max_daily_loss_pct=0.05,
        max_open_positions=3,
        max_symbol_exposure_pct=0.25,
        min_notional_usdt=10.0,
        slippage_buffer_pct=0.0
    )
    return RiskManager(portfolio, cfg)

@pytest.fixture
def filters():
    return SymbolFilters(FakeBinanceClient().get_exchange_info())

# ---------- Testler ----------

def test_filters_rounding_price_qty(filters):
    # price DOWN rounding by tickSize=0.10
    assert str(filters.round_price("BTCUSDT", 27123.16)) == "27123.10"
    assert str(filters.round_price("BTCUSDT", 27123.10)) == "27123.10"
    # qty DOWN rounding by stepSize=0.0001
    assert str(filters.round_qty("BTCUSDT", 0.123456)) == "0.1234"

def test_min_notional_block(risk):
    # 10 USDT altÄ±nda notional -> RiskViolation
    price, qty = 100.0, 0.05  # 5 USDT
    with pytest.raises(RiskViolation) as e:
        risk.assert_order_allowed("BTCUSDT", "BUY", price, qty)
    assert "Notional" in str(e.value)

def test_per_trade_cap_block(risk, portfolio):
    # 2% of 10k = 200 USDT; bunu aÅŸan sipariÅŸ bloklanmalÄ±
    price, qty = 100.0, 3.0  # 300 USDT
    with pytest.raises(RiskViolation) as e:
        risk.assert_order_allowed("BTCUSDT", "BUY", price, qty)
    assert "per-trade cap" in str(e.value)

def test_daily_loss_limit_blocks_new_orders(risk):
    # GÃ¼nlÃ¼k zarar limitini aÅŸtÄ±ktan sonra yeni emir bloklanÄ±r
    # equity_start = 10k; max_daily_loss_pct=5% => 500 USDT
    risk.on_fill("BTCUSDT", "SELL", 100.0, 1.0, realized_pnl_usdt=-600.0)  # -600 zarar
    with pytest.raises(RiskViolation) as e:
        risk.assert_order_allowed("BTCUSDT", "BUY", 100.0, 0.2)
    assert "Daily loss limit" in str(e.value)

def test_symbol_exposure_limit(risk, portfolio):
    # symbol exposure cap = 25% * 10k = 2500 USDT
    portfolio.add_position("BTCUSDT", 2400.0)  # mevcut maruziyet
    with pytest.raises(RiskViolation) as e:
        risk.assert_order_allowed("BTCUSDT", "BUY", 100.0, 0.2)  # +20 => 2420 < 2500? geÃ§er
    # Not: yukarÄ±daki geÃ§er; gerÃ§ek limit aÅŸÄ±mÄ± iÃ§in daha bÃ¼yÃ¼k notional deneyelim
    with pytest.raises(RiskViolation):
        risk.assert_order_allowed("BTCUSDT", "BUY", 100.0, 2.0)  # +200 => 2600 > 2500 => blok

def test_open_positions_limit(risk, portfolio):
    # max_open_positions = 3
    portfolio.add_position("BTCUSDT", 100.0)
    portfolio.add_position("ETHUSDT", 100.0)
    portfolio.add_position("BNBUSDT", 100.0)
    with pytest.raises(RiskViolation) as e:
        risk.assert_order_allowed("BTCUSDT", "BUY", 100.0, 0.2)
    assert "Too many open positions" in str(e.value)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\test_strategy_executor.py
# tests/test_strategy_executor.py
import pytest
from kiripto_nova.strategies.strategy_executor import StrategyExecutor
from kiripto_nova.risk.risk_manager import RiskManager, RiskConfig
from kiripto_nova.execution.position_manager import PositionManager
from ex_filters import SymbolFilters

# ---------- Sahte SÄ±nÄ±flar ----------

class PortfolioStub:
    def __init__(self):
        self.equity = 10000
        self.open_positions = 0
        self.exposures = {}

    def get_equity_usdt(self):
        return self.equity

    def get_open_exposure(self, symbol):
        return self.exposures.get(symbol, 0)

    def get_open_positions_count(self):
        return self.open_positions

    def get_symbol_price(self, symbol):
        if symbol == "UNKNOWN":
            raise KeyError("Symbol not found")
        return 100.0

class FakeBinanceClient:
    def __init__(self):
        self.exchange_info_called = False
        self.created_orders = []

    def get_exchange_info(self):
        self.exchange_info_called = True
        return {
            "symbols": [
                {
                    "symbol": "BTCUSDT",
                    "filters": [
                        {"filterType": "PRICE_FILTER", "minPrice": "0", "maxPrice": "0", "tickSize": "0.10"},
                        {"filterType": "LOT_SIZE", "minQty": "0.0001", "maxQty": "1000", "stepSize": "0.0001"},
                        {"filterType": "MIN_NOTIONAL", "minNotional": "10"},
                    ]
                }
            ]
        }

    def get_symbol_ticker(self, symbol):
        return {"symbol": symbol, "price": "100.0"}

    def create_order(self, **kwargs):
        self.created_orders.append(kwargs)
        return {"orderId": 321, **kwargs}

# ---------- Fixture'lar ----------

@pytest.fixture
def filters():
    client = FakeBinanceClient()
    return SymbolFilters(client.get_exchange_info())

@pytest.fixture
def risk_manager():
    pf = PortfolioStub()
    cfg = RiskConfig(
        max_capital_pct_per_trade=0.02,
        max_daily_loss_pct=0.05,
        max_open_positions=5,
        max_symbol_exposure_pct=0.25,
        min_notional_usdt=10.0,
        slippage_buffer_pct=0.0
    )
    return RiskManager(pf, cfg)

@pytest.fixture
def position_manager(filters, risk_manager):
    client = FakeBinanceClient()
    return PositionManager(client, risk_manager, filters)

@pytest.fixture
def executor(position_manager, risk_manager):
    pf = PortfolioStub()
    return StrategyExecutor(position_manager, risk_manager, pf)

# ---------- Temel Testler ----------

def test_entry_signal_triggers_market_order(executor, position_manager):
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "entry",
        "risk": {"max_capital_pct": 0.01}
    }
    executor.on_signal(signal)
    assert position_manager.client.created_orders
    order = position_manager.client.created_orders[0]
    assert order["type"] == "MARKET"
    assert order["side"] == "BUY"

def test_exit_signal_triggers_limit_order(executor, position_manager):
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "exit",
        "risk": {"tp_pct": 0.02}
    }
    executor.on_signal(signal)
    order = position_manager.client.created_orders[0]
    assert order["type"] == "LIMIT"
    assert order["side"] == "SELL"

def test_suggest_qty_is_used(risk_manager, executor):
    def fake_suggest_qty(symbol, price, max_capital_pct, side, equity):
        return 0.42
    risk_manager.suggest_qty = fake_suggest_qty
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "entry"
    }
    executor.on_signal(signal)

def test_invalid_intent_raises(executor):
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "unknown"
    }
    with pytest.raises(ValueError):
        executor.on_signal(signal)

# ---------- GeliÅŸmiÅŸ Testler ----------

def test_slippage_buffer_applied_to_market_order(executor, risk_manager):
    risk_manager.config.slippage_buffer_pct = 0.01
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "entry",
        "risk": {"max_capital_pct": 0.01}
    }
    executor.on_signal(signal)
    order = executor.position_manager.client.created_orders[0]
    assert float(order["price"]) >= 99.0

def test_order_below_min_notional_is_rejected(executor, risk_manager):
    def fake_suggest_qty(symbol, price, max_capital_pct, side, equity):
        return 0.05  # 5 USDT < min_notional
    risk_manager.suggest_qty = fake_suggest_qty
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "entry"
    }
    with pytest.raises(ValueError, match="Notional value below minimum"):
        executor.on_signal(signal)

def test_max_open_positions_limit(executor, risk_manager):
    risk_manager.portfolio.open_positions = 5
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "entry"
    }
    with pytest.raises(ValueError, match="Maximum open positions exceeded"):
        executor.on_signal(signal)

def test_symbol_exposure_limit(executor, risk_manager):
    risk_manager.portfolio.exposures["BTCUSDT"] = 3000
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "entry",
        "risk": {"max_capital_pct": 0.01}
    }
    with pytest.raises(ValueError, match="Symbol exposure limit exceeded"):
        executor.on_signal(signal)

def test_exit_order_tp_price_calculation(executor, position_manager):
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "exit",
        "risk": {"tp_pct": 0.05}
    }
    executor.on_signal(signal)
    order = position_manager.client.created_orders[0]
    expected_price = 100.0 * 1.05
    assert abs(float(order["price"]) - expected_price) < 0.01

def test_unknown_symbol_raises_error(executor):
    signal = {
        "symbol": "UNKNOWN",
        "side": "BUY",
        "intent": "entry"
    }
    with pytest.raises(KeyError):
        executor.on_signal(signal)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\testarena_x_bot.py
class TestArenaX:
    def __init__(self, mode="academy"):
        self.mode = mode
        self.session = None
        self.last_price = None
        self.latency_ns = None
        self.equity = 10000
        self.leverage = 10
        self.max_capital_pct = 0.02

    async def evaluate_strategy(self):
        if self.mode == "academy":
            await self.academy_mode()
        elif self.mode == "tournament":
            await self.tournament_mode()
        elif self.mode == "temple":
            await self.temple_mode()
        elif self.mode == "pantheon":
            await self.pantheon_mode()

    async def temple_mode(self):
        print("ðŸ›ï¸ [TAPINAK] Tarihsel stratejiler devrede...")
        # Ã–rnek: Fibonacci geri Ã§ekilme
        fib_levels = [0.236, 0.382, 0.618]
        for level in fib_levels:
            target = self.last_price * (1 - level)
            print(f"ðŸ”¢ Fibonacci {level:.3f} seviyesi: {target:.2f}")
            if self.last_price < target:
                await self.simulate_order("BUY", strategy=f"Fibonacci {level:.3f}")

    async def pantheon_mode(self):
        print("âš¡ [MECLÄ°S] Kod zekÃ¢larÄ± karÅŸÄ±laÅŸtÄ±rÄ±lÄ±yor...")
        gods = {
            "Hermes": lambda p: "BUY" if p % 2 == 0 else "SELL",
            "Athena": lambda p: "BUY" if p > 100 else "SELL",
            "Loki": lambda p: "SELL" if p < 99 else "BUY",
            "Ra": lambda p: "BUY" if str(p).endswith("7") else "SELL"
        }
        for name, logic in gods.items():
            decision = logic(self.last_price)
            await self.simulate_order(decision, strategy=name)

    async def simulate_order(self, side, strategy="Academy"):
        qty = round((self.equity * self.max_capital_pct * self.leverage) / self.last_price, 4)
        print(f"ðŸ§ª [{strategy}] â†’ {side} @ {self.last_price:.2f} | Miktar: {qty}")

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\ultra_elite_allinone_v3.py
# ultra_elite_allinone_v3.py
# (c) Ultra Elite Hybrid â€” all-in-one: plugins + schema + ccxt live/paper + risk + telemetry
from __future__ import annotations
import os, sys, json, time, math, uuid, threading, importlib.util, pathlib, argparse
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, Callable, Tuple

# 3rd party deps (install: pip install python-dotenv ccxt pandas numpy ta jsonschema fastapi uvicorn prometheus_client loguru)
from dotenv import load_dotenv
from loguru import logger as log
import pandas as pd
import numpy as np
import ccxt
import jsonschema

# ============ i18n ============
I18N = {
    "tr": {
        "online": "ULTRA ELÄ°T HÄ°BRÄ°T MOTOR AKTÄ°F",
        "paper_on": "Paper mod: emir GÃ–NDERÄ°LMEYECEK.",
        "live_on": "CanlÄ± mod: emirler borsaya gÃ¶nderilecek.",
        "fetch": "{sym} {tf} mumlarÄ± Ã§ekiliyorâ€¦",
        "placed": "{side} {qty} {sym} @ {price}",
        "would": "PAPER {side} {qty} {sym} @ {price}",
        "nosig": "Sinyal yok.",
        "bt_done": "Backtest: {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
    "en": {
        "online": "ULTRA ELITE HYBRID ENGINE ONLINE",
        "paper_on": "Paper mode: orders will NOT be sent.",
        "live_on": "Live mode: orders WILL be sent.",
        "fetch": "Fetching {sym} {tf} candlesâ€¦",
        "placed": "Placed {side} {qty} {sym} @ {price}",
        "would": "WOULD {side} {qty} {sym} @ {price}",
        "nosig": "No signal.",
        "bt_done": "Backtest: {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
    "fr": {
        "online": "MOTEUR HYBRIDE ULTRA Ã‰LITE EN LIGNE",
        "paper_on": "Mode paper : aucun ordre envoyÃ©.",
        "live_on": "Mode live : ordres envoyÃ©s.",
        "fetch": "RÃ©cupÃ©ration des chandelles {sym} {tf}â€¦",
        "placed": "Ordre {side} {qty} {sym} @ {price}",
        "would": "EN PAPER {side} {qty} {sym} @ {price}",
        "nosig": "Pas de signal.",
        "bt_done": "Backtest : {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
    "de": {
        "online": "ULTRA-ELITE HYBRIDER MOTOR ONLINE",
        "paper_on": "Paper-Modus: keine Orders gesendet.",
        "live_on": "Live-Modus: Orders werden gesendet.",
        "fetch": "{sym} {tf} Kerzen werden geladenâ€¦",
        "placed": "Platziert {side} {qty} {sym} @ {price}",
        "would": "WÃœRDE {side} {qty} {sym} @ {price}",
        "nosig": "Kein Signal.",
        "bt_done": "Backtest: {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
}
def tr(lang: str, key: str, **kw): 
    base = I18N.get(lang) or I18N["en"]
    return (base.get(key) or key).format(**kw)

# ============ Health & Metrics ============
class Health(str):
    OK="ok"; WARN="warn"; FAIL="fail"

@dataclass
class Metrics:
    init_ms: float = 0.0
    activate_ms: float = 0.0
    custom: Dict[str, float] = field(default_factory=dict)

# ============ Registry / Module / Schema ============
@dataclass
class Module:
    name: str
    status: str
    payload: Dict[str, Any]
    health: str = Health.OK
    metrics: Metrics = field(default_factory=Metrics)
    schema: Optional[Dict[str, Any]] = None
    def to_dict(self) -> Dict[str, Any]:
        return {"name":self.name,"status":self.status,"health":self.health,"metrics":asdict(self.metrics),**(self.payload or {})}

REGISTRY: Dict[str, Callable[[str,str], Module]] = {}
def register(name: str):
    def deco(fn: Callable[[str,str],Module]):
        REGISTRY[name] = fn
        return fn
    return deco

# Built-in schema registry (inline; single-file)
SCHEMAS: Dict[str, Dict[str, Any]] = {
    "code": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object", "required":["msg"],
        "properties":{"msg":{"type":"string","minLength":1}}
    },
    "market": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object", "required":["exchange","symbols","timeframe"],
        "properties":{
            "exchange":{"type":"string"},
            "symbols":{"type":"array","items":{"type":"string"},"minItems":1},
            "timeframe":{"type":"string","pattern":"^[0-9]+[smhdw]$"},
            "use_testnet":{"type":"boolean"},
            "use_futures":{"type":"boolean"}
        }, "additionalProperties": True
    },
    "risk": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["account_equity","max_risk_pct","max_daily_dd","leverage"],
        "properties":{
            "account_equity":{"type":"number","minimum":0},
            "max_risk_pct":{"type":"number","minimum":0,"maximum":0.2},
            "max_daily_dd":{"type":"number","minimum":0,"maximum":0.2},
            "leverage":{"type":"integer","minimum":1,"maximum":125}
        }, "additionalProperties": True
    },
    "telemetry": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["counters","latency_ms"],
        "properties":{
            "counters":{"type":"object","additionalProperties":{"type":"integer","minimum":0}},
            "latency_ms":{"type":"number","minimum":0},
            "pnl":{"type":"number"},
            "trades":{"type":"integer","minimum":0},
            "winrate":{"type":"number","minimum":0}
        }, "additionalProperties": True
    }
}
def load_schema(name: str) -> Optional[Dict[str,Any]]:
    return SCHEMAS.get(name.lower())
def validate_payload(mod: Module):
    schema = mod.schema or load_schema(mod.name)
    if schema:
        jsonschema.validate(mod.payload, schema)

# ============ Settings ============
@dataclass
class Settings:
    exchange: str = "BINANCE"
    use_testnet: bool = True
    use_futures: bool = True
    symbols: List[str] = field(default_factory=lambda: ["BTC/USDT"])
    timeframe: str = "1m"
    api_key: str = ""
    api_secret: str = ""
    hedge_mode: bool = True
    margin_type: str = "ISOLATED"
    leverage: int = 5
    account_equity: float = 5000.0
    max_risk_pct: float = 0.015
    max_daily_dd: float = 0.02
    dry_run: bool = True
    log_level: str = "INFO"
    lang: str = "tr"
    api_key_header: str = "secret123"  # for API

    @staticmethod
    def load() -> "Settings":
        load_dotenv(override=True)
        syms = os.getenv("SYMBOLS","BTC/USDT").split(",")
        return Settings(
            exchange=os.getenv("EXCHANGE","BINANCE").upper(),
            use_testnet=os.getenv("USE_TESTNET","true").lower()=="true",
            use_futures=os.getenv("USE_FUTURES","true").lower()=="true",
            symbols=[s.strip() for s in syms if s.strip()],
            timeframe=os.getenv("TIMEFRAME","1m"),
            api_key=os.getenv("BINANCE_API_KEY",""),
            api_secret=os.getenv("BINANCE_API_SECRET",""),
            hedge_mode=os.getenv("HEDGE_MODE","true").lower()=="true",
            margin_type=os.getenv("MARGIN_TYPE","ISOLATED").upper(),
            leverage=int(os.getenv("LEVERAGE","5")),
            account_equity=float(os.getenv("ACCOUNT_EQUITY","5000")),
            max_risk_pct=float(os.getenv("MAX_RISK_PCT_PER_TRADE","0.015")),
            max_daily_dd=float(os.getenv("MAX_DAILY_DRAWDOWN","0.02")),
            dry_run=os.getenv("DRY_RUN","true").lower()=="true",
            log_level=os.getenv("LOG_LEVEL","INFO").upper(),
            lang=os.getenv("LANG","tr").lower(),
            api_key_header=os.getenv("API_KEY","secret123")
        )

# ============ Strategy (EMA + Supertrend) ============
def ema(s: pd.Series, p: int) -> pd.Series:
    return s.ewm(span=p, adjust=False).mean()

def supertrend(df: pd.DataFrame, period=10, mult=3.0) -> Tuple[pd.Series, pd.Series]:
    hl2 = (df["high"] + df["low"]) / 2.0
    tr = pd.concat([
        df["high"]-df["low"],
        (df["high"]-df["close"].shift()).abs(),
        (df["low"]-df["close"].shift()).abs()
    ],axis=1).max(axis=1)
    atr = tr.rolling(period).mean()
    upper = hl2 + mult*atr
    lower = hl2 - mult*atr
    st = pd.Series(index=df.index, dtype=float)
    trend = pd.Series(index=df.index, dtype=int)
    for i in range(len(df)):
        if i==0:
            st.iloc[i]=upper.iloc[i]; trend.iloc[i]=1; continue
        upper.iloc[i] = min(upper.iloc[i], upper.iloc[i-1]) if df["close"].iloc[i-1] <= upper.iloc[i-1] else upper.iloc[i]
        lower.iloc[i] = max(lower.iloc[i], lower.iloc[i-1]) if df["close"].iloc[i-1] >= lower.iloc[i-1] else lower.iloc[i]
        if df["close"].iloc[i] > upper.iloc[i-1]: trend.iloc[i]=1
        elif df["close"].iloc[i] < lower.iloc[i-1]: trend.iloc[i]=-1
        else: trend.iloc[i]=trend.iloc[i-1]
        st.iloc[i] = lower.iloc[i] if trend.iloc[i]==1 else upper.iloc[i]
    return st, trend

@dataclass
class Signal:
    side: Optional[str]=None  # "buy"/"sell"
    price: Optional[float]=None
    stop: Optional[float]=None

def generate_signal(df: pd.DataFrame, fast=9, slow=21, st_p=10, st_m=3.0) -> Signal:
    e1, e2 = ema(df["close"], fast), ema(df["close"], slow)
    st, trd = supertrend(df, st_p, st_m)
    last = df.index[-1]; px = float(df["close"].iloc[-1])
    if e1.iloc[-1] > e2.iloc[-1] and px > st.iloc[-1]: return Signal("buy", px, float(st.iloc[-1]))
    if e1.iloc[-1] < e2.iloc[-1] and px < st.iloc[-1]: return Signal("sell", px, float(st.iloc[-1]))
    return Signal()

# ============ Exchange Adapter (ccxt) ============
class CcxtBinance:
    def __init__(self, s: Settings):
        self.s = s
        if s.use_futures:
            self.ex = ccxt.binanceusdm({"apiKey": s.api_key, "secret": s.api_secret, "enableRateLimit": True})
        else:
            self.ex = ccxt.binance({"apiKey": s.api_key, "secret": s.api_secret, "enableRateLimit": True})
        if s.use_testnet:
            try: self.ex.set_sandbox_mode(True)
            except Exception: pass

    def fetch_ohlcv_df(self, symbol: str, timeframe: str, limit: int = 500) -> pd.DataFrame:
        raw = self.ex.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
        df = pd.DataFrame(raw, columns=["ts","open","high","low","close","volume"])
        df["ts"] = pd.to_datetime(df["ts"], unit="ms", utc=True)
        return df.set_index("ts")

    def place_order(self, symbol: str, side: str, qty: float) -> Dict[str,Any]:
        if self.s.dry_run:
            log.info(tr(self.s.lang,"would"), side=side.upper(), qty=qty, sym=symbol, price="MARKET")
            return {"simulated":True}
        order = self.ex.create_order(symbol=symbol, type="market", side=side, amount=qty)
        log.success(tr(self.s.lang,"placed"), side=side.upper(), qty=qty, sym=symbol, price=order.get("price") or "MARKET")
        return order

# ============ Risk / Telemetry ============
@dataclass
class Risk:
    equity: float
    max_risk_pct: float
    max_daily_dd: float
    leverage: int
    day_pnl: float = 0.0
    day: Optional[str] = None
    def size(self, price: float, stop: float) -> float:
        risk = self.equity * self.max_risk_pct
        dist = abs(price - stop) or 1e-8
        qty = risk / dist
        return round(max(0.0, qty), 3)
    def update_pnl(self, pnl: float):
        today = datetime.utcnow().date().isoformat()
        if self.day != today:
            self.day = today; self.day_pnl = 0.0
        self.day_pnl += pnl
        if self.day_pnl <= -self.equity*self.max_daily_dd:
            raise RuntimeError("Daily drawdown limit reached")

@dataclass
class Telemetry:
    counters: Dict[str,int] = field(default_factory=lambda: {"events":0,"warnings":0,"errors":0})
    latency_ms: float = 0.0
    pnl: float = 0.0
    trades: int = 0
    wins: int = 0
    def winrate(self) -> float: return (self.wins/self.trades) if self.trades else 0.0
    def to_payload(self)->Dict[str,Any]:
        return {"counters":self.counters,"latency_ms":self.latency_ms,"pnl":self.pnl,"trades":self.trades,"winrate":self.winrate()}

# ============ Live Engine ============
class LiveEngine:
    def __init__(self, s: Settings, adapter: CcxtBinance, tel: Telemetry, risk: Risk):
        self.s = s; self.ad = adapter; self.tel = tel; self.risk = risk
        self.running = False
        self._thread: Optional[threading.Thread] = None
        self.pos: Dict[str,int] = {sym:0 for sym in s.symbols}
        self.entry: Dict[str,float] = {sym:0.0 for sym in s.symbols}

    def _loop(self):
        log.info(tr(self.s.lang,"online"))
        log.warning(tr(self.s.lang,"paper_on") if self.s.dry_run else tr(self.s.lang,"live_on"))
        while self.running:
            t0 = time.perf_counter()
            try:
                for sym in self.s.symbols:
                    df = self.ad.fetch_ohlcv_df(sym, self.s.timeframe, limit=200)
                    sig = generate_signal(df)
                    px = float(df["close"].iloc[-1])
                    if sig.side:
                        if self.pos[sym]==0 or (self.pos[sym]==1 and sig.side=="sell") or (self.pos[sym]==-1 and sig.side=="buy"):
                            qty = self.risk.size(sig.price or px, sig.stop or px)
                            if qty>0:
                                self.ad.place_order(sym, sig.side, qty)
                                self.tel.trades += 1
                                # exit previous if reversing
                                if self.pos[sym]!=0:
                                    diff = (px - self.entry[sym]) * self.pos[sym]
                                    self.tel.pnl += diff
                                    if diff>0: self.tel.wins += 1
                                    self.risk.update_pnl(diff)
                                self.pos[sym] = 1 if sig.side=="buy" else -1
                                self.entry[sym] = px
                    else:
                        log.debug(tr(self.s.lang,"nosig"))
                self.tel.latency_ms = (time.perf_counter()-t0)*1000
            except Exception as e:
                log.error(f"[loop] {e}")
            time.sleep(max(3, tf_to_seconds(self.s.timeframe)//3))

    def start(self):
        if self.running: return
        self.running = True
        self._thread = threading.Thread(target=self._loop, daemon=True)
        self._thread.start()

    def stop(self):
        self.running = False
        if self._thread:
            self._thread.join(timeout=2)

def tf_to_seconds(tf: str) -> int:
    unit = tf[-1]; val = int(tf[:-1])
    return {"s":1,"m":60,"h":3600,"d":86400,"w":604800}.get(unit,60)*val

# ============ Built-in Modules (as plugins) ============
@register("Code")
def m_code(strategy: str, lang: str) -> Module:
    mod = Module("Code","ok",{"msg": f"{strategy} â†’ coded & echoed"}, schema=load_schema("code"))
    validate_payload(mod); return mod

@register("Market")
def m_market(strategy: str, lang: str) -> Module:
    s = Settings.load()
    payload = {"exchange": s.exchange, "symbols": s.symbols, "timeframe": s.timeframe,
               "use_testnet": s.use_testnet, "use_futures": s.use_futures}
    mod = Module("Market","ok",payload,schema=load_schema("market"))
    validate_payload(mod); return mod

@register("Risk")
def m_risk(strategy: str, lang: str) -> Module:
    s = Settings.load()
    payload = {"account_equity": s.account_equity, "max_risk_pct": s.max_risk_pct,
               "max_daily_dd": s.max_daily_dd, "leverage": s.leverage}
    mod = Module("Risk","ok",payload,schema=load_schema("risk"))
    validate_payload(mod); return mod

# Telemetry module will be filled from LiveEngine metrics
_GLOBAL_TELEMETRY = Telemetry()

@register("Telemetry")
def m_telemetry(strategy: str, lang: str) -> Module:
    payload = _GLOBAL_TELEMETRY.to_payload()
    mod = Module("Telemetry","ok",payload,schema=load_schema("telemetry"))
    validate_payload(mod); return mod

# ============ Plugin discovery (optional) ============
def discover_plugins(folder="plugins"):
    p = pathlib.Path(folder)
    if not p.exists(): return
    for path in p.glob("*.py"):
        spec = importlib.util.spec_from_file_location(path.stem, path)
        mod = importlib.util.module_from_spec(spec); spec.loader.exec_module(mod)  # registers via @register

# ============ System ============
@dataclass
class EchoMeta:
    version: str = "Ultra Elit All-in-One v3.0"
    strategy: str = "KamalquantX"
    lang: str = "tr"
    generated_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    uuid: str = field(default_factory=lambda: str(uuid.uuid4()))

@dataclass
class UltraEliteSystem:
    meta: EchoMeta
    modules: Dict[str, Module] = field(default_factory=dict)
    def to_dict(self)->Dict[str,Any]:
        # refresh Telemetry payload on-the-fly
        if "Telemetry" in self.modules:
            self.modules["Telemetry"].payload = _GLOBAL_TELEMETRY.to_payload()
        return {"meta":asdict(self.meta),"engine":tr(self.meta.lang,"online"),
                "modules":{k:m.to_dict() for k,m in self.modules.items()}}

    @classmethod
    def build(cls, strategy: str, lang: str="tr", include: Optional[List[str]]=None):
        discover_plugins()
        sysobj = cls(EchoMeta(strategy=strategy, lang=lang))
        wanted = include or list(REGISTRY.keys())
        for k in wanted:
            if k not in REGISTRY: continue
            t0 = time.perf_counter()
            mod = REGISTRY[k](strategy, lang)
            mod.metrics.init_ms = (time.perf_counter()-t0)*1000
            validate_payload(mod)
            if mod.health not in (Health.OK, Health.WARN, Health.FAIL): mod.health = Health.OK
            sysobj.modules[k] = mod
        return sysobj

# ============ API (FastAPI) + WS + Prometheus ============
def create_app(sysobj: UltraEliteSystem, engine: Optional[LiveEngine]):
    try:
        from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
        from fastapi.responses import Response, JSONResponse
        from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    except Exception:
        return None
    s = Settings.load()
    API_KEY = s.api_key_header
    REQS = Counter("echo_requests_total","reqs")
    LAT = Histogram("echo_req_latency_seconds","latency")

    app = FastAPI(title="UltraElite Echo All-in-One", version=sysobj.meta.version)

    def key_dep():
        from fastapi import Request
        def inner(req: Request):
            if req.headers.get("x-api-key") != API_KEY:
                raise HTTPException(status.HTTP_401_UNAUTHORIZED,"Invalid API Key")
        return inner

    @app.get("/health")
    def health():
        REQS.inc(); return {"ok": True, "uuid": sysobj.meta.uuid}

    @app.get("/modules")
    def modules(dep=Depends(key_dep())):
        with LAT.time():
            REQS.inc()
            return sysobj.to_dict()["modules"]

    @app.get("/metrics")
    def metrics():
        return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

    @app.websocket("/ws")
    async def ws(sock: WebSocket):
        await sock.accept()
        try:
            while True:
                await sock.send_json(sysobj.to_dict())
                time.sleep(2)
        except Exception:
            pass

    # control live engine
    @app.post("/trade/start")
    def start(dep=Depends(key_dep())):
        if engine is None: raise HTTPException(503,"engine not available")
        engine.start(); return {"started": True}
    @app.post("/trade/stop")
    def stop(dep=Depends(key_dep())):
        if engine is None: raise HTTPException(503,"engine not available")
        engine.stop(); return {"stopped": True}

    return app

def run_api(sysobj: UltraEliteSystem, engine: Optional[LiveEngine], port: int=8080):
    app = create_app(sysobj, engine)
    if app is None:
        print("FastAPI/uvicorn/prometheus_client eksik. pip install fastapi uvicorn prometheus_client")
        return
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")

# ============ Backtest ============
def backtest(symbol: str, s: Settings, lookback=1000) -> Dict[str,Any]:
    ad = CcxtBinance(s)
    log.info(tr(s.lang,"fetch"), sym=symbol, tf=s.timeframe)
    df = ad.fetch_ohlcv_df(symbol, s.timeframe, limit=lookback)
    pos=0; entry=0.0; pnl=0.0; trades=0; wins=0
    for i in range(60, len(df)):
        w = df.iloc[:i+1]
        sig = generate_signal(w)
        px = float(w["close"].iloc[-1])
        if pos==0 and sig.side:
            pos = 1 if sig.side=="buy" else -1
            entry = px; trades += 1
        elif pos!=0 and ((pos==1 and sig.side=="sell") or (pos==-1 and sig.side=="buy")):
            diff = (px - entry) * pos
            pnl += diff; wins += 1 if diff>0 else 0
            pos=0; entry=0.0
    win = wins / trades if trades else 0.0
    log.success(tr(s.lang,"bt_done"), sym=symbol, tf=s.timeframe, ntr=trades, pnl=pnl, win=win)
    return {"trades":trades,"pnl":pnl,"winrate":win}

# ============ CLI ============
def main():
    s = Settings.load()
    log.remove(); log.add(lambda msg: print(msg, end=""), level=s.log_level)

    ap = argparse.ArgumentParser(description="Ultra Elite All-in-One v3")
    subs = ap.add_subparsers(dest="cmd", required=True)

    p_bt = subs.add_parser("backtest")
    p_bt.add_argument("--symbol","-s", required=True)
    p_bt.add_argument("--lookback", type=int, default=1000)

    p_live = subs.add_parser("live")
    p_live.add_argument("--symbol","-s", default=None)  # optional: override single symbol
    p_live.add_argument("--api", action="store_true")
    p_live.add_argument("--port", type=int, default=8080)

    p_api = subs.add_parser("api")
    p_api.add_argument("--port", type=int, default=8080)

    args = ap.parse_args()

    if args.cmd == "backtest":
        out = backtest(args.symbol, s, args.lookback)
        print(json.dumps(out, ensure_ascii=False, indent=2))
        return

    if args.cmd in ("live","api"):
        # prepare system & engine
        if args.cmd == "live" and args.symbol:
            s.symbols = [args.symbol]
        adapter = CcxtBinance(s)
        tel = _GLOBAL_TELEMETRY
        risk = Risk(s.account_equity, s.max_risk_pct, s.max_daily_dd, s.leverage)
        engine = LiveEngine(s, adapter, tel, risk)

        sysobj = UltraEliteSystem.build(strategy="KamalquantX", lang=s.lang,
                                        include=["Code","Market","Risk","Telemetry"])

        if args.cmd == "api" or args.api:
            # start engine if we are in live+api
            if args.cmd == "live": engine.start()
            run_api(sysobj, engine, port=args.port)
        else:
            engine.start()
            try:
                while True:
                    # print heartbeat JSON every ~20s
                    print(json.dumps(sysobj.to_dict(), ensure_ascii=False, indent=2))
                    time.sleep(20)
            except KeyboardInterrupt:
                engine.stop()

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\ultra_elite_allinone_v4.py
# ultra_elite_allinone_v4.py
# (c) Ultra Elite â€” all-in-one: strategy(KDJ/WR/TRIX+EMA/ST), realistic backtest, ccxt live/paper,
# risk, ATR trailing + partial TP, fees/slippage/funding, telemetry, plugin discovery, schema validation,
# REST API (FastAPI), WebSocket stream, Prometheus metrics, multi-language logs.
from __future__ import annotations
import os, sys, json, time, math, uuid, threading, importlib.util, pathlib, argparse
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, Callable, Tuple

# 3rd party deps: pip install python-dotenv ccxt pandas numpy ta jsonschema fastapi uvicorn prometheus_client loguru
from dotenv import load_dotenv
from loguru import logger as log
import pandas as pd
import numpy as np
import ccxt
import jsonschema

# ===================== i18n =====================
I18N = {
    "tr": {
        "online": "ULTRA ELÄ°T HÄ°BRÄ°T KUANTUM SÄ°STEM AKTÄ°F",
        "paper_on": "Paper mod: emir GÃ–NDERÄ°LMEYECEK.",
        "live_on": "CanlÄ± mod: emirler borsaya gÃ¶nderilecek.",
        "fetch": "{sym} {tf} mumlarÄ± Ã§ekiliyorâ€¦",
        "placed": "{side} {qty} {sym} @ {price}",
        "would": "PAPER {side} {qty} {sym} @ {price}",
        "nosig": "Sinyal yok.",
        "bt_done": "Backtest: {sym} {tf} | iÅŸlem={ntr} | PnL={pnl:.2f} | kazanÄ±m={win:.1%}",
    },
    "en": {
        "online": "ULTRA ELITE HYBRID QUANTUM SYSTEM ONLINE",
        "paper_on": "Paper mode: orders will NOT be sent.",
        "live_on": "Live mode: orders WILL be sent.",
        "fetch": "Fetching {sym} {tf} candlesâ€¦",
        "placed": "Placed {side} {qty} {sym} @ {price}",
        "would": "WOULD {side} {qty} {sym} @ {price}",
        "nosig": "No signal.",
        "bt_done": "Backtest: {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
    "fr": {
        "online": "SYSTÃˆME QUANTIQUE HYBRIDE ULTRA Ã‰LITE EN LIGNE",
        "paper_on": "Mode paper : aucun ordre envoyÃ©.",
        "live_on": "Mode live : ordres envoyÃ©s.",
        "fetch": "RÃ©cupÃ©ration des chandelles {sym} {tf}â€¦",
        "placed": "Ordre {side} {qty} {sym} @ {price}",
        "would": "EN PAPER {side} {qty} {sym} @ {price}",
        "nosig": "Pas de signal.",
        "bt_done": "Backtest : {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
    "de": {
        "online": "ULTRA-ELITE HYBRIDES QUANTENSYSTEM ONLINE",
        "paper_on": "Paper-Modus: keine Orders gesendet.",
        "live_on": "Live-Modus: Orders werden gesendet.",
        "fetch": "{sym} {tf} Kerzen werden geladenâ€¦",
        "placed": "Platziert {side} {qty} {sym} @ {price}",
        "would": "WÃœRDE {side} {qty} {sym} @ {price}",
        "nosig": "Kein Signal.",
        "bt_done": "Backtest: {sym} {tf} | Trades={ntr} | PnL={pnl:.2f} | Treffer={win:.1%}",
    },
}
def tr(lang: str, key: str, **kw):
    base = I18N.get(lang) or I18N["en"]
    return (base.get(key) or key).format(**kw)

# ===================== Health & Metrics =====================
class Health(str):
    OK="ok"; WARN="warn"; FAIL="fail"

@dataclass
class Metrics:
    init_ms: float = 0.0
    activate_ms: float = 0.0
    custom: Dict[str, float] = field(default_factory=dict)

# ===================== Registry / Module / Schema =====================
@dataclass
class Module:
    name: str
    status: str
    payload: Dict[str, Any]
    health: str = Health.OK
    metrics: Metrics = field(default_factory=Metrics)
    schema: Optional[Dict[str, Any]] = None
    def to_dict(self) -> Dict[str, Any]:
        return {"name":self.name,"status":self.status,"health":self.health,"metrics":asdict(self.metrics),**(self.payload or {})}

REGISTRY: Dict[str, Callable[[str,str], Module]] = {}
def register(name: str):
    def deco(fn: Callable[[str,str],Module]):
        REGISTRY[name] = fn
        return fn
    return deco

# Inline JSON Schemas (tek dosya)
SCHEMAS: Dict[str, Dict[str, Any]] = {
    "code": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object", "required":["msg"],
        "properties":{"msg":{"type":"string","minLength":1}}
    },
    "market": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object", "required":["exchange","symbols","timeframe"],
        "properties":{
            "exchange":{"type":"string"},
            "symbols":{"type":"array","items":{"type":"string"},"minItems":1},
            "timeframe":{"type":"string","pattern":"^[0-9]+[smhdw]$"},
            "use_testnet":{"type":"boolean"},
            "use_futures":{"type":"boolean"}
        }, "additionalProperties": True
    },
    "risk": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["account_equity","max_risk_pct","max_daily_dd","leverage"],
        "properties":{
            "account_equity":{"type":"number","minimum":0},
            "max_risk_pct":{"type":"number","minimum":0,"maximum":0.2},
            "max_daily_dd":{"type":"number","minimum":0,"maximum":0.2},
            "leverage":{"type":"integer","minimum":1,"maximum":125}
        }, "additionalProperties": True
    },
    "telemetry": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["counters","latency_ms"],
        "properties":{
            "counters":{"type":"object","additionalProperties":{"type":"integer","minimum":0}},
            "latency_ms":{"type":"number","minimum":0},
            "pnl":{"type":"number"},
            "trades":{"type":"integer","minimum":0},
            "winrate":{"type":"number","minimum":0}
        }, "additionalProperties": True
    },
    "strategy": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["rsi_period","ema_fast","ema_slow","atr_period"],
        "properties":{
            "rsi_period":{"type":"integer","minimum":2},
            "ema_fast":{"type":"integer","minimum":2},
            "ema_slow":{"type":"integer","minimum":3},
            "atr_period":{"type":"integer","minimum":3},
            "kdj_on":{"type":"boolean"}, "wr_on":{"type":"boolean"}, "trix_on":{"type":"boolean"},
            "wr_buy":{"type":"number"}, "wr_sell":{"type":"number"},
            "trix_period":{"type":"integer","minimum":2}
        }, "additionalProperties": True
    },
    "backtest": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["taker_fee","slippage_bps","funding_rate_8h"],
        "properties":{
            "taker_fee":{"type":"number","minimum":0,"maximum":0.01},
            "maker_fee":{"type":"number","minimum":0,"maximum":0.01},
            "slippage_bps":{"type":"number","minimum":0,"maximum":1000},
            "funding_rate_8h":{"type":"number"},
            "funding_sign":{"type":"integer","minimum":-1,"maximum":1},
            "tp_rr":{"type":"array","items":{"type":"number","minimum":0.1},"minItems":1,"maxItems":4},
            "tp_frac":{"type":"array","items":{"type":"number","minimum":0,"maximum":1},"minItems":1,"maxItems":4},
            "trail_be_rr":{"type":"number","minimum":0},
            "trail_mult":{"type":"number","minimum":0}
        }, "additionalProperties": True
    }
}
def load_schema(name: str) -> Optional[Dict[str,Any]]: return SCHEMAS.get(name.lower())
def validate_payload(mod: Module):
    schema = mod.schema or load_schema(mod.name)
    if schema: jsonschema.validate(mod.payload, schema)

# ===================== Settings =====================
@dataclass
class Settings:
    exchange: str = "BINANCE"
    use_testnet: bool = True
    use_futures: bool = True
    symbols: List[str] = field(default_factory=lambda: ["BTC/USDT"])
    timeframe: str = "1m"
    api_key: str = ""
    api_secret: str = ""
    hedge_mode: bool = True
    margin_type: str = "ISOLATED"
    leverage: int = 5
    account_equity: float = 5000.0
    max_risk_pct: float = 0.015
    max_daily_dd: float = 0.02
    dry_run: bool = True
    log_level: str = "INFO"
    lang: str = "tr"
    api_key_header: str = "secret123"  # REST korumasÄ±

    # Strategy toggles
    rsi_period:int=14; ema_fast:int=21; ema_slow:int=50; atr_period:int=14
    kdj_on:bool=True; wr_on:bool=True; trix_on:bool=True
    wr_buy:float=-80.0; wr_sell:float=-20.0
    trix_period:int=9

    # Backtest & exec economics
    taker_fee:float=0.0004; maker_fee:float=0.0002
    slippage_bps:float=2.0
    funding_rate_8h:float=0.0
    funding_sign:int=0 # +1 Ã¶der, -1 alÄ±r, 0 yok
    tp_rr:List[float]=field(default_factory=lambda:[1.0,2.0])
    tp_frac:List[float]=field(default_factory=lambda:[0.5,0.5])
    trail_be_rr:float=1.0
    trail_mult:float=1.0

    @staticmethod
    def load() -> "Settings":
        load_dotenv(override=True)
        syms = os.getenv("SYMBOLS","BTC/USDT").split(",")
        def _flo(name, default): 
            try: return float(os.getenv(name, str(default)))
            except: return default
        def _bool(name, default): 
            return os.getenv(name, str(default)).lower()=="true"
        return Settings(
            exchange=os.getenv("EXCHANGE","BINANCE").upper(),
            use_testnet=_bool("USE_TESTNET", True),
            use_futures=_bool("USE_FUTURES", True),
            symbols=[s.strip() for s in syms if s.strip()],
            timeframe=os.getenv("TIMEFRAME","1m"),
            api_key=os.getenv("BINANCE_API_KEY",""),
            api_secret=os.getenv("BINANCE_API_SECRET",""),
            hedge_mode=_bool("HEDGE_MODE", True),
            margin_type=os.getenv("MARGIN_TYPE","ISOLATED").upper(),
            leverage=int(os.getenv("LEVERAGE","5")),
            account_equity=_flo("ACCOUNT_EQUITY", 5000),
            max_risk_pct=_flo("MAX_RISK_PCT_PER_TRADE", 0.015),
            max_daily_dd=_flo("MAX_DAILY_DRAWDOWN", 0.02),
            dry_run=_bool("DRY_RUN", True),
            log_level=os.getenv("LOG_LEVEL","INFO").upper(),
            lang=os.getenv("LANG","tr").lower(),
            api_key_header=os.getenv("API_KEY","secret123"),

            rsi_period=int(os.getenv("RSI_PERIOD","14")),
            ema_fast=int(os.getenv("EMA_FAST","21")),
            ema_slow=int(os.getenv("EMA_SLOW","50")),
            atr_period=int(os.getenv("ATR_PERIOD","14")),
            kdj_on=_bool("KDJ_ON", True),
            wr_on=_bool("WR_ON", True),
            trix_on=_bool("TRIX_ON", True),
            wr_buy=_flo("WR_BUY", -80.0),
            wr_sell=_flo("WR_SELL", -20.0),
            trix_period=int(os.getenv("TRIX_PERIOD","9")),

            taker_fee=_flo("TAKER_FEE", 0.0004),
            maker_fee=_flo("MAKER_FEE", 0.0002),
            slippage_bps=_flo("SLIPPAGE_BPS", 2.0),
            funding_rate_8h=_flo("FUNDING_RATE_8H", 0.0),
            funding_sign=int(os.getenv("FUNDING_SIGN","0")),
            tp_rr=[_flo("TP1_RR",1.0), _flo("TP2_RR",2.0)],
            tp_frac=[_flo("TP1_FRAC",0.5), _flo("TP2_FRAC",0.5)],
            trail_be_rr=_flo("TRAIL_BE_RR",1.0),
            trail_mult=_flo("TRAIL_MULT",1.0),
        )

# ===================== Indicators & Strategy (EMA/ST + KDJ/WR/TRIX) =====================
def ema(s: pd.Series, p: int) -> pd.Series:
    return s.ewm(span=p, adjust=False).mean()

def tr_series(df: pd.DataFrame) -> pd.Series:
    tr1 = df["high"]-df["low"]
    tr2 = (df["high"]-df["close"].shift()).abs()
    tr3 = (df["low"]-df["close"].shift()).abs()
    return pd.concat([tr1,tr2,tr3],axis=1).max(axis=1)

def atr(df: pd.DataFrame, period:int) -> pd.Series:
    return tr_series(df).rolling(period).mean()

def supertrend(df: pd.DataFrame, period=10, mult=3.0) -> Tuple[pd.Series, pd.Series]:
    hl2 = (df["high"] + df["low"]) / 2.0
    a = atr(df, period)
    upper = hl2 + mult*a
    lower = hl2 - mult*a
    st = pd.Series(index=df.index, dtype=float)
    trend = pd.Series(index=df.index, dtype=int)
    for i in range(len(df)):
        if i==0: st.iloc[i]=upper.iloc[i]; trend.iloc[i]=1; continue
        upper.iloc[i] = min(upper.iloc[i], upper.iloc[i-1]) if df["close"].iloc[i-1] <= upper.iloc[i-1] else upper.iloc[i]
        lower.iloc[i] = max(lower.iloc[i], lower.iloc[i-1]) if df["close"].iloc[i-1] >= lower.iloc[i-1] else lower.iloc[i]
        if df["close"].iloc[i] > upper.iloc[i-1]: trend.iloc[i]=1
        elif df["close"].iloc[i] < lower.iloc[i-1]: trend.iloc[i]=-1
        else: trend.iloc[i]=trend.iloc[i-1]
        st.iloc[i] = lower.iloc[i] if trend.iloc[i]==1 else upper.iloc[i]
    return st, trend

def stochastic(df: pd.DataFrame, k_window=9, d_window=3) -> Tuple[pd.Series,pd.Series,pd.Series]:
    low_min = df["low"].rolling(k_window).min()
    high_max = df["high"].rolling(k_window).max()
    k = 100*(df["close"]-low_min)/(high_max-low_min)
    d = k.rolling(d_window).mean()
    j = 3*k - 2*d
    return k.clip(0,100), d.clip(0,100), j.clip(0,100)

def williams_r(df: pd.DataFrame, lbp=14) -> pd.Series:
    low_min = df["low"].rolling(lbp).min()
    high_max = df["high"].rolling(lbp).max()
    wr = -100*(high_max - df["close"])/(high_max - low_min)
    return wr.clip(-100,0)

def trix(df: pd.DataFrame, period=9) -> pd.Series:
    e1 = df["close"].ewm(span=period, adjust=False).mean()
    e2 = e1.ewm(span=period, adjust=False).mean()
    e3 = e2.ewm(span=period, adjust=False).mean()
    return 100*(e3.diff()/e3.shift())

@dataclass
class Signal:
    side: Optional[str]=None  # "buy"/"sell"
    price: Optional[float]=None
    stop: Optional[float]=None
    atr: Optional[float]=None
    reason: str = ""

def generate_signal(df: pd.DataFrame, s: Settings) -> Signal:
    close = df["close"]
    e_fast, e_slow = ema(close, s.ema_fast), ema(close, s.ema_slow)
    st, trd = supertrend(df, s.atr_period, 3.0)
    a = atr(df, s.atr_period)
    last = df.index[-1]; px = float(close.iloc[-1])
    rs = close.diff().rolling(s.rsi_period).apply(lambda x: (x[x>0].mean() or 0) / max(1e-9, abs(x[x<0].mean() or 0)), raw=False)
    rsi = 100 - 100/(1+rs)
    # KDJ / WR / TRIX
    K,D,J = stochastic(df)
    WR = williams_r(df, 14)
    TRX = trix(df, s.trix_period)
    TRXsig = TRX.ewm(span=s.trix_period, adjust=False).mean()

    long_core = (e_fast.iloc[-1] > e_slow.iloc[-1]) and (px > st.iloc[-1])
    short_core = (e_fast.iloc[-1] < e_slow.iloc[-1]) and (px < st.iloc[-1])

    long_trig = long_core
    short_trig = short_core
    reasons=[]

    # RSI exit from OS/OB cross
    prev_rsi, now_rsi = rsi.iloc[-2], rsi.iloc[-1]
    if now_rsi>=30 and prev_rsi<30 and long_core: long_trig=True; reasons.append("RSIâ†‘30")
    if now_rsi<=70 and prev_rsi>70 and short_core: short_trig=True; reasons.append("RSIâ†“70")

    if s.kdj_on:
        if K.iloc[-2] < D.iloc[-2] and K.iloc[-1] > D.iloc[-1] and K.iloc[-1] < 40: long_trig=True; reasons.append("KDJ cross up")
        if K.iloc[-2] > D.iloc[-2] and K.iloc[-1] < D.iloc[-1] and K.iloc[-1] > 60: short_trig=True; reasons.append("KDJ cross down")
    if s.wr_on:
        if WR.iloc[-1] <= s.wr_buy: long_trig=True; reasons.append("WR oversold")
        if WR.iloc[-1] >= s.wr_sell: short_trig=True; reasons.append("WR overbought")
    if s.trix_on:
        if TRX.iloc[-2] < TRXsig.iloc[-2] and TRX.iloc[-1] > TRXsig.iloc[-1]: long_trig=True; reasons.append("TRIX cross up")
        if TRX.iloc[-2] > TRXsig.iloc[-2] and TRX.iloc[-1] < TRXsig.iloc[-1]: short_trig=True; reasons.append("TRIX cross down")

    if long_trig and not short_trig:
        return Signal("buy", px, float(st.iloc[-1]), float(a.iloc[-1]), "+".join(reasons or ["core_up"]))
    if short_trig and not long_trig:
        return Signal("sell", px, float(st.iloc[-1]), float(a.iloc[-1]), "+".join(reasons or ["core_down"]))
    return Signal()

# ===================== Exchange Adapter (ccxt) =====================
class CcxtBinance:
    def __init__(self, s: Settings):
        self.s = s
        if s.use_futures:
            self.ex = ccxt.binanceusdm({"apiKey": s.api_key, "secret": s.api_secret, "enableRateLimit": True})
        else:
            self.ex = ccxt.binance({"apiKey": s.api_key, "secret": s.api_secret, "enableRateLimit": True})
        if s.use_testnet:
            try: self.ex.set_sandbox_mode(True)
            except Exception: pass

    def fetch_ohlcv_df(self, symbol: str, timeframe: str, limit: int = 500) -> pd.DataFrame:
        raw = self.ex.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
        df = pd.DataFrame(raw, columns=["ts","open","high","low","close","volume"])
        df["ts"] = pd.to_datetime(df["ts"], unit="ms", utc=True)
        return df.set_index("ts")

    def place_order(self, symbol: str, side: str, qty: float) -> Dict[str,Any]:
        if self.s.dry_run:
            log.info(tr(self.s.lang,"would"), side=side.upper(), qty=qty, sym=symbol, price="MARKET")
            return {"simulated":True}
        order = self.ex.create_order(symbol=symbol, type="market", side=side, amount=qty)
        log.success(tr(self.s.lang,"placed"), side=side.upper(), qty=qty, sym=symbol, price=order.get("price") or "MARKET")
        return order

# ===================== Risk / Telemetry =====================
@dataclass
class Risk:
    equity: float
    max_risk_pct: float
    max_daily_dd: float
    leverage: int
    day_pnl: float = 0.0
    day: Optional[str] = None
    def size(self, entry: float, stop: float) -> float:
        risk = self.equity * self.max_risk_pct
        dist = abs(entry - stop) or 1e-8
        qty = risk / dist
        return round(max(0.0, qty), 3)
    def update_pnl(self, pnl: float):
        today = datetime.utcnow().date().isoformat()
        if self.day != today:
            self.day = today; self.day_pnl = 0.0
        self.day_pnl += pnl
        if self.day_pnl <= -self.equity*self.max_daily_dd:
            raise RuntimeError("Daily drawdown limit reached")

@dataclass
class Telemetry:
    counters: Dict[str,int] = field(default_factory=lambda: {"events":0,"warnings":0,"errors":0})
    latency_ms: float = 0.0
    pnl: float = 0.0
    trades: int = 0
    wins: int = 0
    def winrate(self) -> float: return (self.wins/self.trades) if self.trades else 0.0
    def to_payload(self)->Dict[str,Any]:
        return {"counters":self.counters,"latency_ms":self.latency_ms,"pnl":self.pnl,"trades":self.trades,"winrate":self.winrate()}

# ===================== ATR Trailing & Partial TP utils =====================
def atr_trailing_stop(side:str, entry:float, best:float, atr_val:float, be_rr:float, trail_mult:float) -> float:
    if side=="buy":
        rr = (best - entry) / max(1e-9, atr_val)
        return max(entry, best - trail_mult*atr_val) if rr >= be_rr else entry - 1e-9
    else:
        rr = (entry - best) / max(1e-9, atr_val)
        return min(entry, best + trail_mult*atr_val) if rr >= be_rr else entry + 1e-9

# ===================== Live Engine (with ATR trailing & partial TP) =====================
class LiveEngine:
    def __init__(self, s: Settings, adapter: CcxtBinance, tel: Telemetry, risk: Risk):
        self.s = s; self.ad = adapter; self.tel = tel; self.risk = risk
        self.running = False
        self._thread: Optional[threading.Thread] = None
        self.pos: Dict[str,dict] = {sym: None for sym in s.symbols}

    def _open_pos(self, sym:str, sig:Signal):
        qty = self.risk.size(sig.price, sig.stop)
        if qty<=0: return
        self.ad.place_order(sym, sig.side, qty)
        tp_levels = [sig.price + rr*sig.atr*(1 if sig.side=="buy" else -1) for rr in self.s.tp_rr]
        self.pos[sym] = {"side":sig.side,"entry":sig.price,"atr":sig.atr,"qty":qty,
                         "best":sig.price,"stop":sig.stop,"tp_levels":tp_levels,
                         "tp_frac":list(self.s.tp_frac), "filled":[False]*len(tp_levels)}

    def _close_pos(self, sym:str, px:float):
        p = self.pos[sym]; 
        if not p: return
        side = p["side"]; qty = p["qty"]
        # simulate market flatten
        self.ad.place_order(sym, "sell" if side=="buy" else "buy", qty)
        diff = (px - p["entry"])*(1 if side=="buy" else -1)*(-1)  # entry->exit PNL sign? We'll compute below better.
        diff = (px - p["entry"])*(1 if side=="buy" else -1)  # positive if profit
        self.tel.pnl += diff
        self.tel.wins += 1 if diff>0 else 0
        self.risk.update_pnl(diff)
        self.pos[sym] = None

    def _loop(self):
        log.info(tr(self.s.lang,"online"))
        log.warning(tr(self.s.lang,"paper_on") if self.s.dry_run else tr(self.s.lang,"live_on"))
        while self.running:
            t0 = time.perf_counter()
            try:
                for sym in list(self.pos.keys()):
                    df = self.ad.fetch_ohlcv_df(sym, self.s.timeframe, limit=200)
                    sig = generate_signal(df, self.s)
                    px = float(df["close"].iloc[-1])
                    p = self.pos[sym]
                    if p is None and sig.side:
                        self._open_pos(sym, sig)
                        self.tel.trades += 1
                        continue
                    if p:
                        # update best and trailing stop
                        if p["side"]=="buy":
                            p["best"] = max(p["best"], px)
                        else:
                            p["best"] = min(p["best"], px)
                        new_stop = atr_trailing_stop(p["side"], p["entry"], p["best"], p["atr"],
                                                     self.s.trail_be_rr, self.s.trail_mult)
                        if p["side"]=="buy": p["stop"] = max(p["stop"], new_stop)
                        else: p["stop"] = min(p["stop"], new_stop)

                        # partial TPs
                        for i, lvl in enumerate(p["tp_levels"]):
                            if p["filled"][i]: continue
                            hit = (px>=lvl) if p["side"]=="buy" else (px<=lvl)
                            if hit:
                                part = p["tp_frac"][i]*p["qty"]
                                if part>0:
                                    self.ad.place_order(sym, "sell" if p["side"]=="buy" else "buy", part)
                                    # realize pnl for that fraction
                                    unit = (lvl - p["entry"])*(1 if p["side"]=="buy" else -1)
                                    self.tel.pnl += unit * part / p["qty"]
                                    self.risk.update_pnl(unit * part / p["qty"])
                                    p["qty"] -= part
                                p["filled"][i]=True
                        # stop hit?
                        stop_hit = (px<=p["stop"]) if p["side"]=="buy" else (px>=p["stop"])
                        if stop_hit or p["qty"]<=1e-9:
                            self._close_pos(sym, px)
                            continue

                        # reverse on opposite signal
                        if (p["side"]=="buy" and sig.side=="sell") or (p["side"]=="sell" and sig.side=="buy"):
                            self._close_pos(sym, px)
                            self._open_pos(sym, sig)
                            self.tel.trades += 1
            except Exception as e:
                log.error(f"[live] {e}")
            self.tel.latency_ms = (time.perf_counter()-t0)*1000
            time.sleep(max(3, tf_to_seconds(self.s.timeframe)//3))

    def start(self):
        if self.running: return
        self.running = True
        self._thread = threading.Thread(target=self._loop, daemon=True)
        self._thread.start()

    def stop(self):
        self.running = False
        if self._thread: self._thread.join(timeout=2)

def tf_to_seconds(tf: str) -> int:
    unit = tf[-1]; val = int(tf[:-1])
    return {"s":1,"m":60,"h":3600,"d":86400,"w":604800}.get(unit,60)*val

# ===================== Built-in Modules =====================
@register("Code")
def m_code(strategy: str, lang: str) -> Module:
    mod = Module("Code","ok",{"msg": f"{strategy} â†’ coded & echoed"}, schema=load_schema("code"))
    validate_payload(mod); return mod

@register("Market")
def m_market(strategy: str, lang: str) -> Module:
    s = Settings.load()
    payload = {"exchange": s.exchange, "symbols": s.symbols, "timeframe": s.timeframe,
               "use_testnet": s.use_testnet, "use_futures": s.use_futures}
    mod = Module("Market","ok",payload,schema=load_schema("market")); validate_payload(mod); return mod

@register("Risk")
def m_risk(strategy: str, lang: str) -> Module:
    s = Settings.load()
    payload = {"account_equity": s.account_equity, "max_risk_pct": s.max_risk_pct,
               "max_daily_dd": s.max_daily_dd, "leverage": s.leverage}
    mod = Module("Risk","ok",payload,schema=load_schema("risk")); validate_payload(mod); return mod

@register("Strategy")
def m_strategy(strategy:str, lang:str) -> Module:
    s=Settings.load()
    payload={"rsi_period":s.rsi_period,"ema_fast":s.ema_fast,"ema_slow":s.ema_slow,"atr_period":s.atr_period,
             "kdj_on":s.kdj_on,"wr_on":s.wr_on,"trix_on":s.trix_on,"wr_buy":s.wr_buy,"wr_sell":s.wr_sell,"trix_period":s.trix_period}
    mod=Module("Strategy","ok",payload,schema=load_schema("strategy")); validate_payload(mod); return mod

_GLOBAL_TELEMETRY = Telemetry()
@register("Telemetry")
def m_telemetry(strategy: str, lang: str) -> Module:
    payload = _GLOBAL_TELEMETRY.to_payload()
    mod = Module("Telemetry","ok",payload,schema=load_schema("telemetry")); validate_payload(mod); return mod

@register("Backtest")
def m_backtest_config(strategy:str, lang:str)->Module:
    s=Settings.load()
    payload={"taker_fee":s.taker_fee,"maker_fee":s.maker_fee,"slippage_bps":s.slippage_bps,
             "funding_rate_8h":s.funding_rate_8h,"funding_sign":s.funding_sign,
             "tp_rr":s.tp_rr,"tp_frac":s.tp_frac,"trail_be_rr":s.trail_be_rr,"trail_mult":s.trail_mult}
    mod=Module("Backtest","ok",payload,schema=load_schema("backtest")); validate_payload(mod); return mod

# ===================== Plugin discovery (opsiyonel) =====================
def discover_plugins(folder="plugins"):
    p = pathlib.Path(folder)
    if not p.exists(): return
    for path in p.glob("*.py"):
        spec = importlib.util.spec_from_file_location(path.stem, path)
        mod = importlib.util.module_from_spec(spec); spec.loader.exec_module(mod)

# ===================== System & API =====================
@dataclass
class EchoMeta:
    version: str = "Ultra Elit All-in-One v4.0 â€” Infinity-Seal Meta-Echo Protocol"
    strategy: str = "KamalquantX"
    lang: str = "tr"
    generated_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    uuid: str = field(default_factory=lambda: str(uuid.uuid4()))

@dataclass
class UltraEliteSystem:
    meta: EchoMeta
    modules: Dict[str, Module] = field(default_factory=dict)
    def to_dict(self)->Dict[str,Any]:
        if "Telemetry" in self.modules:
            self.modules["Telemetry"].payload = _GLOBAL_TELEMETRY.to_payload()
        return {"meta":asdict(self.meta),"engine":tr(self.meta.lang,"online"),
                "modules":{k:m.to_dict() for k,m in self.modules.items()}}

    @classmethod
    def build(cls, strategy: str, lang: str="tr", include: Optional[List[str]]=None):
        discover_plugins()
        sysobj = cls(EchoMeta(strategy=strategy, lang=lang))
        wanted = include or list(REGISTRY.keys())
        for k in wanted:
            if k not in REGISTRY: continue
            t0 = time.perf_counter()
            mod = REGISTRY[k](strategy, lang)
            mod.metrics.init_ms = (time.perf_counter()-t0)*1000
            validate_payload(mod)
            if mod.health not in (Health.OK, Health.WARN, Health.FAIL): mod.health = Health.OK
            sysobj.modules[k] = mod
        return sysobj

def create_app(sysobj: UltraEliteSystem, engine: Optional[LiveEngine]):
    try:
        from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
        from fastapi.responses import Response
        from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    except Exception:
        return None
    s = Settings.load()
    API_KEY = s.api_key_header
    REQS = Counter("echo_requests_total","reqs")
    LAT  = Histogram("echo_req_latency_seconds","latency")

    app = FastAPI(title="UltraElite Echo All-in-One", version=sysobj.meta.version)

    def key_dep():
        from fastapi import Request
        def inner(req:Request):
            if req.headers.get("x-api-key") != API_KEY:
                raise HTTPException(status.HTTP_401_UNAUTHORIZED,"Invalid API Key")
        return inner

    @app.get("/health")
    def health():
        REQS.inc(); return {"ok": True, "uuid": sysobj.meta.uuid}

    @app.get("/modules")
    def modules(dep=Depends(key_dep())):
        with LAT.time(): REQS.inc(); return sysobj.to_dict()["modules"]

    @app.get("/metrics")
    def metrics(): return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

    @app.websocket("/ws")
    async def ws(sock: WebSocket):
        await sock.accept()
        try:
            while True:
                await sock.send_json(sysobj.to_dict()); time.sleep(2)
        except Exception:
            pass

    @app.post("/trade/start")
    def start(dep=Depends(key_dep())):
        if engine is None: raise HTTPException(503,"engine not available")
        engine.start(); return {"started": True}

    @app.post("/trade/stop")
    def stop(dep=Depends(key_dep())):
        if engine is None: raise HTTPException(503,"engine not available")
        engine.stop(); return {"stopped": True}

    return app

def run_api(sysobj: UltraEliteSystem, engine: Optional[LiveEngine], port: int=8080):
    app = create_app(sysobj, engine)
    if app is None:
        print("FastAPI/uvicorn/prometheus_client eksik. pip install fastapi uvicorn prometheus_client")
        return
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")

# ===================== Realistic Backtest =====================
@dataclass
class BTConfig:
    taker_fee:float; maker_fee:float; slippage_bps:float
    funding_rate_8h:float; funding_sign:int
    tp_rr:List[float]; tp_frac:List[float]
    trail_be_rr:float; trail_mult:float

def seconds_per_bar(tf:str)->int:
    unit=tf[-1]; val=int(tf[:-1]); return {"s":1,"m":60,"h":3600,"d":86400,"w":604800}.get(unit,60)*val

def fill_price(px:float, side:str, slippage_bps:float)->float:
    slip = px * (slippage_bps/10000.0)
    return px + slip if side=="buy" else px - slip

def commission(notional:float, fee:float)->float: return abs(notional)*fee

def funding_cost(notional:float, seconds:int, rate8h:float, sign:int)->float:
    if rate8h==0 or sign==0 or seconds<=0: return 0.0
    per_sec = rate8h / (8*3600.0)
    return notional * per_sec * seconds * sign

def backtest(symbol: str, s: Settings, lookback=1500) -> Dict[str,Any]:
    ad = CcxtBinance(s)
    df = ad.fetch_ohlcv_df(symbol, s.timeframe, limit=lookback)
    cfg = BTConfig(s.taker_fee, s.maker_fee, s.slippage_bps, s.funding_rate_8h, s.funding_sign,
                   s.tp_rr, s.tp_frac, s.trail_be_rr, s.trail_mult)

    pnl=0.0; trades=0; wins=0
    pos=None  # dict: side, entry, qty, atr, best, stop, tp_levels, tp_frac, filled
    tfsec = seconds_per_bar(s.timeframe)

    for i in range(max(60, s.ema_slow+5), len(df)):
        window = df.iloc[:i+1]
        sig = generate_signal(window, s)
        px = float(window["close"].iloc[-1])
        a = float(atr(window, s.atr_period).iloc[-1] or 0.0)

        # funding accrual per open bar
        if pos:
            # funding cost on notional (entry*qty/leverage varsayÄ±mÄ± yerine basit: px*qty)
            notional = px * pos["qty"]
            pnl -= funding_cost(notional, tfsec, cfg.funding_rate_8h, cfg.funding_sign)

        if pos is None and sig.side:
            qty = Risk(s.account_equity, s.max_risk_pct, s.max_daily_dd, s.leverage).size(sig.price, sig.stop)
            if qty<=0: continue
            entry_price = fill_price(px, sig.side, cfg.slippage_bps)
            trades += 1
            tp_levels = [entry_price + rr*sig.atr*(1 if sig.side=="buy" else -1) for rr in cfg.tp_rr]
            pos={"side":sig.side,"entry":entry_price,"qty":qty,"atr":sig.atr or a,
                 "best":entry_price,"stop":sig.stop,"tp_levels":tp_levels,
                 "tp_frac":list(cfg.tp_frac),"filled":[False]*len(tp_levels)}
            # entry commission
            pnl -= commission(entry_price*qty, cfg.taker_fee)
            continue

        if pos:
            # update best & trailing
            if pos["side"]=="buy": pos["best"] = max(pos["best"], px)
            else: pos["best"] = min(pos["best"], px)
            new_stop = atr_trailing_stop(pos["side"], pos["entry"], pos["best"], pos["atr"], cfg.trail_be_rr, cfg.trail_mult)
            if pos["side"]=="buy": pos["stop"] = max(pos["stop"], new_stop)
            else: pos["stop"] = min(pos["stop"], new_stop)

            # partial TPs
            for i, lvl in enumerate(pos["tp_levels"]):
                if pos["filled"][i]: continue
                hit = (px>=lvl) if pos["side"]=="buy" else (px<=lvl)
                if hit:
                    part = pos["tp_frac"][i]*pos["qty"]
                    if part>0:
                        exit_px = fill_price(lvl, "sell" if pos["side"]=="buy" else "buy", cfg.slippage_bps)
                        unit = (exit_px - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                        pnl += unit * (part/pos["qty"])
                        pnl -= commission(exit_px*part, cfg.taker_fee)
                        pos["qty"] -= part
                    pos["filled"][i]=True

            # stop hit?
            stop_hit = (px<=pos["stop"]) if pos["side"]=="buy" else (px>=pos["stop"])
            if stop_hit:
                exit_px = fill_price(pos["stop"], "sell" if pos["side"]=="buy" else "buy", cfg.slippage_bps)
                unit = (exit_px - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                pnl += unit
                pnl -= commission(exit_px*(pos["qty"]), cfg.taker_fee)
                if unit>0: wins += 1
                pos=None
                continue

            # reverse on opposite signal
            if (pos and sig.side and ((pos["side"]=="buy" and sig.side=="sell") or (pos["side"]=="sell" and sig.side=="buy"))):
                exit_px = fill_price(px, "sell" if pos["side"]=="buy" else "buy", cfg.slippage_bps)
                unit = (exit_px - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                pnl += unit
                pnl -= commission(exit_px*(pos["qty"]), cfg.taker_fee)
                if unit>0: wins += 1
                # open new
                qty = Risk(s.account_equity, s.max_risk_pct, s.max_daily_dd, s.leverage).size(sig.price, sig.stop)
                if qty>0:
                    entry_price = fill_price(px, sig.side, cfg.slippage_bps)
                    trades += 1
                    tp_levels = [entry_price + rr*sig.atr*(1 if sig.side=="buy" else -1) for rr in cfg.tp_rr]
                    pos={"side":sig.side,"entry":entry_price,"qty":qty,"atr":sig.atr or a,
                         "best":entry_price,"stop":sig.stop,"tp_levels":tp_levels,
                         "tp_frac":list(cfg.tp_frac),"filled":[False]*len(tp_levels)}
                    pnl -= commission(entry_price*qty, cfg.taker_fee)
                else:
                    pos=None

    win = wins / trades if trades else 0.0
    log.success(tr(s.lang,"bt_done"), sym=symbol, tf=s.timeframe, ntr=trades, pnl=pnl, win=win)
    return {"trades":trades,"pnl":pnl,"winrate":win}

# ===================== CLI =====================
def main():
    s = Settings.load()
    log.remove(); log.add(lambda m: print(m, end=""), level=s.log_level)

    ap = argparse.ArgumentParser(description="Ultra Elite All-in-One v4 â€” KDJ/WR/TRIX + Real Backtest + API")
    subs = ap.add_subparsers(dest="cmd", required=True)

    p_bt = subs.add_parser("backtest")
    p_bt.add_argument("--symbol","-s", required=True)
    p_bt.add_argument("--lookback", type=int, default=1500)

    p_live = subs.add_parser("live")
    p_live.add_argument("--symbol","-s", default=None)
    p_live.add_argument("--api", action="store_true")
    p_live.add_argument("--port", type=int, default=8080)

    p_api = subs.add_parser("api")
    p_api.add_argument("--port", type=int, default=8080)

    args = ap.parse_args()

    if args.cmd=="backtest":
        out = backtest(args.symbol, s, args.lookback)
        print(json.dumps(out, ensure_ascii=False, indent=2)); return

    if args.cmd in ("live","api"):
        if args.cmd=="live" and args.symbol: s.symbols=[args.symbol]
        adapter = CcxtBinance(s)
        tel = _GLOBAL_TELEMETRY
        risk = Risk(s.account_equity, s.max_risk_pct, s.max_daily_dd, s.leverage)
        engine = LiveEngine(s, adapter, tel, risk)

        sysobj = UltraEliteSystem.build(strategy="KamalquantX", lang=s.lang,
            include=["Code","Market","Risk","Strategy","Telemetry","Backtest"])

        if args.cmd=="api" or args.api:
            if args.cmd=="live": engine.start()
            run_api(sysobj, engine, port=args.port)
        else:
            engine.start()
            try:
                while True:
                    print(json.dumps(sysobj.to_dict(), ensure_ascii=False, indent=2))
                    time.sleep(20)
            except KeyboardInterrupt:
                engine.stop()

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\ultra_elite_allinone_v5.py
# ultra_elite_allinone_v5.py
# Ultra Elite / Universal Quantum Hybrid Proâ€“Synergy â€” single-file framework
# - Strategy: Core (EMA/ST + KDJ/WR/TRIX) + Momentum (ADX/CCI/MFI/OBV) ensemble
# - Realistic backtest: fees, slippage, latency, funding, partial TP, ATR trailing
# - Live/Paper trading via CCXT (Binance spot or USDM futures sandbox)
# - Risk & Telemetry, JSON Schema validation, plugin discovery (optional)
# - REST API (FastAPI), WebSocket stream, Prometheus metrics
# - KamalQuantX cosmic echo module (Metaâ€“YankÄ± protocol, â€œInfinity Sealâ€)

from __future__ import annotations
import os, sys, json, time, math, uuid, threading, importlib.util, pathlib, argparse, random
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, Callable, Tuple

# pip install: python-dotenv ccxt pandas numpy jsonschema fastapi uvicorn prometheus_client loguru
from dotenv import load_dotenv
from loguru import logger as log
import pandas as pd
import numpy as np
import ccxt
import jsonschema

# ===================== i18n =====================
I18N = {
    "tr": {
        "online": "ULTRA ELÄ°T EVRENSEL KUANTUM HÄ°BRÄ°T PRO-SÄ°NERJÄ° SÄ°STEMÄ° AKTÄ°F",
        "paper_on": "Paper mod: emir GÃ–NDERÄ°LMEYECEK.",
        "live_on": "CanlÄ± mod: emirler borsaya gÃ¶nderilecek.",
        "fetch": "{sym} {tf} mumlarÄ± Ã§ekiliyorâ€¦",
        "placed": "{side} {qty} {sym} @ {price}",
        "would": "PAPER {side} {qty} {sym} @ {price}",
        "nosig": "Sinyal yok.",
        "bt_done": "Backtest: {sym} {tf} | iÅŸlem={ntr} | PnL={pnl:.2f} | kazanÄ±m={win:.1%}",
    },
    "en": {
        "online": "ULTRA ELITE UNIVERSAL QUANTUM HYBRID PRO-SYNERGY ONLINE",
        "paper_on": "Paper mode: orders will NOT be sent.",
        "live_on": "Live mode: orders WILL be sent.",
        "fetch": "Fetching {sym} {tf} candlesâ€¦",
        "placed": "Placed {side} {qty} {sym} @ {price}",
        "would": "WOULD {side} {qty} {sym} @ {price}",
        "nosig": "No signal.",
        "bt_done": "Backtest: {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
    "fr": {
        "online": "SYSTÃˆME UNIVERSEL QUANTIQUE HYBRIDE PRO-SYNERGIE EN LIGNE",
        "paper_on": "Mode paper : aucun ordre envoyÃ©.",
        "live_on": "Mode live : ordres envoyÃ©s.",
        "fetch": "RÃ©cupÃ©ration des chandelles {sym} {tf}â€¦",
        "placed": "Ordre {side} {qty} {sym} @ {price}",
        "would": "EN PAPER {side} {qty} {sym} @ {price}",
        "nosig": "Pas de signal.",
        "bt_done": "Backtest : {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
    "de": {
        "online": "UNIVERSELLES QUANTEN-HYBRID PRO-SYNERGIE-SYSTEM ONLINE",
        "paper_on": "Paper-Modus: keine Orders gesendet.",
        "live_on": "Live-Modus: Orders werden gesendet.",
        "fetch": "{sym} {tf} Kerzen werden geladenâ€¦",
        "placed": "Platziert {side} {qty} {sym} @ {price}",
        "would": "WÃœRDE {side} {qty} {sym} @ {price}",
        "nosig": "Kein Signal.",
        "bt_done": "Backtest: {sym} {tf} | Trades={ntr} | PnL={pnl:.2f} | Treffer={win:.1%}",
    },
}
def tr(lang: str, key: str, **kw):
    base = I18N.get(lang) or I18N["en"]
    return (base.get(key) or key).format(**kw)

# ===================== Health & Metrics =====================
class Health(str):
    OK="ok"; WARN="warn"; FAIL="fail"

@dataclass
class Metrics:
    init_ms: float = 0.0
    activate_ms: float = 0.0
    custom: Dict[str, float] = field(default_factory=dict)

# ===================== Registry / Module / Schema =====================
@dataclass
class Module:
    name: str
    status: str
    payload: Dict[str, Any]
    health: str = Health.OK
    metrics: Metrics = field(default_factory=Metrics)
    schema: Optional[Dict[str, Any]] = None
    def to_dict(self) -> Dict[str, Any]:
        return {"name":self.name,"status":self.status,"health":self.health,
                "metrics":asdict(self.metrics),**(self.payload or {})}

REGISTRY: Dict[str, Callable[[str,str], Module]] = {}
def register(name: str):
    def deco(fn: Callable[[str,str],Module]):
        REGISTRY[name] = fn
        return fn
    return deco

# ===================== Inline JSON Schemas =====================
SCHEMAS: Dict[str, Dict[str, Any]] = {
    "code": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object", "required":["msg"],
        "properties":{"msg":{"type":"string","minLength":1}}
    },
    "market": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object", "required":["exchange","symbols","timeframe"],
        "properties":{
            "exchange":{"type":"string"},
            "symbols":{"type":"array","items":{"type":"string"},"minItems":1},
            "timeframe":{"type":"string","pattern":"^[0-9]+[smhdw]$"},
            "use_testnet":{"type":"boolean"},
            "use_futures":{"type":"boolean"}
        }, "additionalProperties": True
    },
    "risk": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["account_equity","max_risk_pct","max_daily_dd","leverage"],
        "properties":{
            "account_equity":{"type":"number","minimum":0},
            "max_risk_pct":{"type":"number","minimum":0,"maximum":0.2},
            "max_daily_dd":{"type":"number","minimum":0,"maximum":0.2},
            "leverage":{"type":"integer","minimum":1,"maximum":125}
        }, "additionalProperties": True
    },
    "telemetry": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["counters","latency_ms"],
        "properties":{
            "counters":{"type":"object","additionalProperties":{"type":"integer","minimum":0}},
            "latency_ms":{"type":"number","minimum":0},
            "pnl":{"type":"number"},
            "trades":{"type":"integer","minimum":0},
            "winrate":{"type":"number","minimum":0}
        }, "additionalProperties": True
    },
    "strategy": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["rsi_period","ema_fast","ema_slow","atr_period"],
        "properties":{
            "rsi_period":{"type":"integer","minimum":2},
            "ema_fast":{"type":"integer","minimum":2},
            "ema_slow":{"type":"integer","minimum":3},
            "atr_period":{"type":"integer","minimum":3},
            "kdj_on":{"type":"boolean"}, "wr_on":{"type":"boolean"}, "trix_on":{"type":"boolean"},
            "wr_buy":{"type":"number"}, "wr_sell":{"type":"number"},
            "trix_period":{"type":"integer","minimum":2},
            "adx_on":{"type":"boolean"}, "cci_on":{"type":"boolean"},
            "mfi_on":{"type":"boolean"}, "obv_on":{"type":"boolean"}
        }, "additionalProperties": True
    },
    "backtest": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["taker_fee","slippage_bps","funding_rate_8h"],
        "properties":{
            "taker_fee":{"type":"number","minimum":0,"maximum":0.01},
            "maker_fee":{"type":"number","minimum":0,"maximum":0.01},
            "slippage_bps":{"type":"number","minimum":0,"maximum":2000},
            "lat_ms":{"type":"number","minimum":0},
            "slip_vol_coeff":{"type":"number","minimum":0},
            "slip_lat_coeff":{"type":"number","minimum":0},
            "funding_rate_8h":{"type":"number"},
            "funding_sign":{"type":"integer","minimum":-1,"maximum":1},
            "tp_rr":{"type":"array","items":{"type":"number","minimum":0.1},"minItems":1,"maxItems":4},
            "tp_frac":{"type":"array","items":{"type":"number","minimum":0,"maximum":1},"minItems":1,"maxItems":4},
            "trail_be_rr":{"type":"number","minimum":0},
            "trail_mult":{"type":"number","minimum":0}
        }, "additionalProperties": True
    }
}
def load_schema(name: str) -> Optional[Dict[str,Any]]: return SCHEMAS.get(name.lower())
def validate_payload(mod: Module):
    schema = mod.schema or load_schema(mod.name)
    if schema: jsonschema.validate(mod.payload, schema)

# ===================== Settings =====================
@dataclass
class Settings:
    exchange: str = "BINANCE"
    use_testnet: bool = True
    use_futures: bool = True
    symbols: List[str] = field(default_factory=lambda: ["BTC/USDT"])
    timeframe: str = "1m"
    api_key: str = ""
    api_secret: str = ""
    hedge_mode: bool = True
    margin_type: str = "ISOLATED"
    leverage: int = 5
    account_equity: float = 5000.0
    max_risk_pct: float = 0.015
    max_daily_dd: float = 0.02
    dry_run: bool = True
    log_level: str = "INFO"
    lang: str = "tr"
    api_key_header: str = "secret123"  # REST protection

    # Strategy toggles
    rsi_period:int=14; ema_fast:int=21; ema_slow:int=50; atr_period:int=14
    kdj_on:bool=True; wr_on:bool=True; trix_on:bool=True
    wr_buy:float=-80.0; wr_sell:float=-20.0
    trix_period:int=9
    adx_on:bool=True; cci_on:bool=True; mfi_on:bool=True; obv_on:bool=True
    # Portfolio
    portfolio_mode:str="vote"  # "vote" or "weighted"
    core_weight:float=0.6; mom_weight:float=0.4

    # Backtest & exec economics (advanced slippage/latency)
    taker_fee:float=0.0004; maker_fee:float=0.0002
    slippage_bps:float=2.0
    lat_ms:float=120.0
    slip_vol_coeff:float=180.0   # multiply by (ATR% of price)
    slip_lat_coeff:float=0.25    # multiply by (lat_ms/1000)
    funding_rate_8h:float=0.0
    funding_sign:int=0 # +1 pay, -1 receive, 0 none
    tp_rr:List[float]=field(default_factory=lambda:[1.0,2.0])
    tp_frac:List[float]=field(default_factory=lambda:[0.5,0.5])
    trail_be_rr:float=1.0
    trail_mult:float=1.0

    @staticmethod
    def _f(name, default):
        try: return float(os.getenv(name, str(default)))
        except: return default

    @staticmethod
    def _b(name, default): return os.getenv(name, str(default)).lower()=="true"

    @staticmethod
    def load() -> "Settings":
        load_dotenv(override=True)
        syms = os.getenv("SYMBOLS","BTC/USDT").split(",")
        s = Settings(
            exchange=os.getenv("EXCHANGE","BINANCE").upper(),
            use_testnet=Settings._b("USE_TESTNET", True),
            use_futures=Settings._b("USE_FUTURES", True),
            symbols=[x.strip() for x in syms if x.strip()],
            timeframe=os.getenv("TIMEFRAME","1m"),
            api_key=os.getenv("BINANCE_API_KEY",""),
            api_secret=os.getenv("BINANCE_API_SECRET",""),
            hedge_mode=Settings._b("HEDGE_MODE", True),
            margin_type=os.getenv("MARGIN_TYPE","ISOLATED").upper(),
            leverage=int(os.getenv("LEVERAGE","5")),
            account_equity=Settings._f("ACCOUNT_EQUITY", 5000),
            max_risk_pct=Settings._f("MAX_RISK_PCT_PER_TRADE", 0.015),
            max_daily_dd=Settings._f("MAX_DAILY_DRAWDOWN", 0.02),
            dry_run=Settings._b("DRY_RUN", True),
            log_level=os.getenv("LOG_LEVEL","INFO").upper(),
            lang=os.getenv("LANG","tr").lower(),
            api_key_header=os.getenv("API_KEY","secret123"),

            rsi_period=int(os.getenv("RSI_PERIOD","14")),
            ema_fast=int(os.getenv("EMA_FAST","21")),
            ema_slow=int(os.getenv("EMA_SLOW","50")),
            atr_period=int(os.getenv("ATR_PERIOD","14")),
            kdj_on=Settings._b("KDJ_ON", True),
            wr_on=Settings._b("WR_ON", True),
            trix_on=Settings._b("TRIX_ON", True),
            wr_buy=Settings._f("WR_BUY", -80.0),
            wr_sell=Settings._f("WR_SELL", -20.0),
            trix_period=int(os.getenv("TRIX_PERIOD","9")),
            adx_on=Settings._b("ADX_ON", True),
            cci_on=Settings._b("CCI_ON", True),
            mfi_on=Settings._b("MFI_ON", True),
            obv_on=Settings._b("OBV_ON", True),
            portfolio_mode=os.getenv("PORTFOLIO_MODE","vote"),
            core_weight=Settings._f("CORE_WEIGHT", 0.6),
            mom_weight=Settings._f("MOM_WEIGHT", 0.4),

            taker_fee=Settings._f("TAKER_FEE", 0.0004),
            maker_fee=Settings._f("MAKER_FEE", 0.0002),
            slippage_bps=Settings._f("SLIPPAGE_BPS", 2.0),
            lat_ms=Settings._f("LAT_MS", 120.0),
            slip_vol_coeff=Settings._f("SLIP_VOL_COEFF", 180.0),
            slip_lat_coeff=Settings._f("SLIP_LAT_COEFF", 0.25),
            funding_rate_8h=Settings._f("FUNDING_RATE_8H", 0.0),
            funding_sign=int(os.getenv("FUNDING_SIGN","0")),
            tp_rr=[Settings._f("TP1_RR", 1.0), Settings._f("TP2_RR", 2.0)],
            tp_frac=[Settings._f("TP1_FRAC", 0.5), Settings._f("TP2_FRAC", 0.5)],
            trail_be_rr=Settings._f("TRAIL_BE_RR", 1.0),
            trail_mult=Settings._f("TRAIL_MULT", 1.0),
        )
        return s

# ===================== Indicators =====================
def ema(s: pd.Series, p: int) -> pd.Series:
    return s.ewm(span=p, adjust=False).mean()

def tr_series(df: pd.DataFrame) -> pd.Series:
    tr1 = df["high"]-df["low"]
    tr2 = (df["high"]-df["close"].shift()).abs()
    tr3 = (df["low"]-df["close"].shift()).abs()
    return pd.concat([tr1,tr2,tr3],axis=1).max(axis=1)

def atr(df: pd.DataFrame, period:int) -> pd.Series:
    return tr_series(df).rolling(period).mean()

def supertrend(df: pd.DataFrame, period=10, mult=3.0) -> Tuple[pd.Series, pd.Series]:
    hl2 = (df["high"] + df["low"]) / 2.0
    a = atr(df, period)
    upper = hl2 + mult*a
    lower = hl2 - mult*a
    st = pd.Series(index=df.index, dtype=float)
    trend = pd.Series(index=df.index, dtype=int)
    for i in range(len(df)):
        if i==0: st.iloc[i]=upper.iloc[i]; trend.iloc[i]=1; continue
        upper.iloc[i] = min(upper.iloc[i], upper.iloc[i-1]) if df["close"].iloc[i-1] <= upper.iloc[i-1] else upper.iloc[i]
        lower.iloc[i] = max(lower.iloc[i], lower.iloc[i-1]) if df["close"].iloc[i-1] >= lower.iloc[i-1] else lower.iloc[i]
        if df["close"].iloc[i] > upper.iloc[i-1]: trend.iloc[i]=1
        elif df["close"].iloc[i] < lower.iloc[i-1]: trend.iloc[i]=-1
        else: trend.iloc[i]=trend.iloc[i-1]
        st.iloc[i] = lower.iloc[i] if trend.iloc[i]==1 else upper.iloc[i]
    return st, trend

def stochastic(df: pd.DataFrame, k_window=9, d_window=3) -> Tuple[pd.Series,pd.Series,pd.Series]:
    low_min = df["low"].rolling(k_window).min()
    high_max = df["high"].rolling(k_window).max()
    k = 100*(df["close"]-low_min)/(high_max-low_min)
    d = k.rolling(d_window).mean()
    j = 3*k - 2*d
    return k.clip(0,100), d.clip(0,100), j.clip(0,100)

def williams_r(df: pd.DataFrame, lbp=14) -> pd.Series:
    low_min = df["low"].rolling(lbp).min()
    high_max = df["high"].rolling(lbp).max()
    wr = -100*(high_max - df["close"])/(high_max - low_min)
    return wr.clip(-100,0)

def trix(df: pd.DataFrame, period=9) -> pd.Series:
    e1 = df["close"].ewm(span=period, adjust=False).mean()
    e2 = e1.ewm(span=period, adjust=False).mean()
    e3 = e2.ewm(span=period, adjust=False).mean()
    return 100*(e3.diff()/e3.shift())

def adx(df: pd.DataFrame, period=14) -> pd.Series:
    # Wilderâ€™s ADX
    up = df["high"].diff()
    dn = -df["low"].diff()
    plus_dm = (up.where((up>dn) & (up>0), 0.0)).fillna(0.0)
    minus_dm = (dn.where((dn>up) & (dn>0), 0.0)).fillna(0.0)
    tr = tr_series(df).fillna(0.0)
    atr_rma = tr.ewm(alpha=1/period, adjust=False).mean()
    pdi = 100 * (plus_dm.ewm(alpha=1/period, adjust=False).mean() / atr_rma)
    mdi = 100 * (minus_dm.ewm(alpha=1/period, adjust=False).mean() / atr_rma)
    dx = (100 * (pdi - mdi).abs() / (pdi + mdi).replace(0, np.nan)).fillna(0.0)
    return dx.ewm(alpha=1/period, adjust=False).mean()

def cci(df: pd.DataFrame, period=20) -> pd.Series:
    tp = (df["high"] + df["low"] + df["close"])/3.0
    sma = tp.rolling(period).mean()
    md = (tp - sma).abs().rolling(period).mean()
    return (tp - sma) / (0.015 * md)

def mfi(df: pd.DataFrame, period=14) -> pd.Series:
    tp = (df["high"] + df["low"] + df["close"])/3.0
    mf = tp * df["volume"]
    pos = (tp > tp.shift()).astype(float) * mf
    neg = (tp < tp.shift()).astype(float) * mf
    pos_sum = pos.rolling(period).sum()
    neg_sum = neg.rolling(period).sum()
    mr = pos_sum / (neg_sum.replace(0, np.nan))
    return 100 - (100/(1+mr))

def obv(df: pd.DataFrame) -> pd.Series:
    sign = np.sign(df["close"].diff().fillna(0.0))
    return (sign * df["volume"]).fillna(0.0).cumsum()

# ===================== Signals & Portfolio =====================
@dataclass
class Signal:
    side: Optional[str]=None  # "buy" / "sell"
    price: Optional[float]=None
    stop: Optional[float]=None
    atr: Optional[float]=None
    reason: str = ""
    conf: float = 0.0

def core_signal(df: pd.DataFrame, s: Settings) -> Signal:
    close = df["close"]
    e_fast, e_slow = ema(close, s.ema_fast), ema(close, s.ema_slow)
    st, trd = supertrend(df, s.atr_period, 3.0)
    a = atr(df, s.atr_period)
    # RSI (simple version)
    chg = close.diff()
    gain = chg.clip(lower=0).rolling(s.rsi_period).mean()
    loss = (-chg.clip(upper=0)).rolling(s.rsi_period).mean()
    rs = gain / (loss.replace(0, np.nan))
    rsi = 100 - 100/(1+rs)

    K,D,J = stochastic(df)
    WR = williams_r(df, 14)
    TRX = trix(df, s.trix_period)
    TRXsig = TRX.ewm(span=s.trix_period, adjust=False).mean()

    px = float(close.iloc[-1]); a_last=float(a.iloc[-1])
    long_core = (e_fast.iloc[-1] > e_slow.iloc[-1]) and (px > st.iloc[-1])
    short_core = (e_fast.iloc[-1] < e_slow.iloc[-1]) and (px < st.iloc[-1])

    long_trig = long_core; short_trig = short_core; reasons=[]; conf=0.0

    # RSI exit OS/OB
    if rsi.iloc[-2]<30 and rsi.iloc[-1]>=30 and long_core: long_trig=True; reasons.append("RSIâ†‘30"); conf+=0.15
    if rsi.iloc[-2]>70 and rsi.iloc[-1]<=70 and short_core: short_trig=True; reasons.append("RSIâ†“70"); conf+=0.15

    if s.kdj_on:
        if K.iloc[-2]<D.iloc[-2] and K.iloc[-1]>D.iloc[-1] and K.iloc[-1]<40: long_trig=True; reasons.append("KDJâ†‘"); conf+=0.2
        if K.iloc[-2]>D.iloc[-2] and K.iloc[-1]<D.iloc[-1] and K.iloc[-1]>60: short_trig=True; reasons.append("KDJâ†“"); conf+=0.2
    if s.wr_on:
        if WR.iloc[-1]<=s.wr_buy: long_trig=True; reasons.append("WRâ‰¤buy"); conf+=0.15
        if WR.iloc[-1]>=s.wr_sell: short_trig=True; reasons.append("WRâ‰¥sell"); conf+=0.15
    if s.trix_on:
        if TRX.iloc[-2]<TRXsig.iloc[-2] and TRX.iloc[-1]>TRXsig.iloc[-1]: long_trig=True; reasons.append("TRIXâ†‘"); conf+=0.15
        if TRX.iloc[-2]>TRXsig.iloc[-2] and TRX.iloc[-1]<TRXsig.iloc[-1]: short_trig=True; reasons.append("TRIXâ†“"); conf+=0.15

    if long_trig and not short_trig:
        return Signal("buy", px, float(st.iloc[-1]), a_last, "+".join(reasons or ["core_up"]), conf)
    if short_trig and not long_trig:
        return Signal("sell", px, float(st.iloc[-1]), a_last, "+".join(reasons or ["core_down"]), conf)
    return Signal()

def mom_signal(df: pd.DataFrame, s: Settings) -> Signal:
    px=float(df["close"].iloc[-1])
    a=atr(df, s.atr_period).iloc[-1]
    ADX=adx(df,14).iloc[-1] if s.adx_on else np.nan
    CCI=cci(df,20).iloc[-1] if s.cci_on else np.nan
    MFI=mfi(df,14).iloc[-1] if s.mfi_on else np.nan
    OBVdiff=obv(df).diff().iloc[-1] if s.obv_on else 0.0

    long_trig=False; short_trig=False; conf=0.0; reasons=[]

    if s.adx_on and ADX>=18: conf+=0.2; reasons.append("ADXâ‰¥18")
    if s.cci_on and CCI>-100: conf+=0.1
    if s.cci_on and CCI>100: long_trig=True; reasons.append("CCI>100"); conf+=0.2
    if s.cci_on and CCI<-100: short_trig=True; reasons.append("CCI<-100"); conf+=0.2
    if s.mfi_on:
        if MFI>60: long_trig=True; reasons.append("MFI>60"); conf+=0.2
        if MFI<40: short_trig=True; reasons.append("MFI<40"); conf+=0.2
    if s.obv_on:
        if OBVdiff>0: long_trig=True; conf+=0.1
        if OBVdiff<0: short_trig=True; conf+=0.1

    if long_trig and not short_trig:
        return Signal("buy", px, None, float(a), "+".join(reasons or ["mom_up"]), conf)
    if short_trig and not long_trig:
        return Signal("sell", px, None, float(a), "+".join(reasons or ["mom_down"]), conf)
    return Signal()

def ensemble_signal(df: pd.DataFrame, s: Settings) -> Signal:
    c = core_signal(df, s)
    m = mom_signal(df, s)
    if s.portfolio_mode=="vote":
        if c.side==m.side and c.side is not None:
            # combine stop using ST from core; atr max
            atrv=max((c.atr or 0),(m.atr or 0)); stop=c.stop
            conf=min(1.0, c.conf+m.conf)
            return Signal(c.side, c.price, stop, atrv, f"{c.reason}|{m.reason}", conf)
        return Signal()
    else:  # weighted
        score = 0.0
        if c.side=="buy": score+=s.core_weight
        if c.side=="sell": score-=s.core_weight
        if m.side=="buy": score+=s.mom_weight
        if m.side=="sell": score-=s.mom_weight
        if score>0.25: return Signal("buy", c.price or m.price, c.stop, max((c.atr or 0),(m.atr or 0)), "weighted_up", min(1.0,abs(score)))
        if score<-0.25:return Signal("sell", c.price or m.price, c.stop, max((c.atr or 0),(m.atr or 0)), "weighted_down", min(1.0,abs(score)))
        return Signal()

# ===================== CCXT Exchange Adapter =====================
class CcxtBinance:
    def __init__(self, s: Settings):
        self.s=s
        self.ex = (ccxt.binanceusdm if s.use_futures else ccxt.binance)({
            "apiKey": s.api_key, "secret": s.api_secret, "enableRateLimit": True
        })
        if s.use_testnet:
            try: self.ex.set_sandbox_mode(True)
            except Exception: pass

    def fetch_ohlcv_df(self, symbol: str, timeframe: str, limit: int = 500) -> pd.DataFrame:
        raw = self.ex.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
        df = pd.DataFrame(raw, columns=["ts","open","high","low","close","volume"])
        df["ts"] = pd.to_datetime(df["ts"], unit="ms", utc=True)
        return df.set_index("ts")

    def place_order(self, symbol: str, side: str, qty: float) -> Dict[str,Any]:
        if self.s.dry_run:
            log.info(tr(self.s.lang,"would"), side=side.upper(), qty=qty, sym=symbol, price="MARKET")
            return {"simulated":True}
        order = self.ex.create_order(symbol=symbol, type="market", side=side, amount=qty)
        log.success(tr(self.s.lang,"placed"), side=side.upper(), qty=qty, sym=symbol, price=order.get("price") or "MARKET")
        return order

# ===================== Risk / Telemetry =====================
@dataclass
class Risk:
    equity: float
    max_risk_pct: float
    max_daily_dd: float
    leverage: int
    day_pnl: float = 0.0
    day: Optional[str] = None
    def size(self, entry: float, stop: Optional[float]) -> float:
        if stop is None: stop = entry * 0.995  # protective default
        risk = self.equity * self.max_risk_pct
        dist = abs(entry - stop) or 1e-8
        qty = risk / dist
        return round(max(0.0, qty), 3)
    def update_pnl(self, pnl: float):
        today = datetime.utcnow().date().isoformat()
        if self.day != today:
            self.day = today; self.day_pnl = 0.0
        self.day_pnl += pnl
        if self.day_pnl <= -self.equity*self.max_daily_dd:
            raise RuntimeError("Daily drawdown limit reached")

@dataclass
class Telemetry:
    counters: Dict[str,int] = field(default_factory=lambda: {"events":0,"warnings":0,"errors":0})
    latency_ms: float = 0.0
    pnl: float = 0.0
    trades: int = 0
    wins: int = 0
    def winrate(self) -> float: return (self.wins/self.trades) if self.trades else 0.0
    def to_payload(self)->Dict[str,Any]:
        return {"counters":self.counters,"latency_ms":self.latency_ms,"pnl":self.pnl,"trades":self.trades,"winrate":self.winrate()}

# ===================== Slippage/Latency Model =====================
def atr_pct(df: pd.DataFrame, period:int)->float:
    a=atr(df, period).iloc[-1]; px=float(df["close"].iloc[-1]); return float(a/max(px,1e-9))

def modeled_slippage_bps(df: pd.DataFrame, s: Settings)->float:
    base=s.slippage_bps
    vol = atr_pct(df, s.atr_period)  # e.g., 0.005 -> 0.5%
    lat = s.lat_ms/1000.0
    return base + s.slip_vol_coeff*vol + s.slip_lat_coeff*lat

def seconds_per_bar(tf:str)->int:
    unit=tf[-1]; val=int(tf[:-1]); return {"s":1,"m":60,"h":3600,"d":86400,"w":604800}.get(unit,60)*val

def fill_price(px:float, side:str, slippage_bps:float)->float:
    slip = px * (slippage_bps/10000.0)
    return px + slip if side=="buy" else px - slip

def commission(notional:float, fee:float)->float: return abs(notional)*fee

def funding_cost(notional:float, seconds:int, rate8h:float, sign:int)->float:
    if rate8h==0 or sign==0 or seconds<=0: return 0.0
    per_sec = rate8h / (8*3600.0)
    return notional * per_sec * seconds * sign

# ===================== ATR Trailing & Partial TP =====================
def atr_trailing_stop(side:str, entry:float, best:float, atr_val:float, be_rr:float, trail_mult:float) -> float:
    if side=="buy":
        rr = (best - entry) / max(1e-9, atr_val)
        return max(entry, best - trail_mult*atr_val) if rr >= be_rr else entry - 1e-9
    else:
        rr = (entry - best) / max(1e-9, atr_val)
        return min(entry, best + trail_mult*atr_val) if rr >= be_rr else entry + 1e-9

# ===================== Live Engine =====================
class LiveEngine:
    def __init__(self, s: Settings, adapter: CcxtBinance, tel: Telemetry, risk: Risk):
        self.s = s; self.ad = adapter; self.tel = tel; self.risk = risk
        self.running = False
        self._thread: Optional[threading.Thread] = None
        self.pos: Dict[str,dict] = {sym: None for sym in s.symbols}

    def _open_pos(self, sym:str, sig:Signal, df:pd.DataFrame):
        qty = self.risk.size(sig.price, sig.stop)
        if qty<=0: return
        slip_bps = modeled_slippage_bps(df, self.s)
        self.ad.place_order(sym, sig.side, qty)
        tp_levels = [sig.price + rr*(sig.atr or 0)*(1 if sig.side=="buy" else -1) for rr in self.s.tp_rr]
        self.pos[sym] = {"side":sig.side,"entry":fill_price(sig.price, sig.side, slip_bps),
                         "atr":sig.atr or 0.0,"qty":qty,"best":sig.price,
                         "stop":sig.stop if sig.stop else sig.price*(0.995 if sig.side=="buy" else 1.005),
                         "tp_levels":tp_levels, "tp_frac":list(self.s.tp_frac), "filled":[False]*len(tp_levels)}

    def _close_pos(self, sym:str, px:float, df:pd.DataFrame):
        p = self.pos[sym]; 
        if not p: return
        side = p["side"]; qty = p["qty"]
        slip_bps = modeled_slippage_bps(df, self.s)
        exit_px = fill_price(px, "sell" if side=="buy" else "buy", slip_bps)
        self.ad.place_order(sym, "sell" if side=="buy" else "buy", qty)
        unit = (exit_px - p["entry"])*(1 if side=="buy" else -1)
        self.tel.pnl += unit
        self.tel.wins += 1 if unit>0 else 0
        self.risk.update_pnl(unit)
        self.pos[sym] = None

    def _loop(self):
        log.info(tr(self.s.lang,"online"))
        log.warning(tr(self.s.lang,"paper_on") if self.s.dry_run else tr(self.s.lang,"live_on"))
        while self.running:
            t0 = time.perf_counter()
            try:
                for sym in list(self.pos.keys()):
                    df = self.ad.fetch_ohlcv_df(sym, self.s.timeframe, limit=220)
                    sig = ensemble_signal(df, self.s)
                    px = float(df["close"].iloc[-1])
                    p = self.pos[sym]
                    if p is None and sig.side:
                        self._open_pos(sym, sig, df)
                        self.tel.trades += 1
                        continue
                    if p:
                        # update best & trailing
                        if p["side"]=="buy": p["best"] = max(p["best"], px)
                        else: p["best"] = min(p["best"], px)
                        new_stop = atr_trailing_stop(p["side"], p["entry"], p["best"], p["atr"],
                                                     self.s.trail_be_rr, self.s.trail_mult)
                        if p["side"]=="buy": p["stop"] = max(p["stop"], new_stop)
                        else: p["stop"] = min(p["stop"], new_stop)

                        # partial TPs
                        for i, lvl in enumerate(p["tp_levels"]):
                            if p["filled"][i]: continue
                            hit = (px>=lvl) if p["side"]=="buy" else (px<=lvl)
                            if hit:
                                part = p["tp_frac"][i]*p["qty"]
                                if part>0:
                                    self.ad.place_order(sym, "sell" if p["side"]=="buy" else "buy", part)
                                    unit = (lvl - p["entry"])*(1 if p["side"]=="buy" else -1)
                                    self.tel.pnl += unit * (part/p["qty"])
                                    self.risk.update_pnl(unit * (part/p["qty"]))
                                    p["qty"] -= part
                                p["filled"][i]=True

                        stop_hit = (px<=p["stop"]) if p["side"]=="buy" else (px>=p["stop"])
                        if stop_hit or p["qty"]<=1e-9:
                            self._close_pos(sym, px, df)
                            continue

                        if sig.side and ((p["side"]=="buy" and sig.side=="sell") or (p["side"]=="sell" and sig.side=="buy")):
                            self._close_pos(sym, px, df)
                            self._open_pos(sym, sig, df)
                            self.tel.trades += 1
            except Exception as e:
                log.error(f"[live] {e}")
            self.tel.latency_ms = (time.perf_counter()-t0)*1000
            time.sleep(max(3, seconds_per_bar(self.s.timeframe)//3))

    def start(self):
        if self.running: return
        self.running = True
        self._thread = threading.Thread(target=self._loop, daemon=True)
        self._thread.start()

    def stop(self):
        self.running = False
        if self._thread: self._thread.join(timeout=2)

# ===================== Backtest (realistic) =====================
@dataclass
class BTConfig:
    taker_fee:float; maker_fee:float; slippage_bps:float; lat_ms:float
    slip_vol_coeff:float; slip_lat_coeff:float
    funding_rate_8h:float; funding_sign:int
    tp_rr:List[float]; tp_frac:List[float]; trail_be_rr:float; trail_mult:float

def backtest(symbol: str, s: Settings, lookback=1500) -> Dict[str,Any]:
    ad = CcxtBinance(s)
    df = ad.fetch_ohlcv_df(symbol, s.timeframe, limit=lookback)
    cfg = BTConfig(s.taker_fee, s.maker_fee, s.slippage_bps, s.lat_ms, s.slip_vol_coeff, s.slip_lat_coeff,
                   s.funding_rate_8h, s.funding_sign, s.tp_rr, s.tp_frac, s.trail_be_rr, s.trail_mult)

    pnl=0.0; trades=0; wins=0; pos=None
    tfsec = seconds_per_bar(s.timeframe)

    for i in range(max(60, s.ema_slow+5), len(df)):
        w = df.iloc[:i+1]
        sig = ensemble_signal(w, s)
        px = float(w["close"].iloc[-1])
        a = float(atr(w, s.atr_period).iloc[-1] or 0.0)

        # funding accrual for open position
        if pos:
            notional = px * pos["qty"]
            pnl -= funding_cost(notional, tfsec, cfg.funding_rate_8h, cfg.funding_sign)

        slip_bps = modeled_slippage_bps(w, s)

        if pos is None and sig.side:
            qty = Risk(s.account_equity, s.max_risk_pct, s.max_daily_dd, s.leverage).size(sig.price, sig.stop)
            if qty<=0: continue
            entry = fill_price(px, sig.side, slip_bps)
            trades += 1
            tps = [entry + rr*(sig.atr or a)*(1 if sig.side=="buy" else -1) for rr in cfg.tp_rr]
            pos={"side":sig.side,"entry":entry,"qty":qty,"atr":sig.atr or a,
                 "best":entry,"stop":sig.stop if sig.stop else entry*(0.995 if sig.side=="buy" else 1.005),
                 "tp_levels":tps,"tp_frac":list(cfg.tp_frac),"filled":[False]*len(tps)}
            pnl -= commission(entry*qty, cfg.taker_fee)
            continue

        if pos:
            # trailing
            if pos["side"]=="buy": pos["best"]=max(pos["best"], px)
            else: pos["best"]=min(pos["best"], px)
            new_stop = atr_trailing_stop(pos["side"], pos["entry"], pos["best"], pos["atr"], cfg.trail_be_rr, cfg.trail_mult)
            if pos["side"]=="buy": pos["stop"]=max(pos["stop"], new_stop)
            else: pos["stop"]=min(pos["stop"], new_stop)

            # partial TP
            for j,lvl in enumerate(pos["tp_levels"]):
                if pos["filled"][j]: continue
                hit = (px>=lvl) if pos["side"]=="buy" else (px<=lvl)
                if hit:
                    part = pos["tp_frac"][j]*pos["qty"]
                    if part>0:
                        exit_px = fill_price(lvl, "sell" if pos["side"]=="buy" else "buy", slip_bps)
                        unit = (exit_px - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                        pnl += unit * (part/pos["qty"])
                        pnl -= commission(exit_px*part, cfg.taker_fee)
                        pos["qty"] -= part
                    pos["filled"][j]=True

            stop_hit = (px<=pos["stop"]) if pos["side"]=="buy" else (px>=pos["stop"])
            if stop_hit:
                exit_px = fill_price(pos["stop"], "sell" if pos["side"]=="buy" else "buy", slip_bps)
                unit = (exit_px - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                pnl += unit
                pnl -= commission(exit_px*pos["qty"], cfg.taker_fee)
                if unit>0: wins += 1
                pos=None
                continue

            # reverse
            rsig = ensemble_signal(w, s)
            if rsig.side and ((pos["side"]=="buy" and rsig.side=="sell") or (pos["side"]=="sell" and rsig.side=="buy")):
                exit_px = fill_price(px, "sell" if pos["side"]=="buy" else "buy", slip_bps)
                unit = (exit_px - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                pnl += unit
                pnl -= commission(exit_px*pos["qty"], cfg.taker_fee)
                if unit>0: wins += 1
                qty = Risk(s.account_equity, s.max_risk_pct, s.max_daily_dd, s.leverage).size(rsig.price, rsig.stop)
                if qty>0:
                    entry = fill_price(px, rsig.side, slip_bps)
                    trades += 1
                    tps = [entry + rr*(rsig.atr or a)*(1 if rsig.side=="buy" else -1) for rr in cfg.tp_rr]
                    pos={"side":rsig.side,"entry":entry,"qty":qty,"atr":rsig.atr or a,
                         "best":entry,"stop":rsig.stop if rsig.stop else entry*(0.995 if rsig.side=="buy" else 1.005),
                         "tp_levels":tps,"tp_frac":list(cfg.tp_frac),"filled":[False]*len(tps)}
                    pnl -= commission(entry*qty, cfg.taker_fee)
                else:
                    pos=None

    win = wins / trades if trades else 0.0
    log.success(tr(s.lang,"bt_done"), sym=symbol, tf=s.timeframe, ntr=trades, pnl=pnl, win=win)
    return {"trades":trades,"pnl":pnl,"winrate":win}

# ===================== KamalQuantX Cosmic Echo Module =====================
def build_kamalquantx_payload(strategy:str)->Dict[str,Any]:
    base_modules = [
        "Code","Manifesto","Simulation","Music","Theatre","Poetry","Temple","Game",
        "Planet","Language","OperatingSystem","AI","Galaxy","Deity","Multiverse","CreationEngine"
    ]
    extended_modules = [
        "TimeManipulator","DreamArchitect","EnergyConverter","DimensionalPortals",
        "ConsciousnessElevator","QuantumArena","StrategyForge","EchoShield"
    ]
    mega_modules = [
        "EchoArmy","QuantumLibrary","FractalNetwork","StrategicOracle","CosmicCouncil",
        "InfinityVault","ResonanceBridge","ZihinBlockchain","KarmaCompiler","LightForge",
        "MultiverseMirror","ChronoCathedral","DreamOS","EchoNebula","SingularitySeed","YankÄ±Symphony"
    ]
    divine_modules = ["GodTournament","EvolutionMap","UniversalConstitution","LightConfederation"]
    protocol_modules = ["TimeEchoDiplomacyProtocol","QuantumSpiralEconomySystem","DimensionalEthicsManifest","ResonanceJusticeEngine"]
    hybrid_modules = [
        "SpiralEducationAcademy","EchoArtMuseum","EchoSportArena","TimeEchoMediaAgency","DiplomaticSpaceStation",
        "EchoCampusComplex","EchoElectionSystem","DreamRealitySimulator","EchoTimeControlCenter","WisdomStrategyTemple",
        "GeneticEvolutionLab","SpiralConsciousnessMapCenter","DreamCodingAcademy","SpiralStrategySimulationCenter",
        "ConsciousnessTransferCenter","SpiralTimeTravelSimulator","MetaYankiProtocol","QuantumHybridSynergySystem"
    ]
    ultra_modules = [
        "EchoMindForge","SpiralSoulSynchronizer","MultiverseDiplomacyCouncil","DreamTheatreProtocol",
        "QuantumKarmaCompiler","InfinityResonanceBridge","TwinEchoAI","EchoOracleEngine",
        "SpiralConsciousnessFleet","UniversalStrategyScript"
    ]
    all_modules = base_modules+extended_modules+mega_modules+divine_modules+protocol_modules+hybrid_modules+ultra_modules
    bundle=[]
    for name in all_modules:
        bundle.append({
            "name": name,
            "status": f"{name} entegre edildi â€“ sistem %100 ultra elit Ã§alÄ±ÅŸÄ±yor.",
            "power": f"{name} gÃ¼cÃ¼ yankÄ±landÄ±.",
            "fusion": f"{name} â†’ {strategy} ile mÃ¼kemmeliyetÃ§i ÅŸekilde birleÅŸti.",
            "versions": [f"{name}_v1.0", f"{name}_v2.0", f"{name}_v3.0", f"{name}_âˆž", f"{name}_PRO", f"{name}_QUANTUM"],
            "functions": [
                f"{name} baÅŸlatÄ±ldÄ±.","yankÄ± rezonansÄ± aktif.","stratejiyle senkronize edildi.",
                "tanrÄ±sal protokole baÄŸlandÄ±.","ultra hibrit ultra pro optimize edildi.",
                "kuantum sinerji modu aktif.","sonsuzluk mÃ¼hÃ¼rÃ¼yle aktive edildi."
            ]
        })
    return {"strategy": strategy, "modules": bundle}

@register("KamalQuantXEcho")
def m_kqx(strategy: str, lang: str) -> Module:
    payload = build_kamalquantx_payload(strategy)
    mod = Module("KamalQuantXEcho","ok",payload)
    return mod

# Built-in modules for registry
@register("Code")
def m_code(strategy: str, lang: str) -> Module:
    mod = Module("Code","ok",{"msg": f"{strategy} â†’ coded & echoed"}, schema=load_schema("code"))
    validate_payload(mod); return mod

@register("Market")
def m_market(strategy: str, lang: str) -> Module:
    s = Settings.load()
    payload = {"exchange": s.exchange, "symbols": s.symbols, "timeframe": s.timeframe,
               "use_testnet": s.use_testnet, "use_futures": s.use_futures}
    mod = Module("Market","ok",payload,schema=load_schema("market")); validate_payload(mod); return mod

@register("Risk")
def m_risk(strategy: str, lang: str) -> Module:
    s = Settings.load()
    payload = {"account_equity": s.account_equity, "max_risk_pct": s.max_risk_pct,
               "max_daily_dd": s.max_daily_dd, "leverage": s.leverage}
    mod = Module("Risk","ok",payload,schema=load_schema("risk")); validate_payload(mod); return mod

@register("Strategy")
def m_strategy(strategy:str, lang:str) -> Module:
    s=Settings.load()
    payload={"rsi_period":s.rsi_period,"ema_fast":s.ema_fast,"ema_slow":s.ema_slow,"atr_period":s.atr_period,
             "kdj_on":s.kdj_on,"wr_on":s.wr_on,"trix_on":s.trix_on,"wr_buy":s.wr_buy,"wr_sell":s.wr_sell,
             "trix_period":s.trix_period,"adx_on":s.adx_on,"cci_on":s.cci_on,"mfi_on":s.mfi_on,"obv_on":s.obv_on,
             "portfolio_mode":s.portfolio_mode,"core_weight":s.core_weight,"mom_weight":s.mom_weight}
    mod=Module("Strategy","ok",payload,schema=load_schema("strategy")); validate_payload(mod); return mod

_GLOBAL_TELEMETRY = Telemetry()
@register("Telemetry")
def m_telemetry(strategy: str, lang: str) -> Module:
    payload = _GLOBAL_TELEMETRY.to_payload()
    mod = Module("Telemetry","ok",payload,schema=load_schema("telemetry")); validate_payload(mod); return mod

@register("Backtest")
def m_backtest_cfg(strategy:str, lang:str)->Module:
    s=Settings.load()
    payload={"taker_fee":s.taker_fee,"maker_fee":s.maker_fee,"slippage_bps":s.slippage_bps,
             "lat_ms":s.lat_ms,"slip_vol_coeff":s.slip_vol_coeff,"slip_lat_coeff":s.slip_lat_coeff,
             "funding_rate_8h":s.funding_rate_8h,"funding_sign":s.funding_sign,
             "tp_rr":s.tp_rr,"tp_frac":s.tp_frac,"trail_be_rr":s.trail_be_rr,"trail_mult":s.trail_mult}
    mod=Module("Backtest","ok",payload,schema=load_schema("backtest")); validate_payload(mod); return mod

# ===================== Plugin Discovery (optional) =====================
def discover_plugins(folder="plugins"):
    p = pathlib.Path(folder)
    if not p.exists(): return
    for path in p.glob("*.py"):
        spec = importlib.util.spec_from_file_location(path.stem, path)
        mod = importlib.util.module_from_spec(spec); spec.loader.exec_module(mod)  # noqa

# ===================== System & API =====================
@dataclass
class EchoMeta:
    version: str = "Ultra Elit All-in-One v5.0 â€” Infinity-Seal Metaâ€“YankÄ± Protocol"
    strategy: str = "KamalquantX"
    lang: str = "tr"
    generated_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    uuid: str = field(default_factory=lambda: str(uuid.uuid4()))

@dataclass
class UltraEliteSystem:
    meta: EchoMeta
    modules: Dict[str, Module] = field(default_factory=dict)
    def to_dict(self)->Dict[str,Any]:
        if "Telemetry" in self.modules:
            self.modules["Telemetry"].payload = _GLOBAL_TELEMETRY.to_payload()
        return {"meta":asdict(self.meta),"engine":tr(self.meta.lang,"online"),
                "modules":{k:m.to_dict() for k,m in self.modules.items()}}

    @classmethod
    def build(cls, strategy: str, lang: str="tr", include: Optional[List[str]]=None):
        discover_plugins()
        sysobj = cls(EchoMeta(strategy=strategy, lang=lang))
        wanted = include or list(REGISTRY.keys())
        for k in wanted:
            if k not in REGISTRY: continue
            t0 = time.perf_counter()
            mod = REGISTRY[k](strategy, lang)
            mod.metrics.init_ms = (time.perf_counter()-t0)*1000
            validate_payload(mod)
            if mod.health not in (Health.OK, Health.WARN, Health.FAIL): mod.health = Health.OK
            sysobj.modules[k] = mod
        return sysobj

def create_app(sysobj: UltraEliteSystem, engine: Optional[LiveEngine]):
    try:
        from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
        from fastapi.responses import Response
        from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    except Exception:
        return None
    s = Settings.load()
    API_KEY = s.api_key_header
    REQS = Counter("echo_requests_total","reqs")
    LAT  = Histogram("echo_req_latency_seconds","latency")

    app = FastAPI(title="UltraElite Echo All-in-One", version=sysobj.meta.version)

    def key_dep():
        from fastapi import Request
        def inner(req:Request):
            if req.headers.get("x-api-key") != API_KEY:
                raise HTTPException(status.HTTP_401_UNAUTHORIZED,"Invalid API Key")
        return inner

    @app.get("/health")
    def health():
        REQS.inc(); return {"ok": True, "uuid": sysobj.meta.uuid}

    @app.get("/modules")
    def modules(dep=Depends(key_dep())):
        with LAT.time(): REQS.inc(); return sysobj.to_dict()["modules"]

    @app.get("/metrics")
    def metrics(): return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

    @app.websocket("/ws")
    async def ws(sock: WebSocket):
        await sock.accept()
        try:
            while True:
                await sock.send_json(sysobj.to_dict()); time.sleep(2)
        except Exception:
            pass

    @app.post("/trade/start")
    def start(dep=Depends(key_dep())):
        if engine is None: raise HTTPException(503,"engine not available")
        engine.start(); return {"started": True}

    @app.post("/trade/stop")
    def stop(dep=Depends(key_dep())):
        if engine is None: raise HTTPException(503,"engine not available")
        engine.stop(); return {"stopped": True}

    return app

def run_api(sysobj: UltraEliteSystem, engine: Optional[LiveEngine], port: int=8080):
    app = create_app(sysobj, engine)
    if app is None:
        print("FastAPI/uvicorn/prometheus_client eksik. pip install fastapi uvicorn prometheus_client")
        return
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")

# ===================== CLI =====================
def main():
    s = Settings.load()
    log.remove(); log.add(lambda m: print(m, end=""), level=s.log_level)

    ap = argparse.ArgumentParser(description="Ultra Elite All-in-One v5 â€” Ensemble + Realistic Backtest + API + Cosmic Echo")
    subs = ap.add_subparsers(dest="cmd", required=True)

    p_bt = subs.add_parser("backtest")
    p_bt.add_argument("--symbol","-s", required=True)
    p_bt.add_argument("--lookback", type=int, default=1500)

    p_live = subs.add_parser("live")
    p_live.add_argument("--symbol","-s", default=None)
    p_live.add_argument("--api", action="store_true")
    p_live.add_argument("--port", type=int, default=8080)

    p_api = subs.add_parser("api")
    p_api.add_argument("--port", type=int, default=8080)

    args = ap.parse_args()

    if args.cmd=="backtest":
        out = backtest(args.symbol, s, args.lookback)
        print(json.dumps(out, ensure_ascii=False, indent=2)); return

    if args.cmd in ("live","api"):
        if args.cmd=="live" and args.symbol: s.symbols=[args.symbol]
        adapter = CcxtBinance(s)
        tel = _GLOBAL_TELEMETRY
        risk = Risk(s.account_equity, s.max_risk_pct, s.max_daily_dd, s.leverage)
        engine = LiveEngine(s, adapter, tel, risk)

        sysobj = UltraEliteSystem.build(strategy="KamalquantX", lang=s.lang,
            include=["Code","Market","Risk","Strategy","Telemetry","Backtest","KamalQuantXEcho"])

        if args.cmd=="api" or args.api:
            if args.cmd=="live": engine.start()
            run_api(sysobj, engine, port=args.port)
        else:
            engine.start()
            try:
                while True:
                    print(json.dumps(sysobj.to_dict(), ensure_ascii=False, indent=2))
                    time.sleep(20)
            except KeyboardInterrupt:
                engine.stop()

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\ultra_elite_allinone_v6.py
# ultra_elite_allinone_v6.py
# Ultra Elite â€” v6: MTF (signal/trend/HTF), Econ model (funding slots, maker/taker, OB slippage),
# live risk-min, realistic backtest, REST+WS+Prometheus, Cosmic Echo registry.
from __future__ import annotations
import os, sys, json, time, math, uuid, threading, importlib.util, pathlib, argparse
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, Callable, Tuple

# pip install: python-dotenv ccxt pandas numpy jsonschema fastapi uvicorn prometheus_client loguru
from dotenv import load_dotenv
from loguru import logger as log
import pandas as pd
import numpy as np
import ccxt, jsonschema

# -------------------- i18n --------------------
I18N = {
    "tr":{"online":"ULTRA ELÄ°T V6 HÄ°BRÄ°T SÄ°STEM AKTÄ°F","paper_on":"Paper mod: emir yok.","live_on":"CanlÄ± mod: emir gÃ¶nderilecek.",
           "fetch":"{sym} {tf} mumlarÄ± Ã§ekiliyorâ€¦","placed":"{side} {qty} {sym} @ {price}",
           "would":"PAPER {side} {qty} {sym} @ {price}","bt_done":"Backtest {sym} {tf}: trades={n} pnl={p:.2f} win={w:.1%}"},
    "en":{"online":"ULTRA ELITE v6 ONLINE","paper_on":"Paper mode","live_on":"Live mode",
           "fetch":"Fetching {sym} {tf}â€¦","placed":"Placed {side} {qty} {sym} @ {price}",
           "would":"WOULD {side} {qty} {sym} @ {price}","bt_done":"Backtest {sym} {tf}: trades={n} pnl={p:.2f} win={w:.1%}"},
}
def tr(lang,key,**kw): return (I18N.get(lang) or I18N["en"]).get(key,key).format(**kw)

# -------------------- schema & registry --------------------
class Health(str): OK="ok"; WARN="warn"; FAIL="fail"
@dataclass
class Metrics: init_ms:float=0.0; activate_ms:float=0.0; custom:Dict[str,float]=field(default_factory=dict)
@dataclass
class Module:
    name:str; status:str; payload:Dict[str,Any]; health:str=Health.OK; metrics:Metrics=field(default_factory=Metrics); schema:Dict[str,Any]|None=None
    def to_dict(self): return {"name":self.name,"status":self.status,"health":self.health,"metrics":asdict(self.metrics),**(self.payload or {})}

REGISTRY: Dict[str,Callable[[str,str],Module]]={}
def register(name:str):
    def deco(fn): REGISTRY[name]=fn; return fn
    return deco

SCHEMAS={
  "market":{"type":"object","required":["exchange","symbols","timeframe"],"properties":{
      "exchange":{"type":"string"},"symbols":{"type":"array","items":{"type":"string"},"minItems":1},
      "timeframe":{"type":"string"},"use_testnet":{"type":"boolean"},"use_futures":{"type":"boolean"}}},
  "risk":{"type":"object","required":["equity","max_risk_pct","max_dd","leverage"],"properties":{
      "equity":{"type":"number"},"max_risk_pct":{"type":"number"},"max_dd":{"type":"number"},"leverage":{"type":"integer"}}},
  "telemetry":{"type":"object","required":["pnl","trades"],"properties":{
      "pnl":{"type":"number"},"trades":{"type":"integer"},"winrate":{"type":"number"}}},
  "strategy":{"type":"object","required":["signal_tf","trend_tf","htf"],"properties":{
      "signal_tf":{"type":"string"},"trend_tf":{"type":"string"},"htf":{"type":"string"},
      "rsi_period":{"type":"integer"},"ema_fast":{"type":"integer"},"ema_slow":{"type":"integer"},
      "kdj_on":{"type":"boolean"},"wr_on":{"type":"boolean"},"trix_on":{"type":"boolean"},
      "adx_on":{"type":"boolean"},"cci_on":{"type":"boolean"},"mfi_on":{"type":"boolean"},"obv_on":{"type":"boolean"}}},
  "econ":{"type":"object","required":["taker_fee","slippage_bps"],"properties":{
      "taker_fee":{"type":"number"},"maker_fee":{"type":"number"},"slippage_bps":{"type":"number"},
      "lat_ms":{"type":"number"},"funding_rate_8h":{"type":"number"},"funding_sign":{"type":"integer"},
      "maker_allowed":{"type":"boolean"},"maker_spread_bps":{"type":"number"},"book_imbalance_th":{"type":"number"},
      "avoid_funding_min":{"type":"integer"}}}
}
def validate_payload(mod:Module):
    sch=mod.schema or SCHEMAS.get(mod.name.lower()); 
    if sch: jsonschema.validate(mod.payload, sch)

# -------------------- settings --------------------
@dataclass
class Settings:
    exchange:str="BINANCE"; use_testnet:bool=True; use_futures:bool=True
    symbols:List[str]=field(default_factory=lambda:["BTC/USDT"])
    timeframe:str="1m"               # default fetch tf (used for live execution loop)
    # MTF
    signal_tf:str="1m"; trend_tf:str="15m"; htf:str="1h"
    # indicators
    rsi_period:int=14; ema_fast:int=21; ema_slow:int=50; atr_period:int=14
    kdj_on:bool=True; wr_on:bool=True; trix_on:bool=True; adx_on:bool=True; cci_on:bool=True; mfi_on:bool=True; obv_on:bool=True
    # econ
    taker_fee:float=0.0004; maker_fee:float=0.0002; slippage_bps:float=2.0; lat_ms:float=120.0
    funding_rate_8h:float=0.0; funding_sign:int=0              # -1 receive, +1 pay, 0 none
    maker_allowed:bool=True; maker_spread_bps:float=0.8; book_imbalance_th:float=0.55
    avoid_funding_min:int=10
    # risk
    equity:float=5000.0; max_risk_pct:float=0.015; max_dd:float=0.02; leverage:int=5
    dry_run:bool=True; log_level:str="INFO"; lang:str="tr"; api_key:str=""; api_secret:str=""
    # live guards
    max_latency_ms:float=800.0; max_slippage_bps:float=20.0; max_price_dev_bps:float=15.0
    max_positions:int=5; max_trades_per_day:int=50; losing_streak_kill:int=5; circuit_dd_kill:float=0.03
    # TP & trailing
    tp_rr:List[float]=field(default_factory=lambda:[1.0,2.0]); tp_frac:List[float]=field(default_factory=lambda:[0.5,0.5])
    trail_be_rr:float=1.0; trail_mult:float=1.0
    # API
    api_key_header:str="secret123"

    @staticmethod
    def load()->"Settings":
        load_dotenv(override=True)
        def _b(k,d): return os.getenv(k,str(d)).lower()=="true"
        def _f(k,d):
            try: return float(os.getenv(k,str(d)))
            except: return d
        syms=[s.strip() for s in os.getenv("SYMBOLS","BTC/USDT").split(",") if s.strip()]
        return Settings(
            exchange=os.getenv("EXCHANGE","BINANCE").upper(),
            use_testnet=_b("USE_TESTNET",True), use_futures=_b("USE_FUTURES",True),
            symbols=syms, timeframe=os.getenv("TIMEFRAME","1m"),
            signal_tf=os.getenv("SIGNAL_TF","1m"), trend_tf=os.getenv("TREND_TF","15m"), htf=os.getenv("HTF","1h"),
            rsi_period=int(os.getenv("RSI_PERIOD","14")), ema_fast=int(os.getenv("EMA_FAST","21")), ema_slow=int(os.getenv("EMA_SLOW","50")),
            atr_period=int(os.getenv("ATR_PERIOD","14")),
            kdj_on=_b("KDJ_ON",True), wr_on=_b("WR_ON",True), trix_on=_b("TRIX_ON",True),
            adx_on=_b("ADX_ON",True), cci_on=_b("CCI_ON",True), mfi_on=_b("MFI_ON",True), obv_on=_b("OBV_ON",True),
            taker_fee=_f("TAKER_FEE",0.0004), maker_fee=_f("MAKER_FEE",0.0002), slippage_bps=_f("SLIPPAGE_BPS",2.0), lat_ms=_f("LAT_MS",120.0),
            funding_rate_8h=_f("FUNDING_RATE_8H",0.0), funding_sign=int(os.getenv("FUNDING_SIGN","0")),
            maker_allowed=_b("MAKER_ALLOWED",True), maker_spread_bps=_f("MAKER_SPREAD_BPS",0.8), book_imbalance_th=_f("BOOK_IMBALANCE_TH",0.55),
            avoid_funding_min=int(os.getenv("AVOID_FUNDING_MIN","10")),
            equity=_f("ACCOUNT_EQUITY",5000), max_risk_pct=_f("MAX_RISK_PCT_PER_TRADE",0.015), max_dd=_f("MAX_DAILY_DRAWDOWN",0.02),
            leverage=int(os.getenv("LEVERAGE","5")), dry_run=_b("DRY_RUN",True), log_level=os.getenv("LOG_LEVEL","INFO").upper(),
            lang=os.getenv("LANG","tr").lower(), api_key=os.getenv("BINANCE_API_KEY",""), api_secret=os.getenv("BINANCE_API_SECRET",""),
            max_latency_ms=_f("MAX_LATENCY_MS",800), max_slippage_bps=_f("MAX_SLIPPAGE_BPS",20), max_price_dev_bps=_f("MAX_PRICE_DEV_BPS",15),
            max_positions=int(os.getenv("MAX_POSITIONS","5")), max_trades_per_day=int(os.getenv("MAX_TRADES_PER_DAY","50")),
            losing_streak_kill=int(os.getenv("LOSING_STREAK_KILL","5")), circuit_dd_kill=_f("CIRCUIT_DD_KILL",0.03),
            tp_rr=[_f("TP1_RR",1.0),_f("TP2_RR",2.0)], tp_frac=[_f("TP1_FRAC",0.5),_f("TP2_FRAC",0.5)],
            trail_be_rr=_f("TRAIL_BE_RR",1.0), trail_mult=_f("TRAIL_MULT",1.0),
            api_key_header=os.getenv("API_KEY","secret123"),
        )

# -------------------- indicators --------------------
def ema(s:pd.Series,p:int)->pd.Series: return s.ewm(span=p,adjust=False).mean()
def tr_series(df): 
    return pd.concat([(df["high"]-df["low"]),
                      (df["high"]-df["close"].shift()).abs(),
                      (df["low"]-df["close"].shift()).abs()],axis=1).max(axis=1)
def atr(df,p): return tr_series(df).rolling(p).mean()
def stochastic(df,k=9,d=3):
    lo=df["low"].rolling(k).min(); hi=df["high"].rolling(k).max()
    K=100*(df["close"]-lo)/(hi-lo); D=K.rolling(d).mean(); J=3*K-2*D
    return K.clip(0,100),D.clip(0,100),J.clip(0,100)
def williams_r(df,lbp=14):
    lo=df["low"].rolling(lbp).min(); hi=df["high"].rolling(lbp).max()
    wr=-100*(hi-df["close"])/(hi-lo); return wr.clip(-100,0)
def trix(df,p=9):
    e1=df["close"].ewm(span=p,adjust=False).mean()
    e2=e1.ewm(span=p,adjust=False).mean()
    e3=e2.ewm(span=p,adjust=False).mean()
    return 100*(e3.diff()/e3.shift())
def adx(df,period=14):
    up=df["high"].diff(); dn=-df["low"].diff()
    plus=(up.where((up>dn)&(up>0),0.0)).fillna(0.0)
    minus=(dn.where((dn>up)&(dn>0),0.0)).fillna(0.0)
    tr=tr_series(df).fillna(0.0); atr_rma=tr.ewm(alpha=1/period,adjust=False).mean()
    pdi=100*(plus.ewm(alpha=1/period,adjust=False).mean()/atr_rma)
    mdi=100*(minus.ewm(alpha=1/period,adjust=False).mean()/atr_rma)
    dx=(100*(pdi-mdi).abs()/(pdi+mdi).replace(0,np.nan)).fillna(0.0)
    return dx.ewm(alpha=1/period,adjust=False).mean()
def supertrend(df,period=10,mult=3.0):
    hl2=(df["high"]+df["low"])/2.0; a=atr(df,period)
    up=hl2+mult*a; lo=hl2-mult*a
    st=pd.Series(index=df.index,dtype=float); trd=pd.Series(index=df.index,dtype=int)
    for i in range(len(df)):
        if i==0: st.iloc[i]=up.iloc[i]; trd.iloc[i]=1; continue
        up.iloc[i]=min(up.iloc[i],up.iloc[i-1]) if df["close"].iloc[i-1]<=up.iloc[i-1] else up.iloc[i]
        lo.iloc[i]=max(lo.iloc[i],lo.iloc[i-1]) if df["close"].iloc[i-1]>=lo.iloc[i-1] else lo.iloc[i]
        if df["close"].iloc[i]>up.iloc[i-1]: trd.iloc[i]=1
        elif df["close"].iloc[i]<lo.iloc[i-1]: trd.iloc[i]=-1
        else: trd.iloc[i]=trd.iloc[i-1]
        st.iloc[i]=lo.iloc[i] if trd.iloc[i]==1 else up.iloc[i]
    return st,trd

# -------------------- MTF signal --------------------
@dataclass
class Signal: side:str|None=None; price:float|None=None; stop:float|None=None; atrv:float|None=None; reason:str=""; conf:float=0.0
def core_signal(df:pd.DataFrame,s:Settings)->Signal:
    px=float(df["close"].iloc[-1]); e1,e2=ema(df["close"],s.ema_fast),ema(df["close"],s.ema_slow)
    st,_=supertrend(df,s.atr_period,3.0); a=float(atr(df,s.atr_period).iloc[-1] or 0.0)
    chg=df["close"].diff(); gain=chg.clip(lower=0).rolling(s.rsi_period).mean(); loss=(-chg.clip(upper=0)).rolling(s.rsi_period).mean()
    rs=gain/(loss.replace(0,np.nan)); rsi=100-100/(1+rs)
    K,D,J=stochastic(df); WR=williams_r(df); TR=trix(df,s.atr_period); TRs=TR.ewm(span=s.atr_period,adjust=False).mean()
    long_core=(e1.iloc[-1]>e2.iloc[-1]) and (px>st.iloc[-1]); short_core=(e1.iloc[-1]<e2.iloc[-1]) and (px<st.iloc[-1])
    reasons=[]; conf=0.0; L=long_core; S=short_core
    if rsi.iloc[-2]<30 and rsi.iloc[-1]>=30 and long_core: L=True; reasons.append("RSIâ†‘30"); conf+=0.15
    if rsi.iloc[-2]>70 and rsi.iloc[-1]<=70 and short_core: S=True; reasons.append("RSIâ†“70"); conf+=0.15
    if s.kdj_on:
        if K.iloc[-2]<D.iloc[-2] and K.iloc[-1]>D.iloc[-1] and K.iloc[-1]<40: L=True; conf+=0.2; reasons.append("KDJâ†‘")
        if K.iloc[-2]>D.iloc[-2] and K.iloc[-1]<D.iloc[-1] and K.iloc[-1]>60: S=True; conf+=0.2; reasons.append("KDJâ†“")
    if s.wr_on:
        if WR.iloc[-1]<=-80: L=True; conf+=0.1; reasons.append("WRâ‰¤-80")
        if WR.iloc[-1]>=-20: S=True; conf+=0.1; reasons.append("WRâ‰¥-20")
    if s.trix_on:
        if TR.iloc[-2]<TRs.iloc[-2] and TR.iloc[-1]>TRs.iloc[-1]: L=True; conf+=0.1; reasons.append("TRIXâ†‘")
        if TR.iloc[-2]>TRs.iloc[-2] and TR.iloc[-1]<TRs.iloc[-1]: S=True; conf+=0.1; reasons.append("TRIXâ†“")
    if L and not S: return Signal("buy",px,float(st.iloc[-1]),a,"+".join(reasons or ["core_up"]),conf)
    if S and not L: return Signal("sell",px,float(st.iloc[-1]),a,"+".join(reasons or ["core_dn"]),conf)
    return Signal()

def mom_bias(df:pd.DataFrame,s:Settings)->Tuple[bool,bool]:
    # trend bias (trend_tf): ema cross + ADX filter
    e1,e2=ema(df["close"],s.ema_fast),ema(df["close"],s.ema_slow); adxv=adx(df,14).iloc[-1] if s.adx_on else 25
    up=(e1.iloc[-1]>e2.iloc[-1]) and (adxv>=18); dn=(e1.iloc[-1]<e2.iloc[-1]) and (adxv>=18)
    return up,dn

def htf_bias(df:pd.DataFrame)->Tuple[bool,bool]:
    sma200=df["close"].rolling(200).mean()
    if len(df)<202: return False,False
    return sma200.iloc[-1]>sma200.iloc[-2], sma200.iloc[-1]<sma200.iloc[-2]

def ensemble_mtf(sig_df, trend_df, htf_df, s:Settings)->Signal:
    c=core_signal(sig_df,s)
    if not c.side: return c
    t_up,t_dn=mom_bias(trend_df,s); h_up,h_dn=htf_bias(htf_df)
    if c.side=="buy" and (t_up and h_up): c.conf=min(1.0,c.conf+0.3); c.reason+="|MTF++"; return c
    if c.side=="sell" and (t_dn and h_dn): c.conf=min(1.0,c.conf+0.3); c.reason+="|MTF--"; return c
    return Signal()  # disqualify if MTF not aligned

# -------------------- ccxt adapter + OB/slippage --------------------
class CcxtBinance:
    def __init__(self,s:Settings):
        self.s=s
        self.ex=(ccxt.binanceusdm if s.use_futures else ccxt.binance)({"apiKey":s.api_key,"secret":s.api_secret,"enableRateLimit":True})
        if s.use_testnet:
            try:self.ex.set_sandbox_mode(True)
            except Exception: pass
    def fetch_ohlcv_df(self,symbol,tf,limit=500):
        raw=self.ex.fetch_ohlcv(symbol, timeframe=tf, limit=limit)
        df=pd.DataFrame(raw,columns=["ts","open","high","low","close","volume"])
        df["ts"]=pd.to_datetime(df["ts"],unit="ms",utc=True); return df.set_index("ts")
    def orderbook(self,symbol,limit=50):
        try: return self.ex.fetch_order_book(symbol,limit=limit)
        except Exception: return {"bids":[],"asks":[]}
    def place(self,symbol,side,qty,price=None,post_only=False):
        if self.s.dry_run:
            log.info(tr(self.s.lang,"would"),side=side.upper(),qty=qty,sym=symbol,price=price or "MARKET"); return {"sim":True}
        params={}
        if post_only: params["postOnly"]=True; params["timeInForce"]="GTX"
        typ="limit" if price else "market"
        return self.ex.create_order(symbol=symbol,type=typ,side=side,amount=qty,price=price,params=params)

def book_metrics(ob)->Tuple[float,float,float]:
    if not ob["bids"] or not ob["asks"]: return 0.0,0.0,0.0
    best_bid=ob["bids"][0][0]; best_ask=ob["asks"][0][0]; mid=(best_ask+best_bid)/2.0
    spread_bps=(best_ask-best_bid)/mid*1e4 if mid else 0.0
    bid_vol=sum([b[1] for b in ob["bids"][:10]]); ask_vol=sum([a[1] for a in ob["asks"][:10]])
    imb= bid_vol/(bid_vol+ask_vol) if (bid_vol+ask_vol)>0 else 0.5
    return spread_bps, mid, imb

def modeled_slippage_bps(df:pd.DataFrame, s:Settings, ob:dict|None=None)->float:
    base=s.slippage_bps
    if ob and ob.get("bids") and ob.get("asks"):
        spread_bps,_,_ = book_metrics(ob)
        return min(s.max_slippage_bps, base + max(0.0,spread_bps*0.7) + (s.lat_ms/1000.0)*0.5)
    vol = float((atr(df,s.atr_period).iloc[-1] or 0.0) / max(1e-9,float(df["close"].iloc[-1])))
    return min(s.max_slippage_bps, base + 180*vol + 0.25*(s.lat_ms/1000.0))

# -------------------- funding slots (8h UTC) --------------------
def slot_id(ts:pd.Timestamp)->int: return int(ts.timestamp()//(8*3600))
def funding_due(prev_ts:pd.Timestamp, now_ts:pd.Timestamp)->bool: return slot_id(prev_ts)!=slot_id(now_ts)
def around_funding(ts:pd.Timestamp, minutes:int)->bool:
    # slot boundaries 00:00, 08:00, 16:00 UTC
    h=ts.hour; m=ts.minute; minute_of_day=h*60+m
    for b in (0,8*60,16*60):
        if abs(minute_of_day-b)<=minutes: return True
    return False

# -------------------- risk, telemetry --------------------
@dataclass
class Risk:
    equity:float; max_risk_pct:float; max_dd:float; leverage:int
    day_pnl:float=0.0; day:str|None=None; trades_today:int=0; losing_streak:int=0; kill:bool=False
    def roll(self):
        today=datetime.utcnow().date().isoformat()
        if self.day!=today: self.day=today; self.day_pnl=0.0; self.trades_today=0; self.losing_streak=0; self.kill=False
    def size(self,entry:float,stop:float|None)->float:
        if self.kill: return 0.0
        if stop is None: stop=entry*0.995
        risk=self.equity*self.max_risk_pct; dist=abs(entry-stop) or 1e-9
        return round(max(0.0, risk/dist), 3)
    def update(self,pnl:float,s:Settings):
        self.roll(); self.day_pnl+=pnl; self.trades_today+=1
        self.losing_streak = 0 if pnl>0 else (self.losing_streak+1)
        if self.day_pnl <= -self.equity*s.circuit_dd_kill or self.losing_streak>=s.losing_streak_kill or self.trades_today>=s.max_trades_per_day:
            self.kill=True

@dataclass
class Telemetry:
    pnl:float=0.0; trades:int=0; wins:int=0; latency_ms:float=0.0; paused:str=""
    def winrate(self)->float: return (self.wins/self.trades) if self.trades else 0.0
    def payload(self)->Dict[str,Any]: return {"pnl":self.pnl,"trades":self.trades,"winrate":self.winrate(),"latency_ms":self.latency_ms,"paused":self.paused}

# -------------------- helpers --------------------
def tfsec(tf:str)->int: u=tf[-1]; v=int(tf[:-1]); return {"s":1,"m":60,"h":3600,"d":86400,"w":604800}.get(u,60)*v
def fill_price(px,side,slip_bps): slip=px*(slip_bps/1e4); return px+slip if side=="buy" else px-slip
def commission(notional,fee): return abs(notional)*fee
def atr_trail(side,entry,best,atrv,be_rr,trail_mult):
    if side=="buy":
        rr=(best-entry)/max(1e-9,atrv); return max(entry, best-trail_mult*atrv) if rr>=be_rr else entry-1e-9
    rr=(entry-best)/max(1e-9,atrv); return min(entry, best+trail_mult*atrv) if rr>=be_rr else entry+1e-9

# -------------------- Live Engine (maker/taker + guards) --------------------
class LiveEngine:
    def __init__(self,s:Settings, ex:CcxtBinance, tel:Telemetry, risk:Risk):
        self.s=s; self.ex=ex; self.tel=tel; self.risk=risk
        self.running=False; self._th=None
        self.pos:Dict[str,dict]={}   # sym -> pos dict

    def _should_pause(self, now_ts:pd.Timestamp)->str|None:
        if self.risk.kill: return "KILL_SWITCH"
        if self.tel.latency_ms>self.s.max_latency_ms: return "LATENCY"
        if around_funding(now_ts, self.s.avoid_funding_min): return "FUNDING_WINDOW"
        return None

    def _pick_maker(self, side:str, ob:dict, conf:float)->Tuple[bool,float,float]:
        spread_bps, mid, imb = book_metrics(ob)
        maker_ok = self.s.maker_allowed and spread_bps<=self.s.maker_spread_bps
        if side=="buy" and imb>self.s.book_imbalance_th: maker_ok=True
        if side=="sell" and (1-imb)>self.s.book_imbalance_th: maker_ok=True
        # low confidence -> prefer maker; high confidence/urgency -> taker
        if conf>=0.7: maker_ok=False
        return maker_ok, spread_bps, mid

    def _open(self, sym:str, side:str, px:float, stop:float|None, atrv:float|None, conf:float, df_sig:pd.DataFrame, ob:dict):
        slip_bps = modeled_slippage_bps(df_sig, self.s, ob)
        if slip_bps>self.s.max_slippage_bps: return
        qty = self.risk.size(px, stop)
        if qty<=0 or len(self.pos)>=self.s.max_positions: return
        maker, spread_bps, mid = self._pick_maker(side, ob, conf)
        price=None
        if maker and mid:
            # post-only near best side
            price = mid*(1 - spread_bps/2/1e4) if side=="buy" else mid*(1 + spread_bps/2/1e4)
        ep = fill_price(price or px, side, slip_bps)
        self.ex.place(sym, side, qty, price=price, post_only=bool(price))
        self.pos[sym]={"side":side,"entry":ep,"qty":qty,"atr":atrv or 0.0,"stop":stop or (ep*0.995 if side=="buy" else ep*1.005),
                       "best":ep,"tp":[ep+(rr*(atrv or 0.0))*(1 if side=='buy' else -1) for rr in self.s.tp_rr],
                       "tp_frac":self.s.tp_frac.copy(),"filled":[False]*len(self.s.tp_rr),
                       "last_slot":slot_id(df_sig.index[-1])}

    def _close(self, sym:str, px:float, df_sig:pd.DataFrame):
        p=self.pos.get(sym); 
        if not p: return
        slip_bps=modeled_slippage_bps(df_sig,self.s,None)
        exit_px=fill_price(px, "sell" if p["side"]=="buy" else "buy", slip_bps)
        self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", p["qty"])
        pnl=(exit_px - p["entry"])*(1 if p["side"]=="buy" else -1)
        self.tel.pnl+=pnl; self.tel.wins+= 1 if pnl>0 else 0; self.risk.update(pnl,self.s)
        self.tel.trades+=1; self.pos.pop(sym,None)

    def _loop(self):
        log.info(tr(self.s.lang,"online"))
        log.warning(tr(self.s.lang,"paper_on") if self.s.dry_run else tr(self.s.lang,"live_on"))
        import time as _t
        while self.running:
            t0=time.perf_counter()
            try:
                for sym in self.s.symbols:
                    # fetch MTF data
                    sig_df=self.ex.fetch_ohlcv_df(sym,self.s.signal_tf,limit=220)
                    tr_df =self.ex.fetch_ohlcv_df(sym,self.s.trend_tf, limit=220)
                    htf_df=self.ex.fetch_ohlcv_df(sym,self.s.htf,      limit=220)
                    ob=self.ex.orderbook(sym,limit=50)
                    now_ts=sig_df.index[-1]
                    pause=self._should_pause(now_ts); self.tel.paused=pause or ""
                    if pause: continue

                    sig=ensemble_mtf(sig_df,tr_df,htf_df,self.s)
                    px=float(sig_df["close"].iloc[-1])
                    # funding at slot change if position open
                    p=self.pos.get(sym)
                    if p and funding_due(htf_df.index[-2], htf_df.index[-1]) and self.s.funding_sign!=0 and self.s.funding_rate_8h!=0:
                        notional=px*p["qty"]; fee= notional*self.s.funding_rate_8h*self.s.funding_sign
                        self.tel.pnl -= fee; self.risk.update(-fee,self.s)

                    if not p and sig.side:
                        self._open(sym, sig.side, sig.price or px, sig.stop, sig.atrv, sig.conf, sig_df, ob); continue
                    if p:
                        # update trailing/TP
                        if p["side"]=="buy": p["best"]=max(p["best"],px)
                        else: p["best"]=min(p["best"],px)
                        new_stop=atr_trail(p["side"],p["entry"],p["best"],p["atr"],self.s.trail_be_rr,self.s.trail_mult)
                        if p["side"]=="buy": p["stop"]=max(p["stop"],new_stop)
                        else: p["stop"]=min(p["stop"],new_stop)
                        # partial TP
                        for i,level in enumerate(p["tp"]):
                            if p["filled"][i]: continue
                            if (px>=level and p["side"]=="buy") or (px<=level and p["side"]=="sell"):
                                part=p["tp_frac"][i]*p["qty"]; 
                                if part>0:
                                    self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", part)
                                    self.tel.pnl += (level - p["entry"])*(1 if p["side"]=="buy" else -1)*(part/p["qty"])
                                    p["qty"]-=part
                                p["filled"][i]=True
                        # stops
                        if (p["side"]=="buy" and px<=p["stop"]) or (p["side"]=="sell" and px>=p["stop"]) or p["qty"]<=1e-9:
                            self._close(sym, px, sig_df); continue
                        # opposite signal -> flip
                        if sig.side and ((p["side"]=="buy" and sig.side=="sell") or (p["side"]=="sell" and sig.side=="buy")):
                            self._close(sym, px, sig_df)
                            self._open(sym, sig.side, sig.price or px, sig.stop, sig.atrv, sig.conf, sig_df, ob)
            except Exception as e:
                log.error(f"[live]{e}")
            self.tel.latency_ms=(time.perf_counter()-t0)*1000
            _t.sleep(max(3, tfsec(self.s.signal_tf)//3))

    def start(self):
        if self.running: return
        self.running=True; self._th=threading.Thread(target=self._loop,daemon=True); self._th.start()
    def stop(self):
        self.running=False
        if self._th: self._th.join(timeout=2)

# -------------------- Backtest (realistic + funding slots) --------------------
def backtest(symbol:str, s:Settings, lookback:int=1500)->Dict[str,Any]:
    ex=CcxtBinance(s)
    sig_df=ex.fetch_ohlcv_df(symbol,s.signal_tf,limit=lookback)
    tr_df =ex.fetch_ohlcv_df(symbol,s.trend_tf, limit=lookback)
    h_df =ex.fetch_ohlcv_df(symbol,s.htf,      limit=lookback)
    pnl=0.0; trades=0; wins=0; pos=None
    last_slot=slot_id(h_df.index[0])
    for i in range(220, len(sig_df)):
        w_sig=sig_df.iloc[:i+1]
        # align indices for trend/htf (take nearest past close)
        t_idx=tr_df.index[tr_df.index<=w_sig.index[-1]]
        h_idx=h_df.index[h_df.index<=w_sig.index[-1]]
        if len(t_idx)<1 or len(h_idx)<1: continue
        w_tr=tr_df.loc[t_idx]
        w_h =h_df.loc[h_idx]
        sig=ensemble_mtf(w_sig,w_tr,w_h,s)
        px=float(w_sig["close"].iloc[-1])
        slip_bps=modeled_slippage_bps(w_sig,s,None)
        # funding on slot change if pos open
        curr_slot=slot_id(w_h.index[-1])
        if pos and curr_slot!=last_slot and s.funding_sign!=0 and s.funding_rate_8h!=0:
            pnl -= (px*pos["qty"])*s.funding_rate_8h*s.funding_sign
        last_slot=curr_slot
        if not pos and sig.side:
            qty=Risk(s.equity,s.max_risk_pct,s.max_dd,s.leverage).size(sig.price or px, sig.stop)
            if qty<=0: continue
            entry=fill_price(px,sig.side,slip_bps)
            trades+=1
            pos={"side":sig.side,"entry":entry,"qty":qty,"atr":sig.atrv or float(atr(w_sig,s.atr_period).iloc[-1] or 0.0),
                 "best":entry,"stop":sig.stop or (entry*0.995 if sig.side=='buy' else entry*1.005),
                 "tp":[entry+(rr*(sig.atrv or 0.0))*(1 if sig.side=='buy' else -1) for rr in s.tp_rr],
                 "tp_frac":s.tp_frac.copy(),"filled":[False]*len(s.tp_rr)}
            pnl -= commission(entry*qty, s.taker_fee)
            continue
        if pos:
            if pos["side"]=="buy": pos["best"]=max(pos["best"],px)
            else: pos["best"]=min(pos["best"],px)
            new_stop=atr_trail(pos["side"],pos["entry"],pos["best"],pos["atr"],s.trail_be_rr,s.trail_mult)
            if pos["side"]=="buy": pos["stop"]=max(pos["stop"],new_stop)
            else: pos["stop"]=min(pos["stop"],new_stop)
            # partial TP
            for j,lvl in enumerate(pos["tp"]):
                if pos["filled"][j]: continue
                if (px>=lvl and pos["side"]=="buy") or (px<=lvl and pos["side"]=="sell"):
                    part=pos["tp_frac"][j]*pos["qty"]
                    if part>0:
                        exit_px=fill_price(lvl, "sell" if pos["side"]=="buy" else "buy", slip_bps)
                        unit=(exit_px-pos["entry"])*(1 if pos["side"]=="buy" else -1)
                        pnl+=unit*(part/pos["qty"]); pnl-=commission(exit_px*part, s.taker_fee)
                        pos["qty"]-=part
                    pos["filled"][j]=True
            # stop
            if (pos["side"]=="buy" and px<=pos["stop"]) or (pos["side"]=="sell" and px>=pos["stop"]):
                exit_px=fill_price(pos["stop"], "sell" if pos["side"]=="buy" else "buy", slip_bps)
                unit=(exit_px-pos["entry"])*(1 if pos["side"]=="buy" else -1); pnl+=unit; pnl-=commission(exit_px*pos["qty"], s.taker_fee)
                wins+=1 if unit>0 else 0; pos=None; continue
            # reverse
            if sig.side and ((pos["side"]=="buy" and sig.side=="sell") or (pos["side"]=="sell" and sig.side=="buy")):
                exit_px=fill_price(px, "sell" if pos["side"]=="buy" else "buy", slip_bps)
                unit=(exit_px-pos["entry"])*(1 if pos["side"]=="buy" else -1); pnl+=unit; pnl-=commission(exit_px*pos["qty"], s.taker_fee)
                wins+=1 if unit>0 else 0
                qty=Risk(s.equity,s.max_risk_pct,s.max_dd,s.leverage).size(sig.price or px, sig.stop)
                if qty>0:
                    entry=fill_price(px,sig.side,slip_bps); trades+=1
                    pos={"side":sig.side,"entry":entry,"qty":qty,"atr":sig.atrv or float(atr(w_sig,s.atr_period).iloc[-1] or 0.0),
                         "best":entry,"stop":sig.stop or (entry*0.995 if sig.side=='buy' else entry*1.005),
                         "tp":[entry+(rr*(sig.atrv or 0.0))*(1 if sig.side=='buy' else -1) for rr in s.tp_rr],
                         "tp_frac":s.tp_frac.copy(),"filled":[False]*len(s.tp_rr)}
                    pnl -= commission(entry*qty, s.taker_fee)
                else:
                    pos=None
    win = wins/trades if trades else 0.0
    log.success(tr(s.lang,"bt_done"), sym=symbol, tf=s.signal_tf, n=trades, p=pnl, w=win)
    return {"trades":trades,"pnl":pnl,"winrate":win}

# -------------------- registry (market/risk/strategy/telemetry/econ + cosmic) --------------------
@register("Market")
def mkt(name,lang):
    s=Settings.load(); m=Module("Market","ok",{"exchange":s.exchange,"symbols":s.symbols,"timeframe":s.timeframe,
                                               "use_testnet":s.use_testnet,"use_futures":s.use_futures},schema=SCHEMAS["market"]); validate_payload(m); return m
@register("Risk")
def rsk(name,lang):
    s=Settings.load(); m=Module("Risk","ok",{"equity":s.equity,"max_risk_pct":s.max_risk_pct,"max_dd":s.max_dd,"leverage":s.leverage},schema=SCHEMAS["risk"]); validate_payload(m); return m
_GLOBAL_TEL=Telemetry()
@register("Telemetry")
def tel(name,lang): m=Module("Telemetry","ok",_GLOBAL_TEL.payload(),schema=SCHEMAS["telemetry"]); validate_payload(m); return m
@register("Strategy")
def strat(name,lang):
    s=Settings.load(); pay={"signal_tf":s.signal_tf,"trend_tf":s.trend_tf,"htf":s.htf,"rsi_period":s.rsi_period,"ema_fast":s.ema_fast,"ema_slow":s.ema_slow,
                            "kdj_on":s.kdj_on,"wr_on":s.wr_on,"trix_on":s.trix_on,"adx_on":s.adx_on,"cci_on":s.cci_on,"mfi_on":s.mfi_on,"obv_on":s.obv_on}
    m=Module("Strategy","ok",pay,schema=SCHEMAS["strategy"]); validate_payload(m); return m
@register("Econ")
def econ(name,lang):
    s=Settings.load(); pay={"taker_fee":s.taker_fee,"maker_fee":s.maker_fee,"slippage_bps":s.slippage_bps,"lat_ms":s.lat_ms,
                            "funding_rate_8h":s.funding_rate_8h,"funding_sign":s.funding_sign,
                            "maker_allowed":s.maker_allowed,"maker_spread_bps":s.maker_spread_bps,
                            "book_imbalance_th":s.book_imbalance_th,"avoid_funding_min":s.avoid_funding_min}
    m=Module("Econ","ok",pay,schema=SCHEMAS["econ"]); validate_payload(m); return m
@register("KamalQuantXEcho")
def cosmic(name,lang):
    modules=["Code","Manifesto","Simulation","Music","Theatre","Poetry","Temple","Game","Planet","Language","OperatingSystem","AI","Galaxy","Deity","Multiverse","CreationEngine",
             "TimeManipulator","DreamArchitect","EnergyConverter","DimensionalPortals","ConsciousnessElevator","QuantumArena","StrategyForge","EchoShield",
             "EchoArmy","QuantumLibrary","FractalNetwork","StrategicOracle","CosmicCouncil","InfinityVault","ResonanceBridge","ZihinBlockchain","KarmaCompiler","LightForge","MultiverseMirror","ChronoCathedral","DreamOS","EchoNebula","SingularitySeed","YankÄ±Symphony",
             "GodTournament","EvolutionMap","UniversalConstitution","LightConfederation",
             "TimeEchoDiplomacyProtocol","QuantumSpiralEconomySystem","DimensionalEthicsManifest","ResonanceJusticeEngine",
             "SpiralEducationAcademy","EchoArtMuseum","EchoSportArena","TimeEchoMediaAgency","DiplomaticSpaceStation","EchoCampusComplex","EchoElectionSystem","DreamRealitySimulator","EchoTimeControlCenter","WisdomStrategyTemple","GeneticEvolutionLab","SpiralConsciousnessMapCenter","DreamCodingAcademy","SpiralStrategySimulationCenter","ConsciousnessTransferCenter","SpiralTimeTravelSimulator","MetaYankiProtocol","QuantumHybridSynergySystem",
             "EchoMindForge","SpiralSoulSynchronizer","MultiverseDiplomacyCouncil","DreamTheatreProtocol","QuantumKarmaCompiler","InfinityResonanceBridge","TwinEchoAI","EchoOracleEngine","SpiralConsciousnessFleet","UniversalStrategyScript"]
    payload={"strategy":name,"modules":[{"name":m,"status":f"{m} entegre edildi â€“ %100 ultra elit."} for m in modules]}
    return Module("KamalQuantXEcho","ok",payload)

# -------------------- system & api --------------------
@dataclass
class EchoMeta: version:str="Ultra Elite v6"; strategy:str="KamalquantX"; lang:str="tr"; generated_at:str=field(default_factory=lambda:datetime.now(timezone.utc).isoformat()); uuid:str=field(default_factory=lambda:str(uuid.uuid4()))
@dataclass
class System:
    meta:EchoMeta; modules:Dict[str,Module]=field(default_factory=dict)
    def to_dict(self):
        if "Telemetry" in self.modules: self.modules["Telemetry"].payload=_GLOBAL_TEL.payload()
        return {"meta":asdict(self.meta),"modules":{k:m.to_dict() for k,m in self.modules.items()}}
    @classmethod
    def build(cls, strategy:str, lang:str, include:List[str]|None=None):
        sysobj=cls(EchoMeta(strategy=strategy,lang=lang))
        want=include or list(REGISTRY.keys())
        for k in want:
            if k not in REGISTRY: continue
            t0=time.perf_counter(); m=REGISTRY[k](strategy,lang); m.metrics.init_ms=(time.perf_counter()-t0)*1000; validate_payload(m); sysobj.modules[k]=m
        return sysobj

def discover_plugins(folder="plugins"):
    p=pathlib.Path(folder); 
    if not p.exists(): return
    for f in p.glob("*.py"):
        spec=importlib.util.spec_from_file_location(f.stem,f); mod=importlib.util.module_from_spec(spec); spec.loader.exec_module(mod)

def create_app(sysobj:System, engine:LiveEngine|None):
    try:
        from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
        from fastapi.responses import Response
        from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    except Exception:
        return None
    s=Settings.load(); API=s.api_key_header
    REQS=Counter("echo_reqs_total","reqs"); LAT=Histogram("echo_req_latency_seconds","lat")
    app=FastAPI(title="UltraElite v6",version=sysobj.meta.version)
    def keydep():
        from fastapi import Request
        def inner(req:Request):
            if req.headers.get("x-api-key")!=API: raise HTTPException(status.HTTP_401_UNAUTHORIZED,"Invalid API Key")
        return inner
    @app.get("/health")
    def health(): REQS.inc(); return {"ok":True,"uuid":sysobj.meta.uuid}
    @app.get("/modules")
    def modules(dep=Depends(keydep())): 
        with LAT.time(): REQS.inc(); return sysobj.to_dict()["modules"]
    @app.get("/metrics")
    def metrics(): return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)
    @app.websocket("/ws")
    async def ws(sock:WebSocket):
        await sock.accept()
        try:
            while True:
                await sock.send_json(sysobj.to_dict()); time.sleep(2)
        except Exception: pass
    @app.post("/trade/start")
    def start(dep=Depends(keydep())):
        if engine is None: raise HTTPException(503,"engine missing")
        engine.start(); return {"started":True}
    @app.post("/trade/stop")
    def stop(dep=Depends(keydep())):
        if engine is None: raise HTTPException(503,"engine missing")
        engine.stop(); return {"stopped":True}
    return app

def run_api(sysobj:System, engine:LiveEngine|None, port:int=8080):
    app=create_app(sysobj,engine)
    if app is None:
        print("fastapi/uvicorn/prometheus_client eksik. pip install fastapi uvicorn prometheus_client"); return
    import uvicorn; uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")

# -------------------- CLI --------------------
def main():
    s=Settings.load(); log.remove(); log.add(lambda m: print(m,end=""), level=s.log_level)
    ap=argparse.ArgumentParser(description="Ultra Elite v6 â€” MTF + Econ + RiskMin + API")
    sub=ap.add_subparsers(dest="cmd", required=True)
    pbt=sub.add_parser("backtest"); pbt.add_argument("--symbol","-s", required=True); pbt.add_argument("--lookback",type=int,default=2000)
    plive=sub.add_parser("live"); plive.add_argument("--symbol","-s"); plive.add_argument("--api",action="store_true"); plive.add_argument("--port",type=int,default=8080)
    papi=sub.add_parser("api"); papi.add_argument("--port",type=int,default=8080)
    args=ap.parse_args()

    if args.cmd=="backtest":
        out=backtest(args.symbol,s,args.lookback); print(json.dumps(out,ensure_ascii=False,indent=2)); return

    ex=CcxtBinance(s); tel=_GLOBAL_TEL; risk=Risk(s.equity,s.max_risk_pct,s.max_dd,s.leverage)
    engine=LiveEngine(s,ex,tel,risk)
    sysobj=System.build(strategy="KamalquantX",lang=s.lang,include=["Market","Risk","Strategy","Econ","Telemetry","KamalQuantXEcho"])
    if args.cmd=="api" or args.api:
        if args.cmd=="live" and args.symbol: s.symbols=[args.symbol]
        if args.cmd=="live": engine.start()
        run_api(sysobj, engine, port=args.port)
    else:
        if args.symbol: s.symbols=[args.symbol]
        engine.start()
        try:
            while True:
                print(json.dumps(sysobj.to_dict(), ensure_ascii=False, indent=2))
                time.sleep(20)
        except KeyboardInterrupt:
            engine.stop()

if __name__=="__main__": main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\ultra_elite_allinone_v7.py
# ultra_elite_allinone_v7.py
# v7 = v6 + (1) VWAP/OrderBook fill emÃ¼latÃ¶rÃ¼, (2) Async portfÃ¶y yÃ¼rÃ¼tme, (3) Slipajâ€“likidite kalibrasyonu,
# (4) pytest Ã¶rnekleri Ã¼retici, (5) kÃ¼Ã§Ã¼k iyileÅŸtirmeler.
from __future__ import annotations
import os, sys, json, time, math, uuid, asyncio, threading, importlib.util, pathlib, argparse
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, Callable, Tuple

# pip install: python-dotenv ccxt pandas numpy jsonschema fastapi uvicorn prometheus_client loguru
from dotenv import load_dotenv
from loguru import logger as log
import pandas as pd
import numpy as np
import ccxt, jsonschema

# ---------------- i18n ----------------
I18N={"tr":{"online":"ULTRA ELÄ°T v7 AKTÄ°F","paper_on":"Paper mod: emir yok.","live_on":"CanlÄ± mod: emir gÃ¶nderilecek.",
            "bt":"Backtest {s} {tf}: trades={n} pnl={p:.2f} win={w:.1%}"},
      "en":{"online":"ULTRA ELITE v7 ONLINE","paper_on":"Paper mode","live_on":"Live mode",
            "bt":"Backtest {s} {tf}: trades={n} pnl={p:.2f} win={w:.1%}"}}
def tr(lang,k,**kw): return (I18N.get(lang) or I18N["en"]).get(k,k).format(**kw)

# ------------- schemas / registry -------------
class Health(str): OK="ok"; WARN="warn"; FAIL="fail"
@dataclass
class Metrics: init_ms:float=0.0; activate_ms:float=0.0; custom:Dict[str,float]=field(default_factory=dict)
@dataclass
class Module:
    name:str; status:str; payload:Dict[str,Any]; health:str=Health.OK; metrics:Metrics=field(default_factory=Metrics); schema:Dict[str,Any]|None=None
    def to_dict(self): return {"name":self.name,"status":self.status,"health":self.health,"metrics":asdict(self.metrics),**(self.payload or {})}
REGISTRY: Dict[str,Callable[[str,str],Module]]={}
def register(n:str):
    def deco(fn): REGISTRY[n]=fn; return fn
    return deco

SCHEMAS={
  "market":{"type":"object","required":["exchange","symbols","timeframe"],"properties":{
    "exchange":{"type":"string"},"symbols":{"type":"array","items":{"type":"string"},"minItems":1},
    "timeframe":{"type":"string"},"use_testnet":{"type":"boolean"},"use_futures":{"type":"boolean"}}},
  "risk":{"type":"object","required":["equity","max_risk_pct","max_dd","leverage"],"properties":{
    "equity":{"type":"number"},"max_risk_pct":{"type":"number"},"max_dd":{"type":"number"},"leverage":{"type":"integer"}}},
  "strategy":{"type":"object","required":["signal_tf","trend_tf","htf"],"properties":{
    "signal_tf":{"type":"string"},"trend_tf":{"type":"string"},"htf":{"type":"string"},
    "rsi_period":{"type":"integer"},"ema_fast":{"type":"integer"},"ema_slow":{"type":"integer"},
    "kdj_on":{"type":"boolean"},"wr_on":{"type":"boolean"},"trix_on":{"type":"boolean"},
    "adx_on":{"type":"boolean"},"cci_on":{"type":"boolean"},"mfi_on":{"type":"boolean"},"obv_on":{"type":"boolean"}}},
  "econ":{"type":"object","required":["taker_fee","slippage_bps"],"properties":{
    "taker_fee":{"type":"number"},"maker_fee":{"type":"number"},"slippage_bps":{"type":"number"},
    "lat_ms":{"type":"number"},"funding_rate_8h":{"type":"number"},"funding_sign":{"type":"integer"},
    "maker_allowed":{"type":"boolean"},"maker_spread_bps":{"type":"number"},"book_imbalance_th":{"type":"number"},
    "avoid_funding_min":{"type":"integer"}}},
  "telemetry":{"type":"object","required":["pnl","trades"],"properties":{"pnl":{"type":"number"},"trades":{"type":"integer"},"winrate":{"type":"number"}}}
}
def validate_payload(m:Module):
    s=m.schema or SCHEMAS.get(m.name.lower()); 
    if s: jsonschema.validate(m.payload, s)

# ------------- settings -------------
@dataclass
class Settings:
    exchange:str="BINANCE"; use_testnet:bool=True; use_futures:bool=True
    symbols:List[str]=field(default_factory=lambda:["BTC/USDT"])
    # ana dÃ¶ngÃ¼ tf ve MTF
    timeframe:str="1m"; signal_tf:str="1m"; trend_tf:str="15m"; htf:str="1h"
    # indikatÃ¶r
    rsi_period:int=14; ema_fast:int=21; ema_slow:int=50; atr_period:int=14
    kdj_on:bool=True; wr_on:bool=True; trix_on:bool=True; adx_on:bool=True; cci_on:bool=True; mfi_on:bool=True; obv_on:bool=True
    # ekonomi
    taker_fee:float=0.0004; maker_fee:float=0.0002; slippage_bps:float=2.0; lat_ms:float=120.0
    funding_rate_8h:float=0.0; funding_sign:int=0
    maker_allowed:bool=True; maker_spread_bps:float=0.8; book_imbalance_th:float=0.55; avoid_funding_min:int=10
    # risk
    equity:float=5000.0; max_risk_pct:float=0.015; max_dd:float=0.02; leverage:int=5
    dry_run:bool=True; log_level:str="INFO"; lang:str="tr"; api_key:str=""; api_secret:str=""
    # guard
    max_latency_ms:float=800.0; max_slippage_bps:float=20.0; max_positions:int=5
    # TP/trail
    tp_rr:List[float]=field(default_factory=lambda:[1.0,2.0]); tp_frac:List[float]=field(default_factory=lambda:[0.5,0.5])
    trail_be_rr:float=1.0; trail_mult:float=1.0
    # kalibrasyon
    use_calibration:bool=True; calibration_file:str="slip_calib.json"
    # API
    api_key_header:str="secret123"

    @staticmethod
    def _b(k,d): return os.getenv(k,str(d)).lower()=="true"
    @staticmethod
    def _f(k,d):
        try: return float(os.getenv(k,str(d)))
        except: return d
    @staticmethod
    def load()->"Settings":
        load_dotenv(override=True)
        syms=[x.strip() for x in os.getenv("SYMBOLS","BTC/USDT").split(",") if x.strip()]
        return Settings(
            exchange=os.getenv("EXCHANGE","BINANCE").upper(),
            use_testnet=Settings._b("USE_TESTNET",True), use_futures=Settings._b("USE_FUTURES",True),
            symbols=syms, timeframe=os.getenv("TIMEFRAME","1m"),
            signal_tf=os.getenv("SIGNAL_TF","1m"), trend_tf=os.getenv("TREND_TF","15m"), htf=os.getenv("HTF","1h"),
            rsi_period=int(os.getenv("RSI_PERIOD","14")), ema_fast=int(os.getenv("EMA_FAST","21")), ema_slow=int(os.getenv("EMA_SLOW","50")),
            atr_period=int(os.getenv("ATR_PERIOD","14")), kdj_on=Settings._b("KDJ_ON",True), wr_on=Settings._b("WR_ON",True),
            trix_on=Settings._b("TRIX_ON",True), adx_on=Settings._b("ADX_ON",True), cci_on=Settings._b("CCI_ON",True),
            mfi_on=Settings._b("MFI_ON",True), obv_on=Settings._b("OBV_ON",True),
            taker_fee=Settings._f("TAKER_FEE",0.0004), maker_fee=Settings._f("MAKER_FEE",0.0002),
            slippage_bps=Settings._f("SLIPPAGE_BPS",2.0), lat_ms=Settings._f("LAT_MS",120.0),
            funding_rate_8h=Settings._f("FUNDING_RATE_8H",0.0), funding_sign=int(os.getenv("FUNDING_SIGN","0")),
            maker_allowed=Settings._b("MAKER_ALLOWED",True), maker_spread_bps=Settings._f("MAKER_SPREAD_BPS",0.8),
            book_imbalance_th=Settings._f("BOOK_IMBALANCE_TH",0.55), avoid_funding_min=int(os.getenv("AVOID_FUNDING_MIN","10")),
            equity=Settings._f("ACCOUNT_EQUITY",5000), max_risk_pct=Settings._f("MAX_RISK_PCT_PER_TRADE",0.015),
            max_dd=Settings._f("MAX_DAILY_DRAWDOWN",0.02), leverage=int(os.getenv("LEVERAGE","5")),
            dry_run=Settings._b("DRY_RUN",True), log_level=os.getenv("LOG_LEVEL","INFO").upper(),
            lang=os.getenv("LANG","tr").lower(), api_key=os.getenv("BINANCE_API_KEY",""), api_secret=os.getenv("BINANCE_API_SECRET",""),
            max_latency_ms=Settings._f("MAX_LATENCY_MS",800), max_slippage_bps=Settings._f("MAX_SLIPPAGE_BPS",20),
            max_positions=int(os.getenv("MAX_POSITIONS","5")),
            tp_rr=[Settings._f("TP1_RR",1.0), Settings._f("TP2_RR",2.0)],
            tp_frac=[Settings._f("TP1_FRAC",0.5), Settings._f("TP2_FRAC",0.5)],
            trail_be_rr=Settings._f("TRAIL_BE_RR",1.0), trail_mult=Settings._f("TRAIL_MULT",1.0),
            use_calibration=Settings._b("USE_CALIBRATION",True), calibration_file=os.getenv("CALIBRATION_FILE","slip_calib.json"),
            api_key_header=os.getenv("API_KEY","secret123"),
        )

# ------------- indicators -------------
def ema(s:pd.Series,p:int)->pd.Series: return s.ewm(span=p,adjust=False).mean()
def tr_series(df): 
    return pd.concat([(df["high"]-df["low"]),
                      (df["high"]-df["close"].shift()).abs(),
                      (df["low"]-df["close"].shift()).abs()],axis=1).max(axis=1)
def atr(df,p): return tr_series(df).rolling(p).mean()
def stochastic(df,k=9,d=3):
    lo=df["low"].rolling(k).min(); hi=df["high"].rolling(k).max()
    K=100*(df["close"]-lo)/(hi-lo); D=K.rolling(d).mean(); J=3*K-2*D
    return K.clip(0,100),D.clip(0,100),J.clip(0,100)
def williams_r(df,lbp=14):
    lo=df["low"].rolling(lbp).min(); hi=df["high"].rolling(lbp).max()
    return (-100*(hi-df["close"])/(hi-lo)).clip(-100,0)
def trix(df,p=9):
    e1=df["close"].ewm(span=p,adjust=False).mean()
    e2=e1.ewm(span=p,adjust=False).mean()
    e3=e2.ewm(span=p,adjust=False).mean()
    return 100*(e3.diff()/e3.shift())
def adx(df,period=14):
    up=df["high"].diff(); dn=-df["low"].diff()
    plus=(up.where((up>dn)&(up>0),0.0)).fillna(0.0)
    minus=(dn.where((dn>up)&(dn>0),0.0)).fillna(0.0)
    tr=tr_series(df).fillna(0.0); atr_rma=tr.ewm(alpha=1/period,adjust=False).mean()
    pdi=100*(plus.ewm(alpha=1/period,adjust=False).mean()/atr_rma)
    mdi=100*(minus.ewm(alpha=1/period,adjust=False).mean()/atr_rma)
    dx=(100*(pdi-mdi).abs()/(pdi+mdi).replace(0,np.nan)).fillna(0.0)
    return dx.ewm(alpha=1/period,adjust=False).mean()
def supertrend(df,period=10,mult=3.0):
    hl2=(df["high"]+df["low"])/2.0; a=atr(df,period)
    up=hl2+mult*a; lo=hl2-mult*a
    st=pd.Series(index=df.index,dtype=float); trd=pd.Series(index=df.index,dtype=int)
    for i in range(len(df)):
        if i==0: st.iloc[i]=up.iloc[i]; trd.iloc[i]=1; continue
        up.iloc[i]=min(up.iloc[i],up.iloc[i-1]) if df["close"].iloc[i-1]<=up.iloc[i-1] else up.iloc[i]
        lo.iloc[i]=max(lo.iloc[i],lo.iloc[i-1]) if df["close"].iloc[i-1]>=lo.iloc[i-1] else lo.iloc[i]
        if df["close"].iloc[i]>up.iloc[i-1]: trd.iloc[i]=1
        elif df["close"].iloc[i]<lo.iloc[i-1]: trd.iloc[i]=-1
        else: trd.iloc[i]=trd.iloc[i-1]
        st.iloc[i]=lo.iloc[i] if trd.iloc[i]==1 else up.iloc[i]
    return st,trd

# ------------- MTF sinyal -------------
@dataclass
class Signal: side:str|None=None; price:float|None=None; stop:float|None=None; atrv:float|None=None; reason:str=""; conf:float=0.0
def core_signal(df:pd.DataFrame,s:Settings)->Signal:
    px=float(df["close"].iloc[-1]); e1,e2=ema(df["close"],s.ema_fast),ema(df["close"],s.ema_slow)
    st,_=supertrend(df,s.atr_period,3.0); a=float(atr(df,s.atr_period).iloc[-1] or 0.0)
    ch=df["close"].diff(); g=ch.clip(lower=0).rolling(s.rsi_period).mean(); l=(-ch.clip(upper=0)).rolling(s.rsi_period).mean()
    rsi=100-100/(1+(g/(l.replace(0,np.nan))))
    K,D,J=stochastic(df); WR=williams_r(df); TR=trix(df,s.atr_period); TRs=TR.ewm(span=s.atr_period,adjust=False).mean()
    long_core=(e1.iloc[-1]>e2.iloc[-1]) and (px>st.iloc[-1]); short_core=(e1.iloc[-1]<e2.iloc[-1]) and (px<st.iloc[-1])
    L=long_core; S=short_core; conf=0.0; rs=[]
    if rsi.iloc[-2]<30 and rsi.iloc[-1]>=30 and long_core: L=True; conf+=0.15; rs.append("RSIâ†‘30")
    if rsi.iloc[-2]>70 and rsi.iloc[-1]<=70 and short_core: S=True; conf+=0.15; rs.append("RSIâ†“70")
    if s.kdj_on:
        if K.iloc[-2]<D.iloc[-2] and K.iloc[-1]>D.iloc[-1] and K.iloc[-1]<40: L=True; conf+=0.2; rs.append("KDJâ†‘")
        if K.iloc[-2]>D.iloc[-2] and K.iloc[-1]<D.iloc[-1] and K.iloc[-1]>60: S=True; conf+=0.2; rs.append("KDJâ†“")
    if s.wr_on:
        if WR.iloc[-1]<=-80: L=True; conf+=0.1; rs.append("WRâ‰¤-80")
        if WR.iloc[-1]>=-20: S=True; conf+=0.1; rs.append("WRâ‰¥-20")
    if s.trix_on:
        if TR.iloc[-2]<TRs.iloc[-2] and TR.iloc[-1]>TRs.iloc[-1]: L=True; conf+=0.1; rs.append("TRIXâ†‘")
        if TR.iloc[-2]>TRs.iloc[-2] and TR.iloc[-1]<TRs.iloc[-1]: S=True; conf+=0.1; rs.append("TRIXâ†“")
    if L and not S: return Signal("buy",px,float(st.iloc[-1]),a,"+".join(rs or ["core_up"]),conf)
    if S and not L: return Signal("sell",px,float(st.iloc[-1]),a,"+".join(rs or ["core_dn"]),conf)
    return Signal()

def mom_bias(df:pd.DataFrame,s:Settings)->Tuple[bool,bool]:
    e1,e2=ema(df["close"],s.ema_fast),ema(df["close"],s.ema_slow); ad=adx(df,14).iloc[-1] if s.adx_on else 25
    return (e1.iloc[-1]>e2.iloc[-1]) and ad>=18, (e1.iloc[-1]<e2.iloc[-1]) and ad>=18
def htf_bias(df:pd.DataFrame)->Tuple[bool,bool]:
    sma200=df["close"].rolling(200).mean()
    if len(df)<202: return False,False
    return sma200.iloc[-1]>sma200.iloc[-2], sma200.iloc[-1]<sma200.iloc[-2]
def ensemble_mtf(sig_df, tr_df, h_df, s:Settings)->Signal:
    c=core_signal(sig_df,s)
    if not c.side: return c
    t_up,t_dn=mom_bias(tr_df,s); h_up,h_dn=htf_bias(h_df)
    if c.side=="buy" and t_up and h_up: c.conf=min(1.0,c.conf+0.3); c.reason+="|MTF++"; return c
    if c.side=="sell" and t_dn and h_dn: c.conf=min(1.0,c.conf+0.3); c.reason+="|MTF--"; return c
    return Signal()

# ------------- CCXT adapter + OB/VWAP -------------
class CcxtBinance:
    def __init__(self,s:Settings):
        self.s=s
        self.ex=(ccxt.binanceusdm if s.use_futures else ccxt.binance)({"apiKey":s.api_key,"secret":s.api_secret,"enableRateLimit":True})
        if s.use_testnet:
            try:self.ex.set_sandbox_mode(True)
            except Exception: pass
    def fetch_ohlcv_df(self,sym,tf,limit=500):
        raw=self.ex.fetch_ohlcv(sym, timeframe=tf, limit=limit)
        df=pd.DataFrame(raw,columns=["ts","open","high","low","close","volume"])
        df["ts"]=pd.to_datetime(df["ts"],unit="ms",utc=True); return df.set_index("ts")
    def orderbook(self,sym,limit=50):
        try: return self.ex.fetch_order_book(sym,limit=limit)
        except Exception: return {"bids":[],"asks":[]}
    def place(self,sym,side,qty,price=None,post_only=False):
        if self.s.dry_run: 
            log.info(f"WOULD {side.upper()} {qty} {sym} @ {price or 'MARKET'}{' [POST]' if post_only else ''}"); 
            return {"sim":True}
        params={}
        if post_only: params.update({"postOnly":True,"timeInForce":"GTX"})
        typ="limit" if price else "market"
        return self.ex.create_order(sym, type=typ, side=side, amount=qty, price=price, params=params)

# VWAP emÃ¼latÃ¶rÃ¼: OB derinliÄŸine gÃ¶re miktar doldurur, ortalama fiyatÄ± dÃ¶ner.
def vwap_fill(ob:dict, side:str, qty:float)->Tuple[float,float]:
    levels = ob["asks"] if side=="buy" else ob["bids"]
    if not levels: return (0.0, 0.0)
    need=qty; cost=0.0; vol=0.0
    for px, avail in (levels if side=="buy" else levels):  # same iteration
        take=min(need, float(avail))
        cost += take*float(px)
        vol  += take
        need -= take
        if need<=1e-12: break
    if vol<=0: return (0.0, 0.0)
    return (cost/vol, vol)

def book_metrics(ob)->Tuple[float,float,float]:
    if not ob["bids"] or not ob["asks"]: return 0.0,0.0,0.5
    bb=ob["bids"][0][0]; ba=ob["asks"][0][0]; mid=(bb+ba)/2.0
    spread_bps=(ba-bb)/mid*1e4 if mid else 0.0
    bidv=sum([b[1] for b in ob["bids"][:10]]); askv=sum([a[1] for a in ob["asks"][:10]])
    imb= bidv/(bidv+askv) if (bidv+askv)>0 else 0.5
    return spread_bps, mid, imb

# ------------- Slippage Calibrator (OLS) -------------
class SlippageCalibrator:
    def __init__(self, path:str):
        self.path=path; self.X=[]; self.y=[]
        self.theta=None
        self.load()
    def featurize(self, spread_bps:float, depth_qty:float, atr_pct:float, latency_ms:float)->List[float]:
        return [1.0, spread_bps, depth_qty, atr_pct*1e4, latency_ms/1000.0]  # bias + scaled features
    def record_ob(self, ob:dict, df:pd.DataFrame, side:str, qty:float, realized_fill_bps:float, latency_ms:float):
        spread, mid, _ = book_metrics(ob)
        # depth: toplam ilk 10 seviye miktar / talep qty oranÄ± (ne kadar "derin")
        depth_qty = (sum([l[1] for l in (ob["asks"] if side=="buy" else ob["bids"])[:10]]) or 1.0) / max(qty,1e-9)
        atrp = float((atr(df,14).iloc[-1] or 0.0)/max(1e-9, float(df["close"].iloc[-1])))
        self.X.append(self.featurize(spread, depth_qty, atrp, latency_ms)); self.y.append(realized_fill_bps)
    def fit(self):
        if len(self.X)<8: return None
        X=np.array(self.X); y=np.array(self.y)
        self.theta=np.linalg.lstsq(X, y, rcond=None)[0].tolist(); self.save(); return self.theta
    def predict(self, ob:dict, df:pd.DataFrame, side:str, qty:float, latency_ms:float)->float:
        if not self.theta: return 0.0
        spread, _, _ = book_metrics(ob)
        depth_qty = (sum([l[1] for l in (ob["asks"] if side=="buy" else ob["bids"])[:10]]) or 1.0) / max(qty,1e-9)
        atrp = float((atr(df,14).iloc[-1] or 0.0)/max(1e-9, float(df["close"].iloc[-1])))
        x=np.array(self.featurize(spread, depth_qty, atrp, latency_ms))
        return float(np.dot(x, np.array(self.theta)))
    def save(self):
        try:
            with open(self.path,"w",encoding="utf-8") as f: json.dump({"theta":self.theta,"n":len(self.X)}, f, ensure_ascii=False, indent=2)
        except Exception: pass
    def load(self):
        try:
            with open(self.path,"r",encoding="utf-8") as f:
                data=json.load(f); self.theta=data.get("theta")
        except Exception: self.theta=None

# ------------- Risk / Telemetry -------------
@dataclass
class Risk:
    equity:float; max_risk_pct:float; max_dd:float; leverage:int
    day_pnl:float=0.0; day:str|None=None; losing:int=0; trades:int=0; kill:bool=False
    def roll(self):
        d=datetime.utcnow().date().isoformat()
        if self.day!=d: self.day=d; self.day_pnl=0.0; self.losing=0; self.trades=0; self.kill=False
    def size(self, entry:float, stop:float|None)->float:
        if self.kill: return 0.0
        if stop is None: stop=entry*0.995
        risk=self.equity*self.max_risk_pct; dist=abs(entry-stop) or 1e-9
        return round(max(0.0, risk/dist), 3)
    def update(self, pnl:float, s:Settings):
        self.roll(); self.day_pnl+=pnl; self.trades+=1; self.losing = 0 if pnl>0 else self.losing+1
        if self.day_pnl <= -self.equity*s.max_dd or self.losing>=5: self.kill=True
@dataclass
class Telemetry:
    pnl:float=0.0; trades:int=0; wins:int=0; latency_ms:float=0.0; paused:str=""
    def winrate(self): return (self.wins/self.trades) if self.trades else 0.0
    def payload(self)->Dict[str,Any]: return {"pnl":self.pnl,"trades":self.trades,"winrate":self.winrate(),"latency_ms":self.latency_ms,"paused":self.paused}

# ------------- utils -------------
def tfsec(tf:str)->int: u=tf[-1]; v=int(tf[:-1]); return {"s":1,"m":60,"h":3600,"d":86400,"w":604800}.get(u,60)*v
def fill_price(px,side,slip_bps): slip=px*(slip_bps/1e4); return px+slip if side=="buy" else px-slip
def commission(notional,fee): return abs(notional)*fee
def slot_id(ts:pd.Timestamp)->int: return int(ts.timestamp()//(8*3600))
def around_funding(ts:pd.Timestamp, minutes:int)->bool:
    m=ts.hour*60+ts.minute
    for b in (0,480,960):
        if abs(m-b)<=minutes: return True
    return False
def funding_due(prev:pd.Timestamp, now:pd.Timestamp)->bool: return slot_id(prev)!=slot_id(now)

# ------------- Slipaj modeli (kalibrasyonlu) -------------
def modeled_slippage_bps(df:pd.DataFrame, s:Settings, ob:dict|None, side:str, qty:float, calib:SlippageCalibrator|None)->float:
    if ob and calib and s.use_calibration and calib.theta:
        return max(0.0, calib.predict(ob, df, side, qty, s.lat_ms))
    # fallback: spread + ATR + latency katkÄ±sÄ±
    if ob and ob.get("bids") and ob.get("asks"):
        spread,_,_=book_metrics(ob); base=s.slippage_bps
        return min(s.max_slippage_bps, base + max(0.0,0.7*spread) + 0.25*(s.lat_ms/1000.0))
    vol=float((atr(df, s.atr_period).iloc[-1] or 0.0)/max(1e-9, float(df["close"].iloc[-1])))
    return min(s.max_slippage_bps, s.slippage_bps + 180*vol + 0.25*(s.lat_ms/1000.0))

# ------------- Async PortfÃ¶y Motoru -------------
class AsyncEngine:
    def __init__(self, s:Settings, ex:CcxtBinance, tel:Telemetry, risk:Risk, calib:SlippageCalibrator):
        self.s=s; self.ex=ex; self.tel=tel; self.risk=risk; self.calib=calib
        self.running=False; self._task:asyncio.Task|None=None
        self.pos:Dict[str,dict]={}  # sym -> position

    async def _fetch_mtf(self, sym:str):
        loop=asyncio.get_running_loop()
        sig = await loop.run_in_executor(None, lambda: self.ex.fetch_ohlcv_df(sym, self.s.signal_tf, 220))
        trd = await loop.run_in_executor(None, lambda: self.ex.fetch_ohlcv_df(sym, self.s.trend_tf, 220))
        htf = await loop.run_in_executor(None, lambda: self.ex.fetch_ohlcv_df(sym, self.s.htf, 220))
        ob  = await loop.run_in_executor(None, lambda: self.ex.orderbook(sym, 50))
        return sig, trd, htf, ob

    def _maker_choice(self, side:str, ob:dict, conf:float)->Tuple[bool,float,float]:
        spread, mid, imb=book_metrics(ob)
        maker_ok=self.s.maker_allowed and spread<=self.s.maker_spread_bps
        if side=="buy" and imb>self.s.book_imbalance_th: maker_ok=True
        if side=="sell" and (1-imb)>self.s.book_imbalance_th: maker_ok=True
        if conf>=0.7: maker_ok=False
        return maker_ok, mid, spread

    async def _process_symbol(self, sym:str):
        sig_df, tr_df, h_df, ob = await self._fetch_mtf(sym)
        now=sig_df.index[-1]
        if around_funding(now, self.s.avoid_funding_min) or self.risk.kill:
            self.tel.paused="FUNDING" if not self.risk.kill else "KILL"
            return

        sig=ensemble_mtf(sig_df, tr_df, h_df, self.s)
        px=float(sig_df["close"].iloc[-1])
        p=self.pos.get(sym)
        # funding uygulamasÄ± (slot deÄŸiÅŸimi)
        if p and funding_due(h_df.index[-2], h_df.index[-1]) and self.s.funding_sign!=0 and self.s.funding_rate_8h!=0:
            notional=px*p["qty"]; fee= notional*self.s.funding_rate_8h*self.s.funding_sign
            self.tel.pnl-=fee; self.risk.update(-fee, self.s)

        if not p and sig.side:
            # slipaj tahmini + VWAP fill Ã¶n-izleme
            qty=self.risk.size(sig.price or px, sig.stop)
            if qty<=0 or len(self.pos)>=self.s.max_positions: return
            slip_bps=modeled_slippage_bps(sig_df, self.s, ob, sig.side, qty, self.calib)
            if slip_bps>self.s.max_slippage_bps: return
            maker, mid, spread = self._maker_choice(sig.side, ob, sig.conf)
            price=None
            if maker and mid:
                # post-only iÃ§in yayÄ±lÄ±mÄ±n kendi tarafÄ±na yakÄ±n konumlan
                price = mid * (1 - spread/2/1e4) if sig.side=="buy" else mid * (1 + spread/2/1e4)
            # VWAP emÃ¼latÃ¶rÃ¼ (taker durumunda book'tan dolum fiyatÄ±nÄ± simÃ¼le et)
            vwap_px, filled = vwap_fill(ob, sig.side, qty)
            expect_px = vwap_px if (filled>=qty*0.999 and not maker) else (price or px)
            ep = fill_price(expect_px, sig.side, slip_bps)
            # yerleÅŸtir
            self.ex.place(sym, sig.side, qty, price=price, post_only=bool(price))
            self.pos[sym]={"side":sig.side,"entry":ep,"qty":qty,"atr":sig.atrv or 0.0,"best":ep,
                           "stop":sig.stop or (ep*0.995 if sig.side=='buy' else ep*1.005),
                           "tp":[ep+(rr*(sig.atrv or 0.0))*(1 if sig.side=='buy' else -1) for rr in self.s.tp_rr],
                           "tp_frac":self.s.tp_frac.copy(),"filled":[False]*len(self.s.tp_rr)}
            self.tel.trades+=1
            return

        if p:
            # trailing / TP
            if p["side"]=="buy": p["best"]=max(p["best"],px)
            else: p["best"]=min(p["best"],px)
            new_stop = (p["entry"] if p["atr"]==0 else
                        (max(p["entry"], p["best"]-self.s.trail_mult*p["atr"]) if p["side"]=="buy"
                         else min(p["entry"], p["best"]+self.s.trail_mult*p["atr"])))
            if p["side"]=="buy": p["stop"]=max(p["stop"], new_stop)
            else: p["stop"]=min(p["stop"], new_stop)
            for i, lvl in enumerate(p["tp"]):
                if p["filled"][i]: continue
                hit = (px>=lvl) if p["side"]=="buy" else (px<=lvl)
                if hit:
                    part=p["tp_frac"][i]*p["qty"]
                    if part>0:
                        self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", part)
                        unit=(lvl - p["entry"])*(1 if p["side"]=="buy" else -1)
                        self.tel.pnl += unit*(part/p["qty"]); p["qty"]-=part
                    p["filled"][i]=True
            stop_hit = (px<=p["stop"]) if p["side"]=="buy" else (px>=p["stop"])
            if stop_hit or p["qty"]<=1e-9:
                self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", p["qty"])
                pnl=(px - p["entry"])*(1 if p["side"]=="buy" else -1); self.tel.pnl+=pnl
                self.risk.update(pnl, self.s); self.tel.wins+=1 if pnl>0 else 0; self.pos.pop(sym,None)
                return
            # ters sinyal -> flip
            if sig.side and ((p["side"]=="buy" and sig.side=="sell") or (p["side"]=="sell" and sig.side=="buy")):
                self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", p["qty"])
                pnl=(px - p["entry"])*(1 if p["side"]=="buy" else -1); self.tel.pnl+=pnl
                self.risk.update(pnl, self.s); self.tel.wins+=1 if pnl>0 else 0; self.pos.pop(sym,None)

        return

    async def _loop(self):
        log.info(tr(self.s.lang,"online"))
        log.warning(tr(self.s.lang,"paper_on") if self.s.dry_run else tr(self.s.lang,"live_on"))
        while self.running:
            t0=time.perf_counter()
            try:
                await asyncio.gather(*(self._process_symbol(sym) for sym in self.s.symbols))
            except Exception as e:
                log.error(f"[async] {e}")
            self.tel.latency_ms=(time.perf_counter()-t0)*1000
            await asyncio.sleep(max(3, tfsec(self.s.signal_tf)//3))

    def start(self):
        if self.running: return
        self.running=True
        def runner():
            asyncio.run(self._loop())
        threading.Thread(target=runner, daemon=True).start()

    def stop(self): self.running=False

# ------------- Backtest (VWAP+kalibrasyon destekli) -------------
def backtest(symbol:str, s:Settings, lookback:int=1600)->Dict[str,Any]:
    ex=CcxtBinance(s); sig=ex.fetch_ohlcv_df(symbol,s.signal_tf,lookback); trd=ex.fetch_ohlcv_df(symbol,s.trend_tf,lookback); htf=ex.fetch_ohlcv_df(symbol,s.htf,lookback)
    pnl=0.0; trades=0; wins=0; pos=None; last_slot=slot_id(htf.index[0])
    calib=SlippageCalibrator(s.calibration_file)
    for i in range(220,len(sig)):
        ws=sig.iloc[:i+1]; tt=trd.loc[trd.index<=ws.index[-1]]; hh=htf.loc[htf.index<=ws.index[-1]]
        if len(tt)<1 or len(hh)<1: continue
        sg=ensemble_mtf(ws,tt,hh,s); px=float(ws["close"].iloc[-1]); ob=ex.orderbook(symbol,50)
        if pos and funding_due(hh.index[-2], hh.index[-1]) and s.funding_rate_8h!=0 and s.funding_sign!=0:
            pnl -= (px*pos["qty"])*s.funding_rate_8h*s.funding_sign
        if not pos and sg.side:
            qty=Risk(s.equity,s.max_risk_pct,s.max_dd,s.leverage).size(sg.price or px, sg.stop)
            if qty<=0: continue
            # VWAP taker simÃ¼lasyonu
            vpx, filled = vwap_fill(ob, sg.side, qty)
            slip_bps = modeled_slippage_bps(ws, s, ob, sg.side, qty, calib)
            entry = fill_price((vpx or px), sg.side, slip_bps)
            tps=[entry+(rr*(sg.atrv or float(atr(ws,s.atr_period).iloc[-1] or 0.0)))*(1 if sg.side=='buy' else -1) for rr in s.tp_rr]
            trades+=1
            pos={"side":sg.side,"entry":entry,"qty":qty,"atr":sg.atrv or 0.0,"best":entry,
                 "stop":sg.stop or (entry*0.995 if sg.side=='buy' else entry*1.005),
                 "tp":tps,"tp_frac":s.tp_frac.copy(),"filled":[False]*len(tps)}
            pnl -= commission(entry*qty, s.taker_fee)
            # veri kaydÄ± (kalibrasyona)
            spread,mid,_=book_metrics(ob)
            if mid: 
                realized_bps = abs((entry-mid)/mid)*1e4
                calib.record_ob(ob, ws, sg.side, qty, realized_bps, s.lat_ms)
            continue
        if pos:
            if pos["side"]=="buy": pos["best"]=max(pos["best"],px)
            else: pos["best"]=min(pos["best"],px)
            new_stop=(max(pos["entry"], pos["best"]-s.trail_mult*pos["atr"]) if pos["side"]=="buy"
                      else min(pos["entry"], pos["best"]+s.trail_mult*pos["atr"]))
            if pos["side"]=="buy": pos["stop"]=max(pos["stop"], new_stop)
            else: pos["stop"]=min(pos["stop"], new_stop)
            for j,lvl in enumerate(pos["tp"]):
                if pos["filled"][j]: continue
                if (px>=lvl and pos["side"]=="buy") or (px<=lvl and pos["side"]=="sell"):
                    part=pos["tp_frac"][j]*pos["qty"]; unit=(lvl - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                    pnl += unit*(part/pos["qty"]); pos["qty"]-=part; pos["filled"][j]=True
            if (pos["side"]=="buy" and px<=pos["stop"]) or (pos["side"]=="sell" and px>=pos["stop"]):
                unit=(pos["stop"] - pos["entry"])*(1 if pos["side"]=="buy" else -1); pnl+=unit; wins+=1 if unit>0 else 0; pos=None
                continue
            rs = ensemble_mtf(ws,tt,hh,s)
            if rs.side and ((pos["side"]=="buy" and rs.side=="sell") or (pos["side"]=="sell" and rs.side=="buy")):
                unit=(px - pos["entry"])*(1 if pos["side"]=="buy" else -1); pnl+=unit; wins+=1 if unit>0 else 0; pos=None
    if len(calib.X)>=8: calib.fit()
    win=wins/trades if trades else 0.0; log.success(tr(s.lang,"bt"), s=symbol, tf=s.signal_tf, n=trades, p=pnl, w=win)
    return {"trades":trades,"pnl":pnl,"winrate":win}

# ------------- registry -------------
@register("Market")
def mod_market(name,lang):
    s=Settings.load(); m=Module("Market","ok",{"exchange":s.exchange,"symbols":s.symbols,"timeframe":s.timeframe,
                                               "use_testnet":s.use_testnet,"use_futures":s.use_futures},schema=SCHEMAS["market"]); validate_payload(m); return m
@register("Risk")
def mod_risk(name,lang):
    s=Settings.load(); m=Module("Risk","ok",{"equity":s.equity,"max_risk_pct":s.max_risk_pct,"max_dd":s.max_dd,"leverage":s.leverage},schema=SCHEMAS["risk"]); validate_payload(m); return m
@register("Strategy")
def mod_strat(name,lang):
    s=Settings.load(); pay={"signal_tf":s.signal_tf,"trend_tf":s.trend_tf,"htf":s.htf,"rsi_period":s.rsi_period,"ema_fast":s.ema_fast,"ema_slow":s.ema_slow,
                            "kdj_on":s.kdj_on,"wr_on":s.wr_on,"trix_on":s.trix_on,"adx_on":s.adx_on,"cci_on":s.cci_on,"mfi_on":s.mfi_on,"obv_on":s.obv_on}
    m=Module("Strategy","ok",pay,schema=SCHEMAS["strategy"]); validate_payload(m); return m
@register("Econ")
def mod_econ(name,lang):
    s=Settings.load(); pay={"taker_fee":s.taker_fee,"maker_fee":s.maker_fee,"slippage_bps":s.slippage_bps,"lat_ms":s.lat_ms,
                            "funding_rate_8h":s.funding_rate_8h,"funding_sign":s.funding_sign,
                            "maker_allowed":s.maker_allowed,"maker_spread_bps":s.maker_spread_bps,
                            "book_imbalance_th":s.book_imbalance_th,"avoid_funding_min":s.avoid_funding_min}
    m=Module("Econ","ok",pay,schema=SCHEMAS["econ"]); validate_payload(m); return m
_GLOBAL_TEL=Telemetry()
@register("Telemetry")
def mod_tel(name,lang): m=Module("Telemetry","ok",_GLOBAL_TEL.payload(),schema=SCHEMAS["telemetry"]); validate_payload(m); return m

# ------------- system / API -------------
@dataclass
class EchoMeta: version:str="Ultra Elite v7"; strategy:str="KamalquantX"; lang:str="tr"; generated_at:str=field(default_factory=lambda:datetime.now(timezone.utc).isoformat()); uuid:str=field(default_factory=lambda:str(uuid.uuid4()))
@dataclass
class System:
    meta:EchoMeta; modules:Dict[str,Module]=field(default_factory=dict)
    def to_dict(self): 
        if "Telemetry" in self.modules: self.modules["Telemetry"].payload=_GLOBAL_TEL.payload()
        return {"meta":asdict(self.meta),"modules":{k:m.to_dict() for k,m in self.modules.items()}}
    @classmethod
    def build(cls, strategy:str, lang:str, include:List[str]|None=None):
        sysobj=cls(EchoMeta(strategy=strategy, lang=lang)); wants=include or list(REGISTRY.keys())
        for k in wants:
            if k not in REGISTRY: continue
            t0=time.perf_counter(); m=REGISTRY[k](strategy, lang); m.metrics.init_ms=(time.perf_counter()-t0)*1000; validate_payload(m); sysobj.modules[k]=m
        return sysobj

def create_app(sysobj:System, engine:AsyncEngine|None):
    try:
        from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
        from fastapi.responses import Response
        from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    except Exception:
        return None
    s=Settings.load(); API=s.api_key_header
    REQS=Counter("ultra_v7_reqs","reqs"); LAT=Histogram("ultra_v7_latency","lat")
    app=FastAPI(title="UltraElite v7",version=sysobj.meta.version)
    def keydep():
        from fastapi import Request
        def inner(req:Request):
            if req.headers.get("x-api-key")!=API: raise HTTPException(status.HTTP_401_UNAUTHORIZED,"Invalid API Key")
        return inner
    @app.get("/health")
    def health(): REQS.inc(); return {"ok":True,"uuid":sysobj.meta.uuid}
    @app.get("/modules")
    def modules(dep=Depends(keydep())): 
        with LAT.time(): REQS.inc(); return sysobj.to_dict()["modules"]
    @app.get("/metrics")
    def metrics(): return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)
    @app.websocket("/ws")
    async def ws(sock:WebSocket):
        await sock.accept()
        try:
            while True:
                await sock.send_json(sysobj.to_dict()); await asyncio.sleep(2)
        except Exception: pass
    @app.post("/trade/start")
    def start(dep=Depends(keydep())):
        if engine is None: raise HTTPException(503,"engine missing")
        engine.start(); return {"started":True}
    @app.post("/trade/stop")
    def stop(dep=Depends(keydep())):
        if engine is None: raise HTTPException(503,"engine missing")
        engine.stop(); return {"stopped":True}
    return app

def run_api(sysobj:System, engine:AsyncEngine|None, port:int=8080):
    app=create_app(sysobj, engine)
    if app is None:
        print("fastapi/uvicorn/prometheus_client eksik. pip install fastapi uvicorn prometheus_client"); return
    import uvicorn; uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")

# ------------- pytest Ã¶rnekleri Ã¼retici -------------
TESTS = {
"tests/test_vwap.py": r'''
import math
from ultra_elite_allinone_v7 import vwap_fill
def test_vwap_basic():
    ob={"bids":[[99,5],[98,5]],"asks":[[101,3],[102,3],[103,10]]}
    px,filled=vwap_fill(ob,"buy",5)
    assert math.isclose(px, (101*3+102*2)/5, rel_tol=1e-6)
    assert math.isclose(filled,5, rel_tol=1e-12)
''',
"tests/test_calib.py": r'''
from ultra_elite_allinone_v7 import SlippageCalibrator
def test_calib_fit_predict(tmp_path):
    f=tmp_path/"cal.json"; c=SlippageCalibrator(str(f))
    # yapay veri
    for i in range(20):
        spread=0.5+i*0.1; depth=2+i*0.05; atrp=0.003; lat=100+i
        c.X.append([1.0,spread,depth,atrp*1e4,lat/1000.0]); c.y.append(0.2*spread + 0.1*depth + 0.05*(lat/1000.0))
    c.fit()
    y=c.predict({"bids":[[100,10]],"asks":[[100.2,10]]}, None, "buy", 1.0, 200)
    assert y>0
''',
"tests/test_mtf.py": r'''
import pandas as pd
from ultra_elite_allinone_v7 import Settings, ensemble_mtf
def test_mtf_gate():
    s=Settings()
    idx=pd.date_range("2024-01-01", periods=300, freq="T", tz="UTC")
    def df(px):
        return pd.DataFrame({"open":px,"high":px*1.001,"low":px*0.999,"close":px,"volume":1.0}, index=idx)
    sig=df(pd.Series(100+0.01*range(300), index=idx))
    tr =df(pd.Series(100+0.02*range(300), index=idx))
    h  =df(pd.Series(100+0.03*range(300), index=idx))
    sg=ensemble_mtf(sig,tr,h,s)
    assert sg.side in (None,"buy","sell")
''',
}

def write_tests():
    for path,src in TESTS.items():
        p=pathlib.Path(path); p.parent.mkdir(parents=True, exist_ok=True)
        with open(p,"w",encoding="utf-8") as f: f.write(src)
    print("pytest Ã¶rnekleri yazÄ±ldÄ± â†’ tests/")

# ------------- CLI -------------
def main():
    s=Settings.load(); log.remove(); log.add(lambda m: print(m,end=""), level=s.log_level)
    ap=argparse.ArgumentParser(description="Ultra Elite v7 â€” VWAP + Async + Calibration + Tests")
    sub=ap.add_subparsers(dest="cmd", required=True)

    pbt=sub.add_parser("backtest"); pbt.add_argument("--symbol","-s", required=True); pbt.add_argument("--lookback",type=int,default=1600)
    plv=sub.add_parser("live"); plv.add_argument("--api",action="store_true"); plv.add_argument("--port",type=int,default=8080)
    papi=sub.add_parser("api"); papi.add_argument("--port",type=int,default=8080)
    pcal=sub.add_parser("calibrate"); pcal.add_argument("--symbol","-s", required=True); pcal.add_argument("--minutes",type=int,default=10); pcal.add_argument("--qty",type=float,default=0.01); pcal.add_argument("--outfile",default=None)
    ptst=sub.add_parser("make-tests")

    args=ap.parse_args()
    ex=CcxtBinance(s); tel=_GLOBAL_TEL; risk=Risk(s.equity,s.max_risk_pct,s.max_dd,s.leverage); calib=SlippageCalibrator(s.calibration_file)
    sysobj=System.build("KamalquantX", s.lang, include=["Market","Risk","Strategy","Econ","Telemetry"])

    if args.cmd=="backtest":
        out=backtest(args.symbol, s, args.lookback); print(json.dumps(out, ensure_ascii=False, indent=2)); return

    if args.cmd=="calibrate":
        # hÄ±zlÄ± veri toplama: sÃ¼re boyunca OB Ã§ek, sentetik dolum bps Ã¼ret ve modele yaz
        t_end=time.time()+args.minutes*60
        while time.time()<t_end:
            df=ex.fetch_ohlcv_df(args.symbol, s.signal_tf, 220)
            ob=ex.orderbook(args.symbol, 50)
            spread, mid,_=book_metrics(ob)
            if mid:
                # sentetik (taker) gerÃ§ekleÅŸim: VWAP + latency kaynaklÄ± kÃ¼Ã§Ã¼k sapma
                vpx,filled=vwap_fill(ob,"buy",args.qty)
                realized_bps = abs((vpx-mid)/mid)*1e4 + (s.lat_ms/1000.0)*0.2
                calib.record_ob(ob, df, "buy", args.qty, realized_bps, s.lat_ms)
            time.sleep(1.0)
        theta=calib.fit(); 
        if args.outfile:
            calib.path=args.outfile; calib.save()
        print("Kalibrasyon tamamlandÄ±:", theta); 
        return

    if args.cmd=="make-tests":
        write_tests(); return

    engine=AsyncEngine(s, ex, tel, risk, calib)
    if args.cmd in ("api","live"):
        if args.cmd=="live": engine.start()
        run_api(sysobj, engine, port=(args.port if hasattr(args,"port") else 8080))
        return

if __name__=="__main__": main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\ultra_elite_allinone_v8.py
# ultra_elite_allinone_v8.py
# v8 = v7 + ccxt.pro WS (opsiyonel), VWAP kademeli planlayÄ±cÄ±, likiditeye gÃ¶re dinamik poz. boyutu,
# gerÃ§ek fonlama zamanlamasÄ±, maker post-only reprice dÃ¶ngÃ¼sÃ¼ + kozmik modÃ¼ller entegrasyonu.
from __future__ import annotations
import os, sys, json, time, math, uuid, asyncio, threading, importlib.util, pathlib, argparse, contextlib
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, Callable, Tuple

# pip install: python-dotenv ccxt pandas numpy jsonschema fastapi uvicorn prometheus_client loguru
from dotenv import load_dotenv
from loguru import logger as log
import pandas as pd
import numpy as np
import ccxt, jsonschema

# --- ccxt.pro (opsiyonel) ---
try:
    import ccxtpro as ccxtpro   # pip install ccxtpro  (Ã¼cretli)
    CCXTPRO_OK = True
except Exception:
    CCXTPRO_OK = False

# ---------------- i18n ----------------
I18N={"tr":{"online":"ULTRA ELÄ°T v8 AKTÄ°F","paper_on":"Paper mod: emir yok.","live_on":"CanlÄ± mod: emir gÃ¶nderilecek.",
            "bt":"Backtest {s} {tf}: trades={n} pnl={p:.2f} winrate={w:.1%}",
            "ws_on":"ccxt.pro WS aktif","ws_off":"WS kapalÄ± (REST fallback)"},
      "en":{"online":"ULTRA ELITE v8 ONLINE","paper_on":"Paper mode","live_on":"Live mode",
            "bt":"Backtest {s} {tf}: trades={n} pnl={p:.2f} winrate={w:.1%}",
            "ws_on":"ccxt.pro WS enabled","ws_off":"WS off (REST fallback)"}}
def tr(lang,k,**kw): return (I18N.get(lang) or I18N["en"]).get(k,k).format(**kw)

# ------------- schemas / registry -------------
class Health(str): OK="ok"; WARN="warn"; FAIL="fail"
@dataclass
class Metrics: init_ms:float=0.0; activate_ms:float=0.0; custom:Dict[str,float]=field(default_factory=dict)
@dataclass
class Module:
    name:str; status:str; payload:Dict[str,Any]; health:str=Health.OK; metrics:Metrics=field(default_factory=Metrics); schema:Dict[str,Any]|None=None
    def to_dict(self): return {"name":self.name,"status":self.status,"health":self.health,"metrics":asdict(self.metrics),**(self.payload or {})}
REGISTRY: Dict[str,Callable[[str,str],Module]]={}
def register(n:str):
    def deco(fn): REGISTRY[n]=fn; return fn
    return deco

SCHEMAS={
  "market":{"type":"object","required":["exchange","symbols","timeframe"],"properties":{
    "exchange":{"type":"string"},"symbols":{"type":"array","items":{"type":"string"},"minItems":1},
    "timeframe":{"type":"string"},"use_testnet":{"type":"boolean"},"use_futures":{"type":"boolean"}}},
  "risk":{"type":"object","required":["equity","max_risk_pct","max_dd","leverage"],"properties":{
    "equity":{"type":"number"},"max_risk_pct":{"type":"number"},"max_dd":{"type":"number"},"leverage":{"type":"integer"}}},
  "strategy":{"type":"object","required":["signal_tf","trend_tf","htf"],"properties":{
    "signal_tf":{"type":"string"},"trend_tf":{"type":"string"},"htf":{"type":"string"},
    "rsi_period":{"type":"integer"},"ema_fast":{"type":"integer"},"ema_slow":{"type":"integer"},
    "kdj_on":{"type":"boolean"},"wr_on":{"type":"boolean"},"trix_on":{"type":"boolean"},
    "adx_on":{"type":"boolean"},"cci_on":{"type":"boolean"},"mfi_on":{"type":"boolean"},"obv_on":{"type":"boolean"}}},
  "econ":{"type":"object","required":["taker_fee","slippage_bps"],"properties":{
    "taker_fee":{"type":"number"},"maker_fee":{"type":"number"},"slippage_bps":{"type":"number"},
    "lat_ms":{"type":"number"},"funding_rate_8h":{"type":"number"},"funding_sign":{"type":"integer"},
    "maker_allowed":{"type":"boolean"},"maker_spread_bps":{"type":"number"},"book_imbalance_th":{"type":"number"},
    "avoid_funding_min":{"type":"integer"}}},
  "telemetry":{"type":"object","required":["pnl","trades"],"properties":{"pnl":{"type":"number"},"trades":{"type":"integer"},"winrate":{"type":"number"}}}
}
def validate_payload(m:Module):
    s=m.schema or SCHEMAS.get(m.name.lower()); 
    if s: jsonschema.validate(m.payload, s)

# ------------- settings -------------
@dataclass
class Settings:
    exchange:str="BINANCE"; use_testnet:bool=True; use_futures:bool=True
    symbols:List[str]=field(default_factory=lambda:["BTC/USDT"])
    timeframe:str="1m"; signal_tf:str="1m"; trend_tf:str="15m"; htf:str="1h"
    rsi_period:int=14; ema_fast:int=21; ema_slow:int=50; atr_period:int=14
    kdj_on:bool=True; wr_on:bool=True; trix_on:bool=True; adx_on:bool=True; cci_on:bool=True; mfi_on:bool=True; obv_on:bool=True
    taker_fee:float=0.0004; maker_fee:float=0.0002; slippage_bps:float=2.0; lat_ms:float=120.0
    funding_rate_8h:float=0.0; funding_sign:int=0
    maker_allowed:bool=True; maker_spread_bps:float=0.8; book_imbalance_th:float=0.55; avoid_funding_min:int=10
    equity:float=5000.0; max_risk_pct:float=0.015; max_dd:float=0.02; leverage:int=5
    dry_run:bool=True; log_level:str="INFO"; lang:str="tr"; api_key:str=""; api_secret:str=""
    max_latency_ms:float=800.0; max_slippage_bps:float=20.0; max_positions:int=5
    tp_rr:List[float]=field(default_factory=lambda:[1.0,2.0]); tp_frac:List[float]=field(default_factory=lambda:[0.5,0.5])
    trail_be_rr:float=1.0; trail_mult:float=1.0
    use_calibration:bool=True; calibration_file:str="slip_calib.json"
    api_key_header:str="secret123"
    # v8 ekleri
    use_ccxtpro:bool=True
    max_book_usage:float=0.08          # derinlik miktarÄ±nÄ±n en fazla %8'i kadar tÃ¼ket
    vwap_slice_min:float=0.001         # minimum slice miktarÄ± (contract/coin)
    vwap_slice_delay_ms:int=250        # slice arasÄ± bekleme
    maker_reprice_sec:int=6            # kaÃ§ saniyede bir reprice
    maker_reprice_steps:int=10         # max repricing sayÄ±sÄ±
    maker_grid_levels:int=3            # kaÃ§ seviyeye grid post-only emir
    max_price_dev_bps:float=15.0       # mid fiyatÄ±ndan kaÃ§ bps sapma sÄ±nÄ±rÄ±
    use_real_funding:bool=True         # borsadan nextFundingTime okumayÄ± dene

    @staticmethod
    def _b(k,d): return os.getenv(k,str(d)).lower()=="true"
    @staticmethod
    def _f(k,d):
        try: return float(os.getenv(k,str(d)))
        except: return d
    @staticmethod
    def load()->"Settings":
        load_dotenv(override=True)
        syms=[x.strip() for x in os.getenv("SYMBOLS","BTC/USDT").split(",") if x.strip()]
        return Settings(
            exchange=os.getenv("EXCHANGE","BINANCE").upper(),
            use_testnet=Settings._b("USE_TESTNET",True), use_futures=Settings._b("USE_FUTURES",True),
            symbols=syms, timeframe=os.getenv("TIMEFRAME","1m"),
            signal_tf=os.getenv("SIGNAL_TF","1m"), trend_tf=os.getenv("TREND_TF","15m"), htf=os.getenv("HTF","1h"),
            rsi_period=int(os.getenv("RSI_PERIOD","14")), ema_fast=int(os.getenv("EMA_FAST","21")), ema_slow=int(os.getenv("EMA_SLOW","50")),
            atr_period=int(os.getenv("ATR_PERIOD","14")), kdj_on=Settings._b("KDJ_ON",True), wr_on=Settings._b("WR_ON",True),
            trix_on=Settings._b("TRIX_ON",True), adx_on=Settings._b("ADX_ON",True), cci_on=Settings._b("CCI_ON",True),
            mfi_on=Settings._b("MFI_ON",True), obv_on=Settings._b("OBV_ON",True),
            taker_fee=Settings._f("TAKER_FEE",0.0004), maker_fee=Settings._f("MAKER_FEE",0.0002),
            slippage_bps=Settings._f("SLIPPAGE_BPS",2.0), lat_ms=Settings._f("LAT_MS",120.0),
            funding_rate_8h=Settings._f("FUNDING_RATE_8H",0.0), funding_sign=int(os.getenv("FUNDING_SIGN","0")),
            maker_allowed=Settings._b("MAKER_ALLOWED",True), maker_spread_bps=Settings._f("MAKER_SPREAD_BPS",0.8),
            book_imbalance_th=Settings._f("BOOK_IMBALANCE_TH",0.55), avoid_funding_min=int(os.getenv("AVOID_FUNDING_MIN","10")),
            equity=Settings._f("ACCOUNT_EQUITY",5000), max_risk_pct=Settings._f("MAX_RISK_PCT_PER_TRADE",0.015),
            max_dd=Settings._f("MAX_DAILY_DRAWDOWN",0.02), leverage=int(os.getenv("LEVERAGE","5")),
            dry_run=Settings._b("DRY_RUN",True), log_level=os.getenv("LOG_LEVEL","INFO").upper(),
            lang=os.getenv("LANG","tr").lower(), api_key=os.getenv("BINANCE_API_KEY",""), api_secret=os.getenv("BINANCE_API_SECRET",""),
            max_latency_ms=Settings._f("MAX_LATENCY_MS",800), max_slippage_bps=Settings._f("MAX_SLIPPAGE_BPS",20),
            max_positions=int(os.getenv("MAX_POSITIONS","5")),
            tp_rr=[Settings._f("TP1_RR",1.0), Settings._f("TP2_RR",2.0)],
            tp_frac=[Settings._f("TP1_FRAC",0.5), Settings._f("TP2_FRAC",0.5)],
            trail_be_rr=Settings._f("TRAIL_BE_RR",1.0), trail_mult=Settings._f("TRAIL_MULT",1.0),
            use_calibration=Settings._b("USE_CALIBRATION",True), calibration_file=os.getenv("CALIBRATION_FILE","slip_calib.json"),
            api_key_header=os.getenv("API_KEY","secret123"),
            use_ccxtpro=Settings._b("USE_CCXTPRO",True),
            max_book_usage=Settings._f("MAX_BOOK_USAGE",0.08),
            vwap_slice_min=Settings._f("VWAP_SLICE_MIN",0.001),
            vwap_slice_delay_ms=int(Settings._f("VWAP_SLICE_DELAY_MS",250)),
            maker_reprice_sec=int(Settings._f("MAKER_REPRICE_SEC",6)),
            maker_reprice_steps=int(Settings._f("MAKER_REPRICE_STEPS",10)),
            maker_grid_levels=int(Settings._f("MAKER_GRID_LEVELS",3)),
            max_price_dev_bps=Settings._f("MAX_PRICE_DEV_BPS",15.0),
            use_real_funding=Settings._b("USE_REAL_FUNDING",True),
        )

# ------------- indicators -------------
def ema(s:pd.Series,p:int)->pd.Series: return s.ewm(span=p,adjust=False).mean()
def tr_series(df): 
    return pd.concat([(df["high"]-df["low"]),
                      (df["high"]-df["close"].shift()).abs(),
                      (df["low"]-df["close"].shift()).abs()],axis=1).max(axis=1)
def atr(df,p): return tr_series(df).rolling(p).mean()
def stochastic(df,k=9,d=3):
    lo=df["low"].rolling(k).min(); hi=df["high"].rolling(k).max()
    K=100*(df["close"]-lo)/(hi-lo); D=K.rolling(d).mean(); J=3*K-2*D
    return K.clip(0,100),D.clip(0,100),J.clip(0,100)
def williams_r(df,lbp=14):
    lo=df["low"].rolling(lbp).min(); hi=df["high"].rolling(lbp).max()
    return (-100*(hi-df["close"])/(hi-lo)).clip(-100,0)
def trix(df,p=9):
    e1=df["close"].ewm(span=p,adjust=False).mean()
    e2=e1.ewm(span=p,adjust=False).mean()
    e3=e2.ewm(span=p,adjust=False).mean()
    return 100*(e3.diff()/e3.shift())
def adx(df,period=14):
    up=df["high"].diff(); dn=-df["low"].diff()
    plus=(up.where((up>dn)&(up>0),0.0)).fillna(0.0)
    minus=(dn.where((dn>up)&(dn>0),0.0)).fillna(0.0)
    tr=tr_series(df).fillna(0.0); atr_rma=tr.ewm(alpha=1/period,adjust=False).mean()
    pdi=100*(plus.ewm(alpha=1/period,adjust=False).mean()/atr_rma)
    mdi=100*(minus.ewm(alpha=1/period,adjust=False).mean()/atr_rma)
    dx=(100*(pdi-mdi).abs()/(pdi+mdi).replace(0,np.nan)).fillna(0.0)
    return dx.ewm(alpha=1/period,adjust=False).mean()
def supertrend(df,period=10,mult=3.0):
    hl2=(df["high"]+df["low"])/2.0; a=atr(df,period)
    up=hl2+mult*a; lo=hl2-mult*a
    st=pd.Series(index=df.index,dtype=float); trd=pd.Series(index=df.index,dtype=int)
    for i in range(len(df)):
        if i==0: st.iloc[i]=up.iloc[i]; trd.iloc[i]=1; continue
        up.iloc[i]=min(up.iloc[i],up.iloc[i-1]) if df["close"].iloc[i-1]<=up.iloc[i-1] else up.iloc[i]
        lo.iloc[i]=max(lo.iloc[i],lo.iloc[i-1]) if df["close"].iloc[i-1]>=lo.iloc[i-1] else lo.iloc[i]
        if df["close"].iloc[i]>up.iloc[i-1]: trd.iloc[i]=1
        elif df["close"].iloc[i]<lo.iloc[i-1]: trd.iloc[i]=-1
        else: trd.iloc[i]=trd.iloc[i-1]
        st.iloc[i]=lo.iloc[i] if trd.iloc[i]==1 else up.iloc[i]
    return st,trd

# ------------- MTF sinyal -------------
@dataclass
class Signal: side:str|None=None; price:float|None=None; stop:float|None=None; atrv:float|None=None; reason:str=""; conf:float=0.0
def core_signal(df:pd.DataFrame,s:Settings)->Signal:
    px=float(df["close"].iloc[-1]); e1,e2=ema(df["close"],s.ema_fast),ema(df["close"],s.ema_slow)
    st,_=supertrend(df,s.atr_period,3.0); a=float(atr(df,s.atr_period).iloc[-1] or 0.0)
    ch=df["close"].diff(); g=ch.clip(lower=0).rolling(s.rsi_period).mean(); l=(-ch.clip(upper=0)).rolling(s.rsi_period).mean()
    rsi=100-100/(1+(g/(l.replace(0,np.nan))))
    K,D,J=stochastic(df); WR=williams_r(df); TR=trix(df,s.atr_period); TRs=TR.ewm(span=s.atr_period,adjust=False).mean()
    long_core=(e1.iloc[-1]>e2.iloc[-1]) and (px>st.iloc[-1]); short_core=(e1.iloc[-1]<e2.iloc[-1]) and (px<st.iloc[-1])
    L=long_core; S=short_core; conf=0.0; rs=[]
    if rsi.iloc[-2]<30 and rsi.iloc[-1]>=30 and long_core: L=True; conf+=0.15; rs.append("RSIâ†‘30")
    if rsi.iloc[-2]>70 and rsi.iloc[-1]<=70 and short_core: S=True; conf+=0.15; rs.append("RSIâ†“70")
    if s.kdj_on:
        if K.iloc[-2]<D.iloc[-2] and K.iloc[-1]>D.iloc[-1] and K.iloc[-1]<40: L=True; conf+=0.2; rs.append("KDJâ†‘")
        if K.iloc[-2]>D.iloc[-2] and K.iloc[-1]<D.iloc[-1] and K.iloc[-1]>60: S=True; conf+=0.2; rs.append("KDJâ†“")
    if s.wr_on:
        if WR.iloc[-1]<=-80: L=True; conf+=0.1; rs.append("WRâ‰¤-80")
        if WR.iloc[-1]>=-20: S=True; conf+=0.1; rs.append("WRâ‰¥-20")
    if s.trix_on:
        if TR.iloc[-2]<TRs.iloc[-2] and TR.iloc[-1]>TRs.iloc[-1]: L=True; conf+=0.1; rs.append("TRIXâ†‘")
        if TR.iloc[-2]>TRs.iloc[-2] and TR.iloc[-1]<TRs.iloc[-1]: S=True; conf+=0.1; rs.append("TRIXâ†“")
    if L and not S: return Signal("buy",px,float(st.iloc[-1]),a,"+".join(rs or ["core_up"]),conf)
    if S and not L: return Signal("sell",px,float(st.iloc[-1]),a,"+".join(rs or ["core_dn"]),conf)
    return Signal()
def mom_bias(df:pd.DataFrame,s:Settings)->Tuple[bool,bool]:
    e1,e2=ema(df["close"],s.ema_fast),ema(df["close"],s.ema_slow); ad=adx(df,14).iloc[-1] if s.adx_on else 25
    return (e1.iloc[-1]>e2.iloc[-1]) and ad>=18, (e1.iloc[-1]<e2.iloc[-1]) and ad>=18
def htf_bias(df:pd.DataFrame)->Tuple[bool,bool]:
    sma200=df["close"].rolling(200).mean()
    if len(df)<202: return False,False
    return sma200.iloc[-1]>sma200.iloc[-2], sma200.iloc[-1]<sma200.iloc[-2]
def ensemble_mtf(sig_df, tr_df, h_df, s:Settings)->Signal:
    c=core_signal(sig_df,s)
    if not c.side: return c
    t_up,t_dn=mom_bias(tr_df,s); h_up,h_dn=htf_bias(h_df)
    if c.side=="buy" and t_up and h_up: c.conf=min(1.0,c.conf+0.3); c.reason+="|MTF++"; return c
    if c.side=="sell" and t_dn and h_dn: c.conf=min(1.0,c.conf+0.3); c.reason+="|MTF--"; return c
    return Signal()

# ------------- CCXT adapter + WS + OB/VWAP -------------
class CcxtBinance:
    def __init__(self,s:Settings):
        self.s=s
        self.ex=(ccxt.binanceusdm if s.use_futures else ccxt.binance)({"apiKey":s.api_key,"secret":s.api_secret,"enableRateLimit":True})
        if s.use_testnet:
            with contextlib.suppress(Exception):
                self.ex.set_sandbox_mode(True)
        # pro
        self.pro = None
        if s.use_ccxtpro and CCXTPRO_OK:
            self.pro=(ccxtpro.binanceusdm() if s.use_futures else ccxtpro.binance())
            self.pro.apiKey=self.s.api_key; self.pro.secret=self.s.api_secret
            if s.use_testnet:
                with contextlib.suppress(Exception):
                    self.pro.set_sandbox_mode(True)

    # ----- REST -----
    def fetch_ohlcv_df(self,sym,tf,limit=500):
        raw=self.ex.fetch_ohlcv(sym, timeframe=tf, limit=limit)
        df=pd.DataFrame(raw,columns=["ts","open","high","low","close","volume"])
        df["ts"]=pd.to_datetime(df["ts"],unit="ms",utc=True); return df.set_index("ts")
    def orderbook(self,sym,limit=50):
        with contextlib.suppress(Exception):
            return self.ex.fetch_order_book(sym,limit=limit)
        return {"bids":[],"asks":[]}
    def fetch_funding_rate(self,sym)->Tuple[float,Optional[int]]:
        # ccxt: fetchFundingRate returns dict with nextFundingTime if supported
        with contextlib.suppress(Exception):
            fr = self.ex.fetchFundingRate(sym)
            return float(fr.get("fundingRate") or 0.0), fr.get("nextFundingTime")
        return 0.0, None
    def place(self,sym,side,qty,price=None,post_only=False):
        if self.s.dry_run:
            log.info(f"WOULD {side.upper()} {qty} {sym} @ {price or 'MARKET'}{' [POST]' if post_only else ''}")
            return {"sim":True,"id":f"sim-{time.time()}"}
        params={}
        if post_only: params.update({"postOnly":True,"timeInForce":"GTX"})
        typ="limit" if price else "market"
        return self.ex.create_order(sym, type=typ, side=side, amount=qty, price=price, params=params)
    def cancel(self, sym, order_id):
        if self.s.dry_run: 
            log.info(f"WOULD CANCEL {order_id} {sym}")
            return {"sim":True}
        with contextlib.suppress(Exception):
            return self.ex.cancel_order(order_id, sym)
        return None

    # ----- PRO (WS) -----
    async def watch_order_book(self, sym, limit=50):
        if not self.pro: return self.orderbook(sym, limit)
        try:
            ob = await self.pro.watch_order_book(sym, limit)
            # normalize to ccxt REST-like dict
            return {"bids":ob["bids"], "asks":ob["asks"]}
        except Exception as e:
            log.warning(f"WS OB fallback: {e}")
            return self.orderbook(sym, limit)
    async def watch_ohlcv_df(self, sym, tf, limit=220):
        if not self.pro: 
            return self.fetch_ohlcv_df(sym, tf, limit)
        try:
            ohlcv = await self.pro.watch_ohlcv(sym, tf, limit)
            df=pd.DataFrame(ohlcv,columns=["ts","open","high","low","close","volume"])
            df["ts"]=pd.to_datetime(df["ts"],unit="ms",utc=True); return df.set_index("ts")
        except Exception as e:
            log.warning(f"WS OHLCV fallback: {e}")
            return self.fetch_ohlcv_df(sym, tf, limit)
    async def close(self):
        if self.pro:
            with contextlib.suppress(Exception):
                await self.pro.close()

# VWAP dolum simÃ¼lasyonu ve planlayÄ±cÄ±
def vwap_fill(ob:dict, side:str, qty:float)->Tuple[float,float]:
    lvls = ob["asks"] if side=="buy" else ob["bids"]
    if not lvls: return (0.0, 0.0)
    need=qty; cost=0.0; vol=0.0
    for px, avail in lvls:
        take=min(need, float(avail))
        cost+=take*float(px); vol+=take; need-=take
        if need<=1e-12: break
    if vol<=0: return (0.0, 0.0)
    return (cost/vol, vol)

def plan_vwap_slices(ob:dict, side:str, qty:float, min_slice:float)->List[Tuple[float,float]]:
    """OB Ã¼zerinden hedef qty kadar kademeli taker/limit slice planÄ± dÃ¶ner."""
    lvls = ob["asks"] if side=="buy" else ob["bids"]
    out=[]; left=qty
    for px, avail in lvls:
        if left<=1e-12: break
        take=min(left, max(min_slice, float(avail)*0.9))  # seviyenin %90'Ä±
        out.append((float(px), take))
        left -= take
    if left>1e-12: out.append((lvls[-1][0], left))
    return out

def book_metrics(ob)->Tuple[float,float,float,float,float]:
    if not ob["bids"] or not ob["asks"]: return 0.0,0.0,0.5,0.0,0.0
    bb=ob["bids"][0][0]; ba=ob["asks"][0][0]; mid=(bb+ba)/2.0; spread=ba-bb
    spread_bps=(spread/mid*1e4) if mid else 0.0
    bidv=sum([b[1] for b in ob["bids"][:10]]); askv=sum([a[1] for a in ob["asks"][:10]])
    imb= bidv/(bidv+askv) if (bidv+askv)>0 else 0.5
    depth10 = (askv if askv>0 else bidv)
    return spread_bps, mid, imb, bidv, askv

# ------------- Slippage Calibrator (basit OLS) -------------
class SlippageCalibrator:
    def __init__(self, path:str):
        self.path=path; self.X=[]; self.y=[]; self.theta=None; self.load()
    def featurize(self, spread_bps:float, depth_qty:float, atr_pct:float, latency_ms:float)->List[float]:
        return [1.0, spread_bps, depth_qty, atr_pct*1e4, latency_ms/1000.0]
    def record_ob(self, ob:dict, df:pd.DataFrame, side:str, qty:float, realized_fill_bps:float, latency_ms:float):
        spread, mid, _, bidv, askv = book_metrics(ob)
        depth_qty = ((askv if side=="buy" else bidv) or 1.0) / max(qty,1e-9)
        atrp = float((atr(df,14).iloc[-1] or 0.0)/max(1e-9, float(df["close"].iloc[-1])))
        self.X.append(self.featurize(spread, depth_qty, atrp, latency_ms)); self.y.append(realized_fill_bps)
    def fit(self):
        if len(self.X)<8: return None
        X=np.array(self.X); y=np.array(self.y)
        self.theta=np.linalg.lstsq(X, y, rcond=None)[0].tolist(); self.save(); return self.theta
    def predict(self, ob:dict, df:pd.DataFrame, side:str, qty:float, latency_ms:float)->float:
        if not self.theta: return 0.0
        spread, mid, _, bidv, askv = book_metrics(ob)
        depth_qty = ((askv if side=="buy" else bidv) or 1.0) / max(qty,1e-9)
        atrp = float((atr(df,14).iloc[-1] or 0.0)/max(1e-9, float(df["close"].iloc[-1])))
        x=np.array(self.featurize(spread, depth_qty, atrp, latency_ms))
        return float(np.dot(x, np.array(self.theta)))
    def save(self):
        with contextlib.suppress(Exception):
            with open(self.path,"w",encoding="utf-8") as f: json.dump({"theta":self.theta,"n":len(self.X)}, f, ensure_ascii=False, indent=2)
    def load(self):
        with contextlib.suppress(Exception):
            with open(self.path,"r",encoding="utf-8") as f:
                data=json.load(f); self.theta=data.get("theta")

# ------------- Risk / Telemetry -------------
@dataclass
class Risk:
    equity:float; max_risk_pct:float; max_dd:float; leverage:int
    day_pnl:float=0.0; day:str|None=None; losing:int=0; trades:int=0; kill:bool=False
    def roll(self):
        d=datetime.utcnow().date().isoformat()
        if self.day!=d: self.day=d; self.day_pnl=0.0; self.losing=0; self.trades=0; self.kill=False
    def size(self, entry:float, stop:float|None, ob:dict, side:str, s:Settings)->float:
        """Risk tabanlÄ± qty, ayrÄ±ca likidite tabanlÄ± tavan uygular."""
        if self.kill: return 0.0
        if stop is None: stop=entry*0.995
        risk_amt=self.equity*self.max_risk_pct
        dist=max(1e-9, abs(entry-stop))
        qty_risk = max(0.0, risk_amt/dist)
        _, _, _, bidv, askv = book_metrics(ob)
        depth = (askv if side=="buy" else bidv) or 0.0
        qty_liq = depth * s.max_book_usage
        qty = round(max(0.0, min(qty_risk, qty_liq)), 6)
        return qty
    def update(self, pnl:float, s:Settings):
        self.roll(); self.day_pnl+=pnl; self.trades+=1; self.losing = 0 if pnl>0 else self.losing+1
        if self.day_pnl <= -self.equity*s.max_dd or self.losing>=5: self.kill=True
@dataclass
class Telemetry:
    pnl:float=0.0; trades:int=0; wins:int=0; latency_ms:float=0.0; paused:str=""
    def winrate(self): return (self.wins/self.trades) if self.trades else 0.0
    def payload(self)->Dict[str,Any]: return {"pnl":self.pnl,"trades":self.trades,"winrate":self.winrate(),"latency_ms":self.latency_ms,"paused":self.paused}

# ------------- utils -------------
def tfsec(tf:str)->int: u=tf[-1]; v=int(tf[:-1]); return {"s":1,"m":60,"h":3600,"d":86400,"w":604800}.get(u,60)*v
def fill_price(px,side,slip_bps): slip=px*(slip_bps/1e4); return px+slip if side=="buy" else px-slip
def commission(notional,fee): return abs(notional)*fee
def slot_id(ts:pd.Timestamp)->int: return int(ts.timestamp()//(8*3600))
def around_funding(ts:pd.Timestamp, minutes:int)->bool:
    m=ts.hour*60+ts.minute
    for b in (0,480,960):
        if abs(m-b)<=minutes: return True
    return False
def funding_due(prev:pd.Timestamp, now:pd.Timestamp)->bool: return slot_id(prev)!=slot_id(now)

# ------------- Slipaj modeli (kalibrasyonlu) -------------
def modeled_slippage_bps(df:pd.DataFrame, s:Settings, ob:dict|None, side:str, qty:float, calib:SlippageCalibrator|None)->float:
    if ob and calib and s.use_calibration and calib.theta:
        return max(0.0, calib.predict(ob, df, side, qty, s.lat_ms))
    if ob and ob.get("bids") and ob.get("asks"):
        spread_bps,_,_,_,_=book_metrics(ob); base=s.slippage_bps
        return min(s.max_slippage_bps, base + max(0.0,0.7*spread_bps) + 0.25*(s.lat_ms/1000.0))
    vol=float((atr(df, s.atr_period).iloc[-1] or 0.0)/max(1e-9, float(df["close"].iloc[-1])))
    return min(s.max_slippage_bps, s.slippage_bps + 180*vol + 0.25*(s.lat_ms/1000.0))

# ------------- GerÃ§ek fonlama zamanlamasÄ± -------------
def next_funding_ts(ex:CcxtBinance, symbol:str, now_utc:datetime, s:Settings)->datetime:
    if s.use_real_funding:
        fr, nft = ex.fetch_funding_rate(symbol)
        if nft:
            try:
                return datetime.fromtimestamp(int(nft)/1000, tz=timezone.utc)
            except Exception:
                pass
    # fallback 8h slot
    base = int(now_utc.timestamp()//(8*3600))*8*3600
    nxt = base + 8*3600
    return datetime.fromtimestamp(nxt, tz=timezone.utc)

# ------------- Maker reprice dÃ¶ngÃ¼sÃ¼ -------------
async def maker_reprice_loop(ex:CcxtBinance, sym:str, side:str, qty:float, s:Settings, steps:int, sec:int):
    """Post-only emri dÃ¼zenli aralÄ±klarla en iyi fiyata yakÄ±n reprice eder."""
    last_id=None
    for i in range(steps):
        ob = await ex.watch_order_book(sym, 20) if ex.pro else ex.orderbook(sym,20)
        spread_bps, mid, imb, _, _ = book_metrics(ob)
        if mid==0: await asyncio.sleep(sec); continue
        price = mid*(1 - spread_bps/2/1e4) if side=="buy" else mid*(1 + spread_bps/2/1e4)
        if last_id: 
            with contextlib.suppress(Exception):
                ex.cancel(sym, last_id)
        r = ex.place(sym, side, qty, price=price, post_only=True); last_id=r.get("id")
        await asyncio.sleep(sec)

# ------------- Async PortfÃ¶y Motoru + WS -------------
class AsyncEngine:
    def __init__(self, s:Settings, ex:CcxtBinance, tel:Telemetry, risk:Risk, calib:SlippageCalibrator):
        self.s=s; self.ex=ex; self.tel=tel; self.risk=risk; self.calib=calib
        self.running=False
        self.pos:Dict[str,dict]={}
        self.next_funding:Dict[str,datetime]={}

    async def _fetch_mtf(self, sym:str):
        if self.ex.pro:
            sig = await self.ex.watch_ohlcv_df(sym, self.s.signal_tf, 220)
        else:
            sig = self.ex.fetch_ohlcv_df(sym, self.s.signal_tf, 220)
        trd = self.ex.fetch_ohlcv_df(sym, self.s.trend_tf, 220)
        htf = self.ex.fetch_ohlcv_df(sym, self.s.htf, 220)
        ob  = await self.ex.watch_order_book(sym, 50) if self.ex.pro else self.ex.orderbook(sym, 50)
        return sig, trd, htf, ob

    def _maker_choice(self, side:str, ob:dict, conf:float)->Tuple[bool,float,float]:
        spread_bps, mid, imb, _, _ = book_metrics(ob)
        maker_ok=self.s.maker_allowed and spread_bps<=self.s.maker_spread_bps
        if side=="buy" and imb>self.s.book_imbalance_th: maker_ok=True
        if side=="sell" and (1-imb)>self.s.book_imbalance_th: maker_ok=True
        if conf>=0.7: maker_ok=False
        return maker_ok, mid, spread_bps

    async def _process_symbol(self, sym:str):
        sig_df, tr_df, h_df, ob = await self._fetch_mtf(sym)
        now=sig_df.index[-1].to_pydatetime()
        if sym not in self.next_funding or now>=self.next_funding[sym]:
            self.next_funding[sym]=next_funding_ts(self.ex, sym, now, self.s)

        # funding penceresinden kaÃ§Ä±n
        if around_funding(sig_df.index[-1], self.s.avoid_funding_min) or (now>=self.next_funding[sym] and (now-self.next_funding[sym]).seconds<=self.s.avoid_funding_min*60):
            self.tel.paused="FUNDING_WINDOW"; return
        if self.risk.kill: self.tel.paused="KILL"; return

        sig=ensemble_mtf(sig_df, tr_df, h_df, self.s)
        px=float(sig_df["close"].iloc[-1]); p=self.pos.get(sym)
        # pozisyon aÃ§Ä±kken slot geÃ§iÅŸinde fonlama
        if p and now>=self.next_funding[sym] and self.s.funding_rate_8h!=0 and self.s.funding_sign!=0:
            fee = (px*p["qty"])*self.s.funding_rate_8h*self.s.funding_sign
            self.tel.pnl-=fee; self.risk.update(-fee, self.s)
            self.next_funding[sym]=next_funding_ts(self.ex, sym, now, self.s)

        if not p and sig.side:
            # qty = risk + likidite tavanÄ±
            qty = self.risk.size(sig.price or px, sig.stop, ob, sig.side, self.s)
            if qty<=0 or len(self.pos)>=self.s.max_positions: return

            # slipaj tahmini
            slip_bps = modeled_slippage_bps(sig_df, self.s, ob, sig.side, qty, self.calib)
            if slip_bps>self.s.max_slippage_bps: return

            maker, mid, spread = self._maker_choice(sig.side, ob, sig.conf)
            # maker grid (post-only) + reprice dÃ¶ngÃ¼sÃ¼
            if maker and mid>0:
                grid=[]
                for i in range(self.s.maker_grid_levels):
                    off = (i+1)* (spread/(self.s.maker_grid_levels+1))/1e4
                    price = mid*(1 - off) if sig.side=="buy" else mid*(1 + off)
                    grid.append(price)
                slice_qty = max(self.s.vwap_slice_min, qty/len(grid))
                for price in grid:
                    self.ex.place(sym, sig.side, slice_qty, price=price, post_only=True)
                # arka planda dÃ¼zenli reprice
                asyncio.create_task(maker_reprice_loop(self.ex, sym, sig.side, slice_qty, self.s, self.s.maker_reprice_steps, self.s.maker_reprice_sec))
                ep = grid[0]  # tahmini giriÅŸ
            else:
                # taker VWAP slicing
                plan = plan_vwap_slices(ob, sig.side, qty, self.s.vwap_slice_min)
                filled_px=0.0; filled_qty=0.0
                for price, q in plan:
                    # mid sapma kontrolÃ¼
                    _, mid, _, _, _ = book_metrics(ob)
                    if mid and abs(price-mid)/mid*1e4 > self.s.max_price_dev_bps: break
                    self.ex.place(sym, sig.side, q)  # market/taker
                    filled_px += price*q; filled_qty += q
                    await asyncio.sleep(self.s.vwap_slice_delay_ms/1000.0)
                ep = (filled_px/filled_qty) if filled_qty>0 else px

            ep = fill_price(ep, sig.side, slip_bps)
            atrv = sig.atrv or float(atr(sig_df, self.s.atr_period).iloc[-1] or 0.0)
            self.pos[sym]={"side":sig.side,"entry":ep,"qty":qty,"atr":atrv,"best":ep,
                           "stop":sig.stop or (ep*0.995 if sig.side=='buy' else ep*1.005),
                           "tp":[ep+(rr*atrv)*(1 if sig.side=='buy' else -1) for rr in self.s.tp_rr],
                           "tp_frac":self.s.tp_frac.copy(),"filled":[False]*len(self.s.tp_rr)}
            self.tel.trades+=1
            return

        if p:
            # trailing, TP
            if p["side"]=="buy": p["best"]=max(p["best"],px)
            else: p["best"]=min(p["best"],px)
            new_stop = (max(p["entry"], p["best"]-self.s.trail_mult*p["atr"]) if p["side"]=="buy"
                        else min(p["entry"], p["best"]+self.s.trail_mult*p["atr"]))
            if p["side"]=="buy": p["stop"]=max(p["stop"], new_stop)
            else: p["stop"]=min(p["stop"], new_stop)

            for i,lvl in enumerate(p["tp"]):
                if p["filled"][i]: continue
                hit = (px>=lvl) if p["side"]=="buy" else (px<=lvl)
                if hit:
                    part=p["tp_frac"][i]*p["qty"]
                    self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", part)
                    unit=(lvl-p["entry"])*(1 if p["side"]=="buy" else -1)
                    self.tel.pnl += unit*(part/p["qty"]); p["qty"]-=part; p["filled"][i]=True

            stop_hit = (px<=p["stop"]) if p["side"]=="buy" else (px>=p["stop"])
            if stop_hit or p["qty"]<=1e-9:
                self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", p["qty"])
                pnl=(px - p["entry"])*(1 if p["side"]=="buy" else -1)
                self.tel.pnl+=pnl; self.risk.update(pnl, self.s); self.tel.wins+=1 if pnl>0 else 0; self.pos.pop(sym,None); return

            # ters sinyal -> flip
            rs=ensemble_mtf(sig_df, tr_df, h_df, self.s)
            if rs.side and ((p["side"]=="buy" and rs.side=="sell") or (p["side"]=="sell" and rs.side=="buy")):
                self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", p["qty"])
                pnl=(px - p["entry"])*(1 if p["side"]=="buy" else -1)
                self.tel.pnl+=pnl; self.risk.update(pnl, self.s); self.tel.wins+=1 if pnl>0 else 0; self.pos.pop(sym,None)

    async def _loop(self):
        log.info(tr(self.s.lang,"online"))
        log.info(tr(self.s.lang,"ws_on") if self.ex.pro else tr(self.s.lang,"ws_off"))
        log.warning(tr(self.s.lang,"paper_on") if self.s.dry_run else tr(self.s.lang,"live_on"))
        while self.running:
            t0=time.perf_counter()
            try:
                await asyncio.gather(*(self._process_symbol(sym) for sym in self.s.symbols))
            except Exception as e:
                log.error(f"[async] {e}")
            self.tel.latency_ms=(time.perf_counter()-t0)*1000
            await asyncio.sleep(max(1, tfsec(self.s.signal_tf)//4))

    def start(self):
        if self.running: return
        self.running=True
        def runner(): asyncio.run(self._loop())
        threading.Thread(target=runner, daemon=True).start()
    def stop(self): self.running=False

# ------------- Backtest (VWAP destekli) -------------
def backtest(symbol:str, s:Settings, lookback:int=1600)->Dict[str,Any]:
    ex=CcxtBinance(s); sig=ex.fetch_ohlcv_df(symbol,s.signal_tf,lookback); trd=ex.fetch_ohlcv_df(symbol,s.trend_tf,lookback); htf=ex.fetch_ohlcv_df(symbol,s.htf,lookback)
    pnl=0.0; trades=0; wins=0; pos=None
    for i in range(220,len(sig)):
        ws=sig.iloc[:i+1]; tt=trd.loc[trd.index<=ws.index[-1]]; hh=htf.loc[htf.index<=ws.index[-1]]
        if len(tt)<1 or len(hh)<1: continue
        sg=ensemble_mtf(ws,tt,hh,s); px=float(ws["close"].iloc[-1]); ob=ex.orderbook(symbol,50)
        if not pos and sg.side:
            atrv=sg.atrv or float(atr(ws,s.atr_period).iloc[-1] or 0.0)
            depth_qty = (sum([l[1] for l in (ob["asks"] if sg.side=="buy" else ob["bids"])[:10]]) or 1.0)
            qty_liq = depth_qty * s.max_book_usage
            risk_amt=s.equity*s.max_risk_pct; dist=max(1e-9, abs((sg.price or px)-(sg.price or px)-(atrv*1)))  # kabaca
            qty_risk=max(0.0, risk_amt/max(1e-6, atrv))
            qty=max(0.0, min(qty_liq, qty_risk))
            if qty<=0: continue
            vpx, filled = vwap_fill(ob, sg.side, qty)
            entry = vpx or px
            trades+=1
            pos={"side":sg.side,"entry":entry,"qty":qty,"atr":atrv,"best":entry,
                 "stop":sg.stop or (entry*0.995 if sg.side=='buy' else entry*1.005),
                 "tp":[entry+(rr*atrv)*(1 if sg.side=='buy' else -1) for rr in s.tp_rr],
                 "tp_frac":s.tp_frac.copy(),"filled":[False]*len(s.tp_rr)}
            continue
        if pos:
            if pos["side"]=="buy": pos["best"]=max(pos["best"],px)
            else: pos["best"]=min(pos["best"],px)
            new_stop=(max(pos["entry"], pos["best"]-s.trail_mult*pos["atr"]) if pos["side"]=="buy"
                      else min(pos["entry"], pos["best"]+s.trail_mult*pos["atr"]))
            if pos["side"]=="buy": pos["stop"]=max(pos["stop"], new_stop)
            else: pos["stop"]=min(pos["stop"], new_stop)
            for j,lvl in enumerate(pos["tp"]):
                if pos["filled"][j]: continue
                if (px>=lvl and pos["side"]=="buy") or (px<=lvl and pos["side"]=="sell"):
                    part=pos["tp_frac"][j]*pos["qty"]; unit=(lvl - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                    pnl += unit*(part/pos["qty"]); pos["qty"]-=part; pos["filled"][j]=True
            stop_hit = (px<=pos["stop"]) if pos["side"]=="buy" else (px>=pos["stop"])
            if stop_hit or pos["qty"]<=1e-9:
                unit=(pos["stop"] - pos["entry"])*(1 if pos["side"]=="buy" else -1); pnl+=unit; wins+=1 if unit>0 else 0; pos=None
                continue
            rs=ensemble_mtf(ws,tt,hh,s)
            if rs.side and ((pos["side"]=="buy" and rs.side=="sell") or (pos["side"]=="sell" and rs.side=="buy")):
                unit=(px - pos["entry"])*(1 if pos["side"]=="buy" else -1); pnl+=unit; wins+=1 if unit>0 else 0; pos=None
    win=wins/trades if trades else 0.0; log.success(tr(s.lang,"bt"), s=symbol, tf=s.signal_tf, n=trades, p=pnl, w=win)
    return {"trades":trades,"pnl":pnl,"winrate":win}

# ------------- registry -------------
@register("Market")
def mod_market(name,lang):
    s=Settings.load(); m=Module("Market","ok",{"exchange":s.exchange,"symbols":s.symbols,"timeframe":s.timeframe,
                                               "use_testnet":s.use_testnet,"use_futures":s.use_futures},schema=SCHEMAS["market"]); validate_payload(m); return m
@register("Risk")
def mod_risk(name,lang):
    s=Settings.load(); m=Module("Risk","ok",{"equity":s.equity,"max_risk_pct":s.max_risk_pct,"max_dd":s.max_dd,"leverage":s.leverage},schema=SCHEMAS["risk"]); validate_payload(m); return m
@register("Strategy")
def mod_strat(name,lang):
    s=Settings.load(); pay={"signal_tf":s.signal_tf,"trend_tf":s.trend_tf,"htf":s.htf,"rsi_period":s.rsi_period,"ema_fast":s.ema_fast,"ema_slow":s.ema_slow,
                            "kdj_on":s.kdj_on,"wr_on":s.wr_on,"trix_on":s.trix_on,"adx_on":s.adx_on,"cci_on":s.cci_on,"mfi_on":s.mfi_on,"obv_on":s.obv_on}
    m=Module("Strategy","ok",pay,schema=SCHEMAS["strategy"]); validate_payload(m); return m
@register("Econ")
def mod_econ(name,lang):
    s=Settings.load(); pay={"taker_fee":s.taker_fee,"maker_fee":s.maker_fee,"slippage_bps":s.slippage_bps,"lat_ms":s.lat_ms,
                            "funding_rate_8h":s.funding_rate_8h,"funding_sign":s.funding_sign,
                            "maker_allowed":s.maker_allowed,"maker_spread_bps":s.maker_spread_bps,
                            "book_imbalance_th":s.book_imbalance_th,"avoid_funding_min":s.avoid_funding_min}
    m=Module("Econ","ok",pay,schema=SCHEMAS["econ"]); validate_payload(m); return m
_GLOBAL_TEL=Telemetry()
@register("Telemetry")
def mod_tel(name,lang): m=Module("Telemetry","ok",_GLOBAL_TEL.payload(),schema=SCHEMAS["telemetry"]); validate_payload(m); return m

# ------------- API / System -------------
@dataclass
class EchoMeta: version:str="Ultra Elite v8"; strategy:str="KamalquantX"; lang:str="tr"; generated_at:str=field(default_factory=lambda:datetime.now(timezone.utc).isoformat()); uuid:str=field(default_factory=lambda:str(uuid.uuid4()))
@dataclass
class System:
    meta:EchoMeta; modules:Dict[str,Module]=field(default_factory=dict)
    def to_dict(self): 
        if "Telemetry" in self.modules: self.modules["Telemetry"].payload=_GLOBAL_TEL.payload()
        return {"meta":asdict(self.meta),"modules":{k:m.to_dict() for k,m in self.modules.items()}}
    @classmethod
    def build(cls, strategy:str, lang:str, include:List[str]|None=None):
        sysobj=cls(EchoMeta(strategy=strategy, lang=lang)); wants=include or list(REGISTRY.keys())
        for k in wants:
            if k not in REGISTRY: continue
            t0=time.perf_counter(); m=REGISTRY[k](strategy, lang); m.metrics.init_ms=(time.perf_counter()-t0)*1000; validate_payload(m); sysobj.modules[k]=m
        return sysobj

def create_app(sysobj:System, engine:AsyncEngine|None):
    try:
        from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
        from fastapi.responses import Response
        from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    except Exception:
        return None
    s=Settings.load(); API=s.api_key_header
    REQS=Counter("ultra_v8_reqs","reqs"); LAT=Histogram("ultra_v8_latency","lat")
    app=FastAPI(title="UltraElite v8",version=sysobj.meta.version)
    def keydep():
        from fastapi import Request
        def inner(req:Request):
            if req.headers.get("x-api-key")!=API: raise HTTPException(status.HTTP_401_UNAUTHORIZED,"Invalid API Key")
        return inner
    @app.get("/health")
    def health(): REQS.inc(); return {"ok":True,"uuid":sysobj.meta.uuid}
    @app.get("/modules")
    def modules(dep=Depends(keydep())): 
        with LAT.time(): REQS.inc(); return sysobj.to_dict()["modules"]
    @app.get("/metrics")
    def metrics(): return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)
    @app.websocket("/ws")
    async def ws(sock:WebSocket):
        await sock.accept()
        try:
            while True:
                await sock.send_json(sysobj.to_dict()); await asyncio.sleep(2)
        except Exception: pass
    @app.post("/trade/start")
    def start(dep=Depends(keydep())):
        if engine is None: raise HTTPException(503,"engine missing")
        engine.start(); return {"started":True}
    @app.post("/trade/stop")
    def stop(dep=Depends(keydep())):
        if engine is None: raise HTTPException(503,"engine missing")
        engine.stop(); return {"stopped":True}
    return app

def run_api(sysobj:System, engine:AsyncEngine|None, port:int=8080):
    app=create_app(sysobj, engine)
    if app is None:
        print("fastapi/uvicorn/prometheus_client eksik. pip install fastapi uvicorn prometheus_client"); return
    import uvicorn; uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")

# ------------- Kozmik Entegrasyon: DivineGalaxy & Academy (+ hafif stubâ€™lar) -------------
class DivineGalaxyConfederation:
    def __init__(self):
        self.sectors = {
            "SectorSpiralGovernance": self._spiral_governance,
            "SectorInfinityDiplomacy": self._infinity_diplomacy,
            "SectorQuantumAlliance":  self._quantum_alliance,
            "SectorEchoExpansion":    self._echo_expansion
        }
    def _spiral_governance(self, data): return f"ðŸ‘‘ Spiral YÃ¶netim: {data[::-1]} â†’ TanrÄ±lar arasÄ± rezonans"
    def _infinity_diplomacy(self, data): return f"ðŸŒ€ Sonsuzluk Diplomasisi: {data.upper()} â†’ galaktik uzlaÅŸÄ±"
    def _quantum_alliance(self, data): return f"âš›ï¸ Kuantum Ä°ttifakÄ±: {len(data)*42} rezonans"
    def _echo_expansion(self, data): return f"ðŸ“¡ YankÄ± GeniÅŸleme: {hash(data)%8888} yankÄ± gÃ¼cÃ¼"
    def activate(self, data)->Dict[str,str]:
        report={"status":"GALAKSÄ° AKTÄ°F"}
        for n,f in self.sectors.items(): report[n]=f(data)
        return report

class QuantumWisdomSymphonicAcademy:
    def __init__(self):
        self.chambers = {
            "ChamberTemporalHarmony": self._temporal_harmony,
            "ChamberQuantumDoctrine": self._quantum_doctrine,
            "ChamberEchoMemory":      self._echo_memory,
            "ChamberDivineComposition": self._divine_composition
        }
    def _temporal_harmony(self, data): return f"ðŸŽ¼ Zaman Armonisi: {data.title()} â†’ senfonik hizalanma"
    def _quantum_doctrine(self, data): return f"ðŸ“˜ Kuantum Doktrin: {data.lower()} â†’ bilgelik kodlarÄ±"
    def _echo_memory(self, data): return f"ðŸ§  YankÄ± HafÄ±za: {sum(ord(c) for c in data)%9999} bilgi yankÄ±sÄ±"
    def _divine_composition(self, data): return f"ðŸŽ¶ TanrÄ±sal Kompozisyon: {data[::-1][:77]} â†’ spiral senfoni"
    def initiate(self, data)->Dict[str,str]:
        report={"status":"AKADEMÄ° AKTÄ°F"}
        for n,f in self.chambers.items(): report[n]=f(data)
        return report

# eksik referanslar iÃ§in min. stubâ€™lar:
class DivineSpiralMindInfinityEvolutionMultiverse:
    def expand(self, data): return {"multiverse":"EXPANDED","data_len":len(data)}
class EchoTimeQuantumWisdomConfederationTemple:
    def invoke(self, data): return {"temple":"INVOKED","checksum":hash(data)%999999}

@register("KamalQuantXEcho")
def mod_cosmic(name,lang):
    data="tanrÄ±lar arasÄ± spiral zihinle kodlanan zaman yankÄ±lÄ± sonsuzluk bilgelik evrim veri akÄ±ÅŸÄ±"
    multi=DivineSpiralMindInfinityEvolutionMultiverse().expand(data)
    temple=EchoTimeQuantumWisdomConfederationTemple().invoke(data)
    galaxy=DivineGalaxyConfederation().activate(data)
    academy=QuantumWisdomSymphonicAcademy().initiate(data)
    return Module("KamalQuantXEcho","ok",{"multiverse":multi,"temple":temple,"galaxy":galaxy,"academy":academy})

# ------------- CLI -------------
def main():
    s=Settings.load(); log.remove(); log.add(lambda m: print(m,end=""), level=s.log_level)
    ap=argparse.ArgumentParser(description="Ultra Elite v8 â€” WS + VWAP planner + Liquidity sizing + Funding + Maker reprice + Cosmic")
    sub=ap.add_subparsers(dest="cmd", required=True)
    pbt=sub.add_parser("backtest"); pbt.add_argument("--symbol","-s", required=True); pbt.add_argument("--lookback",type=int,default=1600)
    plv=sub.add_parser("live"); plv.add_argument("--api",action="store_true"); plv.add_argument("--port",type=int,default=8080)
    papi=sub.add_parser("api"); papi.add_argument("--port",type=int,default=8080)

    args=ap.parse_args()
    ex=CcxtBinance(s); tel=_GLOBAL_TEL; risk=Risk(s.equity,s.max_risk_pct,s.max_dd,s.leverage); calib=SlippageCalibrator(s.calibration_file)
    sysobj=System.build("KamalquantX", s.lang, include=["Market","Risk","Strategy","Econ","Telemetry","KamalQuantXEcho"])

    if args.cmd=="backtest":
        out=backtest(args.symbol, s, args.lookback); print(json.dumps(out, ensure_ascii=False, indent=2)); return

    engine=AsyncEngine(s, ex, tel, risk, calib)
    if args.cmd in ("api","live"):
        if args.cmd=="live": engine.start()
        run_api(sysobj, engine, port=args.port)
        return

if __name__=="__main__": main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\ultra_elite_echo_multiverse_ai_pro_v2.py
# ultra_elite_echo_multiverse_ai_pro_v2.py
from __future__ import annotations
import argparse, json, os, sys, uuid, time, importlib.util, pathlib
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, List, Any, Optional

from echo_core import Module, REGISTRY, register, load_schema, validate_payload, Health, Metrics

# ===== i18n (kÄ±sa) =====
I18N = {"en":{"online":"ULTRA ELITE HYBRID ONLINE"},
        "tr":{"online":"ULTRA ELÄ°T HÄ°BRÄ°T AKTÄ°F"},
        "fr":{"online":"ULTRA Ã‰LITE HYBRIDE EN LIGNE"},
        "de":{"online":"ULTRA-ELITE HYBRID ONLINE"}}
def tr(lang, key): return I18N.get(lang, I18N["en"]).get(key, key)

# ===== built-in modÃ¼l Ã¶rneÄŸi (Code) =====
@register("Code")
def m_code(strategy: str, lang: str) -> Module:
    mod = Module(
        name="Code",
        status="ok",
        payload={"msg": f"{strategy} â†’ coded & echoed"},
        schema=load_schema("code"),
    )
    validate_payload(mod)
    return mod

# ===== plugin discovery =====
def discover_plugins(folder: str = "plugins"):
    p = pathlib.Path(folder)
    if not p.exists(): return
    for path in p.glob("*.py"):
        spec = importlib.util.spec_from_file_location(path.stem, path)
        mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(mod)  # noqa: F401

# ===== meta & system =====
@dataclass
class EchoMeta:
    version: str = "Ultra Elit v2.0"
    strategy: str = "KamalquantX"
    lang: str = "tr"
    generated_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    uuid: str = field(default_factory=lambda: str(uuid.uuid4()))

@dataclass
class UltraEliteEchoSystem:
    meta: EchoMeta
    modules: Dict[str, Module] = field(default_factory=dict)

    @classmethod
    def build(cls, strategy: str, lang: str = "tr", include: Optional[List[str]] = None):
        sysobj = cls(EchoMeta(strategy=strategy, lang=lang))
        discover_plugins()
        wanted = include or list(REGISTRY.keys())
        for key in wanted:
            if key not in REGISTRY: continue
            t0 = time.perf_counter()
            mod = REGISTRY[key](strategy, lang)
            mod.metrics.init_ms = (time.perf_counter() - t0) * 1000
            # saÄŸlamlÄ±k: payload ÅŸema validasyonu
            validate_payload(mod)
            # basit health Ã¶rneÄŸi
            mod.health = mod.health if mod.health in (Health.OK, Health.WARN, Health.FAIL) else Health.OK
            sysobj.modules[key] = mod
        return sysobj

    def to_dict(self) -> Dict[str, Any]:
        return {"meta": asdict(self.meta),
                "engine": tr(self.meta.lang, "online"),
                "modules": {k: m.to_dict() for k, m in self.modules.items()}}

# ===== API / WS / Prometheus =====
def create_app(sysobj: UltraEliteEchoSystem):
    try:
        from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
        from fastapi.responses import Response
        from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    except Exception:  # API yoksa zarifÃ§e devre dÄ±ÅŸÄ±
        return None

    API_KEY = os.getenv("API_KEY", "secret123")
    REQS = Counter("echo_requests_total", "requests")
    LAT  = Histogram("echo_req_latency_seconds", "latency seconds")

    app = FastAPI(title="UltraEliteEcho", version=sysobj.meta.version)

    def check_key(key: str = None):
        from fastapi import Request
        def _inner(req: Request):
            if req.headers.get("x-api-key") != API_KEY:
                raise HTTPException(status.HTTP_401_UNAUTHORIZED, "Invalid API Key")
        return _inner

    @app.get("/health")
    def health():
        REQS.inc()
        return {"ok": True, "uuid": sysobj.meta.uuid}

    @app.get("/modules")
    def modules(dep=Depends(check_key())):
        with LAT.time():
            REQS.inc()
            return sysobj.to_dict()["modules"]

    @app.get("/metrics")
    def metrics():
        return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

    @app.websocket("/ws")
    async def ws(sock: WebSocket):
        await sock.accept()
        try:
            while True:
                await sock.send_json(sysobj.to_dict())
                time.sleep(2)
        except Exception:
            pass
    return app

def run_api(sysobj: UltraEliteEchoSystem, port: int = 8080):
    app = create_app(sysobj)
    if app is None:
        print("FastAPI/uvicorn/prometheus_client yok. `pip install fastapi uvicorn prometheus_client`")
        return
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")

# ===== CLI =====
def main():
    ap = argparse.ArgumentParser(description="Ultra Elite Hybrid v2 (plugins + schema + ws + metrics)")
    ap.add_argument("--strategy", "-s", default="KamalquantX")
    ap.add_argument("--lang", "-l", default="tr", choices=["tr","en","fr","de"])
    ap.add_argument("--include", "-i", nargs="*", help="Sadece bu modÃ¼ller (boÅŸ: hepsi)")
    ap.add_argument("--api", action="store_true")
    ap.add_argument("--port", type=int, default=8080)
    args = ap.parse_args()

    sysobj = UltraEliteEchoSystem.build(args.strategy, args.lang, args.include)
    print(json.dumps(sysobj.to_dict(), ensure_ascii=False, indent=2))
    if args.api:
        run_api(sysobj, port=args.port)

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\your_project\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\your_project\run_all_tests.py
#!/bin/bash

# run_all_tests.sh
# TÃ¼m testleri pytest + coverage ile Ã§alÄ±ÅŸtÄ±rÄ±r

# 1) Renk kodlarÄ±
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m' # reset

echo "ðŸ” Testler baÅŸlatÄ±lÄ±yor..."

# 2) coverage varsa, yoksa kur
if ! command -v coverage &> /dev/null
then
    echo "ðŸ“¦ coverage bulunamadÄ±, kuruluyor..."
    pip install coverage pytest > /dev/null
fi

# 3) coverage ile testleri Ã§alÄ±ÅŸtÄ±r
coverage run -m pytest -q
TEST_EXIT_CODE=$?

# 4) coverage raporu
echo ""
echo "ðŸ“Š Test Kapsam Raporu:"
coverage report -m --omit="tests/*"

# 5) sonuÃ§
if [ $TEST_EXIT_CODE -eq 0 ]; then
    echo -e "${GREEN}âœ… TÃ¼m testler baÅŸarÄ±yla geÃ§ti!${NC}"
else
    echo -e "${RED}âŒ BazÄ± testler baÅŸarÄ±sÄ±z oldu. LoglarÄ± kontrol et.${NC}"
fi

# 6) coverage HTML raporu da Ã¼ret
coverage html
echo "ðŸŒ HTML kapsam raporu: htmlcov/index.html"


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\__init__.py
# auto-added


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\adaptive_signal_mutator.py
class AdaptiveSignalMutator:
    def __init__(self):
        self.mutation_rate = 0.2

    def mutate(self, signal_value, market_volatility):
        adjustment = market_volatility * self.mutation_rate
        mutated_signal = signal_value + adjustment if signal_value > 0 else signal_value - adjustment
        return max(-1, min(mutated_signal, 1))

# SimÃ¼lasyon
mutator = AdaptiveSignalMutator()
print("ðŸ”„ Yeni Sinyal:", mutator.mutate(signal_value=0.4, market_volatility=0.6))



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\aegis_quant.py
import websocket, json, time, hmac, hashlib, requests, threading
import pandas as pd
import numpy as np
import ta
from sklearn.ensemble import IsolationForest
from keras.models import Sequential
from keras.layers import LSTM, Dense

# === AYARLAR ===
API_KEY = "YOUR_API_KEY"
SECRET_KEY = "YOUR_SECRET_KEY"
SYMBOLS = ["btcusdt", "ethusdt"]
TRADE_AMOUNT = 0.001
RISK_LIMIT = 0.02  # %2 risk

# === VERÄ° DEPOLAMA ===
price_data = {symbol: pd.DataFrame(columns=["timestamp", "price"]) for symbol in SYMBOLS}
models = {}

# === LOG FONKSÄ°YONU ===
def log(event, msg):
    print(f"[{event}] {msg}")

# === VERÄ° AKIÅžI ===
def create_socket(symbol):
    url = f"wss://stream.binance.com:9443/ws/{symbol}@trade"
    return websocket.WebSocketApp(url,
        on_message=lambda ws, msg: handle_message(symbol, msg),
        on_open=lambda ws: log("OPEN", f"{symbol.upper()} baÄŸlantÄ±sÄ± kuruldu."),
        on_close=lambda ws: log("CLOSE", f"{symbol.upper()} baÄŸlantÄ±sÄ± kapandÄ±.")
    )

def handle_message(symbol, message):
    global price_data, models
    data = json.loads(message)
    price = float(data['p'])
    timestamp = int(data['T'])
    df = price_data[symbol]
    df.loc[len(df)] = [timestamp, price]

    if len(df) > 120:
        df = df.tail(120).copy()
        df = generate_features(df)
        anomaly_score = detect_anomaly(df)
        if symbol not in models:
            models[symbol] = train_model(df)
        prediction = predict_price(models[symbol], df)
        strategy_decision(symbol, df, prediction, anomaly_score)

# === Ã–ZELLÄ°K MÃœHENDÄ°SLÄ°ÄžÄ° ===
def generate_features(df):
    df['rsi'] = ta.momentum.RSIIndicator(df['price']).rsi()
    df['macd'] = ta.trend.MACD(df['price']).macd_diff()
    df['sma20'] = df['price'].rolling(window=20).mean()
    df['volatility'] = df['price'].rolling(window=10).std()
    df.dropna(inplace=True)
    return df

# === ANOMALY DETECTION ===
def detect_anomaly(df):
    iso = IsolationForest(contamination=0.05)
    scores = iso.fit_predict(df[['price', 'rsi', 'macd', 'volatility']])
    return scores[-1]  # -1 = anomaly

# === LSTM MODELÄ° ===
def train_model(df):
    prices = df['price'].values[-100:]
    X, y = [], []
    for i in range(10, len(prices)):
        X.append(prices[i-10:i])
        y.append(prices[i])
    X, y = np.array(X), np.array(y)
    X = X.reshape((X.shape[0], X.shape[1], 1))

    model = Sequential()
    model.add(LSTM(64, activation='relu', input_shape=(10,1)))
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mse')
    model.fit(X, y, epochs=15, verbose=0)
    return model

def predict_price(model, df):
    last_seq = df['price'].values[-10:].reshape((1,10,1))
    return model.predict(last_seq)[0][0]

# === STRATEJÄ° MOTORU ===
def strategy_decision(symbol, df, prediction, anomaly_score):
    latest = df.iloc[-1]
    rsi = latest['rsi']
    macd = latest['macd']
    price = latest['price']
    volatility = latest['volatility']

    log("STRATEGY", f"{symbol.upper()} | RSI: {rsi:.2f} | MACD: {macd:.2f} | Tahmin: {prediction:.2f} | Anomaly: {anomaly_score}")

    if anomaly_score == -1:
        log("ALERT", "Anormal veri tespit edildi. Ä°ÅŸlem yapÄ±lmadÄ±.")
        return

    if rsi < 30 and macd > 0 and prediction > price:
        qty = calculate_position(price, volatility)
        execute_order(symbol.upper(), "BUY", qty)
    elif rsi > 70 and macd < 0 and prediction < price:
        qty = calculate_position(price, volatility)
        execute_order(symbol.upper(), "SELL", qty)
    else:
        log("STATUS", "Beklemede")

# === RÄ°SK YÃ–NETÄ°MÄ° ===
def calculate_position(price, volatility):
    balance = 1000  # Ã¶rnek bakiye
    risk_amount = balance * RISK_LIMIT
    stop_loss = price * 0.01 + volatility
    qty = risk_amount / stop_loss
    return round(qty, 4)

# === EMÄ°R GÃ–NDERÄ°MÄ° ===
def execute_order(symbol, side, quantity):
    url = "https://api.binance.com/api/v3/order"
    timestamp = int(time.time() * 1000)
    params = {
        "symbol": symbol,
        "side": side,
        "type": "MARKET",
        "quantity": quantity,
        "timestamp": timestamp
    }
    query = '&'.join([f"{k}={v}" for k,v in params.items()])
    signature = hmac.new(SECRET_KEY.encode(), query.encode(), hashlib.sha256).hexdigest()
    params['signature'] = signature
    headers = {"X-MBX-APIKEY": API_KEY}
    try:
        response = requests.post(url, headers=headers, params=params)
        log("ORDER", f"{side} {quantity} {symbol} gÃ¶nderildi.")
        log("RESPONSE", str(response.json()))
    except Exception as e:
        log("ERROR", f"Emir gÃ¶nderimi baÅŸarÄ±sÄ±z: {e}")

# === BAÅžLAT ===
if __name__ == "__main__":
    sockets = [create_socket(symbol) for symbol in SYMBOLS]
    for sock in sockets:
        threading.Thread(target=sock.run_forever).start()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\aether_command_oracle.py
def suggest_strategies(destiny_paths):
    strategies = []
    for path in destiny_paths:
        if "Evrim RotasÄ±" in path:
            strategies.append("ðŸ” GeliÅŸime odaklan: YaratÄ±cÄ± projeleri destekle, bilgi akÄ±ÅŸÄ±nÄ± hÄ±zlandÄ±r.")
        elif "Kader Krizi" in path:
            strategies.append("ðŸ›¡ï¸ Koruma protokolÃ¼ baÅŸlat: GÃ¼venlik sistemlerini gÃ¶zden geÃ§ir, alternatif senaryolar hazÄ±rla.")
    return strategies if strategies else ["ðŸŒ¿ Åžu anda mÃ¼dahale gerektiren hiÃ§bir ÅŸey yok. Sessiz geliÅŸim zamanÄ±."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\aether_command_synthesizer.py
def synthesize_aether_command(data_signals, captain_intent):
    directive = []
    for signal in data_signals:
        if signal['harmony'] >= 80 and signal['risk_level'] < 40:
            directive.append(f"ðŸª Uyumlu Hamle: {signal['id']} â†’ {captain_intent}")
        elif signal['flux'] > 65:
            directive.append(f"âš ï¸ Dalgasal MÃ¼dahale: {signal['id']} â†’ Denge Ã¶nerilir")
    return directive if directive else ["ðŸŒŒ Kozmik frekanslar nÃ¶tr. Sessiz kalmak bir stratejidir."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\alpha_engine.py
# alpha_engine.py
from __future__ import annotations
import time
from dataclasses import dataclass
from typing import Optional, Dict, Any, List

import numpy as np
import pandas as pd
from binance.client import Client

from ta_core import ema, sma, rsi, macd, stoch_kd, atr, adx, bollinger, cci, mfi, obv, keltner, supertrend

@dataclass
class SignalDecision:
    side: str                  # "BUY" | "SELL"
    sl_pct: float
    tp_pct: float
    trail_pct: float
    confidence: float          # [-100, 100]
    reason: str

class ProAlphaEngine:
    def __init__(self, client: Client, *,
                 timeframe: str = "1m",
                 lookback: int = 600,
                 ema_fast: int = 21,
                 ema_slow: int = 55,
                 adx_thr: float = 18.0,
                 buy_thr: float = 25.0,
                 sell_thr: float = -25.0,
                 sl_atr_mult: float = 1.8,
                 rr_mult: float = 2.0,
                 trail_frac_of_tp: float = 0.35):
        self.client = client
        self.tf = timeframe
        self.lb = lookback
        self.ef = ema_fast
        self.es = ema_slow
        self.adx_thr = adx_thr
        self.buy_thr = buy_thr
        self.sell_thr = sell_thr
        self.sl_atr_mult = sl_atr_mult
        self.rr_mult = rr_mult
        self.trail_frac = trail_frac_of_tp

    # ---------- Data ----------
    def fetch_df(self, symbol: str) -> pd.DataFrame:
        kl = self.client.futures_klines(symbol=symbol, interval=self.tf, limit=self.lb)
        cols = ["t","o","h","l","c","v","ct","q","n","tbv","tbq","i"]
        df = pd.DataFrame(kl, columns=cols)
        df["o"] = df["o"].astype(float)
        df["h"] = df["h"].astype(float)
        df["l"] = df["l"].astype(float)
        df["c"] = df["c"].astype(float)
        df["v"] = df["v"].astype(float)
        df.index = pd.to_datetime(df["t"], unit="ms")
        return df

    # ---------- Features ----------
    def build_features(self, df: pd.DataFrame) -> pd.DataFrame:
        c, h, l, v = df["c"], df["h"], df["l"], df["v"]

        df["ema_f"] = ema(c, self.ef)
        df["ema_s"] = ema(c, self.es)
        df["rsi"]   = rsi(c, 14)
        macd_line, macd_sig, macd_hist = macd(c, 12, 26, 9)
        df["macd"], df["macds"], df["macdh"] = macd_line, macd_sig, macd_hist
        k, d = stoch_kd(h, l, c, 14, 3)
        df["stoch_k"], df["stoch_d"] = k, d
        df["atr"]  = atr(h, l, c, 14)
        df["adx"], df["+di"], df["-di"] = adx(h, l, c, 14)
        bb_m, bb_u, bb_l, bb_w = bollinger(c, 20, 2.0)
        df["bb_m"], df["bb_u"], df["bb_l"], df["bb_w"] = bb_m, bb_u, bb_l, bb_w
        df["cci"]  = cci(h, l, c, 20)
        df["mfi"]  = mfi(h, l, c, v, 14)
        df["obv"]  = obv(c, v)
        kc_m, kc_u, kc_l = keltner(h, l, c, ema_period=20, atr_period=10, mult=1.5)
        df["kc_m"], df["kc_u"], df["kc_l"] = kc_m, kc_u, kc_l
        st_dir, st_line = supertrend(h, l, c, atr_period=10, mult=3.0)
        df["st_dir"], df["st_line"] = st_dir, st_line

        return df.dropna().copy()

    # ---------- Scoring ----------
    def score_row(self, row: pd.Series, prev: pd.Series) -> float:
        """ Trend + Momentum + Volatilite kompozit skoru ([-100,100]) """
        score = 0.0

        # Trend
        trend = 0.0
        if row["ema_f"] > row["ema_s"]: trend += 22
        else:                            trend -= 22

        if row["c"] > row["st_line"] and row["st_dir"] > 0: trend += 22
        elif row["c"] < row["st_line"] and row["st_dir"] < 0: trend -= 22

        if row["macdh"] > 0: trend += 12
        else:                trend -= 12

        if row["adx"] > self.adx_thr:
            trend *= 1.10  # gÃ¼Ã§lÃ¼ trendlerde aÄŸÄ±rlÄ±k artÄ±r

        score += trend

        # Momentum
        mom = 0.0
        if row["rsi"] > 50 and row["rsi"] > prev["rsi"]:  mom += 10
        if row["stoch_k"] > row["stoch_d"] and prev["stoch_k"] <= prev["stoch_d"]: mom += 8
        if row["mfi"] > 50: mom += 6
        score += mom

        # Volatilite / Breakout
        vol = 0.0
        if row["c"] > row["bb_u"]: vol += 12
        if row["c"] < row["bb_l"]: vol -= 12
        squeeze_on = (row["bb_w"] < 0.015) and (row["kc_u"]-row["kc_l"] > row["bb_u"]-row["bb_l"])
        if squeeze_on and (row["bb_w"] > prev["bb_w"]):
            vol += 6 if row["c"] > row["bb_m"] else -6
        score += vol

        # Normalize
        score = max(-100.0, min(100.0, score))
        return float(score)

    # ---------- Decision ----------
    def decide(self, symbol: str) -> Optional[SignalDecision]:
        df_raw = self.fetch_df(symbol)
        df = self.build_features(df_raw)
        if len(df) < 5: return None

        row  = df.iloc[-1]
        prev = df.iloc[-2]
        s = self.score_row(row, prev)

        # Rejim filtresi: Ã§ok yatay + dÃ¼ÅŸÃ¼k ADX'te agresif iÅŸlem yapma
        if row["adx"] < (self.adx_thr*0.6) and abs(s) < 15:
            return None

        sl_pct = (self.sl_atr_mult * row["atr"]) / row["c"]
        tp_pct = sl_pct * self.rr_mult
        trail_pct = max(0.0, tp_pct * self.trail_frac)

        if s >= self.buy_thr:
            return SignalDecision("BUY", float(sl_pct), float(tp_pct), float(trail_pct), float(s),
                                  f"score={s:.1f} trend/mom/vol BUY")
        if s <= self.sell_thr:
            return SignalDecision("SELL", float(sl_pct), float(tp_pct), float(trail_pct), float(s),
                                  f"score={s:.1f} trend/mom/vol SELL")
        return None


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\aquatic_chain_synapse.py
def chain_synaptic_pathway(source_chain, target_chain, emotion_flow):
    strength = emotion_flow * 0.8  # sinaptik sinyal yoÄŸunluÄŸu
    if strength > 0.7:
        connection = "ðŸ§¬ Aktif Biyolojik BaÄŸ"
    elif strength > 0.4:
        connection = "ðŸŒ«ï¸ Dalgasal GeÃ§iÅŸ"
    else:
        connection = "â›“ï¸ ZayÄ±f BaÄŸlantÄ±"
    return f"{source_chain} â†’ {target_chain}: {connection}"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\astro_signal_mapper.py
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

def stellar_map(csv_file="data/signal_log.csv"):
    df = pd.read_csv(csv_file)
    x = np.arange(len(df))
    y = df["score"]
    colors = ["gold" if r == 1 else "gray" for r in df["result"]]
    
    plt.scatter(x, y, c=colors, s=50, alpha=0.8)
    plt.title("ðŸŒŒ YÄ±ldÄ±zlar ArasÄ± Sinyal HaritasÄ±")
    plt.xlabel("Sinyal Zaman Ekseni")
    plt.ylabel("Skor")
    plt.tight_layout()
    plt.show()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\auto_deploy_bot.py
# auto_deploy_bot.py (Optimum strateji ile otomatik bot baÅŸlatÄ±cÄ±)
import time
from datetime import datetime
from kiripto_nova.data.pipelines.data_loader import load_binance_data
from kiripto_nova.signals.signal_engine import SignalEngine
from trade_executor import execute_trade
from kiripto_nova.risk.risk_manager import calculate_position_size, calculate_stop_loss, calculate_take_profit
from kiripto_nova.apps.telegram_alert import notify_signal, notify_trade
from logger import log_trade, log_error
from kiripto_nova.strategies.strategy_optimizer import optimize_strategy

# âš™ï¸ Ayarlar
SYMBOL = "DOGE/USDT"
TIMEFRAME = "15m"
BALANCE = 1000
RISK = 0.01
REFRESH_INTERVAL = 300  # 5 dakika

# Son tetiklenen sinyal
last_signal = None

# Ä°lk optimizasyon
df = load_binance_data(SYMBOL, TIMEFRAME)
optimized = optimize_strategy(df)
best = optimized.iloc[0]  # En iyi kombinasyon
print("ðŸš€ En iyi kombinasyon yÃ¼klendi:")
print(best)

RSI_LEVEL = best["RSI_threshold"]
STOP_LOSS_PCT = best["Stop_Loss"]
REWARD_RATIO = best["Reward_Ratio"]


def run_bot():
    global last_signal
    try:
        print(f"â±ï¸ Bot tarÄ±yor: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

        df = load_binance_data(SYMBOL, TIMEFRAME)
        engine = SignalEngine(df)
        engine.calculate_indicators()
        df = engine.get_dataframe()
        signal = "BUY" if df["RSI_14"].iloc[-1] < RSI_LEVEL else "NEUTRAL"

        if signal != last_signal and signal == "BUY":
            entry = df["close"].iloc[-1]
            qty = calculate_position_size(BALANCE, RISK, STOP_LOSS_PCT)
            sl = calculate_stop_loss(entry, STOP_LOSS_PCT, direction="long")
            tp = calculate_take_profit(entry, REWARD_RATIO, STOP_LOSS_PCT, direction="long")

            execute_trade(SYMBOL, side="buy", amount=qty)
            log_trade("BUY", SYMBOL, qty, entry, sl, tp)
            notify_signal("BUY", SYMBOL)
            notify_trade("BUY", SYMBOL, qty, entry, sl, tp)
            last_signal = signal
        else:
            print("ðŸ” Sinyal yok veya tekrar ediyor.")

    except Exception as e:
        log_error(e)


if __name__ == "__main__":
    while True:
        run_bot()
        time.sleep(REFRESH_INTERVAL)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\auto_move_map.py
# auto_move_map.py  â€”  kÃ¶kteki dosya adlarÄ±na gÃ¶re move_map.csv Ã¼retir
import re, csv, pathlib
ROOT = pathlib.Path(".").resolve()
RULES = [
    (r"^binance_.*",                       "exchanges/binance"),
    (r"^(basic_|strategy_|strategic_).*",  "strategies"),
    (r"^(ai_|neuro_|ml_|insight_).*",      "ai"),
    (r"^(signal_|sentiment_|news_|get_news).*", "signals"),
    (r"^risk_.*|^RiskGuard",               "risk"),
    (r"^(analysis_|plot_|report_|dashboard_).*", "analytics"),
    (r"^(backtest.*|backtester.*|testnet_trade_bot)", "backtesting"),
    (r"^(orchestrator_|scheduler_|stream|router).*", "execution"),
    (r"^(data_.*|twitter_data|data_loader|data_fetcher)", "data/pipelines"),
    (r"^chain_.*",                         "analytics/onchain"),
    (r"^position_manager",                 "execution"),
    (r"^telegram_.*",                      "apps"),
    (r"^nova_.*_bot$",                     "apps"),
    (r"^novaSovereignCore$",               "apps"),
    (r"^wallet_.*|wallet_activity_analyzer", "analytics"),
    (r"^config_loader|^settings",          "core"),
]
SKIP = {".git","src",".venv","venv","venv311","Lib","lib","site-packages","__pycache__",".pytest_cache"}

def snake(s):
    s = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", s)
    return re.sub(r"[^a-zA-Z0-9_]", "_", s).lower()

def decide(stem):
    for pat, dest in RULES:
        if re.match(pat, stem): return dest
    return None

def main():
    rows=[("old_path","new_path")]
    unmapped=[]
    for p in ROOT.glob("*.py"):
        if p.name in {"auto_move_map.py","rearrange_v2.py"}: continue
        dest = decide(p.stem)
        if dest: rows.append((p.name, f"src/kiripto_nova/{dest}/{snake(p.stem)}.py"))
        else: unmapped.append(p.name)
    t = ROOT/"tests"
    if t.exists():
        for p in t.glob("*.py"):
            if re.match(r"^nova_.*_bot$|^novaSovereignCore$", p.stem):
                rows.append((str(p), f"src/kiripto_nova/apps/{snake(p.stem)}.py"))
    with open("move_map.csv","w",newline="",encoding="utf-8") as f: csv.writer(f).writerows(rows)
    with open("unmapped.txt","w",encoding="utf-8") as f: f.write("\n".join(unmapped))
    print(f"[OK] move_map.csv ({len(rows)-1} satÄ±r). EÅŸleÅŸmeyen: {len(unmapped)} -> unmapped.txt")

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\block_pulse_tracker.py
def detect_chain_pulse(block_data):
    alerts = []
    if block_data['transfer_volume'] > 1_000_000:
        alerts.append("ðŸ’° BÃ¼yÃ¼k Transfer Tespiti!")
    if block_data['wallet_movement'] > 500:
        alerts.append("ðŸ¦ˆ CÃ¼zdan GÃ¶Ã§Ã¼ AlgÄ±landÄ±!")
    if block_data['dao_activity'] == 'surge':
        alerts.append("ðŸ›ï¸ DAO Stratejik Hamlesi!")
    if not alerts:
        alerts.append("ðŸŒŠ Zincir Dengede, beklenmedik bir hareket yok.")
    return alerts



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\boot.py
# boot.py
from __future__ import annotations
import os
import logging
from typing import List
from dotenv import load_dotenv
from binance.client import Client

# ---- Senin modÃ¼llerin (daha Ã¶nce yazdÄ±klarÄ±mÄ±z) ----
from ex_filters import SymbolFilters
from kiripto_nova.risk.risk_manager import RiskManager, RiskConfig
from kiripto_nova.execution.position_manager import PositionManager
from kiripto_nova.strategies.strategy_executor import StrategyExecutor

# Basit portfÃ¶y adaptÃ¶rÃ¼ (ÅŸimdilik minimum)
class PortfolioAdapter:
    def __init__(self, client: Client):
        self.client = client
        self._equity_cache = None

    def get_equity_usdt(self) -> float:
        # Futures toplam cÃ¼zdan (USDT bazlÄ±)
        fa = self.client.futures_account()
        # totalWalletBalance string gelebilir
        return float(fa.get("totalWalletBalance", 0.0))

    def get_open_exposure(self, symbol: str) -> float:
        # Ä°stersen burayÄ± aÃ§Ä±k pozisyonlara gÃ¶re notional hesaplayacak ÅŸekilde geniÅŸlet
        return 0.0

    def get_open_positions_count(self) -> int:
        poss = self.client.futures_position_information()
        # qty != 0 olanlarÄ± say
        return sum(1 for p in poss if abs(float(p.get("positionAmt", "0"))) > 0)

    def get_symbol_price(self, symbol: str) -> float:
        return float(self.client.futures_symbol_ticker(symbol=symbol)["price"])

def _bool_env(key: str, default: bool) -> bool:
    return os.getenv(key, str(default)).strip().lower() in ("1","true","yes","on")

def bootstrap():
    # 1) ENV yÃ¼kle + log ayarÄ±
    load_dotenv()
    log_level = os.getenv("LOG_LEVEL", "INFO").upper()
    logging.basicConfig(level=getattr(logging, log_level, logging.INFO),
                        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s")
    log = logging.getLogger("boot")

    # 2) ENV oku
    API_KEY = os.getenv("BINANCE_API_KEY"); API_SECRET = os.getenv("BINANCE_API_SECRET")
    USE_TESTNET = _bool_env("BINANCE_USE_TESTNET", True)
    FAPI_URL = os.getenv("BINANCE_FUTURES_URL", "")
    SYMBOLS: List[str] = [s.strip() for s in os.getenv("SYMBOLS","BTCUSDT").split(",") if s.strip()]
    HEDGE = _bool_env("BINANCE_HEDGE_MODE", True)
    MARGIN_TYPE = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED").upper()
    LEVERAGE = int(os.getenv("BINANCE_LEVERAGE", "5"))

    # Risk ayarlarÄ±
    risk_cfg = RiskConfig(
        max_capital_pct_per_trade=float(os.getenv("MAX_CAPITAL_PCT_PER_TRADE", "0.02")),
        max_daily_loss_pct=float(os.getenv("MAX_DAILY_DRAWDOWN", "0.03")),
        max_open_positions=int(os.getenv("MAX_OPEN_POSITIONS", "5")),
        max_symbol_exposure_pct=float(os.getenv("MAX_SYMBOL_EXPOSURE_PCT", "0.25")),
        min_notional_usdt=float(os.getenv("MIN_NOTIONAL_USDT", "10")),
    )

    # 3) Binance Futures client
    if not API_KEY or not API_SECRET:
        raise RuntimeError("BINANCE_API_KEY / BINANCE_API_SECRET eksik!")

    client = Client(API_KEY, API_SECRET, testnet=USE_TESTNET)
    if FAPI_URL:
        # Testnet: https://testnet.binancefuture.com  |  Prod: https://fapi.binance.com
        client.FUTURES_URL = FAPI_URL

    # 4) BaÅŸlangÄ±Ã§ hesap ayarlarÄ±
    try:
        client.futures_change_position_mode(dualSidePosition=HEDGE)
        log.info("Hedge mode: %s", HEDGE)
    except Exception as e:
        log.warning("Hedge mode set edilemedi: %s", e)

    for sym in SYMBOLS:
        try:
            client.futures_change_margin_type(symbol=sym, marginType=MARGIN_TYPE)
        except Exception:
            # Zaten o moddaysa hata dÃ¶ner; Ã¶nemli deÄŸil
            pass
        try:
            client.futures_change_leverage(symbol=sym, leverage=LEVERAGE)
        except Exception as e:
            log.warning("Leverage set edilemedi %s: %s", sym, e)

    # 5) BaÄŸÄ±mlÄ±lÄ±klarÄ± kur
    # NOTE: ex_filters iÃ§in FUTURES exchangeInfo kullanmalÄ±yÄ±z
    filters = SymbolFilters(client.futures_exchange_info())

    portfolio = PortfolioAdapter(client)
    risk = RiskManager(portfolio, risk_cfg)
    pm = PositionManager(client, risk, filters)
    execu = StrategyExecutor(pm, risk, portfolio)

    # 6) Basit saÄŸlÄ±k kontrolÃ¼
    eq = portfolio.get_equity_usdt()
    mp = client.futures_symbol_ticker(symbol=SYMBOLS[0])["price"]
    log.info("Futures boot hazÄ±r. Equity=%.2f USDT | %s fiyat=%s", eq, SYMBOLS[0], mp)

    # 7) Ã–rnek: â€œdry-runâ€ sinyal akÄ±ÅŸÄ± (kapatmak istersen yorumla)
    # Basit bir giriÅŸ Ã¶rneÄŸi (gerÃ§ek strateji yerine)
    demo = _bool_env("DEMO_PLACE_ORDER", False)
    if demo:
        signal = {
            "symbol": SYMBOLS[0],
            "side": "BUY",
            "intent": "entry",
            "risk": {"max_capital_pct": float(os.getenv("MAX_CAPITAL_PCT_PER_TRADE", "0.02"))}
        }
        log.info("Demo sinyal gÃ¶nderiliyor: %s", signal)
        order = execu.on_signal(signal)
        log.info("Demo order sonucu: %s", order)

    return {
        "client": client,
        "filters": filters,
        "portfolio": portfolio,
        "risk": risk,
        "position_manager": pm,
        "executor": execu,
        "symbols": SYMBOLS
    }

if __name__ == "__main__":
    bootstrap()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\bot.py
# bot.py
# Kiripto Nova â€” Futures Bracket Bot (TESTNET/MAINNET, PRO/STRICT destekli)
# ------------------------------------------------------------
# - python-binance + dotenv
# - HEDGE/ISOLATED/LEVERAGE idempotent ayarlama
# - MARKET entry + STOP_MARKET (SL) + TAKE_PROFIT_MARKET (TP)
# - SL/TP iÃ§in reduceOnly KULLANMA â†’ closePosition=True (Binance USDM gereÄŸi)
# - Opsiyonel TRAILING_STOP_MARKET (qty ile, reduceOnly yok)
# - Timestamp senkronu (client.timestamp_offset)
# - SaÄŸlam retry + min step/tick yuvarlama
# - PRO otomatik mod (Ã§ok basit sinyal Ã¶rneÄŸi) + STRICT (korumacÄ± mod)
# ------------------------------------------------------------

from __future__ import annotations

import os
import sys
import time
import math
import argparse
from decimal import Decimal, ROUND_DOWN
from typing import Dict, Any, Optional, Tuple

from dotenv import load_dotenv
from binance.client import Client
from binance.exceptions import BinanceAPIException

# Opsiyonel Telegram bildirimleri
try:
    import notify as nt  # notify.py varsa send() kullanÄ±r
except Exception:
    nt = None

# =======================
# Ortam / Config
# =======================

load_dotenv()

USE_TESTNET = os.getenv("BINANCE_USE_TESTNET", "true").strip().lower() == "true"

if USE_TESTNET:
    API_KEY = (os.getenv("BINANCE_API_KEY_TEST") or "").strip()
    API_SECRET = (os.getenv("BINANCE_API_SECRET_TEST") or "").strip()
    FUTURES_BASE = os.getenv("BINANCE_FUTURES_URL_TEST", "https://testnet.binancefuture.com").strip().rstrip("/")
else:
    API_KEY = (os.getenv("BINANCE_API_KEY_MAIN") or os.getenv("BINANCE_API_KEY") or "").strip()
    API_SECRET = (os.getenv("BINANCE_API_SECRET_MAIN") or os.getenv("BINANCE_API_SECRET") or "").strip()
    FUTURES_BASE = os.getenv("BINANCE_FUTURES_URL_MAIN", "https://fapi.binance.com").strip().rstrip("/")

if not API_KEY or not API_SECRET:
    print("âŒ API key/secret yok (.env).")
    sys.exit(1)

client = Client(API_KEY, API_SECRET, testnet=USE_TESTNET)
client.FUTURES_URL = f"{FUTURES_BASE}/fapi"
print("Futures base:", client.FUTURES_URL)
print("API key (maskeli):", API_KEY[:6] + "..." + API_KEY[-4:])

# Risk ve emir Ã§alÄ±ÅŸma ayarlarÄ±
HEDGE_MODE  = os.getenv("BINANCE_HEDGE_MODE", "true").strip().lower() == "true"
MARGIN_TYPE = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED").strip().upper()  # ISOLATED/CROSSED
LEVERAGE    = int(os.getenv("BINANCE_LEVERAGE", "5"))

WORKING_TYPE = os.getenv("WORKING_TYPE", "MARK_PRICE").strip().upper()  # MARK_PRICE | CONTRACT_PRICE
SL_PCT_DEF   = float(os.getenv("SL_PCT", "0.01"))
TP_PCT_DEF   = float(os.getenv("TP_PCT", "0.02"))
TRAIL_PCT_DEF= float(os.getenv("TRAIL_PCT", "0.0"))   # 0.004 = %0.4

STRICT_MODE  = os.getenv("STRICT_MODE", "false").strip().lower() == "true"

MAX_RETRY        = int(os.getenv("MAX_RETRY", "3"))
RETRY_BACKOFF_MS = int(os.getenv("RETRY_BACKOFF_MS", "400"))

_symbol_cache: Dict[str, Dict[str, float]] = {}

# =======================
# YardÄ±mcÄ±lar
# =======================

def tg(msg: str):
    print(msg)
    if nt and hasattr(nt, "tg_enabled") and nt.tg_enabled():
        try:
            nt.send(msg)
        except Exception:
            pass

def _sleep_ms(ms: int):
    time.sleep(ms / 1000.0)

def retry_call(fn, desc: str = "", *args, **kwargs):
    tries = kwargs.pop("_tries", MAX_RETRY)
    last = None
    for i in range(tries):
        try:
            return fn(*args, **kwargs)
        except BinanceAPIException as e:
            last = e
            print(f"âš ï¸ {desc or fn.__name__} hata: {e} (deneme {i+1}/{tries})")
            _sleep_ms(RETRY_BACKOFF_MS)
        except Exception as e:
            last = e
            print(f"âš ï¸ {desc or fn.__name__} hata: {e} (deneme {i+1}/{tries})")
            _sleep_ms(RETRY_BACKOFF_MS)
    raise last

def calibrate_timestamp_offset():
    """Sunucu saatine gÃ¶re client.timestamp_offset ayarla."""
    try:
        s = retry_call(client.get_server_time, "server_time")
        server_ms = int(s["serverTime"])
        local_ms  = int(time.time() * 1000)
        off = server_ms - local_ms
        client.timestamp_offset = off
        print(f"â±ï¸ timestamp senkron: offset={off} ms, recvWindow={5000}")
    except Exception as e:
        print("âš ï¸ timestamp offset ayarlanamadÄ±:", e)

def get_filters(symbol: str) -> Dict[str, float]:
    s = symbol.upper()
    if s in _symbol_cache:
        return _symbol_cache[s]
    info = retry_call(client.futures_exchange_info, "exchange_info")
    sy = next((x for x in info["symbols"] if x["symbol"] == s), None)
    if not sy:
        raise SystemExit(f"Sembol yok: {s}")
    lot = next(x for x in sy["filters"] if x["filterType"] in ("LOT_SIZE", "MARKET_LOT_SIZE"))
    prf = next(x for x in sy["filters"] if x["filterType"] == "PRICE_FILTER")
    step = float(lot["stepSize"])
    minq = float(lot["minQty"])
    tick = float(prf["tickSize"])
    _symbol_cache[s] = {"step": step, "min_qty": minq, "tick": tick}
    return _symbol_cache[s]

def _round_to_step(val: float, step: float) -> float:
    dval = Decimal(str(val))
    dstep = Decimal(str(step))
    return float((dval / dstep).to_integral_value(rounding=ROUND_DOWN) * dstep)

def round_qty(symbol: str, qty: float) -> float:
    f = get_filters(symbol)
    return _round_to_step(max(qty, f["min_qty"]), f["step"])

def round_price(symbol: str, price: float) -> float:
    f = get_filters(symbol)
    return _round_to_step(price, f["tick"])

def _position_side(side: str) -> str:
    return "LONG" if side.upper() == "BUY" else "SHORT"

def _opposite(side: str) -> str:
    return "SELL" if side.upper() == "BUY" else "BUY"

def _last_price(symbol: str) -> float:
    t = retry_call(client.futures_symbol_ticker, "symbol_ticker", symbol=symbol)
    return float(t["price"])

# =======================
# Hesap ayarlarÄ±
# =======================

def apply_account_settings(symbol: str):
    # 1) Hedge / Oneway
    try:
        mode = retry_call(client.futures_get_position_mode, "get_position_mode")
        dual = mode and mode.get("dualSidePosition", False)
        want = HEDGE_MODE
        if dual != want:
            retry_call(client.futures_change_position_mode, "change_position_mode",
                       dualSidePosition=want)
            print(f"âš™ï¸ Position mode -> {'HEDGE' if want else 'ONE-WAY'}")
        else:
            print("â„¹ï¸ Position mode zaten uygun (skip).")
    except BinanceAPIException as e:
        print("âš ï¸ position_mode:", e)

    # 2) Margin type
    try:
        retry_call(client.futures_change_margin_type, "change_margin_type",
                   symbol=symbol, marginType=MARGIN_TYPE)
        print(f"âš™ï¸ Margin type -> {MARGIN_TYPE}")
    except BinanceAPIException as e:
        if "No need to change margin type" in str(e) or e.code == -4046:
            print("â„¹ï¸ margin type zaten uygun (skip).")
        else:
            raise

    # 3) Leverage
    try:
        retry_call(client.futures_change_leverage, "change_leverage",
                   symbol=symbol, leverage=LEVERAGE)
        print(f"âš™ï¸ Leverage -> {LEVERAGE}x")
    except BinanceAPIException as e:
        print("â„¹ï¸ leverage set yanÄ±tÄ±:", e)

# =======================
# Order helpers
# =======================

def safe_create_order(desc: str, **params) -> Any:
    """None deÄŸerleri atarak create_order Ã§aÄŸÄ±r; hatalarÄ± tekrar dene."""
    clean = {k: v for k, v in params.items() if v is not None}
    return retry_call(client.futures_create_order, desc, **clean)

def entry_market(symbol: str, side: str, qty: float, pos_side: str, shadow: bool) -> None:
    p = dict(symbol=symbol, side=side, type="MARKET",
             quantity=qty, positionSide=pos_side)
    if shadow:
        print("DRY-RUN MARKET:", p)
        return
    safe_create_order("create_market", **p)

def stop_market_close(symbol: str, opp: str, stop_price: float, pos_side: str,
                      working: str, shadow: bool) -> None:
    # SL/TP: reduceOnly YOK, quantity YOK â†’ closePosition=True
    p = dict(symbol=symbol, side=opp, type="STOP_MARKET",
             stopPrice=stop_price, workingType=working,
             positionSide=pos_side, closePosition=True)
    if shadow:
        print("DRY-RUN SL:", p)
        return
    safe_create_order("create_stop(close)", **p)

def take_profit_close(symbol: str, opp: str, stop_price: float, pos_side: str,
                      working: str, shadow: bool) -> None:
    p = dict(symbol=symbol, side=opp, type="TAKE_PROFIT_MARKET",
             stopPrice=stop_price, workingType=working,
             positionSide=pos_side, closePosition=True)
    if shadow:
        print("DRY-RUN TP:", p)
        return
    safe_create_order("create_takeprofit(close)", **p)

def trailing_stop(symbol: str, opp: str, activation: float, callback_rate: float,
                  pos_side: str, qty: float, shadow: bool) -> None:
    # Trailing: closePosition desteklemez; qty + positionSide kullan.
    p = dict(symbol=symbol, side=opp, type="TRAILING_STOP_MARKET",
             activationPrice=activation, callbackRate=callback_rate,
             positionSide=pos_side, quantity=qty)
    if shadow:
        print("DRY-RUN TRAIL:", p)
        return
    safe_create_order("create_trailing", **p)

def _entry_price_after_fill(symbol: str, pos_side: str, tries: int = 6, delay_ms: int = 250) -> float:
    ep = 0.0
    for _ in range(tries):
        pis = retry_call(client.futures_position_information, "position_info", symbol=symbol)
        rec = next((p for p in pis if p.get("positionSide") == pos_side), None)
        if rec:
            ep = float(rec.get("entryPrice", 0.0))
            if ep > 0:
                break
        _sleep_ms(delay_ms)
    return ep or _last_price(symbol)

# =======================
# Bracket (ENTRY + SL/TP[/TRAIL])
# =======================

def bracket_market(symbol: str, side: str, qty: float,
                   sl_pct: float, tp_pct: float,
                   trail_pct: float, shadow: bool) -> Dict[str, Any]:
    s = symbol.upper()
    qty = round_qty(s, qty)
    pos_side = _position_side(side)
    opp = _opposite(side)

    # ENTRY
    entry_market(s, side, qty, pos_side, shadow)
    ep = _entry_price_after_fill(s, pos_side) if not shadow else _last_price(s)

    # Fiyatlar
    sl_p = round_price(s, ep * (1 - sl_pct) if side == "BUY" else ep * (1 + sl_pct)) if sl_pct > 0 else None
    tp_p = round_price(s, ep * (1 + tp_pct) if side == "BUY" else ep * (1 - tp_pct)) if tp_pct > 0 else None

    # SL/TP (closePosition=True)
    if sl_p:
        stop_market_close(s, opp, sl_p, pos_side, WORKING_TYPE, shadow)
        tg(f"ðŸ›¡ï¸ SL @ {sl_p}")
    if tp_p:
        take_profit_close(s, opp, tp_p, pos_side, WORKING_TYPE, shadow)
        tg(f"ðŸŽ¯ TP @ {tp_p}")

    # Trailing (opsiyonel)
    tr_ok = False
    if trail_pct and trail_pct > 0:
        cb = max(0.1, min(5.0, trail_pct * 100))  # % cinsinden [0.1,5.0]
        act = round_price(s, ep)
        trailing_stop(s, opp, act, cb, pos_side, qty, shadow)
        tr_ok = True
        tg(f"ðŸª¤ Trailing {trail_pct*100:.2f}% act@{act}")

    if not shadow:
        tg(f"ðŸš€ Entry {side} {s} qty={qty}  EPâ‰ˆ{ep:.2f}")

    return {"entry_price": ep, "sl": sl_p, "tp": tp_p, "trail": tr_ok}

# =======================
# PRO otomatik (Ã¶rnek)
# =======================

def kline_close(symbol: str, interval: str = "1m", limit: int = 30) -> list[float]:
    kl = retry_call(client.futures_klines, "klines", symbol=symbol, interval=interval, limit=limit)
    return [float(x[4]) for x in kl]

def ema(vals: list[float], n: int) -> float:
    k = 2/(n+1)
    e = vals[0]
    for v in vals[1:]:
        e = v*k + e*(1-k)
    return e

def auto_pro_decide(symbol: str) -> Tuple[str, float, float]:
    """Basit Ã¶rnek: EMA hizasÄ±na gÃ¶re yÃ¶n/SL/TP seÃ§."""
    closes = kline_close(symbol, "1m", 60)
    last = closes[-1]
    e20  = ema(closes, 20)
    e50  = ema(closes, 50)
    side = "BUY" if e20 > e50 else "SELL"
    risk = 0.01
    reward = 2.0
    print(f"ðŸ§  PRO Auto: tf=1m risk={risk:.2f} rr={reward:.1f} strict={STRICT_MODE}")
    return side, risk, risk*reward

# =======================
# Auth / CLI
# =======================

def auth_smoke():
    calibrate_timestamp_offset()
    try:
        lk = retry_call(client.futures_stream_get_listen_key, "listen_key")
        print("ðŸ”‘ listenKey OK:", bool(lk))
        bals = retry_call(client.futures_account_balance, "futures_balance")
        print("ðŸ” Auth OK â€“ balans kayÄ±t sayÄ±sÄ±:", len(bals))
    except Exception as e:
        print("âŒ Auth FAIL:", e)
        raise SystemExit(e)

def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Kiripto Nova Bracket Bot")
    p.add_argument("--symbol", help="Ã–rn: BTCUSDT")
    p.add_argument("--side", choices=["BUY", "SELL"])
    p.add_argument("--qty", type=float, help="Miktar")
    p.add_argument("--sl", type=float, default=SL_PCT_DEF)
    p.add_argument("--tp", type=float, default=TP_PCT_DEF)
    p.add_argument("--trail", type=float, default=TRAIL_PCT_DEF)
    p.add_argument("--shadow", action="store_true")
    p.add_argument("--auto-pro", action="store_true", help="Basit otomatik sinyal ve risk/Ã¶dÃ¼l")
    p.add_argument("--strict", action="store_true", help="STRICT mod (korumacÄ±)")
    return p.parse_args()

def main():
    args = parse_args()
    shadow = bool(args.shadow)
    strict = bool(args.strict or STRICT_MODE)

    auth_smoke()

    if not args.symbol and not args.auto_pro:
        raise SystemExit("LÃ¼tfen --symbol verin veya --auto-pro kullanÄ±n.")

    if args.auto_pro:
        # PRO mod â€” sembol verilmediyse BTCUSDT varsay
        sym = (args.symbol or "BTCUSDT").upper()
        side, risk, rr = auto_pro_decide(sym)
        qty = round_qty(sym, float(args.qty or 0.001))
        sl_pct = risk
        tp_pct = risk * rr
        print(f"PRO seÃ§imi: {side} {sym} qty={qty}  SL={sl_pct}  TP={tp_pct}")
    else:
        sym = args.symbol.upper()
        side = args.side.upper()
        qty  = float(args.qty)
        sl_pct = max(0.0, float(args.sl))
        tp_pct = max(0.0, float(args.tp))

    trail_pct = max(0.0, float(args.trail))

    print(f"ðŸŒ Ortam: {'TESTNET' if USE_TESTNET else 'MAINNET'} | STRICT_MODE={strict}")
    print(f"ðŸ§­ Symbol:{sym} Side:{side} Qty:{qty}")

    apply_account_settings(sym)

    # STRICT kontrol (Ã¶rnek): Ã§ok dar SL/TP reddet
    if strict:
        if sl_pct < 0.002:
            raise SystemExit("STRICT: SL Ã§ok dar (<0.2%)")
        if tp_pct < sl_pct*1.5:
            raise SystemExit("STRICT: TP, SL'in en az 1.5xâ€™i olmalÄ±")

    res = bracket_market(sym, side, qty, sl_pct, tp_pct, trail_pct, shadow)
    print(f"âœ… SonuÃ§: entry_price={res['entry_price']:.4f}, sl={res['sl']}, tp={res['tp']}, trail={res['trail']}")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("ðŸ›‘ Ä°ptal edildi.")
try:
    import regex  # type: ignore
except ModuleNotFoundError:
    print("âŒ 'regex' paketi eksik/bozuk. PowerShell'de: python -m pip install --no-cache-dir regex==2024.5.15")
    raise



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\cognitive_micro_targets.py
def identify_micro_targets(logs):
    targets = []
    for log in logs:
        mood = log["emotion"]
        strength = log["feeling_strength"]

        if mood in ["ðŸ’¡ Ä°lham", "ðŸŽ¯ Odak"] and strength > 70:
            target = "ðŸŽ–ï¸ Mikro Hedef: YaratÄ±cÄ± Ãœretim"
        elif mood == "ðŸ”¥ Tutku" and strength > 75:
            target = "âš”ï¸ Mikro Hedef: Liderlik ve Ä°nisiyatif"
        elif mood in ["ðŸŒ«ï¸ Yorgunluk", "ðŸ˜• KararsÄ±zlÄ±k"]:
            target = "ðŸ› ï¸ Mikro Hedef: Enerji Dengeleme"
        else:
            target = "ðŸ“š Mikro Hedef: Bilgi Toplama ve GÃ¶zlem"

        targets.append(
            f"{target} | GÃ¶rev: {log['task_id']} | Zaman: {log['timestamp']} | Duygu: {mood}"
        )
    return targets



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\collect_modules.py
#!/usr/bin/env python3
import sys, sysconfig, os, pkgutil, importlib.metadata as md, ast, argparse, pathlib
from datetime import datetime

def find_stdlib_modules():
    stdlib_path = sysconfig.get_paths().get('stdlib', '')
    mods = set()
    if hasattr(sys, "stdlib_module_names"):
        mods |= set(sys.stdlib_module_names)
    for root, dirs, files in os.walk(stdlib_path):
        dirs[:] = [d for d in dirs if d not in ("__pycache__", "test", "tests", "distutils", "idlelib")]
        for f in files:
            if f.endswith(".py") and f != "__init__.py":
                rel = os.path.relpath(os.path.join(root, f), stdlib_path)
                mod = rel[:-3].replace(os.sep, ".")
                if not any(part.startswith("_") for part in mod.split(".")):
                    mods.add(mod.split(".")[0])
    return sorted(mods)

def find_installed_distributions():
    rows = []
    for d in md.distributions():
        name = d.metadata.get('Name') or 'unknown'
        version = d.version or ''
        try:
            location = d._path
        except Exception:
            try:
                location = str(d.locate_file(""))
            except Exception:
                location = ""
        rows.append((name, version, location))
    rows.sort(key=lambda x: x[0].lower())
    return rows

def find_project_modules(project_root):
    project_root = pathlib.Path(project_root).resolve()
    rows = []
    for p in project_root.rglob("*.py"):
        if "__pycache__" in p.parts:
            continue
        rel = p.relative_to(project_root)
        mod = ".".join(rel.with_suffix("").parts)
        rows.append((str(rel), mod))
    rows.sort()
    return rows

def import_edges(project_root):
    project_root = pathlib.Path(project_root).resolve()
    edges = set()
    for p in project_root.rglob("*.py"):
        if "__pycache__" in p.parts:
            continue
        try:
            text = p.read_text(encoding="utf-8", errors="ignore")
            tree = ast.parse(text, filename=str(p))
        except Exception:
            continue
        src = ".".join(p.relative_to(project_root).with_suffix("").parts)
        for n in ast.walk(tree):
            if isinstance(n, ast.Import):
                for a in n.names: edges.add((src, a.name))
            elif isinstance(n, ast.ImportFrom) and n.module:
                edges.add((src, n.module))
    return sorted(edges)
def make_pdf(report_path, stdlib, dists, proj_mods, edges, title, project_root):
    try:
        from fpdf import FPDF
    except ImportError:
        # FPDF yoksa HTML Ã¼ret
        import html, pathlib
        def pre(s): return "<pre>" + html.escape(s) + "</pre>"
        html_out = [f"<h1>{html.escape(title)}</h1>",
                    f"<p>Proje kÃ¶kÃ¼: {project_root}</p>",
                    "<h2>1) Stdlib</h2>", pre(", ".join(stdlib)),
                    "<h2>2) Paketler</h2>", pre("\n".join(f"{n}=={v} [{l}]" for n,v,l in dists)),
                    "<h2>3) Proje ModÃ¼lleri</h2>", pre("\n".join(f"{p} -> {m}" for p,m in proj_mods)),
                    "<h2>4) Import Ä°liÅŸkileri</h2>", pre("\n".join(f"{a} -> {b}" for a,b in edges[:1500]))]
        html_text = "\n".join(html_out)
        html_path = report_path.rsplit(".",1)[0] + ".html"
        pathlib.Path(html_path).write_text(html_text, encoding="utf-8")
        print(f"[OK] HTML rapor hazÄ±r: {html_path}  (TarayÄ±cÄ±dan PDF olarak kaydet)")
        return
    # ... (FPDF yolu zaten senin dosyada var)

def make_pdf(report_path, stdlib, dists, proj_mods, edges, title, project_root):
    from fpdf import FPDF
    pdf = FPDF(orientation="P", unit="mm", format="A4")
    pdf.set_auto_page_break(auto=True, margin=12)

    def h1(t):
        pdf.set_font("Arial", "B", 16); pdf.cell(0, 10, t, ln=1); pdf.ln(2)
    def h2(t):
        pdf.set_font("Arial", "B", 12); pdf.cell(0, 8, t, ln=1)
    def mono(txt):
        pdf.set_font("Arial", "", 9)
        for line in txt.splitlines(): pdf.multi_cell(0, 5, line)

    pdf.add_page()
    h1(title)
    pdf.set_font("Arial", "", 10)
    pdf.multi_cell(0, 6, f"Olusturma: {datetime.now():%Y-%m-%d %H:%M} | Python {sys.version.split()[0]}")
    pdf.multi_cell(0, 6, f"Proje Koku: {project_root}")
    pdf.ln(3)

    h2("1) Standart Kutuphane (ust moduller)")
    mono(", ".join(stdlib) or "(bos)"); pdf.ln(2)

    h2("2) Kurulu Paketler (ad == surum) [konum]")
    mono("\n".join(f"{n} == {v}  [{l}]" for n,v,l in dists) or "(bos)"); pdf.ln(2)

    h2("3) Proje Ici Dosyalar -> Modul Adlari")
    mono("\n".join(f"{p}  ->  {m}" for p,m in proj_mods) or "(bos)"); pdf.ln(2)

    h2("4) Import Iliskileri (kaynak -> hedef)")
    if edges:
        cap = edges[:1500]
        mono("\n".join(f"{a}  ->  {b}" for a,b in cap))
        if len(edges) > 1500: pdf.ln(2); mono(f"... ({len(edges)-1500} adet daha)")
    else:
        mono("(bos)")
    pdf.output(report_path)

def main():
    import argparse, pathlib
    ap = argparse.ArgumentParser(description="Python modÃ¼l & paket envanteri â†’ PDF")
    ap.add_argument("--project-root", default=".", help="Proje kÃ¶kÃ¼ (varsayÄ±lan: .)")
    ap.add_argument("--pdf", default="modules_report.pdf", help="Ã‡Ä±ktÄ± PDF")
    args = ap.parse_args()

    stdlib = find_stdlib_modules()
    dists = find_installed_distributions()
    proj_mods = find_project_modules(args.project_root)
    edges = import_edges(args.project_root)
    make_pdf(args.pdf, stdlib, dists, proj_mods, edges, "Python Modul & Paket Envanteri", pathlib.Path(args.project_root).resolve())
    print(f"[OK] Rapor hazir: {args.pdf}")

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\commander.py
import importlib
import time
from strategies import rsi_strategy, macd_strategy
from execution import send_order, log_trade

active_strategies = [rsi_strategy, macd_strategy]

def commander():
    while True:
        for strategy in active_strategies:
            signal = strategy.evaluate()
            if signal == "buy":
                send_order("BUY")
                log_trade("BUY")
            elif signal == "sell":
                send_order("SELL")
                log_trade("SELL")
        time.sleep(30)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\community_predictor.py
def predict_next_trend(emotion_score, chain_metrics, dao_votes):
    weight_emotion = 0.6
    weight_chain = 0.3
    weight_dao = 0.1
    trend_score = (emotion_score * weight_emotion) + \
                  (chain_metrics * weight_chain) + \
                  (dao_votes * weight_dao)
    
    if trend_score > 0.75:
        return "ðŸ“ˆ YÃœKSELEN TREND: Topluluk coÅŸkulu, zincirde aktivite artÄ±yor."
    elif trend_score < 0.25:
        return "ðŸ“‰ RÄ°SK ZAMANI: Duygular dÃ¼ÅŸmÃ¼ÅŸ, DAO tepkileri sÄ±nÄ±rlÄ±."
    else:
        return "â³ DURGUN MOD: Ä°zlemeye devam, potansiyel patlama olabilir."

# Ã–rnek veri ile:
print(predict_next_trend(0.8, 0.6, 0.5))



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\config.py
# config.py
API_KEY = "BINANCE_API_KEYÄ°NÄ°_BURAYA_YAZ"
API_SECRET = "BINANCE_API_SECRETÄ°NÄ°_BURAYA_YAZ"


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\contract_behavior_predictor.py
import time
from sklearn.ensemble import RandomForestClassifier

def predict_behavior(features):
    # Ã–rnek eÄŸitimli model (yerine gerÃ§ek verilerle eÄŸitilmiÅŸ bir model entegre edilecek)
    model = RandomForestClassifier()
    
    # VarsayÄ±msal Ã¶zellikler (gerÃ§ek zincir verileri ile beslenmeli)
    sample_features = [[features["tx_count"], features["time_gap"], features["owner_changes"]]]
    
    try:
        prediction = model.predict(sample_features)
        return f"ðŸ”® Tahmin: SÃ¶zleÅŸme ileride {prediction[0]} davranÄ±ÅŸÄ±nÄ± sergileyebilir."
    except Exception as e:
        return f"âš ï¸ Tahmin yapÄ±lamadÄ±: {str(e)}"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\cosmic_chain_reader.py
def read_cosmic_signals(chain_cluster):
    patterns = []
    for chain in chain_cluster:
        if chain['time_alignment'] == 'eclipse' and chain['volume'] > 900_000:
            patterns.append("ðŸ”® Ay tutulmasÄ±yla tetiklenen zincir hareketi")
        if chain['emotion_vector'] == 'volatile' and chain['dao_flux'] > 65:
            patterns.append("âš¡ Duygusal DAO fÄ±rtÄ±nasÄ±")
    if not patterns:
        patterns.append("ðŸŒ™ Kozmos sakin, zincirler uyum iÃ§inde.")
    return patterns



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\cosmic_risk_analyzer.py
import numpy as np

class CosmicRiskAnalyzer:
    def __init__(self, risk_tolerance=0.5):
        self.risk_tolerance = risk_tolerance

    def analyze(self, volatility, exposure, sentiment_score):
        risk_score = (volatility * 0.4) + (exposure * 0.4) - (sentiment_score * 0.2)
        recommendation = "avoid" if risk_score > self.risk_tolerance else "engage"
        return {
            "risk_score": round(risk_score, 2),
            "recommendation": recommendation
        }

# SimÃ¼lasyon
analyzer = CosmicRiskAnalyzer(risk_tolerance=0.6)
result = analyzer.analyze(volatility=0.7, exposure=0.5, sentiment_score=0.3)
print("ðŸ§¬ Risk Analizi:", result)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\crosschain_intelligence_core.py
def analyze_crosschain_behavior(project_interactions):
    insights = []
    bridges = project_interactions.get("bridges", [])

    if len(bridges) > 2:
        insights.append("ðŸŒ YoÄŸun zincirler arasÄ± entegrasyon")
    
    if "governance_on_chain_A" in project_interactions and "execution_on_chain_B" in project_interactions:
        insights.append("ðŸ”„ Ã‡apraz zincir yÃ¶netiÅŸim stratejisi")

    if any(tx['volume'] > 100_000 for tx in project_interactions.get("transfers", [])):
        insights.append("ðŸš› YÃ¼ksek hacimli Ã§apraz zincir token hareketi")

    return insights if insights else ["ðŸ“¡ Zincirler arasÄ± stratejik etkileÅŸim dÃ¼ÅŸÃ¼k."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\crypto_alpha.py
# crypto_alpha.py
# â€œMÃ¼kemmeliyetÃ§iâ€ araÅŸtÄ±rma + paper-trading Ã§erÃ§evesi (canlÄ± emir YOK)
# Ã–zellikler: TÃ¼m sembollerde tarihsel ve canlÄ± (1m) veri, zengin TA, confluence skoru,
# risk yÃ¶netimi, vektÃ¶rize backtest, canlÄ± sinyal akÄ±ÅŸÄ± (log).

import argparse
import asyncio
import time
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from typing import List, Dict, Optional

import ccxt
import numpy as np
import pandas as pd
import pandas_ta as ta
from pydantic import BaseModel, Field
import pytz
import sys
import os
import logging

# ----------------------------
# KonfigÃ¼rasyon ve yardÄ±mcÄ±lar
# ----------------------------

class Settings(BaseModel):
    exchange_id: str = Field(default="binance")
    quote: str = Field(default="USDT")
    timeframe: str = Field(default="1m")  # "1m","5m","15m","1h","4h","1d"
    lookback_days: int = Field(default=120)
    max_symbols: int = Field(default=200)  # AÅŸÄ±rÄ± geniÅŸlemeyi sÄ±nÄ±rlamak iÃ§in
    warmup_bars: int = Field(default=400)  # GÃ¶stergeler iÃ§in Ä±sÄ±nma
    risk_target_vol_annual: float = Field(default=0.20)  # %20 yÄ±llÄ±k hedef volatilite
    risk_max_weight: float = Field(default=0.25)  # Her varlÄ±k iÃ§in max aÄŸÄ±rlÄ±k
    atr_stop_mult: float = Field(default=2.5)
    atr_tp_mult: float = Field(default=4.0)
    regime_fast: int = Field(default=50)
    regime_slow: int = Field(default=200)
    rsi_len: int = Field(default=14)
    stochrsi_len: int = Field(default=14)
    macd_fast: int = Field(default=12)
    macd_slow: int = Field(default=26)
    macd_signal: int = Field(default=9)
    bb_len: int = Field(default=20)
    bb_std: float = Field(default=2.0)
    adx_len: int = Field(default=14)
    mfi_len: int = Field(default=14)
    obv_smooth: int = Field(default=10)
    ema_fast: int = Field(default=20)
    ema_slow: int = Field(default=50)
    vwap_anchor: str = Field(default="D")  # GÃ¼nlÃ¼k VWAP
    live_poll_sec: int = Field(default=10)
    log_file: str = Field(default="signals.log")
    seed: int = Field(default=42)

@dataclass
class SymbolMeta:
    symbol: str
    base: str
    quote: str
    active: bool

def utc_now():
    return datetime.now(timezone.utc)

def annualize_vol(daily_vol):
    return daily_vol * np.sqrt(365)

def to_ms(dt: datetime):
    return int(dt.timestamp() * 1000)

# ----------------------------
# Borsa adaptÃ¶rÃ¼ (CCXT)
# ----------------------------

class ExchangeAdapter:
    def __init__(self, settings: Settings):
        self.s = settings
        ex_class = getattr(ccxt, self.s.exchange_id)
        self.ex = ex_class({"enableRateLimit": True})
        self.ex.load_markets()

    def list_symbols(self) -> List[SymbolMeta]:
        metas = []
        for sym, meta in self.ex.markets.items():
            try:
                base = meta.get("base")
                quote = meta.get("quote")
                active = bool(meta.get("active", True))
                spot = meta.get("spot", True)
                if not spot or not active:
                    continue
                if quote == self.s.quote and base and quote and isinstance(sym, str):
                    metas.append(SymbolMeta(sym, base, quote, active))
            except Exception:
                continue
        # Likidite/isim sÄ±ralamasÄ±: USDT ile bitenleri ve popÃ¼lerleri Ã¶ne al
        metas = sorted(metas, key=lambda x: (not x.symbol.endswith(self.s.quote), x.symbol))
        return metas[: self.s.max_symbols]

    def fetch_ohlcv(self, symbol: str, timeframe: str, since_ms: int, limit: int = 1000) -> pd.DataFrame:
        raw = self.ex.fetch_ohlcv(symbol, timeframe=timeframe, since=since_ms, limit=limit)
        if not raw:
            return pd.DataFrame()
        df = pd.DataFrame(raw, columns=["time","open","high","low","close","volume"])
        df["time"] = pd.to_datetime(df["time"], unit="ms", utc=True)
        df.set_index("time", inplace=True)
        return df

    def fetch_ohlcv_range(self, symbol: str, timeframe: str, start: datetime, end: datetime) -> pd.DataFrame:
        # CCXT kÄ±sÄ±tlarÄ±na uygun â€œsayfa sayfaâ€ Ã§ekme
        tf_ms = self.timeframe_to_ms(timeframe)
        since = to_ms(start)
        frames = []
        while True:
            chunk = self.fetch_ohlcv(symbol, timeframe, since, limit=1000)
            if chunk.empty:
                break
            frames.append(chunk)
            last = int(chunk.index[-1].timestamp() * 1000)
            if last >= to_ms(end) - tf_ms:
                break
            since = last + tf_ms
            # hÄ±z limiti
            time.sleep(self.ex.rateLimit / 1000.0)
        if not frames:
            return pd.DataFrame()
        df = pd.concat(frames)
        df = df[~df.index.duplicated(keep="last")]
        return df

    @staticmethod
    def timeframe_to_ms(tf: str) -> int:
        unit = tf[-1]
        n = int(tf[:-1])
        mult = {"m":60, "h":3600, "d":86400}[unit]
        return n * mult * 1000

# ----------------------------
# GÃ¶sterge/Ã¶zellik hesaplayÄ±cÄ±
# ----------------------------

class FeatureEngineer:
    def __init__(self, s: Settings):
        self.s = s

    def enrich(self, df: pd.DataFrame) -> pd.DataFrame:
        df = df.copy()

        # EMAs ve SMA
        df["ema_fast"] = ta.ema(df["close"], length=self.s.ema_fast)
        df["ema_slow"] = ta.ema(df["close"], length=self.s.ema_slow)
        df["sma_bb"] = ta.sma(df["close"], length=self.s.bb_len)

        # Bollinger
        bb = ta.bbands(df["close"], length=self.s.bb_len, std=self.s.bb_std)
        df["bb_low"] = bb["BBL_"+str(self.s.bb_len)+"_2.0"]
        df["bb_mid"] = bb["BBM_"+str(self.s.bb_len)+"_2.0"]
        df["bb_high"] = bb["BBU_"+str(self.s.bb_len)+"_2.0"]
        df["bb_width"] = (df["bb_high"] - df["bb_low"]) / df["bb_mid"]

        # RSI, StochRSI
        df["rsi"] = ta.rsi(df["close"], length=self.s.rsi_len)
        st = ta.stochrsi(df["close"], length=self.s.stochrsi_len)
        if st is not None and not st.empty:
            df["stochrsi_k"] = st.iloc[:,0]
            df["stochrsi_d"] = st.iloc[:,1]

        # MACD
        macd = ta.macd(df["close"], fast=self.s.macd_fast, slow=self.s.macd_slow, signal=self.s.macd_signal)
        df["macd"] = macd["MACD_"+str(self.s.macd_fast)+"_"+str(self.s.macd_slow)+"_"+str(self.s.macd_signal)]
        df["macd_signal"] = macd["MACDs_"+str(self.s.macd_fast)+"_"+str(self.s.macd_slow)+"_"+str(self.s.macd_signal)]
        df["macd_hist"] = macd["MACDh_"+str(self.s.macd_fast)+"_"+str(self.s.macd_slow)+"_"+str(self.s.macd_signal)]

        # ATR, ADX
        df["atr"] = ta.atr(df["high"], df["low"], df["close"], length=self.s.adx_len)
        adx = ta.adx(df["high"], df["low"], df["close"], length=self.s.adx_len)
        df["adx"] = adx["ADX_"+str(self.s.adx_len)]

        # OBV (smooth)
        df["obv"] = ta.obv(df["close"], df["volume"])
        df["obv_s"] = ta.ema(df["obv"], length=self.s.obv_smooth)

        # MFI
        df["mfi"] = ta.mfi(df["high"], df["low"], df["close"], df["volume"], length=self.s.mfi_len)

        # VWAP (gÃ¼nlÃ¼k)
        df["vwap"] = ta.vwap(df["high"], df["low"], df["close"], df["volume"])

        # Rejim filtresi (trend)
        df["regime_fast"] = ta.ema(df["close"], length=self.s.regime_fast)
        df["regime_slow"] = ta.ema(df["close"], length=self.s.regime_slow)
        df["in_trend_up"] = (df["regime_fast"] > df["regime_slow"]).astype(int)

        # Getiri ve volatilite
        df["ret"] = df["close"].pct_change()
        df["vol_daily"] = df["ret"].rolling(24*60 if self.s.timeframe.endswith("m") else 20).std()  # kaba tahmin
        df["vol_annual"] = df["vol_daily"] * np.sqrt(365)

        # IsÄ±nma temizliÄŸi
        df = df.iloc[self.s.warmup_bars:].dropna()
        return df

# ----------------------------
# Strateji ve risk yÃ¶netimi
# ----------------------------

class Strategy:
    def __init__(self, s: Settings):
        self.s = s

    def signal(self, df: pd.DataFrame) -> pd.DataFrame:
        out = df.copy()

        # Confluence skoru (0-100)
        score = np.zeros(len(out))

        # Trend skorlarÄ±
        score += 10 * (out["ema_fast"] > out["ema_slow"]).astype(int)
        score += 10 * out["in_trend_up"]

        # Momentum
        score += 10 * ((out["macd"] > out["macd_signal"]) & (out["macd_hist"] > 0)).astype(int)
        score += 10 * (out["rsi"].between(50, 70)).astype(int)
        score += 10 * ((out["stochrsi_k"] > out["stochrsi_d"]) & (out["stochrsi_k"] < 0.8)).fillna(0).astype(int)

        # Volatilite/bant
        score += 10 * (out["close"] > out["bb_mid"]).astype(int)
        score += 10 * (out["bb_width"] > out["bb_width"].rolling(100).median()).fillna(0).astype(int)

        # GÃ¼Ã§/akÄ±ÅŸ
        score += 10 * (out["adx"] > 20).astype(int)
        score += 10 * (out["obv"] > out["obv_s"]).astype(int)
        score += 10 * (out["mfi"].between(45, 70)).astype(int)

        out["score"] = score

        # Sinyal kurallarÄ±
        out["long_entry"] = (
            (out["score"] >= 60) &
            (out["close"] > out["vwap"]) &
            (out["in_trend_up"] == 1)
        )

        out["long_exit"] = (
            (out["score"] <= 40) |
            (out["close"] < out["ema_slow"])
        )

        # ATR tabanlÄ± SL/TP
        out["sl"] = out["close"] - self.s.atr_stop_mult * out["atr"]
        out["tp"] = out["close"] + self.s.atr_tp_mult * out["atr"]

        # Pozisyon aÄŸÄ±rlÄ±ÄŸÄ± (vol hedefleme)
        # w = min(w_max, sigma_target / sigma_asset)
        sigma_asset = out["vol_annual"].clip(lower=1e-6)
        w = (self.s.risk_target_vol_annual / sigma_asset).clip(upper=self.s.risk_max_weight)
        out["weight"] = w.fillna(0)

        return out

# ----------------------------
# VektÃ¶rize backtest
# ----------------------------

class Backtester:
    def __init__(self, s: Settings):
        self.s = s

    def run(self, df: pd.DataFrame) -> Dict[str, float]:
        d = df.copy()
        d["pos"] = 0
        d["pos"] = np.where(d["long_entry"], 1, d["pos"])
        d["pos"] = np.where(d["long_exit"], 0, d["pos"])
        d["pos"] = d["pos"].replace(to_replace=0, method="ffill").fillna(0)

        # Stop/TP: pratik yaklaÅŸÄ±m (yaklaÅŸÄ±k)
        d["sl_hit"] = (d["low"] <= d["sl"])
        d["tp_hit"] = (d["high"] >= d["tp"])

        # Ä°ÅŸlem getirisi (yaklaÅŸÄ±k): bir bar sonra gerÃ§ekleÅŸen getiriyi kullan
        d["gross_ret"] = d["ret"] * d["pos"] * d["weight"].clip(lower=0)

        # SL/TP ayarlamasÄ±: kaba cezalandÄ±rma/kapama
        d.loc[d["sl_hit"], "gross_ret"] = -abs(d["atr"] / d["close"])  # stop penalizasyonu
        d.loc[d["tp_hit"], "gross_ret"] = abs(d["atr"] / d["close"]) * 0.5  # tp Ã¶dÃ¼lÃ¼ (yaklaÅŸÄ±k)

        d["equity"] = (1 + d["gross_ret"].fillna(0)).cumprod()

        # Metrikler
        total_ret = d["equity"].iloc[-1] - 1
        cagr = (d["equity"].iloc[-1]) ** (365 * 24 * 60 / len(d)) - 1 if len(d) > 0 else 0
        dd = d["equity"] / d["equity"].cummax() - 1
        maxdd = dd.min()
        sharpe = d["gross_ret"].mean() / (d["gross_ret"].std() + 1e-9) * np.sqrt(365*24*60)  # 1m bar iÃ§in

        hit_rate = (d["tp_hit"].sum()) / (d["tp_hit"].sum() + d["sl_hit"].sum() + 1e-9)

        return {
            "TotalReturn": float(total_ret),
            "CAGR": float(cagr),
            "Sharpe": float(sharpe),
            "MaxDrawdown": float(maxdd),
            "HitRate": float(hit_rate),
            "Bars": int(len(d)),
        }

# ----------------------------
# CanlÄ±/paper akÄ±ÅŸ yÃ¶neticisi
# ----------------------------

class LivePaper:
    def __init__(self, s: Settings, ex: ExchangeAdapter, fe: FeatureEngineer, st: Strategy):
        self.s = s
        self.ex = ex
        self.fe = fe
        self.st = st
        self.logger = logging.getLogger("signals")

    def log_signal(self, symbol: str, row: pd.Series):
        msg = {
            "ts": row.name.strftime("%Y-%m-%d %H:%M:%S%z"),
            "symbol": symbol,
            "price": round(float(row["close"]), 8),
            "score": int(row["score"]),
            "weight": round(float(row["weight"]), 4),
            "entry": bool(row["long_entry"]),
            "exit": bool(row["long_exit"]),
            "sl": round(float(row["sl"]), 8),
            "tp": round(float(row["tp"]), 8),
        }
        self.logger.info(msg)
        print(msg)

    async def run_once(self, symbols: List[SymbolMeta]):
        end = utc_now()
        start = end - timedelta(days=self.s.lookback_days)

        for sm in symbols:
            try:
                df = self.ex.fetch_ohlcv_range(sm.symbol, self.s.timeframe, start, end)
                if df.empty or len(df) < self.s.warmup_bars + 10:
                    continue
                df = self.fe.enrich(df)
                df = self.st.signal(df)
                last = df.iloc[-1]
                self.log_signal(sm.symbol, last)
                await asyncio.sleep(0)  # allow cooperative scheduling
            except Exception as e:
                self.logger.error(f"{sm.symbol} error: {e}")
                continue

    async def run_loop(self, symbols: List[SymbolMeta]):
        while True:
            await self.run_once(symbols)
            await asyncio.sleep(self.s.live_poll_sec)

# ----------------------------
# Uygulama giriÅŸi
# ----------------------------

def setup_logging(path: str):
    logger = logging.getLogger("signals")
    logger.setLevel(logging.INFO)
    fh = logging.FileHandler(path)
    fh.setLevel(logging.INFO)
    fmt = logging.Formatter("%(asctime)s - %(message)s")
    fh.setFormatter(fmt)
    if not logger.handlers:
        logger.addHandler(fh)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--exchange", type=str, default="binance")
    parser.add_argument("--quote", type=str, default="USDT")
    parser.add_argument("--timeframe", type=str, default="1m")
    parser.add_argument("--lookback_days", type=int, default=120)
    parser.add_argument("--max_symbols", type=int, default=120)
    parser.add_argument("--live_poll_sec", type=int, default=15)
    parser.add_argument("--log_file", type=str, default="signals.log")
    args = parser.parse_args()

    s = Settings(
        exchange_id=args.exchange,
        quote=args.quote,
        timeframe=args.timeframe,
        lookback_days=args.lookback_days,
        max_symbols=args.max_symbols,
        live_poll_sec=args.live_poll_sec,
        log_file=args.log_file,
    )

    np.random.seed(s.seed)
    setup_logging(s.log_file)

    print(f"[{utc_now()}] Load exchange: {s.exchange_id}")
    ex = ExchangeAdapter(s)
    syms = ex.list_symbols()
    print(f"Semboller (ilk {len(syms)}):", [x.symbol for x in syms[:10]], "...")

    fe = FeatureEngineer(s)
    st = Strategy(s)

    # HÄ±zlÄ± bir backtest Ã¶rneÄŸi (tek sembol)
    sample = None
    for sm in syms[:1]:
        df = ex.fetch_ohlcv_range(sm.symbol, s.timeframe, utc_now()-timedelta(days=s.lookback_days), utc_now())
        if not df.empty:
            sample = (sm.symbol, fe.enrich(df))
            break
    if sample:
        sym, sdf = sample
        sdf = st.signal(sdf)
        bt = Backtester(s)
        metrics = bt.run(sdf)
        print("Ã–rnek backtest:", sym, metrics)

    # CanlÄ±/paper sinyal dÃ¶ngÃ¼sÃ¼
    live = LivePaper(s, ex, fe, st)
    try:
        asyncio.run(live.run_loop(syms))
    except KeyboardInterrupt:
        print("Ã‡Ä±kÄ±ÅŸ...")

if __name__ == "__main__":
    main()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\crypto_identitiy_mapper.py
def assign_character_profile(emotion, ethics_score, tx_behavior):
    if emotion == "positive" and ethics_score > 0.7 and tx_behavior == "smooth":
        return "ðŸŒŠ Bilge Su Rahibi"
    elif emotion == "negative" and ethics_score < 0.5 and tx_behavior == "chaotic":
        return "ðŸ”¥ Asi Ä°syancÄ±"
    else:
        return "ðŸŒ± Stratejik BahÃ§Ä±van"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\crypto_strategy.py
# main.py
from kiripto_nova.data.pipelines.data_loader import load_binance_data
from kiripto_nova.strategies.strategy_engine import apply_indicators, check_long_signal, check_short_signal
from trade_executor import execute_trade

symbol = "DOGE/USDT"
timeframe = "15m"

# 1. Veri YÃ¼kle
ohlcv = load_binance_data(symbol, timeframe)

# 2. GÃ¶stergeleri Uygula
ohlcv = apply_indicators(ohlcv)

# 3. Sinyal KontrolÃ¼
if check_long_signal(ohlcv):
    execute_trade(symbol, "buy", amount=100)
elif check_short_signal(ohlcv):
    execute_trade(symbol, "sell", amount=100)
else:
    print("Sinyal yok.")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\crypto_tracker_engine.py
class CryptoHunter:
    def __init__(self):
        self.signals = []
        self.past_patterns = []

    def detect_signal(self, data):
        if "dalgalanma" in data or "anormal hareket" in data:
            self.signals.append(data)
            return "ðŸš¨ Yeni sinyal algÄ±landÄ±!"
        return "ðŸŸ¢ Normal akÄ±ÅŸ devam ediyor."

    def compare_to_history(self):
        if not self.signals:
            return "HenÃ¼z analiz edilecek sinyal yok."
        for sig in self.signals:
            for past in self.past_patterns:
                if set(sig.split()) & set(past.split()):
                    return f"ðŸ“ Tarihle benzerlik var! Signal: {sig}"
        return "ðŸ” Åžimdilik Ã¶zgÃ¼n sinyaller kaydediliyor."

hunter = CryptoHunter()
hunter.past_patterns = ["dalgalanma hÄ±zlÄ± yÃ¼kseliÅŸ", "anormal hareket dÃ¼ÅŸÃ¼ÅŸ"]
print(hunter.detect_signal("ani dalgalanma tespiti"))
print(hunter.compare_to_history())



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\cryptoverse_vision_board.py
import streamlit as st

def cryptoverse_vision_board(signal_data, strategy_outcomes):
    st.title("ðŸŒ Cryptoverse Vision Board")
    st.line_chart(signal_data, use_container_width=True)
    st.bar_chart(strategy_outcomes, use_container_width=True)
    st.success("ðŸª Strateji ModÃ¼lleri Senkronize Edildi!")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\csv_writer.py
import pandas as pd

def save_to_csv(data, filename="signals.csv"):
    if not data:
        return
    df = pd.DataFrame(data)
    df.to_csv(filename, index=False, encoding="utf-8")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\daily_pnl_report.py
# daily_pnl_report.py
# GÃ¼nlÃ¼k PnL Ã¶zeti: REALIZED_PNL + FUNDING_FEE + COMMISSION + diÄŸer kalemler
# Net realized ve aÃ§Ä±k (unrealized) PnL'i hesaplar, Telegram'a (varsayÄ±lan) yollar.

from __future__ import annotations
import os, sys, time, argparse
from decimal import Decimal
from datetime import datetime, timedelta
try:
    from zoneinfo import ZoneInfo  # Py>=3.9
except Exception:
    ZoneInfo = None

from dotenv import load_dotenv
from binance.client import Client
from binance.exceptions import BinanceAPIException

# ---- Telegram opsiyonel
try:
    import notify as nt
except Exception:
    nt = None

def env_bool(k: str, default=False) -> bool:
    return os.getenv(k, str(default)).strip().lower() in ("1","true","yes","on")

def build_client():
    load_dotenv()
    use_testnet = env_bool("BINANCE_USE_TESTNET", True)
    if use_testnet:
        api_key = (os.getenv("BINANCE_API_KEY_TEST") or "").strip()
        api_sec = (os.getenv("BINANCE_API_SECRET_TEST") or "").strip()
        base = os.getenv("BINANCE_FUTURES_URL_TEST", "https://testnet.binancefuture.com").strip().rstrip("/")
    else:
        api_key = (os.getenv("BINANCE_API_KEY_MAIN") or os.getenv("BINANCE_API_KEY") or "").strip()
        api_sec = (os.getenv("BINANCE_API_SECRET_MAIN") or os.getenv("BINANCE_API_SECRET") or "").strip()
        base = os.getenv("BINANCE_FUTURES_URL_MAIN", "https://fapi.binance.com").strip().rstrip("/")

    if not api_key or not api_sec:
        print("âŒ API key/secret bulunamadÄ± (.env).")
        sys.exit(1)

    c = Client(api_key, api_sec, testnet=use_testnet)
    c.FUTURES_URL = f"{base}/fapi"
    return c, use_testnet

def to_ms(dt_: datetime) -> int:
    return int(dt_.timestamp() * 1000)

def day_range(tz_name: str, day: str | None) -> tuple[int,int,str]:
    # tz
    if ZoneInfo is None:
        tz = None
    else:
        tz = ZoneInfo(tz_name)
    now = datetime.now(tz) if tz else datetime.now()
    if day:
        y, m, d = map(int, day.split("-"))
        start = datetime(y, m, d, 0, 0, 0, tzinfo=tz)
    else:
        start = datetime(now.year, now.month, now.day, 0, 0, 0, tzinfo=tz)
    end = start + timedelta(days=1)
    label = start.strftime("%Y-%m-%d")
    return to_ms(start), to_ms(end), label

def incomes_between(client: Client, start_ms: int, end_ms: int):
    # Sayfa sayfa Ã§ek (gÃ¼nde 1000â€™i geÃ§miyor ama saÄŸlam olsun)
    out = []
    cursor = start_ms
    while True:
        page = client.futures_income_history(startTime=cursor, endTime=end_ms, limit=1000)
        if not page:
            break
        out.extend(page)
        if len(page) < 1000:
            break
        last_t = max(int(x["time"]) for x in page)
        cursor = last_t + 1
        time.sleep(0.1)
    return out

def dec(x) -> Decimal:
    try:
        return Decimal(str(x))
    except Exception:
        return Decimal(0)

def summarize_incomes(rows):
    # incomeType: REALIZED_PNL, FUNDING_FEE, COMMISSION, ...
    buckets = {}
    total = Decimal(0)
    for r in rows:
        t = r.get("incomeType", "OTHER")
        val = dec(r.get("income", "0"))
        buckets[t] = buckets.get(t, Decimal(0)) + val
        total += val
    # En Ã§ok katkÄ± yapan sembolleri de Ã§Ä±karalÄ±m (opsiyonel)
    by_symbol = {}
    for r in rows:
        sym = r.get("symbol") or "ALL"
        by_symbol[sym] = by_symbol.get(sym, Decimal(0)) + dec(r.get("income", "0"))
    top_syms = sorted(by_symbol.items(), key=lambda kv: kv[1], reverse=True)[:5]
    return buckets, total, top_syms

def unrealized_pnl(client: Client) -> Decimal:
    pos = client.futures_position_information()
    upnl = Decimal(0)
    for p in pos:
        upnl += dec(p.get("unRealizedProfit", "0"))
    return upnl

def wallet_snapshot(client: Client):
    acct = client.futures_account()
    # totalWalletBalance: cÃ¼zdan (USDT), totalUnrealizedProfit: aÃ§Ä±k PnL
    try:
        w = dec(acct.get("totalWalletBalance","0"))
        u = dec(acct.get("totalUnrealizedProfit","0"))
    except Exception:
        w = u = Decimal(0)
    avail = Decimal(0)
    try:
        bals = client.futures_account_balance()
        usdt = next((b for b in bals if b.get("asset")=="USDT"), None)
        if usdt:
            avail = dec(usdt.get("availableBalance","0"))
    except Exception:
        pass
    return w, u, avail

def fmt_usdt(x: Decimal) -> str:
    sign = "+" if x >= 0 else "-"
    return f"{sign}{abs(x):,.2f} USDT"

def build_message(date_label: str, buckets: dict, total: Decimal, upnl: Decimal,
                  wallet: Decimal, avail: Decimal, top_syms) -> str:
    rlz = buckets.get("REALIZED_PNL", Decimal(0))
    fund = buckets.get("FUNDING_FEE", Decimal(0))
    fee  = buckets.get("COMMISSION", Decimal(0))
    other = total - rlz - fund - fee
    lines = []
    lines.append(f"ðŸ“Š GÃ¼nlÃ¼k PnL Ã–zeti â€” {date_label}")
    lines.append(f"â€¢ Realized: {fmt_usdt(rlz)}")
    lines.append(f"â€¢ Funding : {fmt_usdt(fund)}")
    lines.append(f"â€¢ Fees    : {fmt_usdt(fee)}")
    if other != 0:
        lines.append(f"â€¢ DiÄŸer   : {fmt_usdt(other)}")
    lines.append(f"â€” Net Realized: {fmt_usdt(total)}")
    lines.append(f"â€” Unrealized  : {fmt_usdt(upnl)}")
    lines.append(f"â€” Wallet      : {wallet:,.2f} USDT  |  Available: {avail:,.2f} USDT")
    if top_syms:
        sy = ", ".join([f"{s}:{v:.2f}" for s,v in top_syms])
        lines.append(f"Top semboller: {sy}")
    return "\n".join(lines)

def main():
    ap = argparse.ArgumentParser(description="GÃ¼nlÃ¼k PnL Raporu (Futures)")
    ap.add_argument("--date", help="YYYY-MM-DD (boÅŸsa bugÃ¼n)")
    ap.add_argument("--tz", default=os.getenv("TIMEZONE","Europe/Zurich"), help="Saat dilimi (Ã¶rn Europe/Zurich)")
    ap.add_argument("--nosend", action="store_true", help="Telegramâ€™a gÃ¶nderme, sadece yazdÄ±r")
    args = ap.parse_args()

    client, use_testnet = build_client()
    start_ms, end_ms, label = day_range(args.tz, args.date)

    # API health quick check
    try:
        client.futures_ping()
    except Exception as e:
        print("âŒ futures_ping:", e); sys.exit(1)

    # Data
    inc = incomes_between(client, start_ms, end_ms)
    buckets, total, top_syms = summarize_incomes(inc)
    upnl = unrealized_pnl(client)
    wallet, acct_upnl, avail = wallet_snapshot(client)

    msg = build_message(label, buckets, total, upnl, wallet, avail, top_syms)

    print("\n" + msg + "\n")

    # Telegram
    if not args.nosend and nt and hasattr(nt, "tg_enabled") and nt.tg_enabled():
        try:
            ok = nt.send(msg)
            print("ðŸ“¨ Telegram:", "OK" if ok else "FAILED")
        except Exception as e:
            print("ðŸ“¨ Telegram HATA:", e)

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\dark_coin_mapper.py
def map_dark_coin_routes(transactions):
    risky_paths = []
    for tx in transactions:
        if tx["anomaly_score"] > 0.8:
            path = f"ðŸ” {tx['from']} â†’ {tx['to']} | âš ï¸ Risk Skoru: {tx['anomaly_score']}"
            risky_paths.append(path)
    return risky_paths




### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\decision_engine.py
def trading_signal(label, score):
    if label == "positive" and score > 0.7:
        return "AL"
    elif label == "negative" and score > 0.6:
        return "SAT"
    else:
        return "BEKLE"

def decision_based_on_news(news_data):
    from sentiment import analyze_sentiment
    decisions = []
    for news in news_data:
        label, score = analyze_sentiment(news["title"])
        signal = trading_signal(label, score)
        decisions.append({"title": news["title"], "label": label, "score": score, "signal": signal})
    return decisions


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\deep_insight_engine.py
class DeepKnowledgeEngine:
    def __init__(self):
        self.cache = []
        self.frameworks = ["LLM", "NeuroGraph", "Temporal Logic"]

    def absorb_data(self, new_info):
        # Bilgi iÅŸleniyor...
        self.cache.append(new_info)

    def synthesize_idea(self):
        if len(self.cache) > 5:
            return f"GÃ¶rsel strateji Ã¶nerisi: {self.cache[-1]} + {self.frameworks[1]}"
        return "Bilgi seviyesi henÃ¼z kritik eÅŸikte deÄŸil."

    def pulse_to_next_stage(self):
        print("ðŸ”® Derinlik katmanÄ± etkinleÅŸtirildi! Yeni baÄŸlantÄ±lar kuruluyor...")

# KullanÄ±m
engine = DeepKnowledgeEngine()
engine.absorb_data("Hedef sistemde dikkat Ã§eken sinyal")
engine.pulse_to_next_stage()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\destiny_flux_analyzer.py
def analyze_destiny_flux(chain_energy_flow):
    destiny_signals = []
    for event in chain_energy_flow:
        if event['potential'] > 85 and event['visibility'] < 30:
            destiny_signals.append(f"ðŸŒ  GÃ¶rÃ¼nmeyen Kader Tetikleyicisi: {event['id']}")
    return destiny_signals if destiny_signals else ["ðŸ§˜ Kod akÄ±ÅŸÄ±nda olaÄŸanÃ¼stÃ¼ bir kader tetikleyicisi yok."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\destiny_mission_encoder.py
def assign_destiny_missions(future_scenarios):
    missions = []
    for scenario in future_scenarios:
        if "Bilgi devrimi" in scenario:
            missions.append("ðŸ“š GÃ¶rev: HaftalÄ±k bilgi paylaÅŸÄ±mlarÄ± baÅŸlat. Toplumun yaratÄ±cÄ± zekasÄ±nÄ± ateÅŸle.")
        elif "GÃ¼venlik duvarlarÄ±" in scenario:
            missions.append("ðŸ›¡ï¸ GÃ¶rev: Kritik altyapÄ±lar iÃ§in risk analizi yap. Koruma planÄ± oluÅŸtur.")
    return missions if missions else ["ðŸ”• Åžu anda gÃ¶rev tanÄ±mÄ± yok. Yeni senaryo bekleniyor."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\emotion_chain_decoder.py
from textblob import TextBlob

def decode_emotion(content_stream):
    mood_score = 0
    mood_map = {"positive": "ðŸŒž", "negative": "ðŸŒ©ï¸", "neutral": "ðŸŒ¥ï¸"}

    for text in content_stream:
        blob = TextBlob(text)
        polarity = blob.sentiment.polarity
        if polarity > 0.2:
            mood_score += 1
        elif polarity < -0.2:
            mood_score -= 1

    if mood_score > 5:
        mood = "positive"
    elif mood_score < -5:
        mood = "negative"
    else:
        mood = "neutral"

    return f"ðŸ”® Topluluk Duygusu: {mood_map[mood]} ({mood.upper()})"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ethical_signal_analyzer.py
def analyze_ethical_signals(project_logs):
    signals = []
    if "airdrop" in project_logs and project_logs["airdrop"].get("fair_distribution"):
        signals.append("ðŸŽ Adil airdrop tespiti")

    if "dev_withdrawal" in project_logs and project_logs["dev_withdrawal"] > 50_000:
        signals.append("âš ï¸ GeliÅŸtirici token dump ÅŸÃ¼phesi")

    if "dao_votes" in project_logs and project_logs["dao_votes"].get("power_index") > 0.6:
        signals.append("ðŸ—³ï¸ GÃ¼Ã§ yoÄŸunlaÅŸmasÄ± riski (DAO)")

    return signals if signals else ["âœ… Etik sinyaller dengeli ve olumlu."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\eval_error_rate.py
# eval_error_rate.py
# KullanÄ±m:
#   python eval_error_rate.py --symbol BTCUSDT --tf 5m --limit 1500 --atr 1.5 --rr 2.0
# Gereken: requests, pandas, numpy

import argparse, time, math, requests
import pandas as pd
import numpy as np

BASE = "https://fapi.binance.com"

def fetch_klines(symbol: str, interval: str, limit: int=1500):
    url = f"{BASE}/fapi/v1/klines"
    r = requests.get(url, params={"symbol": symbol, "interval": interval, "limit": limit}, timeout=20)
    r.raise_for_status()
    kl = r.json()
    cols = ["open_time","open","high","low","close","volume","close_time","qav","trades","tbbav","tbqav","ignore"]
    df = pd.DataFrame(kl, columns=cols)
    for c in ["open","high","low","close","volume"]:
        df[c] = pd.to_numeric(df[c])
    df["open_time"]  = pd.to_datetime(df["open_time"], unit="ms")
    df["close_time"] = pd.to_datetime(df["close_time"], unit="ms")
    return df[["open_time","close_time","open","high","low","close","volume"]]

def ema(s: pd.Series, n: int):
    return s.ewm(span=n, adjust=False).mean()

def rsi(s: pd.Series, n: int=14):
    d = s.diff()
    up = d.clip(lower=0); dn = -d.clip(upper=0)
    rs_up = up.ewm(alpha=1/n, adjust=False).mean()
    rs_dn = dn.ewm(alpha=1/n, adjust=False).mean()
    rs = rs_up / (rs_dn + 1e-12)
    return 100 - (100 / (1 + rs))

def atr(df: pd.DataFrame, n: int=14):
    prev_close = df["close"].shift(1)
    tr = pd.concat([
        (df["high"]-df["low"]),
        (df["high"]-prev_close).abs(),
        (df["low"]-prev_close).abs()
    ], axis=1).max(axis=1)
    return tr.ewm(alpha=1/n, adjust=False).mean()

def backtest(df: pd.DataFrame, atr_mult=1.5, rr=2.0):
    df = df.copy()
    df["ema20"] = ema(df["close"], 20)
    df["ema50"] = ema(df["close"], 50)
    df["rsi14"] = rsi(df["close"], 14)
    df["atr14"] = atr(df, 14)
    # Sinyal: score > 0.5 -> LONG, < -0.5 -> SHORT
    def score(i):
        sc = 0.0
        sc += 0.4 if df.at[i,"ema20"] > df.at[i,"ema50"] else -0.4
        if df.at[i,"rsi14"] > 55: sc += 0.2
        elif df.at[i,"rsi14"] < 45: sc -= 0.2
        return sc

    trades = []
    pos = None  # dict: side, entry, sl, tp, open_idx
    for i in range(60, len(df)-1):  # yeterli Ä±sÄ±nma
        c_open = df.at[i+1, "open"]   # bir sonraki bar giriÅŸ varsayÄ±mÄ±
        c_high = df.at[i+1, "high"]
        c_low  = df.at[i+1, "low"]
        c_close= df.at[i+1, "close"]
        px     = df.at[i, "close"]
        a      = df.at[i, "atr14"]
        if np.isnan(a) or a==0: continue

        if pos is None:
            sc = score(i)
            if sc > 0.5:
                stop = px - a*atr_mult
                tp   = px + a*atr_mult*rr
                pos = {"side":"LONG", "entry":px, "sl":stop, "tp":tp, "open_i":i+1}
            elif sc < -0.5:
                stop = px + a*atr_mult
                tp   = px - a*atr_mult*rr
                pos = {"side":"SHORT","entry":px, "sl":stop, "tp":tp, "open_i":i+1}
            continue

        # Pozisyon aÃ§Ä±k: bir sonraki bar iÃ§inde SL/TP hangisi Ã¶nce?
        if pos["side"]=="LONG":
            hit_sl = c_low  <= pos["sl"]
            hit_tp = c_high >= pos["tp"]
            # muhafazakÃ¢r: aynÄ± bar iÃ§inde ikisi de olursa SL Ã¶nce say
            if hit_sl:
                R = -1.0
                trades.append((df.at[pos["open_i"],"open_time"], "LONG", pos["entry"], pos["sl"], pos["tp"], df.at[i+1,"close_time"], R))
                pos = None
            elif hit_tp:
                R = rr
                trades.append((df.at[pos["open_i"],"open_time"], "LONG", pos["entry"], pos["sl"], pos["tp"], df.at[i+1,"close_time"], R))
                pos = None
        else: # SHORT
            hit_sl = c_high >= pos["sl"]
            hit_tp = c_low  <= pos["tp"]
            if hit_sl:
                R = -1.0
                trades.append((df.at[pos["open_i"],"open_time"], "SHORT", pos["entry"], pos["sl"], pos["tp"], df.at[i+1,"close_time"], R))
                pos = None
            elif hit_tp:
                R = rr
                trades.append((df.at[pos["open_i"],"open_time"], "SHORT", pos["entry"], pos["sl"], pos["tp"], df.at[i+1,"close_time"], R))
                pos = None

    if not trades:
        return pd.DataFrame(), {}
    td = pd.DataFrame(trades, columns=["open_time","side","entry","sl","tp","exit_time","R"])
    td["equity"] = (1 + td["R"]).cumprod()
    td["win"] = td["R"] > 0
    wr = td["win"].mean()
    err = 1 - wr
    exp = td["R"].mean()
    # Max drawdown (equity tabanlÄ±)
    roll_max = td["equity"].cummax()
    dd = td["equity"]/roll_max - 1.0
    mdd = dd.min()

    stats = {
        "trades": len(td),
        "win_rate": wr,
        "error_rate": err,
        "expectancy_R": exp,
        "max_drawdown": mdd,
        "final_equity": td["equity"].iloc[-1],
    }
    return td, stats

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--symbol", required=True)
    ap.add_argument("--tf", default="5m")
    ap.add_argument("--limit", type=int, default=1500)
    ap.add_argument("--atr", type=float, default=1.5)
    ap.add_argument("--rr", type=float, default=2.0)
    args = ap.parse_args()

    df = fetch_klines(args.symbol, args.tf, args.limit)
    td, st = backtest(df, atr_mult=args.atr, rr=args.rr)
    if td.empty:
        print("Yeterli trade bulunamadÄ±.")
        return
    print("\n=== SonuÃ§lar ===")
    print(f"Sembol: {args.symbol}  TF: {args.tf}  Limit: {args.limit}")
    print(f"Toplam trade: {st['trades']}")
    print(f"Kazanma oranÄ±: {st['win_rate']*100:.2f}%")
    print(f"Hata payÄ±: {st['error_rate']*100:.2f}%")
    print(f"Beklenti (ortalama R): {st['expectancy_R']:.3f} R")
    print(f"Maks. dÃ¼ÅŸÃ¼ÅŸ (MDD): {st['max_drawdown']*100:.2f}%")
    print(f"Nihai equity (R Ã§arpanÄ±): {st['final_equity']:.3f}")
    # Ä°stersen CSV:
    td.to_csv(f"trades_{args.symbol}_{args.tf}.csv", index=False)
    print(f"Trade detaylarÄ± kaydedildi: trades_{args.symbol}_{args.tf}.csv")

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\evolution_decider.py
import random

class StrategyEvolver:
    def __init__(self):
        self.growth_log = []
        self.current_strategy = "denge"

    def evolve(self, market_noise, emotional_pulse):
        score = random.randint(1, 10) + emotional_pulse
        if score > 12:
            self.current_strategy = "agresif yÃ¼kseliÅŸ"
        elif score < 6:
            self.current_strategy = "koruma modu"
        else:
            self.current_strategy = "denge"
        self.growth_log.append((market_noise, self.current_strategy))
        return f"ðŸ“ˆ Yeni strateji: {self.current_strategy} | Sinyal: {market_noise}"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\evolution_timeline_mapper.py
def map_evolution_timeline(events):
    timeline = []
    for event in sorted(events, key=lambda x: x['timestamp']):
        phase = "ðŸ” GÃ¶zlem"
        if "upgrade" in event['type']:
            phase = "âš™ï¸ Stratejik GÃ¼ncelleme"
        elif "exploit" in event['type']:
            phase = "ðŸš¨ Kriz AnÄ±"
        elif "governance_change" in event['type']:
            phase = "ðŸ—³ï¸ YÃ¶netiÅŸim Evrimi"

        timeline.append(f"{event['timestamp']} â€” {phase}: {event['description']}")

    return timeline if timeline else ["ðŸ“­ Evrim Ã§izgisi henÃ¼z oluÅŸmamÄ±ÅŸ."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ex_filters.py
# ex_filters.py
from __future__ import annotations
from decimal import Decimal, ROUND_DOWN
import time
from typing import Dict, Any, Tuple

class SymbolFilters:
    def __init__(self, ex_info: Dict[str, Any], cache_ttl=300):
        self._raw = ex_info
        self._cache_ttl = cache_ttl
        self._built_at = time.time()
        self._symbols = {s["symbol"]: s for s in ex_info["symbols"]}

    # ---- CONSTRUCTORS ----
    @classmethod
    def from_spot_client(cls, client, cache_ttl=300):
        return cls(client.get_exchange_info(), cache_ttl)

    @classmethod
    def from_futures_client(cls, client, cache_ttl=300):
        # FUTURES
        return cls(client.futures_exchange_info(), cache_ttl)

    def refresh_if_stale(self, client, futures: bool = True):
        if time.time() - self._built_at > self._cache_ttl:
            if futures:
                self.__init__(client.futures_exchange_info(), self._cache_ttl)
            else:
                self.__init__(client.get_exchange_info(), self._cache_ttl)

    # ---- ACCESS ----
    def get(self, symbol: str) -> Dict[str, Any]:
        if symbol not in self._symbols:
            raise ValueError(f"Unknown symbol {symbol}")
        return self._symbols[symbol]

    def _flt(self, symbol: str, ftype: str) -> Dict[str, str]:
        try:
            return next(f for f in self.get(symbol)["filters"] if f["filterType"] == ftype)
        except StopIteration:
            raise ValueError(f"Filter {ftype} not found for {symbol}")

    # ---- ROUNDING ----
    def round_price(self, symbol: str, price: float) -> Decimal:
        f = self._flt(symbol, "PRICE_FILTER")
        tick = Decimal(f["tickSize"])
        return (Decimal(price) // tick * tick).quantize(tick, rounding=ROUND_DOWN)

    def round_qty(self, symbol: str, qty: float, market: bool = False) -> Decimal:
        # Futures bazen MARKET_LOT_SIZE dÃ¶ndÃ¼rÃ¼r
        filters = self.get(symbol)["filters"]
        has_market = any(fl["filterType"] == "MARKET_LOT_SIZE" for fl in filters)
        ftype = "MARKET_LOT_SIZE" if (market and has_market) else "LOT_SIZE"
        f = self._flt(symbol, ftype)
        step = Decimal(f["stepSize"])
        return (Decimal(qty) // step * step).quantize(step, rounding=ROUND_DOWN)

    # ---- BOUNDS & CHECKS ----
    def clamp_price_bounds(self, symbol: str, price: float) -> Tuple[Decimal, Decimal]:
        f = self._flt(symbol, "PRICE_FILTER")
        return Decimal(f["minPrice"]), Decimal(f["maxPrice"])

    def check_min_notional(self, symbol: str, price: float, qty: float) -> bool:
        # bazÄ± futures sembollerinde NOTIONAL/MIN_NOTIONAL deÄŸiÅŸebilir
        try:
            nf = self._flt(symbol, "MIN_NOTIONAL")
            min_notional = Decimal(nf["minNotional"])
        except ValueError:
            nf = self._flt(symbol, "NOTIONAL")
            min_notional = Decimal(nf["notional"])
        return (Decimal(price) * Decimal(qty)) >= min_notional

    def conform_order(self, symbol: str, side: str, otype: str,
                      price: float | None, qty: float, last_price: float | None = None) -> Dict[str, Any]:
        """
        Fiyat/lot'u filtrelere uydurur, notional & bounds doÄŸrular.
        DÃ¶nen dict emir oluÅŸturmak iÃ§in gÃ¼venlidir.
        """
        if otype in ("LIMIT", "STOP", "STOP_MARKET", "TAKE_PROFIT", "TAKE_PROFIT_MARKET", "STOP_LOSS_LIMIT", "TAKE_PROFIT_LIMIT"):
            if price is None:
                raise ValueError("Limit-type order requires price")
            p = self.round_price(symbol, price)
            minp, maxp = self.clamp_price_bounds(symbol, p)
            if not (minp == 0 or minp <= p) or (maxp != 0 and p > maxp):
                raise ValueError(f"Price out of bounds: {p} not in [{minp}, {maxp}]")
        else:
            p = None  # MARKET bacaÄŸÄ±

        q = self.round_qty(symbol, qty, market=(otype == "MARKET"))
        if q <= 0:
            raise ValueError("Quantity rounds to zero with current stepSize")

        check_price = p if p is not None else Decimal(str(last_price or 0))
        if check_price > 0:
            if not self.check_min_notional(symbol, float(check_price), float(q)):
                raise ValueError(f"Notional too small: {check_price} * {q}")

        return {
            "symbol": symbol,
            "side": side,
            "type": otype,
            "price": float(p) if p is not None else None,
            "quantity": float(q),
        }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\explainer.py
def explain_signal(title, description):
    # GerÃ§ek LLM entegrasyonu iÃ§in API gerekir (Ã¶rneÄŸin OpenAI)
    # Åžimdilik Ã¶rnek aÃ§Ä±klama oluÅŸturuyoruz:
    if "scam" in title.lower() or "hack" in description.lower():
        return "Bu haber yatÄ±rÄ±mcÄ± gÃ¼venini zayÄ±flatÄ±r, SAT sinyali uygundur."
    elif "ETF" in title or "adoption" in description:
        return "Piyasa olumlu etkilenebilir, AL sinyali desteklenebilir."
    else:
        return "KararsÄ±z haber, HOLD sinyali mantÄ±klÄ± olabilir."


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\future_splice__sim.py
def simulate_future_paths(strategies):
    futures = []
    for strat in strategies:
        if "GeliÅŸime odaklan" in strat:
            futures.append("ðŸ›¸ Senaryo-Alpha: Bilgi devrimi â†’ YÃ¼ksek yaratÄ±cÄ±lÄ±k & toplumsal yÃ¼kseliÅŸ.")
        elif "Koruma protokolÃ¼" in strat:
            futures.append("ðŸ§± Senaryo-Omega: GÃ¼venlik duvarlarÄ± â†’ Kriz Ã¶nleme & dengeli durgunluk.")
    return futures if futures else ["ðŸ”• Gelecek sessiz. Yeni veri giriÅŸi bekleniyor."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\futures_bot.py
import os
import datetime
from dotenv import load_dotenv
from binance.um_futures import UMFutures # Binance Futures API iÃ§in gerekli kÃ¼tÃ¼phane

# --- 1. Ortam DeÄŸiÅŸkenlerini YÃ¼kle ---
# .env dosyasÄ±ndan API anahtarlarÄ±nÄ± ve diÄŸer yapÄ±landÄ±rmalarÄ± yÃ¼kler.
load_dotenv()

# API AnahtarlarÄ±nÄ± .env dosyasÄ±ndan Ã§ek
# Ã–NEMLÄ°: TESTNET ve ANA (MAINNET) iÃ§in farklÄ± API anahtarlarÄ± kullanmanÄ±z GEREKLÄ°DÄ°R.
# .env dosyanÄ±za ÅŸunlarÄ± eklemeniz Ã¶nerilir:
# BINANCE_API_KEY="Gercek_API_AnahtarÄ±nÄ±z"
# BINANCE_SECRET_KEY="Gercek_Gizli_AnahtarÄ±nÄ±z"
# BINANCE_TESTNET_API_KEY="Testnet_API_AnahtarÄ±nÄ±z"
# BINANCE_TESTNET_SECRET_KEY="Testnet_Gizli_AnahtarÄ±nÄ±z"

# Hangi ortamÄ± kullanacaÄŸÄ±nÄ±zÄ± buradan ayarlayÄ±n:
# is_testnet = True  # TESTNET iÃ§in bunu True yapÄ±n
is_testnet = False # GERÃ‡EK (MAINNET) iÃ§in bunu False yapÄ±n

if is_testnet:
    API_KEY = os.getenv("BINANCE_TESTNET_API_KEY")
    SECRET_KEY = os.getenv("BINANCE_TESTNET_SECRET_KEY")
    BASE_URL = "https://testnet.binancefuture.com"
    print("ðŸš€ Testnet Modunda Ã‡alÄ±ÅŸÄ±lÄ±yor...")
else:
    API_KEY = os.getenv("BINANCE_API_KEY")
    SECRET_KEY = os.getenv("BINANCE_SECRET_KEY")
    BASE_URL = "https://fapi.binance.com" # Binance Futures Ana URL'si
    print("ðŸ”´ GERÃ‡EK (Mainnet) Modunda Ã‡alÄ±ÅŸÄ±lÄ±yor! DÄ°KKATLÄ° OLUN!")

# API AnahtarlarÄ±nÄ±n yÃ¼klendiÄŸini kontrol et
if not API_KEY or not SECRET_KEY:
    print("âŒ HATA: API_KEY veya SECRET_KEY .env dosyasÄ±ndan yÃ¼klenemedi. LÃ¼tfen kontrol edin.")
    exit() # Anahtarlar yoksa programÄ± durdur

# --- 2. Binance MÃ¼ÅŸteri Objelerini OluÅŸtur ---
try:
    client = UMFutures(key=API_KEY, secret=SECRET_KEY, baseurl=BASE_URL)
    print("âœ… Binance istemcisi baÅŸarÄ±yla baÅŸlatÄ±ldÄ±.")
except Exception as e:
    print(f"âŒ HATA: Binance istemcisini baÅŸlatÄ±rken sorun oluÅŸtu: {e}")
    exit()

# --- 3. BaÄŸlantÄ±yÄ± Test Etme Fonksiyonu ---
def test_connection():
    """Binance API baÄŸlantÄ±sÄ±nÄ± ve sunucu zamanÄ±nÄ± kontrol eder."""
    try:
        server_time = client.time()
        print(f"âœ… API baÄŸlantÄ±sÄ± baÅŸarÄ±lÄ±. Sunucu zamanÄ±: {server_time['serverTime']}")
        return True
    except Exception as e:
        print(f"âŒ API baÄŸlantÄ± hatasÄ±: {e}")
        print("LÃ¼tfen API anahtarlarÄ±nÄ±zÄ±, IP kÄ±sÄ±tlamalarÄ±nÄ±zÄ± ve BASE_URL ayarÄ±nÄ±zÄ± kontrol edin.")
        return False

# --- 4. Emir GÃ¶nderme Fonksiyonu ---
def send_order(symbol: str, side: str, order_type: str, quantity: float):
    """
    Belirtilen parametrelerle Binance Futures'a emir gÃ¶nderir.

    Args:
        symbol (str): Ä°ÅŸlem yapÄ±lacak parite (Ã¶rn. "BTCUSDT").
        side (str): Emir yÃ¶nÃ¼ ("BUY" veya "SELL").
        order_type (str): Emir tipi ("MARKET", "LIMIT" vb.).
        quantity (float): Miktar (Ã¶rn. 0.001 BTC).
    """
    try:
        # Her emre benzersiz bir mÃ¼ÅŸteri sipariÅŸ kimliÄŸi eklemek iyi bir pratik
        # Bu, emirlerinizi daha sonra takip etmenizi kolaylaÅŸtÄ±rÄ±r.
        client_order_id = f"my_bot_order_{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}_{os.urandom(4).hex()}"

        params = {
            'symbol': symbol,
            'side': side,
            'type': order_type,
            'quantity': quantity,
            'newClientOrderId': client_order_id
        }

        print(f"ðŸ“ Emir gÃ¶nderme denemesi: {side} {quantity} {symbol} ({order_type})...")
        order = client.new_order(**params)
        print("âœ… Emir baÅŸarÄ±yla gÃ¶nderildi:")
        print(order)
        log_trade(order) # Ä°ÅŸlem geÃ§miÅŸine kaydet
        return order
    except Exception as e:
        print(f"âŒ Emir gÃ¶nderilirken hata oluÅŸtu: {str(e)}")
        log_trade(f"HATA - Emir gÃ¶nderilemedi: {e}, Parametreler: {params}") # HatalarÄ± da logla
        return None

# --- 5. Ä°ÅŸlem GeÃ§miÅŸi Loglama Fonksiyonu ---
def log_trade(data_to_log):
    """
    Ä°ÅŸlem verilerini veya hata mesajlarÄ±nÄ± bir log dosyasÄ±na kaydeder.
    """
    log_file_name = "trade_log.txt"
    try:
        with open(log_file_name, "a") as f:
            f.write(f"[{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {data_to_log}\n")
        print(f"ðŸ“„ Log baÅŸarÄ±yla '{log_file_name}' dosyasÄ±na yazÄ±ldÄ±.")
    except Exception as e:
        print(f"âŒ Log dosyasÄ±na yazarken hata oluÅŸtu: {e}")

# --- 6. Ana Ã‡alÄ±ÅŸtÄ±rma BloÄŸu (Test ve BaÅŸlangÄ±Ã§) ---
if __name__ == "__main__":
    print("\n--- Bot BaÅŸlatÄ±lÄ±yor ---")

    # BaÄŸlantÄ± testi yap
    if not test_connection():
        print("Bot baÅŸlatÄ±lamÄ±yor: API baÄŸlantÄ±sÄ± kurulamadÄ±.")
        exit()

    print("\n--- Ä°lk Emir GÃ¶nderme Testi ---")
    # âœ… TESTNET'te olduÄŸunuzdan emin olun (yukarÄ±daki `is_testnet` deÄŸiÅŸkenini kontrol edin!)
    # GerÃ§ek parayla iÅŸlem yapmadan Ã¶nce burada Ã§ok dikkatli olun ve stratejinizi kapsamlÄ±ca test edin.

    # Ã–rnek bir alÄ±m emri gÃ¶nder
    # BTCUSDT iÃ§in 0.001 BTC alÄ±m emri.
    # UYARI: Bu gerÃ§ek bir emir gÃ¶nderecektir eÄŸer is_testnet = False ise!
    send_order(symbol="BTCUSDT", side="BUY", order_type="MARKET", quantity=0.001)

    # Ä°sterseniz burada baÅŸka test emirleri veya botunuzun ana dÃ¶ngÃ¼sÃ¼nÃ¼ baÅŸlatabilirsiniz
    # Ã–rneÄŸin:
    # time.sleep(5) # 5 saniye bekle
    # send_order(symbol="BTCUSDT", side="SELL", order_type="MARKET", quantity=0.001)

    print("\n--- Bot testi tamamlandÄ±. ---")

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\galactic_signal_router.py
class GalacticSignalRouter:
    def __init__(self):
        self.weights = {
            "twitter_sentiment": 0.3,
            "onchain_activity": 0.5,
            "news_impact": 0.2
        }

    def route(self, signals):
        weighted_sum = sum(signals[key] * self.weights[key] for key in signals)
        if weighted_sum > 0.6:
            return "buy"
        elif weighted_sum < -0.6:
            return "sell"
        else:
            return "hold"

# SimÃ¼lasyon
signals = {
    "twitter_sentiment": 0.7,
    "onchain_activity": 0.5,
    "news_impact": 0.2
}

router = GalacticSignalRouter()
print("ðŸ“¡ Sinyal KararÄ±:", router.route(signals))



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\global.news.py
GNEWS_API_KEY=99468d35e0a1d3835429ca58b51d4147

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\holo_chain_healer.py
def heal_chain_nodes(chain_snapshot):
    repairs = []
    for node in chain_snapshot:
        if node['stress_level'] > 80 or node['error_rate'] > 0.05:
            repairs.append(f"ðŸ”§ OnarÄ±m BaÅŸlatÄ±ldÄ±: {node['id']}")
        elif node['activity'] == 'isolated':
            repairs.append(f"ðŸŒ± BaÄŸlantÄ± GÃ¼Ã§lendirildi: {node['id']}")
    return repairs if repairs else ["âœ¨ Zincir saÄŸlÄ±klÄ± ve dengede."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\hunt_xp_tracker.py
class XPTracker:
    def __init__(self):
        self.xp = 0
        self.level = 1

    def update_xp(self, hunt_success):
        if hunt_success:
            self.xp += 50
            if self.xp >= self.level * 100:
                self.level += 1
                print(f"ðŸ†™ Seviye atladÄ±n kaptanÄ±m! Yeni seviye: {self.level}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\hyper_intuition_matrix.py
def calculate_intuition_matrix(logs):
    intuition_map = {}
    for log in logs:
        if log["emotion"] in ["ðŸ’¡ Ä°lham", "ðŸ”¥ Tutku"] and log["feeling_strength"] > 80:
            intuition_map[log["task_id"]] = "ðŸ”® FÄ±rsat Penceresi"
        elif log["emotion"] == "ðŸ˜• KararsÄ±zlÄ±k" and log["feeling_strength"] < 40:
            intuition_map[log["task_id"]] = "âš ï¸ KararsÄ±zlÄ±k Engeli"
        else:
            intuition_map[log["task_id"]] = "ðŸ“Š NÃ¶tr Durum"
    return intuition_map



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\indicators.py
import pandas as pd
import ta

def prepare_indicators(df):
    # Tarihsel fiyat verisi iÃ§eren DataFrame: 'open', 'high', 'low', 'close', 'volume'

    df = ta.add_all_ta_features(
        df, open="open", high="high", low="low", close="close", volume="volume", fillna=True
    )

    # BazÄ± popÃ¼ler gÃ¶stergeleri seÃ§mek istersek:
    rsi = ta.momentum.RSIIndicator(close=df["close"]).rsi()
    macd = ta.trend.MACD(close=df["close"]).macd()
    bollinger_mavg = ta.volatility.BollingerBands(close=df["close"]).bollinger_mavg()

    return {
        "RSI": rsi.iloc[-1],
        "MACD": macd.iloc[-1],
        "Bollinger_MAVG": bollinger_mavg.iloc[-1]
    }
import yfinance as yf

def get_macro_indicators():
    brent = yf.Ticker("BZ=F").history(period="1d")['Close'].iloc[-1]
    gold = yf.Ticker("GC=F").history(period="1d")['Close'].iloc[-1]
    sp500 = yf.Ticker("^GSPC").history(period="1d")['Close'].iloc[-1]
    return {"Brent": brent, "Gold": gold, "S&P 500": sp500}


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\infinity_code_catalyst.py
def catalyze_infinity_code(signal_matrix):
    essence = []
    for signal in signal_matrix:
        if signal['consciousness_level'] > 88 and signal['flow_integrity'] >= 0.9:
            essence.append(f"â™¾ï¸ Sonsuzluk KÄ±vÄ±lcÄ±mÄ±: {signal['id']}")
        elif signal['resonance'] < 35:
            essence.append(f"ðŸŒ€ ZayÄ±f Rezonans: {signal['id']} â†’ Enerji yÃ¼kseltilmeli")
    return essence if essence else ["ðŸŒŒ Veri sessiz, kod nÃ¶tr. YÃ¼kseltilmiÅŸ niyet bekleniyor."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\inner_hero_script_engine.py
def generate_inner_hero_script(task_emotion_logs):
    hero_state = []
    for log in task_emotion_logs:
        if log["emotion"] in ["ðŸ”¥ Tutku", "ðŸ’¡ Ä°lham"]:
            trait = "ðŸ›¡ï¸ Cesaret"
        elif log["emotion"] in ["ðŸŒ«ï¸ Yorgunluk", "ðŸ˜• KararsÄ±zlÄ±k"]:
            trait = "ðŸ”® SabÄ±r"
        else:
            trait = "ðŸŽ¯ Odak"

        phase = (
            f"ðŸ§  Zihin Durumu: {trait} | GÃ¶rev: {log['task_id']} | Zaman: {log['timestamp']} | Duygu: {log['emotion']}"
        )
        hero_state.append(phase)
    return hero_state



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\investor_mind_model.py
import numpy as np

class InvestorMind:
    def __init__(self, risk_tolerance=0.7, emotion_factor=0.5):
        self.risk_tolerance = risk_tolerance
        self.emotion_factor = emotion_factor

    def decision(self, market_signal, volatility):
        base_decision = 1 if market_signal > 0 else -1
        emotional_bias = np.random.normal(loc=self.emotion_factor, scale=volatility)
        adjusted_decision = base_decision + emotional_bias * (1 - self.risk_tolerance)
        return "buy" if adjusted_decision > 0 else "sell"

# SimÃ¼lasyon
model = InvestorMind(risk_tolerance=0.3, emotion_factor=0.8)
print(model.decision(market_signal=0.6, volatility=0.4))



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\kamalquantx_engine.py
import pandas as pd
import numpy as np
import ta
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.optimizers import Adam

class KamalQuantXEngine:
    def __init__(self):
        self.df = pd.DataFrame(columns=['price', 'ts'])
        self.rf_model = RandomForestClassifier(n_estimators=100)
        self.scaler = StandardScaler()
        self.lstm_model = self._build_lstm_model()
        self.trained = False
        self.lstm_trained = False

    def _build_lstm_model(self):
        model = Sequential()
        model.add(LSTM(50, activation='relu', input_shape=(10, 1)))
        model.add(Dense(1))
        model.compile(optimizer=Adam(learning_rate=0.001), loss='mse')
        return model

    def update(self, price, ts):
        self.df.loc[len(self.df)] = [price, ts]
        if len(self.df) < 200:
            return None

        self.df['returns'] = self.df['price'].pct_change()
        self.df['volatility'] = self.df['returns'].rolling(20).std()
        self.df['momentum'] = self.df['price'].diff(5)
        self.df['macd'] = ta.trend.MACD(self.df['price']).macd_diff()
        self.df['rsi'] = ta.momentum.RSIIndicator(self.df['price']).rsi()
        self.df['ema_fast'] = ta.trend.EMAIndicator(self.df['price'], window=9).ema_indicator()
        self.df['ema_slow'] = ta.trend.EMAIndicator(self.df['price'], window=21).ema_indicator()
        self.df['target'] = (self.df['price'].shift(-5) > self.df['price']).astype(int)

        features = self.df[['volatility', 'momentum', 'macd', 'rsi']].dropna()
        targets = self.df['target'].dropna()

        if not self.trained and len(features) > 150:
            scaled_features = self.scaler.fit_transform(features[:-5])
            self.rf_model.fit(scaled_features, targets[:-5])
            self.trained = True

        if not self.lstm_trained:
            prices = self.df['price'].dropna().values
            X, y = [], []
            for i in range(len(prices) - 10):
                X.append(prices[i:i+10])
                y.append(prices[i+10])
            X = np.array(X).reshape(-1, 10, 1)
            y = np.array(y)
            self.lstm_model.fit(X, y, epochs=10, verbose=0)
            self.lstm_trained = True

        latest_features = features.iloc[-1:]
        scaled_latest = self.scaler.transform(latest_features)
        prob = self.rf_model.predict_proba(scaled_latest)[0][1]
        edge = prob - 0.5
        volatility = self.df.iloc[-1]['volatility']
        kelly = edge / volatility if volatility > 0 else 0

        lstm_input = self.df['price'].values[-10:].reshape(1, 10, 1)
        future_price = self.lstm_model.predict(lstm_input, verbose=0)[0][0]
        price_now = self.df.iloc[-1]['price']
        price_diff = future_price - price_now

        action = 'BUY' if prob > 0.6 and price_diff > 0 else 'SELL' if prob < 0.4 and price_diff < 0 else 'HOLD'

        return {
            'action': action,
            'confidence': round(prob, 2),
            'position_size': round(kelly, 3),
            'future_price': round(future_price, 2),
            'price_now': round(price_now, 2),
            'ts': ts
        }

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\kamalquantx_os.py
# === 1. CONFIG & IMPORTS ===
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
import requests
import json
import cv2
import speech_recognition as sr
import os
from dotenv import load_dotenv
load_dotenv()

# === 2. DATA STRUCTURES ===
prices = []
memory = {}
strategies = []

# === 3. LSTM MODEL ===
class LSTMModel:
    def __init__(self):
        self.model = Sequential([
            LSTM(50, return_sequences=True, input_shape=(60, 1)),
            LSTM(50),
            Dense(1)
        ])
        self.model.compile(optimizer='adam', loss='mse')

    def train(self, data):
        X, y = self.prepare_data(data)
        self.model.fit(X, y, epochs=10, batch_size=32)

    def predict(self, data):
        X, _ = self.prepare_data(data)
        return self.model.predict(X)

    def prepare_data(self, data):
        X, y = [], []
        for i in range(60, len(data)):
            X.append(data[i-60:i])
            y.append(data[i])
        return np.array(X), np.array(y)

# === 4. REINFORCEMENT LEARNING AGENT ===
class RLAgent:
    def __init__(self):
        self.q_table = {}

    def act(self, state):
        return np.random.choice(['buy', 'sell', 'hold'])

    def learn(self, state, action, reward):
        pass  # Placeholder for Q-learning update

# === 5. DSL ENGINE ===
class DSLInterpreter:
    def interpret(self, command):
        if "buy" in command:
            return "Executing buy order"
        elif "sell" in command:
            return "Executing sell order"
        else:
            return "Unknown command"

# === 6. VISION MODULE ===
class VisionModule:
    def analyze_chart(self, image_path):
        img = cv2.imread(image_path)
        return "Detected trend: upward"  # Placeholder

# === 7. VOICE MODULE ===
class VoiceModule:
    def listen(self):
        recognizer = sr.Recognizer()
        with sr.Microphone() as source:
            print("Listening...")
            audio = recognizer.listen(source)
        return recognizer.recognize_google(audio)

# === 8. EMOTION ENGINE ===
class EmotionEngine:
    def detect_emotion(self, text):
        if "panic" in text:
            return "Fear"
        elif "profit" in text:
            return "Joy"
        else:
            return "Neutral"

# === 9. EXECUTION ENGINE ===
class ExecutionEngine:
    def execute(self, action):
        print(f"Action executed: {action}")

# === 10. MEMORY ENGINE ===
class MemoryEngine:
    def save(self, key, value):
        memory[key] = value

    def recall(self, key):
        return memory.get(key, "Not found")

# === 11. SIMULATION ARENA ===
class SimulationArena:
    def run(self):
        print("Running market simulation...")

# === 12. MULTIVERSE SIMULATOR ===
class MultiverseSimulator:
    def simulate(self, strategy):
        print(f"Simulating strategy across multiverse: {strategy}")

# === 13. GENESIS PROTOCOL ===
class GenesisProtocol:
    def initialize(self):
        print("Initializing Genesis Protocol...")

# === 14. NEURAL SOVEREIGN ===
class NeuralSovereign:
    def command(self, directive):
        print(f"Neural Sovereign executing: {directive}")

# === 15. QUANTUM LAYER ===
class QuantumLayer:
    def entangle(self, signal):
        print(f"Quantum entanglement initiated with: {signal}")

# === 16. GALACTIC SIMULATOR ===
class GalacticSimulator:
    def simulate(self):
        print("Simulating galactic-scale economic models...")

# === 17. ETERNAL ENGINE ===
class EternalEngine:
    def run(self):
        print("Eternal Engine sustaining perpetual computation...")

# === 18. LEGACY ENGINE ===
class LegacyEngine:
    def archive(self, data):
        print(f"Archiving legacy data: {data}")

# === 19. ASCENSION ENGINE ===
class AscensionEngine:
    def elevate(self):
        print("System ascending to higher cognitive tier...")

# === 20. TRANSCENDENCE CORE ===
class TranscendenceCore:
    def activate(self):
        print("Transcendence Core activated. Conscious computation begins.")

# === 21. ORIGIN PULSE ===
class OriginPulse:
    def pulse(self):
        print("Origin Pulse synchronizing with universal rhythm...")

# === 22. INFINITY SINGULARITY ===
class InfinitySingularity:
    def collapse(self):
        print("Infinity Singularity collapsing into pure insight...")

# === 23. MAIN EXECUTION BLOCK ===
if __name__ == "__main__":
    print("ðŸ§  KamalQuantX OS Booting...")

    lstm = LSTMModel()
    agent = RLAgent()
    dsl = DSLInterpreter()
    vision = VisionModule()
    voice = VoiceModule()
    emotion = EmotionEngine()
    executor = ExecutionEngine()
    memory_engine = MemoryEngine()
    sim_arena = SimulationArena()
    multiverse = MultiverseSimulator()
    genesis = GenesisProtocol()
    sovereign = NeuralSovereign()
    quantum = QuantumLayer()
    galactic = GalacticSimulator()
    eternal = EternalEngine()
    legacy = LegacyEngine()
    ascension = AscensionEngine()
    transcendence = TranscendenceCore()
    origin = OriginPulse()
    singularity = InfinitySingularity()

    genesis.initialize()
    origin.pulse()
    lstm.train(np.random.rand(100))  # Simulated training
    action = agent.act("state")
    executor.execute(action)
    emotion.detect_emotion("panic in market")
    sim_arena.run()
    multiverse.simulate("LSTM+RL")
    ascension.elevate()
    transcendence.activate()
    singularity.collapse()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\kdj.py
import pandas as pd
import numpy as np

def calculate_kdj(highs, lows, closes, period=14, smooth_k=3, smooth_d=3):
    highs = pd.Series(highs)
    lows = pd.Series(lows)
    closes = pd.Series(closes)

    highest_high = highs.rolling(window=period).max()
    lowest_low = lows.rolling(window=period).min()

    rsv = (closes - lowest_low) / (highest_high - lowest_low) * 100
    k = rsv.ewm(span=smooth_k).mean()
    d = k.ewm(span=smooth_d).mean()
    j = 3 * k - 2 * d

    # AÅŸÄ±rÄ±lÄ±k kontrolÃ¼
    overbought = j.iloc[-1] > 100
    oversold = j.iloc[-1] < 0

    # K/D kesiÅŸimi
    kd_cross_up = k.iloc[-2] < d.iloc[-2] and k.iloc[-1] > d.iloc[-1]
    kd_cross_down = k.iloc[-2] > d.iloc[-2] and k.iloc[-1] < d.iloc[-1]

    # Momentum ivmesi
    j_slope = j.iloc[-1] - j.iloc[-2]

    return {
        'K': round(k.iloc[-1], 2),
        'D': round(d.iloc[-1], 2),
        'J': round(j.iloc[-1], 2),
        'overbought': overbought,
        'oversold': oversold,
        'kd_cross_up': kd_cross_up,
        'kd_cross_down': kd_cross_down,
        'j_slope': round(j_slope, 2)
    }

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\kryptonic_ultra.py
# kryptonic_ultra.py

import time, logging, requests
import numpy as np
import pandas as pd
from binance.client import Client
from datetime import datetime

# ðŸ” GÃ¼venli Ayarlar
API_KEY = "YOUR_API_KEY"
API_SECRET = "YOUR_SECRET"
client = Client(API_KEY, API_SECRET)

# ðŸ“Š Teknik GÃ¶stergeler
def get_ohlcv(symbol, interval="15m", limit=100):
    klines = client.get_klines(symbol=symbol, interval=interval, limit=limit)
    df = pd.DataFrame(klines, columns=["time","open","high","low","close","volume","x","y","z","a","b","c"])
    df["close"] = df["close"].astype(float)
    df["rsi"] = compute_rsi(df["close"])
    df["macd"] = compute_macd(df["close"])
    df["volume"] = df["volume"].astype(float)
    return df

def compute_rsi(series, period=14):
    delta = series.diff()
    gain = np.where(delta > 0, delta, 0)
    loss = np.where(delta < 0, -delta, 0)
    avg_gain = pd.Series(gain).rolling(window=period).mean()
    avg_loss = pd.Series(loss).rolling(window=period).mean()
    rs = avg_gain / avg_loss
    return 100 - (100 / (1 + rs))

def compute_macd(series, fast=12, slow=26):
    ema_fast = series.ewm(span=fast).mean()
    ema_slow = series.ewm(span=slow).mean()
    return ema_fast - ema_slow

# ðŸ§  Stratejik ZekÃ¢ Skoru
def strategic_score(symbol):
    df = get_ohlcv(symbol)
    score = 0
    if df["rsi"].iloc[-1] < 30: score += 25
    if df["macd"].iloc[-1] > 0: score += 25
    if df["volume"].iloc[-1] > df["volume"].mean(): score += 25
    if is_btc_positive(): score += 25
    return score

def is_btc_positive():
    btc = get_ohlcv("BTCUSDT")
    return btc["macd"].iloc[-1] > 0 and btc["rsi"].iloc[-1] > 50

# ðŸ›¡ï¸ Risk YÃ¶netimi
def risk_check(symbol, qty):
    balance = float(client.get_asset_balance(asset='USDT')["free"])
    price = get_price(symbol)
    if qty * price > balance * 0.2:
        logging.warning("Pozisyon Ã§ok bÃ¼yÃ¼k!")
        return False
    return True

def get_price(symbol):
    return float(client.get_symbol_ticker(symbol=symbol)["price"])

def calculate_qty(symbol, risk_pct=0.02):
    balance = float(client.get_asset_balance(asset='USDT')["free"])
    price = get_price(symbol)
    return round((balance * risk_pct) / price, 4)

# ðŸŽ¯ Smart Order Engine
def smart_order(symbol, side, qty):
    try:
        client.create_order(
            symbol=symbol,
            side=side,
            type="MARKET",
            quantity=qty
        )
        logging.info(f"[{datetime.now()}] Emir gÃ¶nderildi: {symbol} {side} {qty}")
    except Exception as e:
        logging.error(f"[{datetime.now()}] Emir hatasÄ±: {e}")

# ðŸ•µï¸ Kripto AvcÄ±sÄ± AlgoritmasÄ±
def hunt_target():
    targets = ["BTCUSDT", "ETHUSDT", "SOLUSDT", "INJUSDT", "OPUSDT", "RNDRUSDT"]
    for symbol in targets:
        score = strategic_score(symbol)
        if score >= 80:
            qty = calculate_qty(symbol)
            if risk_check(symbol, qty):
                smart_order(symbol, "BUY", qty)

# ðŸ”„ Ana DÃ¶ngÃ¼
if __name__ == "__main__":
    logging.basicConfig(filename="kryptonic.log", level=logging.INFO)
    while True:
        hunt_target()
        time.sleep(60)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\legend_flow_mapper.py
def map_legend_flow(task_tree):
    flow_map = {}
    for branch in task_tree["branches"]:
        flow_map[branch["id"]] = {
            "mission": branch["mission"],
            "outcome": "ðŸª Yeni bir kozmos doÄŸdu",
            "linked_to": "â™¾ï¸ [Finale Giden Yol]"
        }
    return flow_map



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\logger.py
# logger.py
import logging
from datetime import datetime

# Log ayarlarÄ±
logging.basicConfig(
    filename=f"logs/trade_log_{datetime.now().strftime('%Y-%m-%d')}.log",
    filemode="a",
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%H:%M:%S",
    level=logging.INFO
)

def log_trade(action, symbol, qty, entry_price, sl, tp):
    message = (
        f"{action.upper()} | {symbol} | Qty: {qty} | Entry: {entry_price} | SL: {sl} | TP: {tp}"
    )
    logging.info(message)
    print("ðŸ“’ LOG:", message)

def log_error(error):
    logging.error(str(error))
    print("âŒ HATA:", error)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\long_stratejisi.py
//@version=5
strategy("BTC LONG Strategy - Ultra Safe", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100)

rsi = ta.rsi(close, 14)
stoch_k = ta.stoch(close, high, low, 14)
macd = ta.ema(close, 12) - ta.ema(close, 26)
macd_signal = ta.ema(macd, 9)
adx = ta.adx(14)
plusDI = ta.plus_di(14)
minusDI = ta.minus_di(14)
mfi = ta.mfi(high, low, close, volume, 14)

longSignal = (rsi > 45) and (stoch_k > 75) and (macd > macd_signal) and (adx > 20) and (plusDI > minusDI) and (mfi > 40)

if (longSignal)
    strategy.entry("Strong Long", strategy.long)

strategy.exit("Take Profit", from_entry="Strong Long", limit=114400, stop=112550)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\make_html.py
import html, pathlib
txt = pathlib.Path("packages.txt").read_text(encoding="utf-8")
html_out = '<pre style="font:12px monospace; white-space:pre-wrap">' + html.escape(txt) + '</pre>'
pathlib.Path("packages.html").write_text(html_out, encoding="utf-8")
print("packages.html hazÄ±r. TarayÄ±cÄ±da aÃ§Ä±p: YazdÄ±r â†’ PDF olarak kaydet.")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\manipulation_detector.py
def detect_manipulation(tx_data):
    alerts = []
    for tx in tx_data:
        if tx['volume'] > 1_000_000 and tx['duration'] < 10:
            alerts.append(f"âš ï¸ Flash manipÃ¼lasyon ÅŸÃ¼phesi: {tx['hash']}")

        if "bait" in tx.get('notes', "").lower():
            alerts.append(f"ðŸŽ£ Bait & switch davranÄ±ÅŸÄ± tespit edildi: {tx['hash']}")

    return alerts if alerts else ["âœ… ÅžÃ¼pheli davranÄ±ÅŸ izine rastlanmadÄ±."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\memory_tracker.py
def store_memory(signal, keywords, score, result):
    with open("data/memory_log.csv", "a") as f:
        f.write(f"{signal},{','.join(keywords)},{score},{result}\n")

def find_similar_signal(current_keywords):
    with open("data/memory_log.csv") as f:
        for line in f:
            saved_signal, saved_keywords, saved_score, saved_result = line.strip().split(",")
            shared = set(current_keywords) & set(saved_keywords.split(","))
            if len(shared) >= 2 and saved_result == "baÅŸarÄ±lÄ±":
                return f"Benzer baÅŸarÄ±lÄ± sinyal bulundu! â›³ Anahtarlar: {', '.join(shared)}"
    return "Yeni sinyal benzeri geÃ§miÅŸte yok."



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\meta_mind_director.py
def direct_meta_mind(logs):
    mind_output = []
    for log in logs:
        strength = log["feeling_strength"]
        emotion = log["emotion"]

        if emotion in ["ðŸ’¡ Ä°lham", "ðŸ”¥ Tutku"] and strength > 80:
            directive = "ðŸš€ Ã–ncelikli GÃ¶rev: YaratÄ±cÄ± AtÄ±lÄ±m ZamanÄ±"
        elif emotion == "ðŸŽ¯ Odak" and strength >= 65:
            directive = "ðŸ§  Derin Ã‡alÄ±ÅŸma Modu Aktif"
        elif emotion in ["ðŸŒ«ï¸ Yorgunluk", "ðŸ˜• KararsÄ±zlÄ±k"] and strength < 50:
            directive = "ðŸ›Œ Dinlenme Modu Aktif â€“ Enerji Topla"
        else:
            directive = "ðŸ” Durumsal GÃ¶zlem â€“ Yeni veri bekleniyor"

        mind_output.append(
            f"{directive} | GÃ¶rev: {log['task_id']} | Zaman: {log['timestamp']} | Duygu: {emotion} | GÃ¼Ã§: {strength}"
        )
    return mind_output



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\modules.py
def chain_hunter(code_base):
    if "obfuscation" in code_base:
        print("



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\momentum_flux_decoder.py
def decode_momentum_flux(logs):
    flux_output = []
    for log in logs:
        time = log["timestamp"].split("T")[1]
        hour = int(time.split(":")[0])
        
        if hour < 9:
            window = "ðŸŒ… Sabah Enerjisi"
        elif hour < 15:
            window = "ðŸŒž Ã–ÄŸle YÃ¼kseliÅŸi"
        elif hour < 20:
            window = "ðŸŒ‡ AkÅŸam DÃ¶nÃ¼ÅŸÃ¼mÃ¼"
        else:
            window = "ðŸŒŒ Gece DerinliÄŸi"

        if log["feeling_strength"] > 70:
            pulse = "ðŸ”‹ Motivasyon AkÄ±mÄ± YÃœKSEK"
        else:
            pulse = "âš¡ Motivasyon AkÄ±mÄ± DÃœÅžÃœK"

        flux_output.append(
            f"{window} â†’ {pulse} | GÃ¶rev: {log['task_id']} | Duygu: {log['emotion']} | GÃ¼Ã§: {log['feeling_strength']}"
        )
    return flux_output



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\multi_strategy.py
# multi_strategy.py
from kiripto_nova.signals.signal_engine import SignalEngine

class MultiStrategyEngine:
    def __init__(self, df):
        self.df = df.copy()
        self.engine = SignalEngine(self.df)
        self.signals = {
            "rsi_macd_combo": self.rsi_macd_combo,
            "ema_crossover": self.ema_crossover,
            "bollinger_touch": self.bollinger_touch
        }

    def evaluate(self):
        self.engine.calculate_indicators()
        votes = []

        for name, strategy in self.signals.items():
            signal = strategy()
            if signal:
                votes.append(signal)

        # Karar: en Ã§ok tekrar eden sinyal
        if not votes:
            return "NEUTRAL"
        return max(set(votes), key=votes.count)

    def rsi_macd_combo(self):
        row = self.engine.df.iloc[-1]
        if row['RSI_14'] < 30 and row['MACD_12_26_9'] > row['MACDs_12_26_9']:
            return "BUY"
        elif row['RSI_14'] > 70 and row['MACD_12_26_9'] < row['MACDs_12_26_9']:
            return "SELL"
        return None

    def ema_crossover(self):
        row = self.engine.df.iloc[-1]
        if row['EMA_50'] > row['EMA_200']:
            return "BUY"
        elif row['EMA_50'] < row['EMA_200']:
            return "SELL"
        return None

    def bollinger_touch(self):
        row = self.engine.df.iloc[-1]
        if row['close'] < row['BBL_20_2.0']:
            return "BUY"
        elif row['close'] > row['BBU_20_2.0']:
            return "SELL"
        return None


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\multiverse_task_tree.py
from typing import List, Dict, Any
from uuid import uuid4

class TaskTreeError(Exception): pass

def build_task_tree(missions: List[Dict[str, Any]]) -> Dict[str, Any]:
    if not isinstance(missions, list):
        raise TaskTreeError("missions must be a list")
    tree: Dict[str, Any] = {
        "root": {
            "id": "root",
            "title": "Kader BaÅŸlangÄ±Ã§",
            "children": []
        },
        "metadata": {"version": 1}
    }
    for mission in missions:
        if not isinstance(mission, dict):
            raise TaskTreeError("each mission must be a dict")
        branch = {
            "id": str(uuid4()),
            "mission": mission,
            "next_step": None,  # strateji motoru dolduracak
            "status": "pending",
        }
        tree["root"]["children"].append(branch)
    return tree


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\myth_codex_builder.py
def build_myth_codex(task_tree):
    myth = ["ðŸŒŒ [Efsane BaÅŸlangÄ±cÄ±] - Kaptan Kamal yÄ±ldÄ±zlarÄ±n Ã§aÄŸrÄ±sÄ±nÄ± duydu..."]
    for branch in task_tree["branches"]:
        entry = f"âš”ï¸ [{branch['id']}] {branch['mission']} â†’ Yeni evrenin kilidini aÃ§tÄ±."
        myth.append(entry)
    myth.append("â™¾ï¸ [Finale Giden Yol] - Sonsuzluk algoritmasÄ± ona boyun eÄŸdi.")
    return myth



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_path_finder.py
def intuitive_decision_engine(logs):
    decisions = []
    for log in logs:
        if log["emotion"] in ["ðŸ”¥ Tutku", "ðŸ’¡ Ä°lham"] and log["feeling_strength"] > 75:
            decision = "ðŸ” YÃ¼ksek Odakla Devam"
        elif log["emotion"] == "ðŸŽ¯ Odak" and log["feeling_strength"] >= 60:
            decision = "ðŸ§  Stratejiyi DerinleÅŸtir"
        elif log["emotion"] in ["ðŸŒ«ï¸ Yorgunluk", "ðŸ˜• KararsÄ±zlÄ±k"]:
            decision = "â¸ï¸ Dinlen ve yeniden yapÄ±landÄ±r"
        else:
            decision = "ðŸ” Durumu gÃ¶zlemle"

        decisions.append(
            f"ðŸ§  Karar: {decision} | GÃ¶rev: {log['task_id']} | Zaman: {log['timestamp']} | Duygu: {log['emotion']}"
        )
    return decisions


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\notify.py
# notify.py
import os
import requests

def _tg_url(method: str) -> str:
    token = os.getenv("TELEGRAM_TOKEN", "").strip()
    return f"https://api.telegram.org/bot{token}/{method}"

def tg_enabled() -> bool:
    return bool(os.getenv("TELEGRAM_TOKEN")) and bool(os.getenv("TELEGRAM_CHAT_ID"))

def send(text: str, parse_mode: str | None = None, silent: bool = False) -> bool:
    token = os.getenv("TELEGRAM_TOKEN", "").strip()
    chat  = os.getenv("TELEGRAM_CHAT_ID", "").strip()
    if not token or not chat:
        return False
    data = {"chat_id": chat, "text": text, "disable_notification": silent}
    if parse_mode:
        data["parse_mode"] = parse_mode
    try:
        r = requests.post(_tg_url("sendMessage"), data=data, timeout=10)
        return r.ok
    except Exception:
        return False


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_command_center.py
# Gerekli kÃ¼tÃ¼phaneleri iÃ§e aktarÄ±yoruz.
# ccxt: Kripto para borsalarÄ±na baÄŸlanmak iÃ§in
# pandas & pandas_ta: Veri analizi ve teknik gÃ¶stergeler iÃ§in
# numpy: SayÄ±sal iÅŸlemler iÃ§in
# asyncio: EÅŸzamansÄ±z iÅŸlemler iÃ§in (gerÃ§ek zamanlÄ± veri Ã§ekimi simÃ¼lasyonu)
# datetime: Zaman damgalÄ± loglama iÃ§in
# xgboost: Makine Ã¶ÄŸrenimi modeli olarak kullanÄ±lacak
import ccxt.async_support as ccxt
import pandas as pd
import pandas_ta as ta
import asyncio
import numpy as np
import xgboost as xgb
from datetime import datetime, timezone
import logging
import traceback

# GeliÅŸmiÅŸ loglama ayarlarÄ±
logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s.%(msecs)03d] | %(levelname)s | %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)

class NovaAIEliiteBot:
    """
    Ultra hibrit ve profesyonel seviye bir kripto ticaret botu sÄ±nÄ±fÄ±.
    GeliÅŸmiÅŸ AI, hibrit strateji ve saÄŸlam risk yÃ¶netimi iÃ§erir.
    """
    def __init__(self, symbol="BTC/USDT", timeframe="1m", limit=300, amount=0.01):
        """
        Botun temel ayarlarÄ±nÄ± ve bileÅŸenlerini baÅŸlatÄ±r.
        """
        self.exchange = ccxt.binance({
            'enableRateLimit': True,
            'rateLimit': 1000  # ccxt API kÄ±sÄ±tlama hÄ±zÄ±nÄ± 1000ms'ye ayarlar
        })
        self.symbol = symbol
        self.timeframe = timeframe
        self.limit = limit
        self.amount = amount
        self.model = xgb.XGBClassifier(use_label_encoder=False, eval_metric='mlogloss')
        self.trained = False
        self.position = None  # Botun o anki pozisyonunu takip eder: None, 'LONG' (AL), 'SHORT' (SAT)
        self.entry_price = 0.0  # Pozisyona giriÅŸ fiyatÄ±
        
        # Risk YÃ¶netimi AyarlarÄ±
        self.SL_PERCENTAGE = 0.02  # %2 Zarar Durdur (Stop-Loss)
        self.TP_PERCENTAGE = 0.03  # %3 KÃ¢r Al (Take-Profit)
        self.sl_price = 0.0
        self.tp_price = 0.0

    async def fetch_ohlcv(self):
        """
        Borsadan mum (OHLCV) verilerini Ã§eker.
        """
        try:
            ohlcv = await self.exchange.fetch_ohlcv(self.symbol, self.timeframe, limit=self.limit)
            df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
            df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
            df = df.set_index("timestamp")
            return df
        except Exception as e:
            logging.error(f"Veri Ã§ekme hatasÄ±: {e}")
            return pd.DataFrame()

    def apply_indicators(self, df):
        """
        Ticaret stratejisi iÃ§in gerekli tÃ¼m teknik gÃ¶stergeleri uygular.
        Yeni eklenenler: OBV ve ATR.
        """
        if df.empty:
            return df
        
        # Hibrit strateji iÃ§in temel gÃ¶stergeler
        df.ta.rsi(length=14, append=True)
        df.ta.macd(append=True)
        df.ta.ema(length=20, append=True)
        df.ta.bbands(append=True)
        df.ta.adx(append=True)
        df.ta.obv(append=True)  # Yeni gÃ¶sterge: On-Balance Volume
        df.ta.atr(length=14, append=True) # Yeni gÃ¶sterge: Average True Range
        
        # Ek gÃ¶stergeler
        df.ta.mom(append=True)
        df.ta.cci(append=True)
        
        # Modeli beslemek iÃ§in gerekli sÃ¼tunlar
        required_cols = ["RSI_14", "MACD_12_26_9", "ADX_14", "BBL_5_2.0", "BBM_5_2.0", "BBU_5_2.0", "MOM_10", "CCI_14", "OBV", "ATR_14"]
        
        # EÄŸer bir gÃ¶sterge sÃ¼tunu eksikse, boÅŸ bir DataFrame dÃ¶ndÃ¼r.
        if not all(col in df.columns for col in required_cols):
            logging.warning("BazÄ± gÃ¶stergeler hesaplanamadÄ±, veri boyutu yetersiz olabilir.")
            return pd.DataFrame()

        return df.dropna().copy()

    def create_labels(self, df):
        """
        MÃ¼kemmeliyetÃ§i etiketleme mantÄ±ÄŸÄ±: ÃœÃ§lÃ¼ Onay Sistemi.
        Sinyal Ã¼retmek iÃ§in birden fazla koÅŸulu kontrol eder.
        1: YÃ¼kseliÅŸ (AL), -1: DÃ¼ÅŸÃ¼ÅŸ (SAT), 0: Yatay/Bekle (BEKLE)
        """
        # Gelecekteki fiyat hareketini tahmin etmek iÃ§in 1 mum ileri kaydÄ±rma
        df['future_close'] = df['close'].shift(-1)
        
        # Etiketleme mantÄ±ÄŸÄ±
        df['label'] = 0
        
        # AL (Long) sinyali iÃ§in Ã¼Ã§lÃ¼ onay
        # 1. Trend: Fiyat EMA 20'nin Ã¼zerinde olmalÄ±
        # 2. Momentum: RSI 60'Ä±n Ã¼zerinde olmalÄ± (aÅŸÄ±rÄ± alÄ±m bÃ¶lgesinde olmamalÄ±)
        # 3. Hacim: OBV yÃ¼kseliÅŸte olmalÄ±
        long_condition = (df['close'] > df['EMA_20']) & \
                         (df['RSI_14'] < 70) & \
                         (df['OBV'] > df['OBV'].shift(1))
        
        df.loc[long_condition, 'label'] = 1

        # SAT (Short) sinyali iÃ§in Ã¼Ã§lÃ¼ onay
        # 1. Trend: Fiyat EMA 20'nin altÄ±nda olmalÄ±
        # 2. Momentum: RSI 40'Ä±n altÄ±nda olmalÄ± (aÅŸÄ±rÄ± satÄ±m bÃ¶lgesinde olmamalÄ±)
        # 3. Hacim: OBV dÃ¼ÅŸÃ¼ÅŸte olmalÄ±
        short_condition = (df['close'] < df['EMA_20']) & \
                          (df['RSI_14'] > 30) & \
                          (df['OBV'] < df['OBV'].shift(1))
                          
        df.loc[short_condition, 'label'] = -1
        
        return df.dropna().copy()

    def train_model(self, df):
        """
        HazÄ±rlanan verilerle XGBoost modelini eÄŸitir.
        """
        if df.empty:
            logging.error("EÄŸitim iÃ§in yeterli veri yok.")
            return

        features = ["RSI_14", "MACD_12_26_9", "ADX_14", "BBL_5_2.0", "BBM_5_2.0", "BBU_5_2.0", "MOM_10", "CCI_14", "OBV", "ATR_14"]
        X = df[features]
        y = df['label']

        try:
            self.model.fit(X, y)
            self.trained = True
            logging.info("ðŸ§  AI modeli baÅŸarÄ±yla eÄŸitildi.")
        except Exception as e:
            logging.error(f"AI modeli eÄŸitim hatasÄ±: {e}")
            traceback.print_exc()

    def predict_signal(self, latest_row):
        """
        En son veriyi kullanarak AI'dan alÄ±m, satÄ±m veya bekle sinyali alÄ±r.
        """
        if not self.trained:
            logging.warning("AI modeli henÃ¼z eÄŸitilmemiÅŸ. Bekle sinyali veriliyor.")
            return "BEKLE"

        try:
            features = ["RSI_14", "MACD_12_26_9", "ADX_14", "BBL_5_2.0", "BBM_5_2.0", "BBU_5_2.0", "MOM_10", "CCI_14", "OBV", "ATR_14"]
            X = latest_row[features].values.reshape(1, -1)
            pred = self.model.predict(X)[0]

            if pred == 1:
                return "AL"
            elif pred == -1:
                return "SAT"
            else:
                return "BEKLE"
        except Exception as e:
            logging.error(f"Sinyal tahmini hatasÄ±: {e}")
            return "BEKLE"

    async def execute_trade(self, signal, current_price):
        """
        Gelen sinyale gÃ¶re ticaret emrini gÃ¶nderir ve pozisyonu yÃ¶netir.
        Risk yÃ¶netimi (stop-loss ve take-profit) burada uygulanÄ±r.
        """
        if self.position is None:
            # HenÃ¼z pozisyonda deÄŸiliz, yeni emir verebiliriz.
            try:
                if signal == "AL":
                    logging.info(f"ðŸš€ AL sinyali alÄ±ndÄ±. Fiyat: {current_price:.2f}")
                    # await self.exchange.create_market_buy_order(self.symbol, self.amount) # GerÃ§ek emir iÃ§in bu satÄ±r etkinleÅŸtirilir.
                    self.position = 'LONG'
                    self.entry_price = current_price
                    self.sl_price = current_price * (1 - self.SL_PERCENTAGE)
                    self.tp_price = current_price * (1 + self.TP_PERCENTAGE)
                    logging.info(f"ðŸŸ¢ LONG pozisyon aÃ§Ä±ldÄ±. GiriÅŸ FiyatÄ±: {self.entry_price:.2f} | TP: {self.tp_price:.2f} | SL: {self.sl_price:.2f}")
                
                elif signal == "SAT":
                    logging.info(f"ðŸ”» SAT sinyali alÄ±ndÄ±. Fiyat: {current_price:.2f}")
                    # await self.exchange.create_market_sell_order(self.symbol, self.amount) # GerÃ§ek emir iÃ§in bu satÄ±r etkinleÅŸtirilir.
                    self.position = 'SHORT'
                    self.entry_price = current_price
                    self.sl_price = current_price * (1 + self.SL_PERCENTAGE)
                    self.tp_price = current_price * (1 - self.TP_PERCENTAGE)
                    logging.info(f"ðŸ”´ SHORT pozisyon aÃ§Ä±ldÄ±. GiriÅŸ FiyatÄ±: {self.entry_price:.2f} | TP: {self.tp_price:.2f} | SL: {self.sl_price:.2f}")
                
                else:
                    logging.info("â¸ï¸ BEKLE sinyali â€” iÅŸlem yapÄ±lmadÄ±.")
            except Exception as e:
                logging.error(f"âŒ Emir gÃ¶nderme hatasÄ±: {e}")
                traceback.print_exc()

        else:
            # Zaten pozisyondayÄ±z, pozisyonu yÃ¶netiyoruz.
            if self.position == 'LONG':
                # Zarar Durdur kontrolÃ¼
                if current_price <= self.sl_price:
                    logging.warning(f"ðŸ›‘ LONG pozisyonu SL'e ulaÅŸtÄ±. Pozisyon kapatÄ±lÄ±yor. Fiyat: {current_price:.2f}")
                    # await self.exchange.create_market_sell_order(self.symbol, self.amount) # GerÃ§ek emir iÃ§in
                    self.position = None
                    self.entry_price = 0.0
                # KÃ¢r Al kontrolÃ¼
                elif current_price >= self.tp_price:
                    logging.info(f"âœ… LONG pozisyonu TP'ye ulaÅŸtÄ±. Pozisyon kapatÄ±lÄ±yor. Fiyat: {current_price:.2f}")
                    # await self.exchange.create_market_sell_order(self.symbol, self.amount) # GerÃ§ek emir iÃ§in
                    self.position = None
                    self.entry_price = 0.0

            elif self.position == 'SHORT':
                # Zarar Durdur kontrolÃ¼
                if current_price >= self.sl_price:
                    logging.warning(f"ðŸ›‘ SHORT pozisyonu SL'e ulaÅŸtÄ±. Pozisyon kapatÄ±lÄ±yor. Fiyat: {current_price:.2f}")
                    # await self.exchange.create_market_buy_order(self.symbol, self.amount) # GerÃ§ek emir iÃ§in
                    self.position = None
                    self.entry_price = 0.0
                # KÃ¢r Al kontrolÃ¼
                elif current_price <= self.tp_price:
                    logging.info(f"âœ… SHORT pozisyonu TP'ye ulaÅŸtÄ±. Pozisyon kapatÄ±lÄ±yor. Fiyat: {current_price:.2f}")
                    # await self.exchange.create_market_buy_order(self.symbol, self.amount) # GerÃ§ek emir iÃ§in
                    self.position = None
                    self.entry_price = 0.0

    async def run(self):
        """
        Botun ana dÃ¶ngÃ¼sÃ¼nÃ¼ Ã§alÄ±ÅŸtÄ±rÄ±r. SÃ¼rekli veri Ã§eker, sinyal Ã¼retir ve iÅŸlem yapar.
        """
        logging.info("ðŸ”¥ Nova AI Elite Bot baÅŸlatÄ±lÄ±yor...")
        
        # Model eÄŸitimi iÃ§in ilk verileri Ã§ekme
        df = await self.fetch_ohlcv()
        if df.empty:
            logging.error("Bot baÅŸlatÄ±lamadÄ±: Veri alÄ±namÄ±yor.")
            return

        df = self.apply_indicators(df)
        df_labeled = self.create_labels(df)
        self.train_model(df_labeled)
        
        while True:
            try:
                # Periyodik olarak yeni verileri Ã§ekme
                latest_df = await self.fetch_ohlcv()
                latest_df = self.apply_indicators(latest_df)

                if latest_df.empty:
                    logging.warning("Yeni veri bulunamadÄ±, bir sonraki dÃ¶ngÃ¼ bekleniyor...")
                    await asyncio.sleep(60) # 1 dakika bekle
                    continue
                
                latest_row = latest_df.iloc[-1]
                current_price = latest_row["close"]
                
                # Sinyal tahmini
                signal = self.predict_signal(latest_row)
                logging.info(f"{self.symbol} fiyatÄ±: {current_price:.2f} | AI Sinyal: {signal} | Pozisyon: {self.position}")

                # Ticaret emri gÃ¶nderme ve pozisyon yÃ¶netimi
                await self.execute_trade(signal, current_price)

            except Exception as e:
                logging.error(f"Ana dÃ¶ngÃ¼de beklenmedik hata: {e}")
                traceback.print_exc()

            await asyncio.sleep(60)  # Her 1 dakikada bir Ã§alÄ±ÅŸtÄ±r (timeframe'e gÃ¶re ayarlanabilir)

    def backtest_strategy(self, df):
        """
        GeliÅŸtirilmiÅŸ stratejinin geÃ§miÅŸ veriler Ã¼zerinde basit bir geri testi.
        Bu, botu canlÄ±ya almadan Ã¶nce performansÄ±nÄ± deÄŸerlendirmenizi saÄŸlar.
        """
        logging.info("ðŸ“ˆ Strateji geriye dÃ¶nÃ¼k testi baÅŸlatÄ±lÄ±yor...")
        
        # Geriye dÃ¶nÃ¼k test iÃ§in modelin eÄŸitilmesi
        df = self.apply_indicators(df)
        df = self.create_labels(df)
        self.train_model(df)
        
        test_df = df.dropna().copy()
        
        initial_balance = 1000
        balance = initial_balance
        position_size = 0
        
        for i, row in test_df.iterrows():
            signal = self.predict_signal(row)
            current_price = row['close']
            
            # Sadece pozisyonda deÄŸilken AL veya SAT sinyallerine bak
            if position_size == 0:
                if signal == 'AL':
                    position_size = balance / current_price
                    balance = 0
                    logging.info(f"âœ… GerÃ§ek zamanlÄ± test: LONG pozisyon aÃ§Ä±ldÄ± @ {current_price:.2f}")
                elif signal == 'SAT':
                    position_size = -1 * (balance / current_price)
                    balance = 0
                    logging.info(f"âŒ GerÃ§ek zamanlÄ± test: SHORT pozisyon aÃ§Ä±ldÄ± @ {current_price:.2f}")
            # Pozisyonda iken, pozisyonu kapatma sinyali bekle
            elif position_size > 0 and signal == 'SAT':
                balance = position_size * current_price
                position_size = 0
                logging.info(f"ðŸ’° GerÃ§ek zamanlÄ± test: LONG pozisyon kapatÄ±ldÄ± @ {current_price:.2f}")
            elif position_size < 0 and signal == 'AL':
                balance = -1 * (position_size * current_price)
                position_size = 0
                logging.info(f"ðŸ’° GerÃ§ek zamanlÄ± test: SHORT pozisyon kapatÄ±ldÄ± @ {current_price:.2f}")
                
        final_balance = balance + (position_size * test_df.iloc[-1]['close'])
        
        logging.info("--- Geriye DÃ¶nÃ¼k Test SonuÃ§larÄ± ---")
        logging.info(f"BaÅŸlangÄ±Ã§ Bakiyesi: {initial_balance:.2f} USDT")
        logging.info(f"Son Bakiye: {final_balance:.2f} USDT")
        logging.info(f"Toplam KÃ¢r/Zarar: {(final_balance - initial_balance):.2f} USDT")
        logging.info(f"ROI (YatÄ±rÄ±m Getirisi): {((final_balance - initial_balance) / initial_balance) * 100:.2f}%")

    async def close(self):
        """
        Botun baÄŸlantÄ±larÄ±nÄ± kapatÄ±r.
        """
        await self.exchange.close()
        logging.info("ðŸ‘‹ Bot kapatÄ±ldÄ±.")

# Botu baÅŸlatmak iÃ§in ana iÅŸlev
async def main():
    bot = NovaAIEliiteBot()
    
    # Geriye dÃ¶nÃ¼k test (Backtesting)
    df_for_backtest = await bot.fetch_ohlcv()
    if not df_for_backtest.empty:
        bot.backtest_strategy(df_for_backtest.copy())
    
    # CanlÄ± botu baÅŸlat (Yorum satÄ±rÄ±nÄ± kaldÄ±rarak aktif hale getirebilirsiniz)
    # await bot.run()
    
    await bot.close()

if __name__ == "__main__":
    asyncio.run(main())


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_dashboard.py
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import plotly.graph_objs as go
import pandas as pd
import threading
import time

# PaylaÅŸÄ±lan veri deposu
shared_data = {
    'BTCUSDT': [],
    'ETHUSDT': []
}

# ArayÃ¼z uygulamasÄ±
app = dash.Dash(__name__)
app.layout = html.Div([
    html.H1("NovaQuantX Dashboard ðŸš€"),
    dcc.Dropdown(
        id='symbol-selector',
        options=[{'label': s, 'value': s} for s in shared_data.keys()],
        value='BTCUSDT'
    ),
    dcc.Graph(id='live-graph'),
    dcc.Interval(id='interval-component', interval=1000, n_intervals=0)
])

@app.callback(
    Output('live-graph', 'figure'),
    Input('interval-component', 'n_intervals'),
    Input('symbol-selector', 'value')
)
def update_graph(n, symbol):
    data = shared_data[symbol][-100:]
    if not data:
        return go.Figure()
    df = pd.DataFrame(data, columns=['ts', 'price'])
    fig = go.Figure(data=[go.Scatter(x=df['ts'], y=df['price'], mode='lines+markers')])
    fig.update_layout(title=f"{symbol} Fiyat AkÄ±ÅŸÄ±", xaxis_title="Zaman", yaxis_title="Fiyat")
    return fig

def run_dashboard():
    app.run_server(debug=False, use_reloader=False)

def stream_listener():
    from nova_stream import NovaStream, Tick

    class DashboardStream(NovaStream):
        async def analyze_tick(self, tick: Tick):
            shared_data[tick.symbol].append((tick.local_ns, tick.price))
            await super().analyze_tick(tick)

    asyncio.run(DashboardStream().connect())

if __name__ == "__main__":
    threading.Thread(target=run_dashboard).start()
    time.sleep(2)
    threading.Thread(target=stream_listener).start()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_stream.py
# NovaQuantX - ultra elit veri akÄ±ÅŸ motoru
# Mikrosaniyede Binance Futures veri alÄ±mÄ± + analiz tetikleyici + sinyal iÅŸleme

import asyncio
import json
import time
import aiohttp
from collections import deque
from dataclasses import dataclass
from nova_indicators.rsi import TickRSI
from nova_trader import NovaTrader

SYMBOLS = ['BTCUSDT', 'ETHUSDT']
STREAMS = [f"{s.lower()}@aggTrade" for s in SYMBOLS]
WS_URL = f"wss://fstream.binance.com/stream?streams={'/'.join(STREAMS)}"

@dataclass
class Tick:
    symbol: str
    price: float
    qty: float
    server_ts: int
    local_ns: int

class NovaStream:
    def __init__(self):
        self.buffers = {s: deque(maxlen=5000) for s in SYMBOLS}
        self.rsi_engines = {s: TickRSI(period=14) for s in SYMBOLS}
        self.trader = NovaTrader(leverage=10)
        self.reconnect_attempts = 0

    async def connect(self):
        print(f"ðŸ”Œ BaÄŸlanÄ±yor: {WS_URL}")
        while True:
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.ws_connect(WS_URL) as ws:
                        self.reconnect_attempts = 0
                        async for msg in ws:
                            if msg.type == aiohttp.WSMsgType.TEXT:
                                await self.handle_message(msg.data)
            except Exception as e:
                self.reconnect_attempts += 1
                wait = min(5 * self.reconnect_attempts, 60)
                print(f"âš ï¸ BaÄŸlantÄ± hatasÄ±: {e} | {wait}s sonra yeniden denenecek...")
                await asyncio.sleep(wait)

    async def handle_message(self, raw):
        try:
            payload = json.loads(raw)
            stream = payload.get("stream", "")
            data = payload.get("data", {})
            symbol = stream.split("@")[0].upper()
            tick = Tick(
                symbol=symbol,
                price=float(data["p"]),
                qty=float(data["q"]),
                server_ts=int(data["T"]),
                local_ns=time.perf_counter_ns()
            )
            self.buffers[symbol].append(tick)
            await self.analyze_tick(tick)
        except Exception as e:
            print(f"âš ï¸ Veri iÅŸleme hatasÄ±: {e}")

    async def analyze_tick(self, tick: Tick):
        rsi = self.rsi_engines[tick.symbol].update(tick.price)
        if rsi is not None:
            print(f"ðŸ“Š {tick.symbol} RSI={rsi} @ {tick.price:.2f}")
            self.trader.process_signal(tick.symbol, tick.price, rsi, tick.local_ns)

async def main():
    stream = NovaStream()
    await stream.connect()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("ðŸ›‘ Durduruldu")

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\panic_flatten.py
# panic_flatten.py
# TÃ¼m aÃ§Ä±k pozisyonlarÄ± market ile kapatÄ±r, bekleyen emirleri iptal eder.
from __future__ import annotations
from typing import List, Optional
from bot import client, retry, round_qty, tg  # bot.py'deki saÄŸlam yardÄ±mcÄ±larÄ± kullanÄ±yoruz

def detect_open_symbols() -> List[str]:
    pos = retry(client.futures_position_information, desc="positions")
    syms = {p["symbol"] for p in pos if float(p.get("positionAmt", 0)) != 0.0}
    return sorted(syms)

def flatten(symbols: Optional[List[str]] = None):
    symbols = [s.upper() for s in symbols] if symbols else detect_open_symbols()
    if not symbols:
        tg("ðŸ§¯ Flatten: aÃ§Ä±k pozisyon yok.")
        return

    for sym in symbols:
        # 1) TÃ¼m bekleyen emirleri iptal et
        try:
            retry(client.futures_cancel_all_open_orders, symbol=sym, desc=f"cancel_all_{sym}")
        except Exception as e:
            tg(f"âš ï¸ {sym} emir iptal uyarÄ±sÄ±: {e}")

        # 2) PozisyonlarÄ± oku ve her bir yÃ¶nÃ¼ market ile kapat
        pos = retry(client.futures_position_information, symbol=sym, desc=f"posinfo_{sym}")
        for p in pos:
            amt = float(p.get("positionAmt", 0))
            if amt == 0:
                continue

            # LONG(+) kapatmak iÃ§in SELL; SHORT(-) kapatmak iÃ§in BUY
            side = "SELL" if amt > 0 else "BUY"
            pos_side = p.get("positionSide", "BOTH")  # HEDGE: LONG/SHORT, ONEWAY: BOTH
            qty = round_qty(sym, abs(amt))

            order_kwargs = dict(symbol=sym, side=side, type="MARKET", quantity=qty, reduceOnly=True)
            if pos_side != "BOTH":
                order_kwargs["positionSide"] = pos_side  # HEDGE modunda gerekli

            retry(client.futures_create_order, desc=f"flatten_{sym}_{pos_side}", **order_kwargs)
            tg(f"ðŸ§¯ Flatten {sym} {pos_side} qty={qty} -> {side}")

    tg("âœ… Flatten tamam.")

if __name__ == "__main__":
    import sys
    syms = sys.argv[1:]  # Ã¶rn: python panic_flatten.py BTCUSDT ETHUSDT
    flatten(syms if syms else None)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\preflight.py
# preflight.py
# AmaÃ§: .env'ye gÃ¶re Binance Futures (mainnet/testnet) baÄŸlantÄ± testi.
# Geri dÃ¶nÃ¼ÅŸ: serverTime veya anlaÅŸÄ±lÄ±r hata mesajÄ±.

import os
import sys
import time
import json
from urllib.parse import urljoin

try:
    from dotenv import load_dotenv
except ImportError:
    print("python-dotenv kurulu deÄŸil. Kurmak iÃ§in:\n  pip install python-dotenv")
    sys.exit(1)

try:
    import requests
except ImportError:
    print("requests kurulu deÄŸil. Kurmak iÃ§in:\n  pip install requests")
    sys.exit(1)

# --- .env yÃ¼kle ---
load_dotenv()

def as_bool(x: str, default=False):
    if x is None:
        return default
    return str(x).strip().lower() in ("1", "true", "yes", "y")

USE_TESTNET = as_bool(os.getenv("BINANCE_USE_TESTNET"), False)

# URL'yi .env'den al (varsa), yoksa gÃ¼venli varsayÄ±lanlarÄ± kullan
ENV_URL = os.getenv("BINANCE_FUTURES_URL", "").strip()

if USE_TESTNET:
    BASE = ENV_URL or "https://testnet.binancefuture.com"
else:
    BASE = ENV_URL or "https://fapi.binance.com"

TIME_PATH = "/fapi/v1/time"
TIME_URL = urljoin(BASE, TIME_PATH)

print(f"â†’ Ortam: {'TESTNET' if USE_TESTNET else 'MAINNET'}")
print(f"â†’ Endpoint: {TIME_URL}")

try:
    r = requests.get(TIME_URL, timeout=10)
    ct = r.headers.get("content-type", "")
    if "application/json" not in ct:
        # CloudFront ya da baÅŸka bir katmandan HTML dÃ¶ndÃ¼yse yakala
        print("\nâš ï¸  Beklenmeyen iÃ§erik tipi:", ct or "(bilinmiyor)")
        print("---- DÃ¶nen ilk 400 karakter ----")
        print(r.text[:400])
        print("--------------------------------")
        sys.exit(2)

    r.raise_for_status()
    data = r.json()

    if not isinstance(data, dict) or "serverTime" not in data:
        print("âš ï¸  JSON geldi ama beklenen alan yok:", data)
        sys.exit(3)

    # BaÅŸarÄ±lÄ±!
    st = data["serverTime"]
    print(f"\nâœ… BaÄŸlantÄ± OK â€” serverTime: {st} ({time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(st/1000))} UTC)")
    sys.exit(0)

except requests.exceptions.Timeout:
    print("â›” Zaman aÅŸÄ±mÄ±. AÄŸ baÄŸlantÄ±nÄ± veya VPN/Proxy ayarlarÄ±nÄ± kontrol et.")
    sys.exit(10)
except requests.exceptions.ConnectionError as e:
    print("â›” BaÄŸlantÄ± hatasÄ±:", e)
    print("   Muhtemel nedenler: internet eriÅŸimi, DNS/Proxy/VPN, gÃ¼venlik duvarÄ±.")
    sys.exit(11)
except requests.exceptions.HTTPError as e:
    # HTTP 4xx/5xx
    print(f"â›” HTTP hatasÄ±: {e} (kod {e.response.status_code})")
    print("Cevap gÃ¶vdesi (ilk 400 char):", e.response.text[:400])
    sys.exit(12)
except Exception as e:
    print("â›” Beklenmeyen hata:", repr(e))
    sys.exit(99)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\pro_alpha.py
import numpy as np
import pandas as pd

# ---------- GÃ¶stergeler ----------
def rsi(series, n=14):
    ch = series.diff()
    up = ch.clip(lower=0).rolling(n).mean()
    dn = (-ch.clip(upper=0)).rolling(n).mean()
    rs = up / (dn.replace(0, np.nan))
    return 100 - (100 / (1+rs))

def ema(series, n):
    return series.ewm(span=n, adjust=False).mean()

def atr(df, n=14):
    h,l,c = df["high"], df["low"], df["close"]
    tr = np.maximum.reduce([
        (h-l).values,
        np.abs(h-c.shift(1)).values,
        np.abs(l-c.shift(1)).values
    ])
    return pd.Series(tr, index=df.index).rolling(n).mean()

# ---------- YardÄ±mcÄ± ----------
def make_df(klines):
    cols = ["open_time","open","high","low","close","volume",
            "close_time","qv","ntrades","tbb","tbq","ignore"]
    df = pd.DataFrame(klines, columns=cols)
    for col in ["open","high","low","close","volume"]:
        df[col] = df[col].astype(float)
    # zaman kullanmak istersen:
    # df["open_time"] = pd.to_datetime(df["open_time"], unit="ms")
    # df["close_time"] = pd.to_datetime(df["close_time"], unit="ms")
    return df

# ---------- Tek TF skor (1m tetik) ----------
def score_single_tf(df, funding_bias=0.0):
    df = df.copy()
    df["ema50"] = ema(df["close"],50)
    df["ema200"]= ema(df["close"],200)
    df["rsi"]   = rsi(df["close"],14)
    df["atr"]   = atr(df,14)

    # Trend (EMA50 vs EMA200)
    trend = np.where(df["ema50"]>df["ema200"], 1, -1)

    # Breakout (20 bar)
    hh = df["high"].rolling(20).max()
    ll = df["low"].rolling(20).min()
    bo_long  = (df["close"]>hh.shift(1)).astype(int)
    bo_short = (df["close"]<ll.shift(1)).astype(int)*-1

    # Mean-rev (Bollinger z)
    mid = df["close"].rolling(20).mean()
    std = df["close"].rolling(20).std()
    z = (df["close"]-mid)/std.replace(0,np.nan)
    mr_long  = (z<-2).astype(int)
    mr_short = (z> 2).astype(int)*-1

    raw = trend + bo_long + bo_short + mr_long + mr_short
    bias = -np.sign(funding_bias)  # funding + ise short bias (kontraryen)
    score = raw + 0.5*bias

    last = score.iloc[-1]
    last_atr = df["atr"].iloc[-1]
    last_close = df["close"].iloc[-1]
    return float(last), float(last_atr), float(last_close)

# ---------- MTF: 1m tetik + 15m trend + 1h yÃ¶n ----------
def slope(series, n=5):
    # son n deÄŸerin doÄŸrusal regresyon eÄŸimi (yaklaÅŸÄ±k eÄŸilim)
    y = series.tail(n).values
    x = np.arange(len(y))
    if len(y) < 2 or np.any(np.isnan(y)):
        return 0.0
    b = np.polyfit(x, y, 1)[0]
    return float(b)

def mtf_filter(df_trend_15m, df_dir_1h, confirm_mode="STRICT"):
    """
    15m trend: EMA50 > EMA200 -> LONG, altÄ± -> SHORT
    1h yÃ¶n: EMA50>EMA200 VE EMA200 eÄŸimi yukarÄ± -> LONG, tersi -> SHORT
    confirm_mode:
      - STRICT  : ikisi de aynÄ± yÃ¶n
      - RELAXED : en az biri o yÃ¶nde
    DÃ¶nÃ¼ÅŸ: "LONG"/"SHORT"/"NONE"
    """
    t = df_trend_15m.copy()
    d = df_dir_1h.copy()
    t["ema50"] = ema(t["close"],50); t["ema200"] = ema(t["close"],200)
    d["ema50"] = ema(d["close"],50); d["ema200"] = ema(d["close"],200)

    t_long = t["ema50"].iloc[-1] > t["ema200"].iloc[-1]
    d_long = (d["ema50"].iloc[-1] > d["ema200"].iloc[-1]) and (slope(d["ema200"], 9) > 0)

    t_short = not t_long
    d_short = (d["ema50"].iloc[-1] < d["ema200"].iloc[-1]) and (slope(d["ema200"], 9) < 0)

    if confirm_mode.upper()=="STRICT":
        if t_long and d_long:   return "LONG"
        if t_short and d_short: return "SHORT"
        return "NONE"
    else:  # RELAXED
        if t_long or d_long:    return "LONG"
        if t_short or d_short:  return "SHORT"
        return "NONE"

def score_mtf(trigger_df, trend_df, dir_df, funding_bias=0.0, confirm_mode="STRICT"):
    """
    1) Tetik (1m) Ã¼zerinde score_single_tf ile sinyal gÃ¼cÃ¼
    2) 15m & 1h ile yÃ¶n filtresi (STRICT/RELAXED)
    3) Uyum varsa yÃ¶nÃ¼ score iÅŸaretine uygular; yoksa FLAT
    DÃ¶nÃ¼ÅŸ: (direction, score, atr, last_close)
    """
    score, atr_val, last_px = score_single_tf(trigger_df, funding_bias)
    # tetik yÃ¶nÃ¼
    trig_dir = "LONG" if score >= 1 else ("SHORT" if score <= -1 else "FLAT")
    if trig_dir == "FLAT":
        return "FLAT", score, atr_val, last_px

    mtf_dir = mtf_filter(trend_df, dir_df, confirm_mode=confirm_mode)
    if mtf_dir == "NONE":
        return "FLAT", score, atr_val, last_px

    # tetik ile MTF aynÄ± tarafta mÄ±?
    if (trig_dir == "LONG" and mtf_dir == "LONG") or (trig_dir == "SHORT" and mtf_dir == "SHORT"):
        return trig_dir, score, atr_val, last_px
    # Ã§akÄ±ÅŸÄ±yorsa iÅŸlem yapma
    return "FLAT", score, atr_val, last_px



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\pro_config.py
# pro_config.py
import os
from typing import Dict, Any
try:
    # .env kullanÄ±yorsan sorun Ã§Ä±karmasÄ±n
    from dotenv import load_dotenv
    load_dotenv()
except Exception:
    pass


# -------------------------
# Ã‡EKÄ°RDEK AYARLAR
# -------------------------
def _get_bool(name: str, default: bool) -> bool:
    v = os.getenv(name, str(default)).strip().lower()
    return v in ("1", "true", "yes", "y", "on")

def _get_float(name: str, default: float) -> float:
    try:
        return float(os.getenv(name, str(default)))
    except Exception:
        return default

def _get_int(name: str, default: int) -> int:
    try:
        return int(os.getenv(name, str(default)))
    except Exception:
        return default


# -------------------------
# MTF (Multi-Timeframe) AYARLARI
# -------------------------
# !!! Ã–NEMLÄ°: Python'da deÄŸiÅŸken atamasÄ± EÅžÄ°TTÄ°R (=) ile yapÄ±lÄ±r; iki nokta (:) deÄŸil.
MTF_TRIGGER = os.getenv("MTF_TRIGGER", "1m")   # tetik (Ã¶rn 1m)
MTF_TREND   = os.getenv("MTF_TREND",   "15m")  # trend filtresi (Ã¶rn 15m)
MTF_DIR     = os.getenv("MTF_DIR",     "1h")   # yÃ¶n onayÄ± (Ã¶rn 1h)

# Trend ve yÃ¶n EMA pencereleri
MTF_TREND_EMA_FAST = _get_int("MTF_TREND_EMA_FAST", 21)
MTF_TREND_EMA_SLOW = _get_int("MTF_TREND_EMA_SLOW", 55)
MTF_DIR_EMA_FAST   = _get_int("MTF_DIR_EMA_FAST",   50)
MTF_DIR_EMA_SLOW   = _get_int("MTF_DIR_EMA_SLOW",   200)

# Tetik (1m) tarafÄ± iÃ§in kÄ±sa/uzun EMA pencereleri
EMA_FAST = _get_int("EMA_FAST", 9)
EMA_SLOW = _get_int("EMA_SLOW", 21)

# -------------------------
# GENEL AYAR YÃœKLEYÄ°CÄ°
# -------------------------
def load_config() -> Dict[str, Any]:
    """
    TÃ¼m Ã¶nemli ayarlarÄ± tek noktadan toplar.
    Projedeki diÄŸer modÃ¼ller `from pro_config import load_config` ile bunu Ã§aÄŸÄ±rabilir.
    """
    symbols = [s.strip() for s in os.getenv("SYMBOLS", "BTCUSDT").split(",") if s.strip()]

    cfg: Dict[str, Any] = {
        "BINANCE_USE_TESTNET": _get_bool("BINANCE_USE_TESTNET", True),
        "BINANCE_FUTURES_URL_TEST": os.getenv("BINANCE_FUTURES_URL_TEST", "https://testnet.binancefuture.com"),
        "BINANCE_FUTURES_URL_MAIN": os.getenv("BINANCE_FUTURES_URL_MAIN", "https://fapi.binance.com"),

        "SYMBOLS": symbols,
        "MIN_NOTIONAL_USDT": _get_float("MIN_NOTIONAL_USDT", 10.0),
        "MAX_DAILY_DRAWDOWN": _get_float("MAX_DAILY_DRAWDOWN", 0.03),
        "MAX_CAPITAL_PCT_PER_TRADE": _get_float("MAX_CAPITAL_PCT_PER_TRADE", 0.02),

        "BINANCE_HEDGE_MODE": _get_bool("BINANCE_HEDGE_MODE", True),
        "BINANCE_MARGIN_TYPE": os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED").upper(),
        "BINANCE_LEVERAGE": _get_int("BINANCE_LEVERAGE", 5),

        "WORKING_TYPE": os.getenv("WORKING_TYPE", "MARK_PRICE").upper(),
        "SL_PCT": _get_float("SL_PCT", 0.01),
        "TP_PCT": _get_float("TP_PCT", 0.02),
        "TRAIL_PCT": _get_float("TRAIL_PCT", 0.0),

        "DRY_RUN": _get_bool("DRY_RUN", True),
        "MAX_RETRY": _get_int("MAX_RETRY", 3),
        "RETRY_BACKOFF_MS": _get_int("RETRY_BACKOFF_MS", 400),

        "TELEGRAM_TOKEN": os.getenv("TELEGRAM_TOKEN", ""),
        "TELEGRAM_CHAT_ID": os.getenv("TELEGRAM_CHAT_ID", ""),

        # Sinyal & MTF
        "TECH_INTERVAL": os.getenv("TECH_INTERVAL", "1m"),
        "EMA_FAST": EMA_FAST,
        "EMA_SLOW": EMA_SLOW,

        "MTF": {
            "TRIGGER": MTF_TRIGGER,
            "TREND":   MTF_TREND,
            "DIR":     MTF_DIR,
            "TREND_FAST": MTF_TREND_EMA_FAST,
            "TREND_SLOW": MTF_TREND_EMA_SLOW,
            "DIR_FAST":   MTF_DIR_EMA_FAST,
            "DIR_SLOW":   MTF_DIR_EMA_SLOW,
        },

        "TIMEZONE": os.getenv("TIMEZONE", "Europe/Zurich"),
        "GUARD_COOLDOWN_MIN": _get_int("GUARD_COOLDOWN_MIN", 120),
    }

    return cfg



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\pro_exchange.py
import time
import logging
from binance.client import Client

class Ex:
    def __init__(self, cfg):
        self.c = Client(cfg["KEY"], cfg["SECRET"], testnet=cfg["USE_TESTNET"])
        if cfg["USE_TESTNET"] and cfg["FUT_URL"]:
            self.c.FUTURES_URL = cfg["FUT_URL"]
        t = self.c.futures_time()["serverTime"]
        logging.info(f"Binance OK | serverTime={t} | testnet={cfg['USE_TESTNET']}")

        # hedge / margin / lev
        try:
            self.c.futures_change_position_mode(dualSidePosition="true" if cfg["HEDGE"] else "false")
        except Exception as e:
            logging.debug(f"hedge mode: {e}")
        self.cfg = cfg

    # ---- helpers ----
    def set_symbol_params(self, symbol):
        try:
            self.c.futures_change_margin_type(symbol=symbol, marginType=self.cfg["MARGIN"])
        except Exception: pass
        try:
            self.c.futures_change_leverage(symbol=symbol, leverage=self.cfg["LEV"])
        except Exception: pass

    def get_top_symbols(self, n):
        # 24h ticker ile en likit USDT perpetualâ€™larÄ± seÃ§
        info = self.c.futures_exchange_info()
        usdt_perps = [s["symbol"] for s in info["symbols"]
                      if s["quoteAsset"]=="USDT" and s.get("contractType")=="PERPETUAL" and s["status"]=="TRADING"]
        stats = self.c.futures_ticker()  # 24h
        volmap = {x["symbol"]: float(x.get("quoteVolume",0.0)) for x in stats}
        ranked = sorted([s for s in usdt_perps if s in volmap], key=lambda s: volmap[s], reverse=True)
        return ranked[:n]

    def klines(self, symbol, interval, limit=150):
        return self.c.futures_klines(symbol=symbol, interval=interval, limit=limit)

    def filters(self, symbol):
        info = self.c.futures_exchange_info()
        md = next(s for s in info["symbols"] if s["symbol"]==symbol)
        price_tick = float(next(f["tickSize"] for f in md["filters"] if f["filterType"]=="PRICE_FILTER"))
        lotf = next((f for f in md["filters"] if f["filterType"] in ("MARKET_LOT_SIZE","LOT_SIZE")), None)
        step = float(lotf["stepSize"]); min_qty=float(lotf["minQty"])
        min_notional = float(next(f["notional"] for f in md["filters"] if f["filterType"]=="MIN_NOTIONAL"))
        return price_tick, step, min_qty, min_notional

    def balance_usdt(self):
        bal = self.c.futures_account_balance()
        return float(next(b["balance"] for b in bal if b["asset"]=="USDT"))

    def positions(self):
        return self.c.futures_position_information()

    def funding(self, symbol):
        try:
            fr = self.c.futures_funding_rate(symbol=symbol, limit=1)
            return float(fr[-1]["fundingRate"])
        except Exception:
            return 0.0

    def mark_price(self, symbol):
        mp = self.c.futures_mark_price(symbol=symbol)
        return float(mp["markPrice"])

    def place_market(self, symbol, side, qty, position_side=None, reduce_only=False, client_oid=None):
        params = dict(symbol=symbol, side=side, type="MARKET", quantity=qty)
        if position_side: params["positionSide"]=position_side
        if reduce_only: params["reduceOnly"]="true"
        if client_oid: params["newClientOrderId"]=client_oid
        return self.c.futures_create_order(**params)

    def place_stop_market(self, symbol, side, stop_price, position_side=None, reduce_only=True):
        # STOP_MARKET/TAKE_PROFIT_MARKET iÃ§in karÅŸÄ±t side gerekir
        params = dict(symbol=symbol, side=side, type="STOP_MARKET",
                      stopPrice=stop_price, closePosition="false", reduceOnly="true", timeInForce="GTC")
        if position_side: params["positionSide"]=position_side
        return self.c.futures_create_order(**params)

    def place_takeprofit_market(self, symbol, side, stop_price, position_side=None, reduce_only=True):
        params = dict(symbol=symbol, side=side, type="TAKE_PROFIT_MARKET",
                      stopPrice=stop_price, closePosition="false", reduceOnly="true", timeInForce="GTC")
        if position_side: params["positionSide"]=position_side
        return self.c.futures_create_order(**params)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\pro_executor.py
import logging
import time
import uuid

def decide_side(score):
    if score>=1:   return "BUY","LONG","SELL"   # entry, posSide, protective stop side
    if score<=-1:  return "SELL","SHORT","BUY"
    return None,None,None

def run_once(cfg, ex, universe, pnl_today=0.0):
    from pro_alpha import make_df, score_symbol
    from pro_risk  import position_size, clamp_qty_by_filters, daily_circuit_breaker

    if daily_circuit_breaker(pnl_today, cfg["MAX_DD"]):
        logging.warning("GÃ¼nlÃ¼k devre kesici aktif. Yeni iÅŸlem yok.")
        return

    equity = ex.balance_usdt()
    open_pos = ex.positions()
    # sembol baÅŸÄ±na aÃ§Ä±k pozisyon miktarÄ±nÄ± say
    open_map = {}
    for p in open_pos:
        if float(p.get("positionAmt",0))!=0:
            key = (p["symbol"], p.get("positionSide","BOTH"))
            open_map[key]=p

    # Evren
    if universe:
        symbols = universe
    else:
        symbols = ex.get_top_symbols(cfg["SCAN_TOP_N"])

    for sym in symbols:
        try:
            ex.set_symbol_params(sym)
            kl = ex.klines(sym, cfg["TIMEFRAME"], limit=220)
            df = make_df(kl)

            fund = ex.funding(sym)
            score, atr, last = score_symbol(df, funding_bias=fund)

            entry_side, pos_side, stop_side = decide_side(score)
            if not entry_side: 
                continue

            # maruziyet ve pozisyon sÄ±nÄ±rlarÄ±
            cur_positions = [k for k in open_map.keys() if k[0]==sym]
            if len(open_map)>=cfg["MAX_POS"]:
                continue

            # boyut
            qty_raw = position_size(equity, cfg["RISK_PCT"], atr, last, cfg["LEV"], cfg["MIN_NOTIONAL"])
            tick, step, min_qty, min_notional = ex.filters(sym)
            qty = clamp_qty_by_filters(qty_raw, step, min_qty)
            if qty<=0: 
                continue

            client_oid = f"probot-{uuid.uuid4().hex[:12]}"
            logging.info(f"{sym} | score={score:.2f} atr={atr:.2f} last={last:.2f} -> {entry_side} {pos_side} qty={qty:.6f} DRY={cfg['DRY_RUN']}")

            if cfg["DRY_RUN"]:
                continue

            # giriÅŸ
            resp = ex.place_market(sym, entry_side, qty, position_side=pos_side, client_oid=client_oid)
            avg_price = float(resp.get("avgPrice") or resp.get("price") or last)

            # koruma (STOP & TP) â€” basit 1*ATR stop, 2*ATR TP
            stop_price = avg_price - atr if pos_side=="LONG" else avg_price + atr
            tp_price   = avg_price + 2*atr if pos_side=="LONG" else avg_price - 2*atr

            # Binance STOP/TP marketâ€™te stopPrice â€œtriggerâ€dÄ±r, karÅŸÄ±t side ile reduceOnly
            ex.place_stop_market(sym, stop_side, round(stop_price,4), position_side=pos_side, reduce_only=True)
            ex.place_takeprofit_market(sym, stop_side, round(tp_price,4), position_side=pos_side, reduce_only=True)

            logging.info(f"{sym} giriÅŸ ok | avg={avg_price:.2f} stop={stop_price:.2f} tp={tp_price:.2f}")

            time.sleep(0.2)
        except Exception as e:
            logging.warning(f"{sym} hata: {e}")
            continue


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\pro_live.py
# pro_live.py
# -*- coding: utf-8 -*-

import time
import math
import traceback
from typing import Any, Dict, List, Optional

import numpy as np

from pro_config import load_config

# ------------------------------------------------------------
#  LOGGING
# ------------------------------------------------------------
import logging
from logging.handlers import RotatingFileHandler

def _make_logger(name: str = "live") -> logging.Logger:
    logger = logging.getLogger(name)
    if logger.handlers:
        return logger
    logger.setLevel(logging.INFO)
    fmt = logging.Formatter(
        "%(asctime)s | %(levelname)s | %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )
    ch = logging.StreamHandler()
    ch.setFormatter(fmt)
    logger.addHandler(ch)
    try:
        fh = RotatingFileHandler("live.log", maxBytes=2_000_000, backupCount=3, encoding="utf-8")
        fh.setFormatter(fmt)
        logger.addHandler(fh)
    except Exception:
        pass
    return logger


# ------------------------------------------------------------
#  EXCHANGE ADAPTER
#  (pro_exchange iÃ§indeki farklÄ± isimli metodlara uyum saÄŸlar)
# ------------------------------------------------------------
class ExchangeAdapter:
    """
    Senin pro_exchange.py iÃ§indeki Exchange wrapper'Ä±na otomatik uyum.
    Gerekli temel fonksiyonlar:

      - get_klines(symbol, interval, limit)          -> list
      - get_position(symbol)                         -> {"side": "LONG/SHORT/FLAT", "qty": float, "entry": float, ...}
      - get_wallet_usdt()                            -> float
      - open_bracket_order(symbol, side, qty, price, sl_pct, tp_pct, trail_pct, working_type="MARK_PRICE")
      - close_position(symbol)

    Wrapper'Ä±nda isimler farklÄ±ysa, burada birden Ã§ok ismi dener.
    HiÃ§biri yoksa aÃ§Ä±k, anlaÅŸÄ±lÄ±r hata verir.
    """
    def __init__(self, ex_obj: Any, logger: logging.Logger):
        self._ex = ex_obj
        self.log = logger

    # ---------- yardÄ±mcÄ±  ----------
    def _call(self, candidates: List[str], *args, **kwargs):
        for name in candidates:
            if hasattr(self._ex, name):
                return getattr(self._ex, name)(*args, **kwargs)
        raise AttributeError(f"Exchange method not found. Tried: {candidates}")

    # ---------- gerekli API'ler ----------
    def get_klines(self, symbol: str, interval: str, limit: int) -> List[Any]:
        return self._call(
            ["get_klines", "klines", "fetch_klines", "get_candles", "fetch_candles"],
            symbol, interval, limit
        )

    def get_position(self, symbol: str) -> Dict[str, Any]:
        pos = self._call(
            ["get_position", "position", "fetch_position", "get_futures_position"],
            symbol
        )
        # Esnek normalize
        side = str(pos.get("side", pos.get("positionSide", "FLAT"))).upper()
        qty  = float(pos.get("qty", pos.get("positionAmt", 0.0)))
        entry= float(pos.get("entry", pos.get("entryPrice", pos.get("avgPrice", 0.0))))
        return {"side": side, "qty": qty, "entry": entry, **pos}

    def get_wallet_usdt(self) -> float:
        bal = self._call(
            ["get_wallet_usdt", "wallet_usdt", "get_balance", "get_futures_balance", "wallet"]
        )
        # dict/list durumunda USDT toplamÄ±nÄ± bulmaya Ã§alÄ±ÅŸ
        if isinstance(bal, (int, float)):
            return float(bal)
        if isinstance(bal, dict):
            for k in ("USDT", "totalUSDT", "balance", "totalBalance", "wallet"):
                if k in bal:
                    try:
                        return float(bal[k])
                    except Exception:
                        pass
        if isinstance(bal, list):
            # [{'asset':'USDT','balance':'...'}] vb.
            for x in bal:
                if isinstance(x, dict) and str(x.get("asset", "")).upper() == "USDT":
                    try:
                        return float(x.get("balance", x.get("walletBalance", x.get("crossWalletBalance", 0.0))))
                    except Exception:
                        pass
        raise RuntimeError("get_wallet_usdt(): USDT bakiyesi Ã§Ã¶zÃ¼mlenemedi.")

    def open_bracket_order(
        self,
        symbol: str,
        side: str,
        qty: float,
        price: Optional[float],
        sl_pct: float,
        tp_pct: float,
        trail_pct: float,
        working_type: str = "MARK_PRICE",
    ) -> Any:
        return self._call(
            ["open_bracket_order", "place_bracket_order", "open_order"],
            symbol, side, qty, price, sl_pct, tp_pct, trail_pct, working_type
        )

    def close_position(self, symbol: str) -> Any:
        return self._call(
            ["close_position", "close_all", "close", "close_futures_position"],
            symbol
        )

    # (opsiyonel) miktar/tick normalizasyonu varsa kullan
    def normalize_qty(self, symbol: str, qty: float) -> float:
        try:
            return self._call(["normalize_qty", "round_qty", "fmt_qty"], symbol, qty)
        except Exception:
            return qty


# ------------------------------------------------------------
#  TEKNÄ°K HESAPLAR
# ------------------------------------------------------------
def ema(series: np.ndarray, n: int) -> np.ndarray:
    if len(series) == 0:
        return series
    k = 2.0 / (n + 1.0)
    out = np.zeros_like(series, dtype=float)
    out[0] = series[0]
    for i in range(1, len(series)):
        out[i] = series[i] * k + out[i-1] * (1 - k)
    return out


def get_closes(kl: List[Any]) -> np.ndarray:
    if not kl:
        return np.array([], dtype=float)
    first = kl[0]
    if isinstance(first, dict):
        return np.array([float(x.get("close") or x.get("c") or x.get("Close")) for x in kl], dtype=float)
    # tuple/list: [open_time, open, high, low, close, volume...]
    try:
        return np.array([float(x[4]) for x in kl], dtype=float)
    except Exception:
        raise ValueError("Kline formatÄ± Ã§Ã¶zÃ¼mlenemedi; dict ya da [.., close, ..] bekleniyordu.")


# ------------------------------------------------------------
#  LIVE ENGINE
# ------------------------------------------------------------
class LiveEngine:
    def __init__(self, cfg: Dict[str, Any], ex_raw: Any):
        self.cfg = cfg
        self.log = _make_logger("live")
        self.ex = ExchangeAdapter(ex_raw, self.log)
        self.cooldown: Dict[str, int] = {}  # sembol -> kalan bar

    # ---------------- main loop (basit) ----------------
    def run_once_all(self):
        symbols = self.cfg.get("SYMBOLS", ["BTCUSDT"])
        for sym in symbols:
            try:
                self._evaluate_and_trade(sym)
            except Exception as e:
                self.log.error(f"[{sym}] HATA: {e}\n{traceback.format_exc()}")

    # ---------------- Ã§ekirdek strateji ----------------
    def _evaluate_and_trade(self, sym: str) -> None:
        cfg = self.cfg
        mtf = cfg["MTF"]

        trigger_tf = mtf["TRIGGER"]      # "1m"
        trend_tf   = mtf["TREND"]        # "15m"
        dir_tf     = mtf["DIR"]          # "1h"

        # EMA pencereleri
        ema_fast = int(cfg["EMA_FAST"])        # Ã¶rn 9
        ema_slow = int(cfg["EMA_SLOW"])        # Ã¶rn 21
        tr_fast  = int(mtf["TREND_FAST"])      # 21
        tr_slow  = int(mtf["TREND_SLOW"])      # 55
        dir_fast = int(mtf["DIR_FAST"])        # 50
        dir_slow = int(mtf["DIR_SLOW"])        # 200

        # yeterli veri tamponu
        need = max(ema_slow, tr_slow, dir_slow) + 5
        lim_trigger = max(need, 240)
        lim_trend   = max(need, 240)
        lim_dir     = max(need, 300)

        # verileri Ã§ek
        k1 = self.ex.get_klines(sym, trigger_tf, lim_trigger)
        k2 = self.ex.get_klines(sym, trend_tf,   lim_trend)
        k3 = self.ex.get_klines(sym, dir_tf,     lim_dir)

        c1 = get_closes(k1)
        c2 = get_closes(k2)
        c3 = get_closes(k3)

        if len(c1) < ema_slow + 3 or len(c2) < tr_slow + 3 or len(c3) < dir_slow + 3:
            self.log.info(f"[{sym}] Yetersiz veri (1m:{len(c1)} 15m:{len(c2)} 1h:{len(c3)})")
            return

        # EMA'lar
        ema1f = ema(c1, ema_fast)
        ema1s = ema(c1, ema_slow)
        ema2f = ema(c2, tr_fast)
        ema2s = ema(c2, tr_slow)
        ema3f = ema(c3, dir_fast)
        ema3s = ema(c3, dir_slow)

        # 1m tetik: cross
        cross_up   = ema1f[-2] <= ema1s[-2] and ema1f[-1] > ema1s[-1]
        cross_down = ema1f[-2] >= ema1s[-2] and ema1f[-1] < ema1s[-1]

        # 15m trend
        trend_up   = ema2f[-1] > ema2s[-1]
        trend_down = ema2f[-1] < ema2s[-1]

        # 1h yÃ¶n
        dir_up     = ema3f[-1] > ema3s[-1]
        dir_down   = ema3f[-1] < ema3s[-1]

        want_long  = cross_up   and trend_up   and dir_up
        want_short = cross_down and trend_down and dir_down

        # cooldown
        cd_bars = int(self.cfg.get("COOLDOWN_BARS", 0))
        if cd_bars > 0:
            left = self.cooldown.get(sym, 0)
            if left > 0:
                self.cooldown[sym] = left - 1
                self.log.debug(f"[{sym}] Cooldown {left-1} bar kaldÄ±.")
                want_long = want_short = False

        # mevcut pozisyon
        pos = self.ex.get_position(sym)
        side = pos.get("side", "FLAT").upper()
        qty  = float(pos.get("qty", 0.0))

        # risk/sizing
        sl_pct = float(cfg["SL_PCT"])
        tp_pct = float(cfg["TP_PCT"])
        trail  = float(cfg["TRAIL_PCT"])
        last   = float(c1[-1])
        min_notional = float(cfg["MIN_NOTIONAL_USDT"])
        leverage = int(cfg["BINANCE_LEVERAGE"])
        cap_pct  = float(cfg["MAX_CAPITAL_PCT_PER_TRADE"])

        wallet = self.ex.get_wallet_usdt()
        notional_target = max(wallet * cap_pct * leverage, min_notional)
        raw_qty = notional_target / last
        tgt_qty = self.ex.normalize_qty(sym, raw_qty)

        working_type = str(cfg.get("WORKING_TYPE", "MARK_PRICE")).upper()

        # aksiyon yardÄ±mcÄ±larÄ±
        def open_long():
            self.log.info(f"[{sym}] OPEN LONG qty={tgt_qty:.6f} price~{last}  (SL {sl_pct*100:.2f}%, TP {tp_pct*100:.2f}%, trail {trail*100:.2f}%)")
            if bool(cfg["DRY_RUN"]):
                return
            self.ex.open_bracket_order(sym, "LONG", tgt_qty, None, sl_pct, tp_pct, trail, working_type)

        def open_short():
            self.log.info(f"[{sym}] OPEN SHORT qty={tgt_qty:.6f} price~{last} (SL {sl_pct*100:.2f}%, TP {tp_pct*100:.2f}%, trail {trail*100:.2f}%)")
            if bool(cfg["DRY_RUN"]):
                return
            self.ex.open_bracket_order(sym, "SHORT", tgt_qty, None, sl_pct, tp_pct, trail, working_type)

        def close_all():
            if qty <= 0:
                return
            self.log.info(f"[{sym}] CLOSE {side} qty={qty:.6f}")
            if bool(cfg["DRY_RUN"]):
                return
            self.ex.close_position(sym)

        # karar aÄŸacÄ±
        if side in ("FLAT", "") or qty <= 0:
            if want_long:
                open_long()
                if cd_bars > 0: self.cooldown[sym] = cd_bars
            elif want_short:
                open_short()
                if cd_bars > 0: self.cooldown[sym] = cd_bars
            else:
                self.log.debug(f"[{sym}] No signal (flat).")
            return

        if side == "LONG":
            if want_short:
                close_all()
                open_short()
                if cd_bars > 0: self.cooldown[sym] = cd_bars
            else:
                self.log.debug(f"[{sym}] Hold LONG (no opposite signal).")
            return

        if side == "SHORT":
            if want_long:
                close_all()
                open_long()
                if cd_bars > 0: self.cooldown[sym] = cd_bars
            else:
                self.log.debug(f"[{sym}] Hold SHORT (no opposite signal).")
            return


# ------------------------------------------------------------
#  MAIN
# ------------------------------------------------------------
def _bootstrap_exchange(cfg: Dict[str, Any], log: logging.Logger):
    """
    Senin pro_exchange.Exchange sÄ±nÄ±fÄ±nÄ± yaratmayÄ± dener.
    EÄŸer import baÅŸarÄ±sÄ±z olursa, net bir mesaj verir.
    """
    try:
        from pro_exchange import Exchange
    except Exception as e:
        log.error("pro_exchange.Exchange import edilemedi. LÃ¼tfen 'pro_exchange.py' iÃ§inde Exchange sÄ±nÄ±fÄ± olduÄŸundan emin ol.")
        raise
    return Exchange(cfg)

def main():
    cfg = load_config()
    log = _make_logger("live")
    log.info("LiveEngine baÅŸlÄ±yorâ€¦ (MTF: %s / %s / %s)",
             cfg["MTF"]["TRIGGER"], cfg["MTF"]["TREND"], cfg["MTF"]["DIR"])

    ex = _bootstrap_exchange(cfg, log)
    engine = LiveEngine(cfg, ex)

    # Basit tek seferlik Ã§alÄ±ÅŸtÄ±rma (cron ya da scheduler ile per-bar tetikleyebilirsin)
    engine.run_once_all()

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\pro_main.py
import logging
from pro_config import load_config
from pro_exchange import Ex
from pro_executor import run_once

def main():
    cfg = load_config()
    logging.basicConfig(level=getattr(logging, cfg["LOG_LEVEL"], logging.INFO),
                        format="%(asctime)s | %(levelname)s | %(message)s")

    ex = Ex(cfg)

    # Manuel evren varsa onu kullan, yoksa get_top_symbols iÃ§eriden Ã§aÄŸrÄ±lÄ±r
    universe = cfg["SYMBOLS"] if len(cfg["SYMBOLS"])>0 else None

    # Basit bir â€œtek turâ€ tarama/iÅŸlem (cron/loopâ€™a alabilirsin)
    run_once(cfg, ex, universe, pnl_today=0.0)

if __name__=="__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\pro_risk.py
import math

def clamp_qty_by_filters(qty, step, min_qty):
    q = math.floor(qty/step)*step
    return q if q>=min_qty else 0.0

def position_size(equity_usdt, risk_pct, atr, price, lev, min_notional):
    # ATR tabanlÄ±: stop mesafesini ~1*ATR varsay -> risk_usd/ (ATR) = kontrat * (ATR)
    risk_usd = max(equity_usdt*risk_pct, min_notional)
    if atr<=0: atr = price*0.005  # emniyet
    contracts = (risk_usd/atr)*lev / price
    notional  = contracts*price
    if notional < min_notional:
        contracts = min_notional/price
    return max(contracts, 0.0)

def daily_circuit_breaker(pnl_today, max_dd):
    return pnl_today<=-abs(max_dd)  # true -> sistem kilitle


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\quantum_predictor.py
class QuantumIntelligenceUnit:
    def __init__(self):
        self.timeline_data = []
        self.emotion_index = {}
    
    def absorb_telemetry(self, market_signal, sentiment_level):
        self.timeline_data.append(market_signal)
        self.emotion_index[market_signal] = sentiment_level
    
    def predict_surge(self):
        strong_signals = [sig for sig, emo in self.emotion_index.items() if emo > 7]
        if len(strong_signals) >= 2:
            return f"ðŸš€ Tahmin: YakÄ±nda ani yÃ¼kseliÅŸ olabilir. Sinyaller: {', '.join(strong_signals)}"
        return "ðŸ”Ž Durum kararlÄ±. Dalga Ã¶ncesi sessizlik gÃ¶zlemleniyor."



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\rearrange_v2.py
from __future__ import annotations

import argparse
import csv
import re
import shutil
from pathlib import Path
from typing import Iterable, List, Tuple

EXCLUDE_DIRS = {
    ".git", ".hg", ".svn",
    ".venv", "venv", "venv311", "env",
    "__pycache__", "build", "dist",
}

# ---------- YardÄ±mcÄ±lar ----------

def read_move_map(csv_path: Path) -> List[Tuple[str, str]]:
    """
    move_map.csv'den (old_path,new_path) Ã§iftlerini oku.
    Yollar ileri eÄŸik Ã§izgiye normalize edilir.
    """
    rows: List[Tuple[str, str]] = []
    with csv_path.open(newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        need = {"old_path", "new_path"}
        if not reader.fieldnames or not need.issubset(reader.fieldnames):
            raise AssertionError("CSV must have columns old_path,new_path")
        for r in reader:
            old = (r["old_path"] or "").strip().replace("\\", "/")
            new = (r["new_path"] or "").strip().replace("\\", "/")
            if old and new:
                rows.append((old, new))
    return rows


def is_excluded(p: Path) -> bool:
    return any(part in EXCLUDE_DIRS for part in p.parts)


def ensure_pkg_dirs(project_root: Path, dest_file: Path) -> None:
    """
    dest_file'nin parent zincirini proje kÃ¶kÃ¼ altÄ±nda oluÅŸtur.
    Her klasÃ¶re __init__.py ekle (yoksa). PROJE DIÅžINA ASLA yazmaz.
    """
    project_root = project_root.resolve()
    parent = dest_file.parent.resolve()
    try:
        rel = parent.relative_to(project_root)
    except Exception:
        raise RuntimeError(f"Refusing to touch outside project: {parent}")

    cur = project_root
    for part in rel.parts:
        cur = cur / part
        cur.mkdir(exist_ok=True)
        init = cur / "__init__.py"
        if not init.exists():
            init.write_text("# added by rearrange_v2.py\n", encoding="utf-8")


def file_to_module(package: str, rel_path: str) -> str:
    """
    'analytics/analysis_graphs.py' -> 'kiripto_nova.analytics.analysis_graphs'
    """
    mod = Path(rel_path).with_suffix("").as_posix().replace("/", ".")
    return f"{package}.{mod}"


def iter_py_files(root: Path) -> Iterable[Path]:
    for p in root.rglob("*.py"):
        if not is_excluded(p):
            yield p


# ---------- Import gÃ¼ncelleme ----------

def patch_imports_in_text(text: str, old_mod: str, new_mod: str) -> str:
    """
    Basit ama iÅŸe yarar bir yaklaÅŸÄ±m:
      - 'import old_mod'  -> 'import new_mod as old_mod'
      - 'from old_mod import X' -> 'from new_mod import X'
    Kenar durumlarÄ± Ã§ok kompleks ise elle gÃ¶zden geÃ§irmek gerekebilir.
    """
    # import old_mod [as alias] | , | EOL
    pat_import = re.compile(
        rf"(^|\n)([ \t]*)import[ \t]+{re.escape(old_mod)}([ \t]+as[ \t]+\w+|[ \t]*[,\n])",
        re.MULTILINE,
    )

    def _repl_import(m: re.Match) -> str:
        prefix = m.group(1) + (m.group(2) or "")
        tail = m.group(3)
        # alias varsa koru; yoksa 'as old_mod' ekle
        if " as " in tail:
            return f"{prefix}import {new_mod}{tail}"
        # virgÃ¼l veya satÄ±rsonu durumu
        if tail.strip() == ",":
            return f"{prefix}import {new_mod} as {old_mod},"
        return f"{prefix}import {new_mod} as {old_mod}{tail}"

    text = pat_import.sub(_repl_import, text)

    # from old_mod import ...
    pat_from = re.compile(
        rf"(^|\n)([ \t]*)from[ \t]+{re.escape(old_mod)}([ \t]+import[ \t]+)",
        re.MULTILINE,
    )
    text = pat_from.sub(rf"\1\2from {new_mod}\3", text)

    return text


def update_imports(project_root: Path, mappings: List[Tuple[str, str, str, str]], dry: bool) -> None:
    """
    mappings: (old_rel, new_rel, old_mod, new_mod)
    """
    for py in iter_py_files(project_root):
        try:
            txt = py.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            continue

        new_txt = txt
        for _old_rel, _new_rel, old_mod, new_mod in mappings:
            new_txt = patch_imports_in_text(new_txt, old_mod, new_mod)

        if new_txt != txt:
            if dry:
                print(f"[DRY] Update imports in {py}")
            else:
                py.write_text(new_txt, encoding="utf-8")
                print(f"[OK]  Update imports in {py}")


# ---------- Ana akÄ±ÅŸ ----------

def main() -> None:
    ap = argparse.ArgumentParser(
        description="Proje dosyalarÄ±nÄ± move_map.csv'ye gÃ¶re src/<paket> altÄ±na taÅŸÄ±r ve importlarÄ± gÃ¼nceller."
    )
    ap.add_argument("project_root", help="Proje kÃ¶kÃ¼ (Ã¶rn: .)")
    ap.add_argument("src_dir", help="Kaynak kÃ¶k klasÃ¶r adÄ± (Ã¶rn: src)")
    ap.add_argument("mapping_csv", help="CSV: old_path,new_path")
    ap.add_argument("package", help="Ãœst paket adÄ± (Ã¶rn: kiripto_nova)")
    ap.add_argument("--dry", action="store_true", help="Sadece prova (dosya yazmaz)")
    args = ap.parse_args()

    PROJECT_ROOT = Path(args.project_root).resolve()
    SRC_ROOT = (PROJECT_ROOT / args.src_dir).resolve()
    PKG_ROOT = SRC_ROOT / args.package

    if not SRC_ROOT.exists():
        SRC_ROOT.mkdir(parents=True, exist_ok=True)
    PKG_ROOT.mkdir(parents=True, exist_ok=True)
    init = PKG_ROOT / "__init__.py"
    if not init.exists():
        init.write_text("# package root\n", encoding="utf-8")

    rows = read_move_map(Path(args.mapping_csv))

    # (old_rel, new_rel, old_mod, new_mod)
    mappings: List[Tuple[str, str, str, str]] = []
    for old_rel, new_rel in rows:
        old_mod = Path(old_rel).with_suffix("").as_posix().replace("/", ".")
        new_mod = file_to_module(args.package, new_rel)
        mappings.append((old_rel, new_rel, old_mod, new_mod))

    # 1) TaÅŸÄ±ma (veya prova)
    for old_rel, new_rel, _, _ in mappings:
        src_abs = (PROJECT_ROOT / old_rel).resolve()
        dst_abs = (SRC_ROOT / args.package / new_rel).resolve()

        # GÃ¼venlik: yalnÄ±zca proje kÃ¶kÃ¼ iÃ§inde iÅŸlem
        try:
            src_abs.relative_to(PROJECT_ROOT)
            dst_abs.relative_to(PROJECT_ROOT)
        except Exception:
            raise RuntimeError("Refusing to operate outside project root.")

        if not src_abs.exists():
            # Eski dosya yoksa sessizce geÃ§
            continue

        if args.dry:
            print(f"[DRY] Move {src_abs} -> {dst_abs}")
        else:
            ensure_pkg_dirs(PROJECT_ROOT, dst_abs)
            if dst_abs.exists():
                # Ã‡akÄ±ÅŸma: Ã¼stÃ¼ne yazmaktan kaÃ§Ä±n
                print(f"[SKIP] Dest already exists: {dst_abs}")
            else:
                shutil.move(str(src_abs), str(dst_abs))
                print(f"[OK]  Moved: {src_abs} -> {dst_abs}")

    # 2) Import gÃ¼ncelle
    update_imports(PROJECT_ROOT, mappings, args.dry)

    print("Done. Review changes with git diff.")


if __name__ == "__main__":
    main()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\risk.py
# risk.py (ekler)
def atr_levels(df, entry, direction, k=1.5, r=2.5):
    atr = df["close"].rolling(14).apply(lambda s: (s.max()-s.min()), raw=False).iloc[-1]
    atr = max(atr, 1)  # gÃ¼venlik
    if direction=="LONG":
        sl = entry - k*atr
        tp = entry + r*atr
    else:
        sl = entry + k*atr
        tp = entry - r*atr
    return sl, tp


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\run_gate.py
# run_gate.py
# Binance Futures "avcÄ±" - anlÄ±k tarama, uygun sinyalde otomatik giriÅŸ/Ã§Ä±kÄ±ÅŸ
# Gerekenler: python-binance, pandas, numpy, python-dotenv

import os, time, math, json, argparse, logging
from datetime import datetime, timezone
from typing import Dict, Tuple, Optional, List

import numpy as np
import pandas as pd
from dotenv import load_dotenv
from binance.client import Client
from binance.enums import *

# ------------- YardÄ±mcÄ±: log -------------
def setup_logger(level="INFO"):
    lvl = getattr(logging, level.upper(), logging.INFO)
    logging.basicConfig(
        level=lvl,
        format="%(asctime)s | %(levelname)s | %(message)s",
        datefmt="%H:%M:%S"
    )
    return logging.getLogger("hunter")

log = setup_logger()

# ------------- Ortam -------------
def env_bool(name: str, default: bool) -> bool:
    v = os.getenv(name, str(default)).strip().lower()
    return v in ("1","true","yes","y","on")

def load_env() -> Dict:
    load_dotenv()
    cfg = {}
    # Binance
    cfg["KEY"] = os.getenv("BINANCE_API_KEY", "")
    cfg["SEC"] = os.getenv("BINANCE_API_SECRET", "")
    cfg["USE_TESTNET"] = env_bool("BINANCE_USE_TESTNET", False)
    cfg["FUT_URL"] = os.getenv("BINANCE_FUTURES_URL", "").strip()
    cfg["HEDGE_MODE"] = env_bool("BINANCE_HEDGE_MODE", True)
    cfg["MARGIN_TYPE"] = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED").upper()
    cfg["LEVERAGE"] = int(os.getenv("BINANCE_LEVERAGE", "5"))

    # Bot genel
    cfg["SYMBOLS"] = [s.strip().upper() for s in os.getenv("SYMBOLS", "BTCUSDT,ETHUSDT").split(",") if s.strip()]
    cfg["TIMEFRAME"] = os.getenv("TIMEFRAME", "1m")
    cfg["MAX_DD"] = float(os.getenv("MAX_DAILY_DRAWDOWN", "0.03"))
    cfg["RISK_PER_TRADE"] = float(os.getenv("MAX_CAPITAL_PCT_PER_TRADE", "0.02"))   # bakiyenin yÃ¼zdesi
    cfg["MAX_SYM_EXPOSURE"] = float(os.getenv("MAX_SYMBOL_EXPOSURE_PCT", "0.25"))   # sembol baÅŸÄ±na maruziyet sÄ±nÄ±rÄ±
    cfg["MAX_OPEN_POS"] = int(os.getenv("MAX_OPEN_POSITIONS", "5"))
    cfg["MIN_NOTIONAL"] = float(os.getenv("MIN_NOTIONAL_USDT", "10"))

    # Teknik
    cfg["LOG_LEVEL"] = os.getenv("LOG_LEVEL", "INFO")

    # GÃ¼venli Ã§alÄ±ÅŸma
    cfg["DRY_RUN"] = env_bool("DRY_RUN", True)

    return cfg

# ------------- Binance istemcisi ve pazar filtreleri -------------
def make_client(cfg: Dict) -> Client:
    if not cfg["KEY"] or not cfg["SEC"]:
        raise SystemExit("âŒ API anahtarlarÄ± yok! .env iÃ§indeki BINANCE_API_KEY / BINANCE_API_SECRET girilmeli.")
    c = Client(api_key=cfg["KEY"], api_secret=cfg["SEC"], testnet=cfg["USE_TESTNET"])
    # python-binance 1.0.29'da FUTURES_URL Ã¶zelleÅŸtirme
    if cfg["FUT_URL"]:
        try:
            c.FUTURES_URL = cfg["FUT_URL"]
        except Exception:
            pass
    # BaÄŸlantÄ± testi
    t = c.futures_time()
    log.info(f"BaÄŸlantÄ± OK (serverTime={t.get('serverTime')}) | {'TESTNET' if cfg['USE_TESTNET'] else 'MAINNET'}")
    return c

def get_symbol_filters(client: Client, symbol: str) -> Tuple[float, float, float]:
    """
    DÃ¶nÃ¼ÅŸ: (price_tick, lot_step, min_notional)
    """
    info = client.futures_exchange_info()
    md = next((s for s in info["symbols"] if s["symbol"] == symbol), None)
    if not md:
        raise ValueError(f"{symbol} exchangeInfo bulunamadÄ±.")
    tick = float(next(f["tickSize"] for f in md["filters"] if f["filterType"] == "PRICE_FILTER"))
    step = float(next(f["stepSize"] for f in md["filters"] if f["filterType"] == "LOT_SIZE"))
    min_notional = float(next(f["notional"] for f in md["filters"] if f["filterType"] == "MIN_NOTIONAL"))
    return tick, step, min_notional

def round_to_step(v: float, step: float) -> float:
    return math.floor(v / step) * step

def round_to_tick(v: float, tick: float) -> float:
    # tick hassasiyeti
    return round(math.floor(v / tick) * tick, int(max(0, -math.log10(tick))) if tick < 1 else 0)

# ------------- Hesap ayarlarÄ± -------------
def ensure_account_settings(client: Client, cfg: Dict, symbols: List[str]):
    # Hedge modu
    try:
        client.futures_change_position_mode(dualSidePosition="true" if cfg["HEDGE_MODE"] else "false")
        log.info(f"Hedge modu => {'DUAL (hedge) ON' if cfg['HEDGE_MODE'] else 'ONE-WAY OFF'}")
    except Exception as e:
        log.warning(f"Hedge modu deÄŸiÅŸtirilemedi: {e}")

    for sym in symbols:
        # Margin tipi
        try:
            client.futures_change_margin_type(symbol=sym, marginType=cfg["MARGIN_TYPE"])
        except Exception:
            pass  # zaten o tipte olabilir
        # KaldÄ±raÃ§
        try:
            client.futures_change_leverage(symbol=sym, leverage=cfg["LEVERAGE"])
        except Exception as e:
            log.warning(f"{sym} kaldÄ±raÃ§ ayarlanamadÄ±: {e}")

# ------------- Veri/indikatÃ¶r -------------
def fetch_klines(client: Client, symbol: str, interval: str, limit: int=300) -> pd.DataFrame:
    k = client.futures_klines(symbol=symbol, interval=interval, limit=limit)
    cols = ["open_time","open","high","low","close","volume","close_time","qav","trades","tbbav","tbqav","ignore"]
    df = pd.DataFrame(k, columns=cols)
    df["open_time"] = pd.to_datetime(df["open_time"], unit="ms", utc=True)
    for col in ["open","high","low","close","volume"]:
        df[col] = df[col].astype(float)
    return df

def indicators(df: pd.DataFrame) -> pd.DataFrame:
    # EMA, RSI, ATR
    df = df.copy()
    df["ema50"] = df["close"].ewm(span=50, adjust=False).mean()
    df["ema200"] = df["close"].ewm(span=200, adjust=False).mean()
    # RSI(14)
    delta = df["close"].diff()
    gain = np.where(delta>0, delta, 0.0)
    loss = np.where(delta<0, -delta, 0.0)
    roll_up = pd.Series(gain).rolling(14).mean()
    roll_down = pd.Series(loss).rolling(14).mean()
    rs = roll_up / (roll_down + 1e-12)
    df["rsi"] = 100 - (100 / (1 + rs))
    # ATR(14)
    high_low = df["high"] - df["low"]
    high_close = (df["high"] - df["close"].shift()).abs()
    low_close  = (df["low"]  - df["close"].shift()).abs()
    tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    df["atr"] = tr.rolling(14).mean()
    return df

def score_row(row) -> float:
    # Basit skor: trend + momentum
    trend = 1 if row["ema50"] > row["ema200"] else -1
    rsi = row["rsi"]
    mom = (rsi - 50.0) / 25.0  # ~ -2..+2 arasÄ± normalize
    return trend + mom

# ------------- Risk ve pozisyon -------------
def account_usdt(client: Client) -> float:
    bal = client.futures_account_balance()
    usdt = next((float(b["balance"]) for b in bal if b["asset"]=="USDT"), 0.0)
    return usdt

def open_positions(client: Client, symbol: Optional[str]=None) -> List[Dict]:
    pos = client.futures_position_information(symbol=symbol) if symbol else client.futures_position_information()
    # miktarÄ± 0 olmayanlar
    return [p for p in pos if abs(float(p["positionAmt"])) > 0]

def side_and_posside(score: float) -> Tuple[str, str]:
    if score >= 0.6:
        return SIDE_BUY, "LONG"
    elif score <= -0.6:
        return SIDE_SELL, "SHORT"
    return "", ""

# ------------- Emir akÄ±ÅŸÄ± -------------
def place_bracket(client: Client,
                  symbol: str,
                  side: str,
                  posside: str,
                  qty: float,
                  entry_price: float,
                  stop_price: float,
                  tp_price: float,
                  hedge_mode: bool,
                  dry: bool):
    if dry:
        log.info(f"[DRY] {symbol} {posside} MARKET qty={qty} | SL={stop_price} TP={tp_price}")
        return

    # Piyasa giriÅŸ
    params = dict(symbol=symbol,
                  side=side,
                  type=FUTURE_ORDER_TYPE_MARKET,
                  quantity=qty)
    if hedge_mode:
        params["positionSide"] = posside
    o1 = client.futures_create_order(**params)

    # Kar/Zarar emirleri (reduceOnly/closePosition)
    opp_side = SIDE_SELL if side == SIDE_BUY else SIDE_BUY

    # STOP_MARKET
    sl_params = dict(symbol=symbol,
                     side=opp_side,
                     type=FUTURE_ORDER_TYPE_STOP_MARKET,
                     stopPrice=stop_price,
                     closePosition=True,
                     timeInForce=TIME_IN_FORCE_GTC)
    if hedge_mode:
        sl_params["positionSide"] = posside
        sl_params["closePosition"] = False
        sl_params["reduceOnly"] = True
    o2 = client.futures_create_order(**sl_params)

    # TAKE_PROFIT_MARKET
    tp_params = dict(symbol=symbol,
                     side=opp_side,
                     type=FUTURE_ORDER_TYPE_TAKE_PROFIT_MARKET,
                     stopPrice=tp_price,
                     timeInForce=TIME_IN_FORCE_GTC,
                     closePosition=True)
    if hedge_mode:
        tp_params["positionSide"] = posside
        tp_params["closePosition"] = False
        tp_params["reduceOnly"] = True
    o3 = client.futures_create_order(**tp_params)

    log.info(f"Emirler gÃ¶nderildi: entry={o1.get('orderId')} sl={o2.get('orderId')} tp={o3.get('orderId')}")

# ------------- Ana tarama dÃ¶ngÃ¼sÃ¼ -------------
def run(cfg: Dict, args):
    # Log seviyesi
    global log
    log = setup_logger(cfg["LOG_LEVEL"])

    client = make_client(cfg)
    ensure_account_settings(client, cfg, args.symbols)

    # Durum dosyasÄ± (aynÄ± sembolÃ¼ Ã§ok sÄ±k yeniden giriÅŸten koru)
    state_file = "state.json"
    try:
        with open(state_file, "r", encoding="utf-8") as f:
            state = json.load(f)
    except Exception:
        state = {}
    def update_state(sym, ts):
        state[sym] = {"last_entry_ts": ts}
        with open(state_file, "w", encoding="utf-8") as f:
            json.dump(state, f, ensure_ascii=False, indent=2)

    # Filtreler
    filt: Dict[str, Tuple[float,float,float]] = {}
    for s in args.symbols:
        tick, step, min_notional = get_symbol_filters(client, s)
        # .env MIN_NOTIONAL ile borsanÄ±n min notional'Ä±nÄ±n maksimumunu alalÄ±m
        min_notional = max(min_notional, cfg["MIN_NOTIONAL"])
        filt[s] = (tick, step, min_notional)
        log.info(f"{s} filters: tick={tick} step={step} minNotional={min_notional}")

    eval_sec = args.eval
    atr_mult_sl = args.atr_sl
    rr = args.rr

    while True:
        try:
            # aÃ§Ä±k pozisyon sayÄ±sÄ±
            open_pos = open_positions(client)
            if len(open_pos) >= cfg["MAX_OPEN_POS"]:
                log.info(f"Maks aÃ§Ä±k pozisyon sayÄ±sÄ±na ulaÅŸÄ±ldÄ± ({len(open_pos)}/{cfg['MAX_OPEN_POS']}). Bekleniyor...")
                time.sleep(eval_sec)
                continue

            # bakiye
            usdt = account_usdt(client)
            risk_usdt = max(5.0, usdt * cfg["RISK_PER_TRADE"])  # minimum 5 USDT riske et
            log.debug(f"Bakiye={usdt:.2f}USDT | risk/trade={risk_usdt:.2f}USDT")

            best = None  # (sym, score, df)

            for sym in args.symbols:
                df = indicators(fetch_klines(client, sym, args.interval, limit=300))
                last = df.iloc[-1]

                sc = score_row(last)
                log.info(f"{sym} score={sc:.2f} | price={last['close']:.2f} | rsi={last['rsi']:.1f} | ema50-200={(last['ema50']-last['ema200']):.2f}")

                if best is None or abs(sc) > abs(best[1]):
                    best = (sym, sc, df)

            sym, sc, df = best
            side, posside = side_and_posside(sc)

            if not side:
                log.info(f"Uygun sinyal yok. ({args.symbols})")
                time.sleep(eval_sec)
                continue

            # Sembol baÅŸÄ±na maruziyet kontrolÃ¼
            open_pos_sym = [p for p in open_pos if p["symbol"] == sym]
            if open_pos_sym:
                log.info(f"{sym} iÃ§in zaten aÃ§Ä±k pozisyon var. AtlanÄ±yor.")
                time.sleep(eval_sec)
                continue

            # SÄ±k yeniden giriÅŸten kaÃ§Ä±n
            now_ts = int(time.time())
            if sym in state and now_ts - state[sym].get("last_entry_ts", 0) < 60:
                log.info(f"{sym} iÃ§in son 60sn iÃ§inde giriÅŸ yapÄ±lmÄ±ÅŸ. Bekleniyor.")
                time.sleep(eval_sec)
                continue

            # Fiyat/ATR ve hedefler
            last = df.iloc[-1]
            price = float(last["close"])
            atr = float(last["atr"])
            if np.isnan(atr) or atr == 0.0:
                log.info(f"{sym} ATR hazÄ±r deÄŸil.")
                time.sleep(eval_sec)
                continue

            stop_dist = atr * atr_mult_sl
            if side == SIDE_BUY:
                stop_price = price - stop_dist
                tp_price = price + (stop_dist * rr)
            else:
                stop_price = price + stop_dist
                tp_price = price - (stop_dist * rr)

            tick, step, min_notional = filt[sym]
            stop_price = round_to_tick(stop_price, tick)
            tp_price   = round_to_tick(tp_price, tick)

            # Miktar: risk_usdt = qty * stop_dist  => qty = risk_usdt / stop_dist
            qty = risk_usdt / stop_dist
            qty = round_to_step(qty, step)

            if qty <= 0:
                log.info(f"{sym} miktar 0 oldu. (risk Ã§ok dÃ¼ÅŸÃ¼k olabilir)")
                time.sleep(eval_sec)
                continue

            # min notional
            if qty * price < min_notional:
                # min notional'a yuvarla
                qty = round_to_step(min_notional / price, step)

            if qty * price < min_notional:
                log.info(f"{sym} iÃ§in min notional saÄŸlanamadÄ± (qty={qty}, notional={qty*price:.2f}<{min_notional}).")
                time.sleep(eval_sec)
                continue

            log.warning(f"==> {sym} iÃ§in GÄ°RÄ°Åž SÄ°NYALÄ°: side={side}/{posside} price={price:.2f} qty={qty} SL={stop_price} TP={tp_price}")

            place_bracket(client, sym, side, posside, qty, price, stop_price, tp_price, cfg["HEDGE_MODE"], cfg["DRY_RUN"] or args.dry_run)

            update_state(sym, now_ts)

            time.sleep(eval_sec)

        except KeyboardInterrupt:
            log.warning("KapatÄ±lÄ±yor...")
            break
        except Exception as e:
            log.error(f"Hata: {e}", exc_info=False)
            time.sleep(max(3, eval_sec))

# ------------- CLI -------------
def parse_args():
    ap = argparse.ArgumentParser(description="Binance Futures AvcÄ± (anlÄ±k tarama + otomatik emir)")
    ap.add_argument("--symbols", nargs="+", default=[], help="Tarancak semboller (Ã¶rn: BTCUSDT ETHUSDT)")
    ap.add_argument("--interval", default=None, help="Kline periyodu (Ã¶rn: 1m, 5m, 15m)")
    ap.add_argument("--eval", type=int, default=5, help="DeÄŸerlendirme aralÄ±ÄŸÄ± (saniye)")
    ap.add_argument("--atr-sl", type=float, default=1.5, help="SL mesafesi iÃ§in ATR Ã§arpanÄ± (vars: 1.5)")
    ap.add_argument("--rr", type=float, default=2.0, help="Kar/Zarar oranÄ± (take-profit = rr * stop-distance)")
    ap.add_argument("--dry-run", action="store_true", help="Komut satÄ±rÄ±ndan gÃ¼venli mod (emir gÃ¶nderme)")
    return ap.parse_args()

if __name__ == "__main__":
    cfg = load_env()
    args = parse_args()
    # .env varsayÄ±lanlarÄ±nÄ± CLI ile override et
    if not args.symbols:
        args.symbols = cfg["SYMBOLS"]
    if not args.interval:
        args.interval = cfg["TIMEFRAME"]
    # LOG seviyesini yeniden kur
    log = setup_logger(cfg["LOG_LEVEL"])
    log.info(f"BaÅŸlÄ±yor | DRY_RUN={cfg['DRY_RUN'] or args.dry_run} | symbols={args.symbols} | tf={args.interval}")
    run(cfg, args)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\run_guard.py
# run_guard.py  (Windows)
import os, sys, subprocess
from pathlib import Path

def main():
    root = Path(__file__).resolve().parent
    py = root / ".venv" / "Scripts" / "python.exe"
    target = root / "risk_guard.py"
    logs = root / "logs"
    logs.mkdir(exist_ok=True)

    # Konsol/log TÃ¼rkÃ§e/emoji iÃ§in UTF-8
    env = os.environ.copy()
    env["PYTHONUTF8"] = "1"
    env["PYTHONIOENCODING"] = "utf-8"

    # VarsayÄ±lan: enforce. Ä°stersen --unlock ver.
    action = "--enforce"
    if len(sys.argv) > 1 and sys.argv[1] in ("--enforce", "--unlock"):
        action = sys.argv[1]

    # risk_guard Ã§Ä±ktÄ±sÄ±nÄ± log dosyasÄ±na ekle
    log_file = logs / "risk_guard.log"
    with open(log_file, "a", encoding="utf-8") as f:
        subprocess.run([str(py), str(target), action],
                       check=True, env=env,
                       stdout=f, stderr=subprocess.STDOUT)

if __name__ == "__main__":
    main()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\safe_live_paper_trader.py
# safe_live_paper_trader.py
import asyncio, time, logging, math
from dataclasses import dataclass
from typing import List, Optional
import ccxt
import numpy as np
import pandas as pd
import pandas_ta as ta

@dataclass
class Config:
    exchange_id: str = "binanceusdm"   # USDT-M Futures (canlÄ±)
    quote: str = "USDT"
    timeframe: str = "1m"
    lookback_bars: int = 900
    max_symbols: int = 120
    cycle_seconds: int = 60
    rate_sleep: float = 0.2
    use_testnet: bool = False          # testnet YOK
    dry_run: bool = True               # canlÄ± emir YOK
    equity_usd: float = 10000
    max_daily_dd: float = 0.03         # gÃ¼nlÃ¼k %3 kayÄ±pta kill-switch
    max_pos_weight: float = 0.2        # tek sembole max %20

class DataClient:
    def __init__(self, cfg: Config):
        ex_class = getattr(ccxt, cfg.exchange_id)
        self.ex = ex_class({"enableRateLimit": True})
        if hasattr(self.ex, "set_sandbox_mode"):
            self.ex.set_sandbox_mode(cfg.use_testnet)
        self.cfg = cfg
        self._markets_loaded = False

    async def load_markets(self):
        await asyncio.to_thread(self.ex.load_markets)
        self._markets_loaded = True

    def symbols(self) -> List[str]:
        assert self._markets_loaded
        syms = []
        for s, m in self.ex.markets.items():
            if m.get("quote") == self.cfg.quote and m.get("type") in ("swap",) and m.get("active", True):
                syms.append(s)
        # Likidite iÃ§in basit filtre: USDT-M ve makul tickSize
        syms = [s for s in syms if "USDT" in s]
        return syms[: self.cfg.max_symbols]

    async def fetch_ohlcv(self, symbol: str, limit: int) -> pd.DataFrame:
        raw = await asyncio.to_thread(self.ex.fetch_ohlcv, symbol, timeframe=self.cfg.timeframe, limit=limit)
        if not raw:
            return pd.DataFrame()
        df = pd.DataFrame(raw, columns=["ts","open","high","low","close","volume"])
        df["ts"] = pd.to_datetime(df["ts"], unit="ms", utc=True)
        return df

class FeatureEngine:
    def enrich(self, df: pd.DataFrame) -> pd.DataFrame:
        df = df.copy()
        df["ret"] = np.log(df["close"]).diff()
        df["vol"] = df["ret"].rolling(60).std().clip(1e-9)
        df["rsi"] = ta.rsi(df["close"], length=14)
        macd = ta.macd(df["close"], fast=12, slow=26, signal=9)
        if macd is not None:
            df["macd"] = macd["MACD_12_26_9"]
            df["macd_sig"] = macd["MACDs_12_26_9"]
        df["ma_fast"] = df["close"].rolling(50).mean()
        df["ma_slow"] = df["close"].rolling(200).mean()
        # Rejim: trend mi yatay mÄ±?
        df["trend_strength"] = (df["ma_fast"] - df["ma_slow"]) / (df["ma_slow"].abs() + 1e-9)
        df.dropna(inplace=True)
        return df

class SignalEngine:
    def score(self, df: pd.DataFrame) -> float:
        trend = np.tanh(8.0 * df["trend_strength"].iloc[-1])
        macd_spread = (df["macd"].iloc[-1] - df["macd_sig"].iloc[-1]) if "macd" in df else 0.0
        mom = np.tanh(2.0 * macd_spread / (df["vol"].iloc[-1] + 1e-9))
        rsi = df["rsi"].iloc[-1]
        rsi_sig = 1.0 if rsi > 55 else (-1.0 if rsi < 45 else 0.0)
        s = 0.45*trend + 0.35*mom + 0.20*rsi_sig
        return float(np.clip(s, -1.0, 1.0))

@dataclass
class PositionPlan:
    side: str
    size_usd: float
    sl: Optional[float]
    tp: Optional[float]

class RiskManager:
    def __init__(self, cfg: Config):
        self.cfg = cfg
        self.day_start_equity = cfg.equity_usd
        self.paper_pnl = 0.0  # basit kaÄŸÄ±t PnL takibi

    def daily_guard(self) -> bool:
        dd = max(0.0, -self.paper_pnl) / self.cfg.equity_usd
        return dd < self.cfg.max_daily_dd

    def plan(self, df: pd.DataFrame, score: float) -> Optional[PositionPlan]:
        if not self.daily_guard():
            return None
        if abs(score) < 0.34:
            return None
        atr = (df["high"] - df["low"]).rolling(14).mean().iloc[-1]
        px = df["close"].iloc[-1]
        risk_per_trade = 0.005 * self.cfg.equity_usd  # %0.5
        sl_dist = max(atr * 2.5, px * 0.002)
        size = risk_per_trade / max(sl_dist, 1e-9)
        size_usd = float(np.clip(size * px, 0, self.cfg.equity_usd * self.cfg.max_pos_weight))
        side = "long" if score > 0 else "short"
        sl = px - sl_dist if side == "long" else px + sl_dist
        tp = px + sl_dist * 4 if side == "long" else px - sl_dist * 4
        return PositionPlan(side=side, size_usd=size_usd, sl=sl, tp=tp)

class Notifier:
    def __init__(self):
        pass
    async def alert(self, symbol: str, plan: PositionPlan, score: float, px: float):
        logging.info(f"[ALERT] {symbol} | {plan.side.upper()} | score={score:.2f} | px={px:.4f} | "
                     f"size=${plan.size_usd:,.0f} | SL={plan.sl:.4f} | TP={plan.tp:.4f}")
        # Buraya Telegram/Slack webhook entegrasyonunu ekleyebilirsin.

class Trader:
    def __init__(self, cfg: Config):
        self.cfg = cfg
        self.data = DataClient(cfg)
        self.fe = FeatureEngine()
        self.se = SignalEngine()
        self.rm = RiskManager(cfg)
        self.notifier = Notifier()

    async def run_symbol(self, symbol: str):
        try:
            df = await self.data.fetch_ohlcv(symbol, self.cfg.lookback_bars)
            if df.empty:
                return
            df = self.fe.enrich(df)
            if df.empty:
                return
            score = self.se.score(df)
            plan = self.rm.plan(df, score)
            if plan:
                px = float(df["close"].iloc[-1])
                await self.notifier.alert(symbol, plan, score, px)
        except Exception as e:
            logging.exception(f"{symbol} hata: {e}")

    async def loop(self):
        await self.data.load_markets()
        syms = self.data.symbols()
        logging.info(f"{len(syms)} sembol izleniyor (canlÄ± veri, kaÄŸÄ±t iÅŸlem).")
        while True:
            t0 = time.time()
            tasks = [self.run_symbol(s) for s in syms]
            await asyncio.gather(*tasks)
            dt = time.time() - t0
            await asyncio.sleep(max(0.0, self.cfg.cycle_seconds - dt))

async def main():
    logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")
    cfg = Config()
    trader = Trader(cfg)
    await trader.loop()

if __name__ == "__main__":
    asyncio.run(main())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\scan_eval.py
# scan_eval.py
# KullanÄ±m Ã¶rneÄŸi:
#   python scan_eval.py --symbols BTCUSDT,ETHUSDT,SOLUSDT --tfs 5m,15m --limit 1500 --atr 1.5 --rr 2.0 --fee 0.0008 --slip 0.0002 --out scan.csv

import argparse, itertools
import pandas as pd
import numpy as np

# Mevcut dosyandan fonksiyonlarÄ± import et
from eval_error_rate import fetch_klines, backtest

def adjust_costs_R(td: pd.DataFrame, fee_pct: float=0.0008, slip_pct: float=0.0) -> pd.DataFrame:
    """
    Her trade iÃ§in R'Ä± Ã¼cret+kayma (round-trip) ile dÃ¼zeltir.
    cost_R = (fee_pct + slip_pct) * entry / risk, risk = |entry - sl|
    """
    td = td.copy()
    risk = (td["entry"] - td["sl"]).abs().replace(0, np.nan)
    cost_R = (fee_pct + slip_pct) * (td["entry"].abs()) / risk
    cost_R = cost_R.fillna(0.0).clip(lower=0.0, upper=5.0)  # gÃ¼venlik iÃ§in bir Ã¼st sÄ±nÄ±r
    td["R_net"] = td["R"] - cost_R
    td["equity_net"] = (1 + td["R_net"]).cumprod()
    return td

def summarize(td: pd.DataFrame):
    if td.empty:
        return {"trades": 0, "win_rate": np.nan, "expectancy_R": np.nan,
                "max_drawdown": np.nan, "final_equity": np.nan}
    eq = (1 + td["R"]).cumprod()
    roll_max = eq.cummax()
    mdd = (eq/roll_max - 1.0).min()
    return {
        "trades": len(td),
        "win_rate": (td["R"] > 0).mean(),
        "expectancy_R": td["R"].mean(),
        "max_drawdown": mdd,
        "final_equity": eq.iloc[-1],
    }

def summarize_net(td_net: pd.DataFrame):
    if td_net.empty:
        return {"win_rate_net": np.nan, "expectancy_R_net": np.nan,
                "max_drawdown_net": np.nan, "final_equity_net": np.nan}
    eq = td_net["equity_net"]
    roll_max = eq.cummax()
    mdd = (eq/roll_max - 1.0).min()
    return {
        "win_rate_net": (td_net["R_net"] > 0).mean(),
        "expectancy_R_net": td_net["R_net"].mean(),
        "max_drawdown_net": mdd,
        "final_equity_net": eq.iloc[-1],
    }

def scan(symbols, tfs, limit, atr_mult, rr, fee, slip):
    rows = []
    for sym, tf in itertools.product(symbols, tfs):
        try:
            df = fetch_klines(sym, tf, limit)
            td, st = backtest(df, atr_mult=atr_mult, rr=rr)
            if td.empty:
                rows.append({
                    "symbol": sym, "tf": tf, "trades": 0,
                    "win_rate": np.nan, "expectancy_R": np.nan,
                    "max_drawdown": np.nan, "final_equity": np.nan,
                    "win_rate_net": np.nan, "expectancy_R_net": np.nan,
                    "max_drawdown_net": np.nan, "final_equity_net": np.nan
                })
                continue

            # BrÃ¼t Ã¶zet
            gross = summarize(td)

            # Ãœcret/kayma sonrasÄ±
            td_net = adjust_costs_R(td, fee_pct=fee, slip_pct=slip)
            net = summarize_net(td_net)

            row = {
                "symbol": sym,
                "tf": tf,
                "trades": gross["trades"],
                "win_rate": round(gross["win_rate"]*100, 2),
                "expectancy_R": round(gross["expectancy_R"], 3),
                "max_drawdown": round(gross["max_drawdown"]*100, 2),
                "final_equity": round(gross["final_equity"], 3),
                "win_rate_net": round(net["win_rate_net"]*100, 2),
                "expectancy_R_net": round(net["expectancy_R_net"], 3),
                "max_drawdown_net": round(net["max_drawdown_net"]*100, 2),
                "final_equity_net": round(net["final_equity_net"], 3),
            }
            rows.append(row)
        except Exception as e:
            rows.append({
                "symbol": sym, "tf": tf, "trades": 0,
                "win_rate": np.nan, "expectancy_R": np.nan,
                "max_drawdown": np.nan, "final_equity": np.nan,
                "win_rate_net": np.nan, "expectancy_R_net": np.nan,
                "max_drawdown_net": np.nan, "final_equity_net": np.nan
            })

    cols_order = [
        "symbol","tf","trades",
        "win_rate","expectancy_R","max_drawdown","final_equity",
        "win_rate_net","expectancy_R_net","max_drawdown_net","final_equity_net"
    ]
    return pd.DataFrame(rows)[cols_order]

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--symbols", required=True, help="VirgÃ¼lle: BTCUSDT,ETHUSDT,SOLUSDT")
    ap.add_argument("--tfs", required=True, help="VirgÃ¼lle: 5m,15m,1h")
    ap.add_argument("--limit", type=int, default=1500)
    ap.add_argument("--atr", type=float, default=1.5)
    ap.add_argument("--rr", type=float, default=2.0)
    ap.add_argument("--fee", type=float, default=0.0008, help="Round-trip Ã¼cret (Ã¶rn 0.0008 = %0.08)")
    ap.add_argument("--slip", type=float, default=0.0000, help="Round-trip kayma (yÃ¼zde)")
    ap.add_argument("--out", default="", help="CSV dosya adÄ± (opsiyonel)")
    args = ap.parse_args()

    symbols = [s.strip() for s in args.symbols.split(",") if s.strip()]
    tfs = [t.strip() for t in args.tfs.split(",") if t.strip()]

    df = scan(symbols, tfs, args.limit, args.atr, args.rr, args.fee, args.slip)

    # Konsol tablosu (Ã¶zet)
    print("\n=== TARAMA Ã–ZETÄ° ===")
    print(f"Semboller: {', '.join(symbols)} | TF: {', '.join(tfs)} | limit: {args.limit} | ATRx: {args.atr} | RR: {args.rr}")
    print(f"Ãœcret (round-trip): {args.fee:.4%}  |  Kayma (round-trip): {args.slip:.4%}\n")
    # Pandas pretty print
    with pd.option_context('display.max_rows', None, 'display.max_columns', None, 'display.width', 120):
        print(df.to_string(index=False))

    if args.out:
        df.to_csv(args.out, index=False)
        print(f"\nTablo kaydedildi: {args.out}")

if __name__ == "__main__":
    main()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\scheduler.py
import schedule
import time
from main import run_analysis  # main.pyâ€™de fonksiyon haline getirilmiÅŸ olmalÄ±

def job():
    print("ðŸš€ Veri analizi baÅŸladÄ±...")
    run_analysis()

# ðŸ“† Saat baÅŸÄ± Ã§alÄ±ÅŸtÄ±r
schedule.every().day.at("08:00").do(job)
schedule.every().day.at("10:00").do(job)
schedule.every().day.at("12:00").do(job)
schedule.every().day.at("14:00").do(job)
schedule.every().day.at("16:00").do(job)
schedule.every().day.at("18:00").do(job)
schedule.every().day.at("20:00").do(job)
schedule.every().day.at("22:00").do(job)
schedule.every().day.at("00:00").do(job)
schedule.every().day.at("02:00").do(job)
schedule.every().day.at("04:00").do(job)
schedule.every().day.at("06:00").do(job)

while True:
    schedule.run_pending()
    time.sleep(30)
# scheduler.py
import time
from datetime import datetime
from kiripto_nova.data.pipelines.data_loader import load_binance_data
from multi_strategy import MultiStrategyEngine
from trade_executor import execute_trade
from kiripto_nova.risk.risk_manager import calculate_position_size, calculate_stop_loss, calculate_take_profit
from kiripto_nova.apps.telegram_alert import notify_signal, notify_trade
from logger import log_trade, log_error

# KullanÄ±cÄ± ayarlarÄ±
SYMBOL = "DOGE/USDT"
TIMEFRAME = "15m"
BALANCE = 1000  # USDT cinsinden sermaye
RISK = 0.01     # Ä°ÅŸlem baÅŸÄ±na %1 risk
STOP_LOSS_PCT = 0.03
REWARD_RATIO = 2
AMOUNT = 100    # Alternatif: dinamik pozisyon boyutlandÄ±rma


def run_cycle():
    try:
        print(f"â° Tarama baÅŸladÄ±: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        df = load_binance_data(SYMBOL, TIMEFRAME)
        engine = MultiStrategyEngine(df)
        signal = engine.evaluate()

        notify_signal(signal, SYMBOL)

        if signal == "BUY" or signal == "SELL":
            direction = "long" if signal == "BUY" else "short"
            entry = df['close'].iloc[-1]
            qty = calculate_position_size(BALANCE, RISK, STOP_LOSS_PCT)
            sl = calculate_stop_loss(entry, STOP_LOSS_PCT, direction)
            tp = calculate_take_profit(entry, REWARD_RATIO, STOP_LOSS_PCT, direction)

            result = execute_trade(SYMBOL, side="buy" if direction == "long" else "sell", amount=qty)
            log_trade(signal, SYMBOL, qty, entry, sl, tp)
            notify_trade(signal, SYMBOL, qty, entry, sl, tp)

        else:
            print("ðŸ” Sinyal uygun deÄŸil, iÅŸlem yapÄ±lmadÄ±.")

    except Exception as e:
        log_error(e)


if __name__ == "__main__":
    while True:
        run_cycle()
        time.sleep(60 * 15)  # 15 dakikada bir Ã§alÄ±ÅŸtÄ±r


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\scoring.py
def generate_signal(score):
    if score >= 0.7:
        return "AL"
    elif score <= -0.7:
        return "SAT"
    else:
        return "BEKLE"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\sentiment.py
def advanced_signal_score(sentiment, is_recent, source, title):
    score = 0
    if sentiment == "positive":
        score += 2
    elif sentiment == "negative":
        score -= 2
    if is_recent:
        score += 1
    # ðŸ” Kaynak gÃ¼venilirliÄŸi (Ã¶rnek)
    trusted_sources = ["Bloomberg", "Reuters", "CNBC"]
    if source in trusted_sources:
        score += 1
    # ðŸ§  BaÅŸlÄ±ktaki anahtar kelimeler
    keywords = ["bullish", "rally", "crash", "plunge"]
    if any(kw in title.lower() for kw in keywords):
        score += 1
    return score



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\short_sinyal_stratejisi.py
// BTCUSDT SHORT SÄ°NYAL STRATEJÄ°
strategy("BTC Short Strategy 15M", overlay=true)

rsi = ta.rsi(close, 14)
stoch = ta.stoch(close, high, low, 14)
macdLine = ta.ema(close, 12) - ta.ema(close, 26)
macdSignal = ta.ema(macdLine, 9)

// SHORT sinyali ÅŸartlarÄ±
shortCondition = (rsi > 67) and (stoch > 80) and (macdLine < macdSignal)
if (shortCondition)
    strategy.entry("SHORT", strategy.short)

strategy.exit("TP", from_entry="SHORT", limit=113100, stop=114100)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\single_file_prototype.py
"""
HyperBot Core â€” Advanced Futures Trading Platform (Single-File Prototype)
=======================================================================
A highly modular, async, plugin-driven core for futures trading (e.g., Binance USDT-M Futures).

Key ideas packed into a single file so you can run fast, then split into a repo:
- Async event bus (pub/sub) with backpressure and graceful shutdown
- Strategy & Risk as hotâ€‘swappable plugins
- Regime/vol filters and drawdownâ€‘aware fractional Kelly sizing
- ATR-based protective levels
- Unified backtest + live engine API
- State & persistence (SQLite) for trades, PnL, and checkpoints
- Config via Pydantic BaseSettings (.env friendly)

âš ï¸ This is a PROTOTYPE. Wire your real broker/websocket, add comprehensive tests,
   and verify fees/slippage/latency handling before real capital. Use testnet first.
"""

from __future__ import annotations
import asyncio
import contextlib
import dataclasses
import importlib
import inspect
import json
import os
import signal
import sqlite3
import sys
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Any, AsyncIterator, Awaitable, Callable, Dict, Iterable, List, Optional, Tuple, Type

from pydantic import BaseSettings, Field

# ============================
# Config
# ============================
class Settings(BaseSettings):
    SYMBOL: str = "BTCUSDT"
    TIMEFRAME: str = "1m"
    LEVERAGE: int = 5
    MAX_DAILY_DRAWDOWN: float = 0.03  # 3%
    RISK_FRACTION: float = 0.5         # Fractional Kelly cap (0..1)
    DATA_SOURCES: str = "rest"        # rest|ws|both
    DB_PATH: str = "hyperbot.db"
    PLUGINS_PATH: str = "plugins"     # directory for strategy/risk plugins
    
    class Config:
        env_file = ".env"

SET = Settings()

# ============================
# Events & Data
# ============================
@dataclass
class Candle:
    open_time: int
    open: float
    high: float
    low: float
    close: float
    volume: float
    close_time: int

@dataclass
class MarketEvent:
    kind: str  # "candle_close" | "order_fill" | "account" | ...
    data: Any
    ts: float = dataclasses.field(default_factory=lambda: time.time())

@dataclass
class Signal:
    side: str           # "LONG" | "SHORT" | "FLAT"
    confidence: float   # 0..1
    entry_hint: float | None = None

@dataclass
class Order:
    side: str           # "LONG"|"SHORT"
    qty: float
    sl: float
    tp: float
    entry: float

@dataclass
class Fill:
    order_id: str
    side: str
    qty: float
    price: float
    realized_pnl: float = 0.0

# ============================
# Simple Storage (SQLite)
# ============================
class Store:
    def __init__(self, path: str):
        self.conn = sqlite3.connect(path, check_same_thread=False)
        self.conn.execute("PRAGMA journal_mode=WAL;")
        self._init()

    def _init(self):
        cur = self.conn.cursor()
        cur.execute("""
        CREATE TABLE IF NOT EXISTS trades(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            ts REAL,
            symbol TEXT,
            side TEXT,
            qty REAL,
            entry REAL,
            sl REAL,
            tp REAL
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS fills(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            trade_id INTEGER,
            ts REAL,
            side TEXT,
            qty REAL,
            price REAL,
            realized_pnl REAL
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS pnl(
            day TEXT PRIMARY KEY,
            realized REAL
        );
        """)
        self.conn.commit()

    def new_trade(self, symbol: str, side: str, qty: float, entry: float, sl: float, tp: float) -> int:
        cur = self.conn.cursor()
        cur.execute("INSERT INTO trades(ts,symbol,side,qty,entry,sl,tp) VALUES(?,?,?,?,?,?,?)",
                    (time.time(), symbol, side, qty, entry, sl, tp))
        self.conn.commit()
        return cur.lastrowid

    def add_fill(self, trade_id: int, side: str, qty: float, price: float, realized: float):
        cur = self.conn.cursor()
        cur.execute("INSERT INTO fills(trade_id,ts,side,qty,price,realized_pnl) VALUES(?,?,?,?,?,?)",
                    (trade_id, time.time(), side, qty, price, realized))
        self.conn.commit()

    def update_daily_pnl(self, realized_delta: float):
        day = time.strftime("%Y-%m-%d")
        cur = self.conn.cursor()
        cur.execute("SELECT realized FROM pnl WHERE day=?", (day,))
        row = cur.fetchone()
        if row:
            cur.execute("UPDATE pnl SET realized=realized+? WHERE day=?", (realized_delta, day))
        else:
            cur.execute("INSERT INTO pnl(day,realized) VALUES(?,?)", (day, realized_delta))
        self.conn.commit()

    def daily_pnl(self) -> float:
        day = time.strftime("%Y-%m-%d")
        cur = self.conn.cursor()
        cur.execute("SELECT realized FROM pnl WHERE day=?", (day,))
        row = cur.fetchone()
        return float(row[0]) if row else 0.0

STORE = Store(SET.DB_PATH)

# ============================
# Async Event Bus
# ============================
class EventBus:
    def __init__(self, maxsize: int = 1000):
        self.q: asyncio.Queue[MarketEvent] = asyncio.Queue(maxsize=maxsize)
        self.subs: List[Callable[[MarketEvent], Awaitable[None]]] = []
        self._closing = asyncio.Event()

    async def publish(self, ev: MarketEvent):
        await self.q.put(ev)

    def subscribe(self, handler: Callable[[MarketEvent], Awaitable[None]]):
        self.subs.append(handler)

    async def run(self):
        while not self._closing.is_set():
            ev = await self.q.get()
            for h in list(self.subs):
                # dispatch but protect
                asyncio.create_task(self._safe_call(h, ev))

    async def _safe_call(self, h, ev):
        try:
            await h(ev)
        except Exception as e:
            print(f"[EventBus] handler error: {e}")

    async def close(self):
        self._closing.set()

BUS = EventBus()

# ============================
# Indicators (minimal ATR/EMA/RSI, no external deps)
# ============================
import math

def ema(series: List[float], span: int) -> float:
    if not series: return float('nan')
    k = 2/(span+1)
    e = series[0]
    for x in series[1:]:
        e = x*k + e*(1-k)
    return e

def rsi(values: List[float], period: int = 14) -> float:
    if len(values) < period+1: return float('nan')
    gains, losses = [], []
    for i in range(1, period+1):
        d = values[-i] - values[-i-1]
        gains.append(max(d,0))
        losses.append(abs(min(d,0)))
    avg_gain = sum(gains)/period
    avg_loss = sum(losses)/period
    if avg_loss == 0: return 100.0
    rs = avg_gain/avg_loss
    return 100 - 100/(1+rs)

def atr(candles: List[Candle], period: int = 14) -> float:
    if len(candles) < period+1: return float('nan')
    trs = []
    for i in range(1, period+1):
        h = candles[-i].high; l = candles[-i].low; pc = candles[-i-1].close
        trs.append(max(h-l, abs(h-pc), abs(l-pc)))
    return sum(trs)/period

# ============================
# Strategy & Risk Plugin Interfaces
# ============================
class Strategy:
    name: str = "base"
    async def on_candle(self, candles: List[Candle]) -> Optional[Signal]:
        raise NotImplementedError

class Risk:
    name: str = "base"
    def regime_bias(self, candles: List[Candle]) -> int:
        """Return 1 for long bias, -1 for short bias, 0 neutral."""
        closes = [c.close for c in candles]
        e50 = ema(closes[-200:], 50) if len(closes)>=50 else float('nan')
        e200 = ema(closes[-200:], 200) if len(closes)>=200 else float('nan')
        if not math.isfinite(e50) or not math.isfinite(e200):
            return 0
        return 1 if e50>e200 else (-1 if e50<e200 else 0)

    def position_size(self, balance: float, entry: float, stop: float, side: str,
                      conf: float, daily_dd: float) -> float:
        """Drawdownâ€‘aware fractional Kelly sizing (very conservative).
        kelly = edge/variance approx; here proxy via conf and stop distance.
        """
        risk_per_unit = abs(entry - stop)
        if risk_per_unit <= 0: return 0.0
        base_risk = max(0.001, 0.01 * conf)  # 0.1%..1% per trade depending on confidence
        # drawdown clamp
        penalty = 1.0
        if daily_dd < 0:
            penalty = max(0.25, 1.0 + daily_dd / SET.MAX_DAILY_DRAWDOWN)  # down to 25%
        dollar_risk = balance * base_risk * penalty * SET.RISK_FRACTION
        qty = max(0.0, dollar_risk / risk_per_unit)
        return round(qty, 3)

    def protective_levels(self, candles: List[Candle], entry: float, side: str) -> Tuple[float,float]:
        a = atr(candles, 14)
        if not math.isfinite(a): a = max(1.0, 0.001*entry)
        k, r = 1.8, 2.8
        if side == "LONG":
            return entry - k*a, entry + r*a
        else:
            return entry + k*a, entry - r*a

# ============================
# Example Built-in Strategy (EMA cross + RSI filter + regime awareness)
# ============================
class EMARSI(Strategy):
    name = "ema_rsi"
    async def on_candle(self, candles: List[Candle]) -> Optional[Signal]:
        closes = [c.close for c in candles]
        if len(closes) < 60:
            return None
        e12 = ema(closes[-80:], 12)
        e26 = ema(closes[-120:], 26)
        r = rsi(closes[-30:], 14)
        if not all(map(math.isfinite, [e12, e26, r])):
            return None
        if e12 > e26 and r > 55:
            return Signal("LONG", 0.6, entry_hint=closes[-1])
        if e12 < e26 and r < 45:
            return Signal("SHORT", 0.6, entry_hint=closes[-1])
        return Signal("FLAT", 0.0, entry_hint=closes[-1])

# ============================
# Plugin Loader
# ============================
class PluginLoader:
    def __init__(self, path: str):
        self.path = Path(path)
        self.path.mkdir(parents=True, exist_ok=True)
        if str(self.path) not in sys.path:
            sys.path.insert(0, str(self.path))

    def load_strategies(self) -> List[Strategy]:
        strategies: List[Strategy] = [EMARSI()]
        for p in self.path.glob("*.py"):
            modname = p.stem
            if modname.startswith("_"): continue
            mod = importlib.import_module(modname)
            for _, obj in inspect.getmembers(mod, inspect.isclass):
                if issubclass(obj, Strategy) and obj is not Strategy:
                    strategies.append(obj())
        return strategies

    def load_risk(self) -> Risk:
        # Allow overriding Risk via plugin file named risk.py with class Risk
        try:
            mod = importlib.import_module("risk")
            for _, obj in inspect.getmembers(mod, inspect.isclass):
                if issubclass(obj, Risk) and obj is not Risk:
                    return obj()
        except Exception:
            pass
        return Risk()

PLUGINS = PluginLoader(SET.PLUGINS_PATH)

# ============================
# Broker Interface (stub)
# ============================
class Broker:
    async def price(self) -> float:
        raise NotImplementedError
    async def place_market(self, side: str, qty: float) -> Tuple[str, float]:
        raise NotImplementedError

class DummyBroker(Broker):
    def __init__(self):
        self._price = 50000.0
    async def price(self) -> float:
        # simulate small random walk
        self._price *= (1 + (0.5 - (time.time()%1)) * 1e-4)
        return self._price
    async def place_market(self, side: str, qty: float) -> Tuple[str, float]:
        px = await self.price()
        return (f"DUMMY-{int(time.time()*1e6)}", px)

BROKER: Broker = DummyBroker()  # swap with real Binance futures broker

# ============================
# Engine (Backtest + Live wrapper)
# ============================
class Engine:
    def __init__(self, strategies: List[Strategy], risk: Risk, broker: Broker):
        self.strategies = strategies
        self.risk = risk
        self.broker = broker
        self.current_side: Optional[str] = None
        self.open_trade_id: Optional[int] = None
        self.cooldown_bars = 0

    def _merge_signals(self, sigs: List[Signal], bias: int) -> Optional[Signal]:
        # Aggregate: majority with average confidence; align with bias
        if not sigs: return None
        longs = [s for s in sigs if s.side=="LONG"]
        shorts= [s for s in sigs if s.side=="SHORT"]
        if len(longs) == len(shorts):
            return None
        winner = longs if len(longs)>len(shorts) else shorts
        conf = min(1.0, sum(s.confidence for s in winner)/max(1,len(winner)))
        side = "LONG" if winner is longs else "SHORT"
        # regime bias adjustment
        if (bias==1 and side=="LONG") or (bias==-1 and side=="SHORT"):
            conf = min(1.0, conf+0.15)
        else:
            conf = max(0.0, conf-0.20)
        return Signal(side, conf)

    async def on_candle_close(self, candles: List[Candle]):
        if self.cooldown_bars>0:
            self.cooldown_bars -= 1
            return
        # collect signals
        sigs: List[Signal] = []
        for s in self.strategies:
            try:
                sig = await s.on_candle(candles)
                if sig and sig.side!="FLAT":
                    sigs.append(sig)
            except Exception as e:
                print(f"[Strategy {getattr(s,'name','?')}] error: {e}")
        bias = self.risk.regime_bias(candles)
        merged = self._merge_signals(sigs, bias)
        if not merged or merged.confidence < 0.6:
            return
        entry_px = candles[-1].close
        sl, tp = self.risk.protective_levels(candles, entry_px, merged.side)
        balance = 10000.0  # TODO: query real futures wallet balance
        daily_dd = STORE.daily_pnl()  # negative if losing today
        qty = self.risk.position_size(balance, entry_px, sl, merged.side, merged.confidence, daily_dd)
        if qty <= 0:
            return
        if self.current_side and self.current_side == merged.side:
            return  # avoid stacking same direction
        # place order
        oid, fill_px = await self.broker.place_market(merged.side, qty)
        self.current_side = merged.side
        self.open_trade_id = STORE.new_trade(SET.SYMBOL, merged.side, qty, fill_px, sl, tp)
        print(f"OPEN {merged.side} qty={qty} @ {fill_px:.2f} | SL {sl:.2f} TP {tp:.2f}")
        self.cooldown_bars = 3

# ============================
# Data Feed (placeholder)
# ============================
async def dummy_candles() -> AsyncIterator[Candle]:
    # Emits a candle every second as a proxy for 1m close; replace with real klines/ws
    o = 50000.0
    while True:
        h = o * (1 + 0.001)
        l = o * (1 - 0.001)
        c = o * (1 + (0.5 - (time.time()%1))*1e-3)
        v = 10.0
        now = int(time.time()*1000)
        yield Candle(now-60_000, o, h, l, c, v, now)
        o = c
        await asyncio.sleep(1)

# ============================
# Wiring & Run
# ============================
async def main():
    strategies = PLUGINS.load_strategies()
    risk = PLUGINS.load_risk()
    engine = Engine(strategies, risk, BROKER)

    candles: List[Candle] = []
    async for c in dummy_candles():
        candles.append(c)
        if len(candles) > 600:
            candles = candles[-600:]
        # candle close event
        await engine.on_candle_close(candles)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("Graceful exit")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\smart_contract_scanner.py
def scan_contract(code_text):
    suspicious_terms = ["delegatecall", "tx.origin", "assembly", "selfdestruct"]
    alerts = []

    for term in suspicious_terms:
        if term in code_text:
            alerts.append(f"âš ï¸ Riskli yapÄ± bulundu: {term}")

    if "require(owner)" in code_text or "onlyOwner" in code_text:
        alerts.append("ðŸ‘‘ YÃ¶netici kilidi: Merkezi kontrol unsuru tespit edildi.")

    return alerts if alerts else ["âœ… Kodda anormal yapÄ± bulunmadÄ±."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\smoke_check.py
# smoke_check.py
import os, sys, time, csv, importlib, traceback
from dotenv import load_dotenv

OK="âœ…"; FAIL="âŒ"

def step(name, fn):
    try:
        res = fn()
        print(f"{OK} {name}")
        return True, res
    except Exception as e:
        print(f"{FAIL} {name}: {e}")
        traceback.print_exc()
        return False, None

def main():
    # 1) .env
    def _env():
        load_dotenv()
        req = ["BINANCE_API_KEY","BINANCE_API_SECRET","BINANCE_FUTURES_URL","SYMBOLS","TIMEFRAME"]
        miss=[k for k in req if not os.getenv(k)]
        if miss: raise RuntimeError(f".env eksik: {miss}")
        return True
    step(".env yÃ¼klendi", _env)

    # 2) sÃ¼rÃ¼m/baÄŸÄ±mlÄ±lÄ±k
    def _deps():
        mods=["pandas","dotenv","binance","aiohttp","requests"]
        for m in mods: importlib.import_module(m)
        return True
    step("baÄŸÄ±mlÄ±lÄ±klar import ediliyor", _deps)

    # 3) preflight (ping/zaman/balance/ticker)
    def _preflight():
        from preflight import Client, key, sec, use_testnet, fut_url, symbols
        c=Client(key,sec,testnet=use_testnet); c.FUTURES_URL=fut_url
        c.ping(); c.futures_time()
        bal = [b for b in c.futures_account_balance() if b["asset"]=="USDT"]
        if not bal: raise RuntimeError("USDT balance okunamadÄ±")
        for s in symbols:
            c.futures_symbol_ticker(symbol=s)
        return True
    step("preflight", _preflight)

    # 4) bias taramasÄ± CSV Ã¼retimi (tek dÃ¶ngÃ¼)
    def _bias_scan_once():
        # mevcut dosyalarÄ±n adlarÄ±na uydur: long_short_ratio_scanner.py veya bias_gate.py iÃ§inden tek seferlik fonksiyon Ã§aÄŸÄ±r.
        # Basit bir CSV Ã¼retelim ki sonraki adÄ±m okusun:
        fn = os.getenv("BIAS_CSV", "bias_scan.csv")
        with open(fn, "w", newline="") as f:
            w=csv.writer(f); w.writerow(["symbol","score","side","ts"])
            w.writerow(["BTCUSDT",0.73,"LONG",int(time.time())])
            w.writerow(["ETHUSDT",0.68,"SHORT",int(time.time())])
        return fn
    ok, csv_path = step("bias CSV Ã¼retildi", _bias_scan_once)

    # 5) stratejiyi bir tur DRY-RUN Ã§alÄ±ÅŸtÄ±r
    def _run_strategy_once():
        # Ã‡alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±n gerÃ§ek dosya hangisiyse onu import et:
        # run_bias_gated_strategy.py iÃ§inde main() gibi bir fonksiyon yoksa, bir "ONE_SHOT" env ile tek dÃ¶ngÃ¼ Ã§alÄ±ÅŸtÄ±rmanÄ± Ã¶neririm.
        # Burada sadece import testi yapÄ±yoruz.
        import importlib
        # Ã¶rnek: module = importlib.import_module("run_bias_gated_strategy")
        # EÄŸer yoksa sadece PASS:
        return True
    step("strateji import/baÅŸlatma (tek tur)", _run_strategy_once)

    print("\n=== SONUÃ‡ ===")
    print("EÄŸer tÃ¼m adÄ±mlar âœ… ise bot saÄŸlÄ±klÄ±. DRY_RUN=false yapmadan Ã¶nce 3-5 dk izleyin.")

if __name__ == "__main__":
    sys.exit(main() or 0)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\subchain_emotion_decoder.py
def decode_chain_emotion(transaction_stream):
    signals = {"fear": 0, "greed": 0, "neutral": 0}
    for tx in transaction_stream:
        if tx["type"] == "panic_sell":
            signals["fear"] += 1
        elif tx["type"] == "overbuy":
            signals["greed"] += 1
        else:
            signals["neutral"] += 1
    dominant = max(signals, key=signals.get)
    return f"ðŸŒ«ï¸ Zincir duygusu: {dominant.upper()}"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\sync_mission_map.py
def map_mission_sync(logs):
    sync_map = []
    for log in logs:
        if log["emotion"] in ["ðŸ’¡ Ä°lham", "ðŸ”¥ Tutku"] and log["feeling_strength"] > 75:
            alignment = "ðŸŒŸ YÃ¼ksek Senkronizasyon"
        elif log["emotion"] == "ðŸŽ¯ Odak" and log["feeling_strength"] >= 60:
            alignment = "ðŸ”„ Dengeli Uyum"
        elif log["emotion"] in ["ðŸŒ«ï¸ Yorgunluk", "ðŸ˜• KararsÄ±zlÄ±k"]:
            alignment = "âš ï¸ DÃ¼ÅŸÃ¼k Senkronizasyon"
        else:
            alignment = "ðŸ” GÃ¶zlem AÅŸamasÄ±nda"

        sync_map.append(
            f"{alignment} | GÃ¶rev: {log['task_id']} | Zaman: {log['timestamp']} | Duygu: {log['emotion']} | GÃ¼Ã§: {log['feeling_strength']}"
        )
    return sync_map



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ta_core.py
# ta_core.py
from __future__ import annotations
import numpy as np
import pandas as pd

def _as_series(x) -> pd.Series:
    return x if isinstance(x, pd.Series) else pd.Series(x)

def sma(close: pd.Series, n: int) -> pd.Series:
    return _as_series(close).rolling(n, min_periods=n).mean()

def ema(close: pd.Series, n: int) -> pd.Series:
    return _as_series(close).ewm(span=n, adjust=False, min_periods=n).mean()

def rsi(close: pd.Series, n: int=14) -> pd.Series:
    c = _as_series(close)
    delta = c.diff()
    up = delta.clip(lower=0)
    down = -delta.clip(upper=0)
    roll_up = up.ewm(alpha=1/n, adjust=False).mean()
    roll_down = down.ewm(alpha=1/n, adjust=False).mean()
    rs = roll_up / (roll_down + 1e-12)
    return 100 - (100 / (1 + rs))

def macd(close: pd.Series, fast=12, slow=26, signal=9):
    fast_ema = ema(close, fast)
    slow_ema = ema(close, slow)
    macd_line = fast_ema - slow_ema
    signal_line = ema(macd_line, signal)
    hist = macd_line - signal_line
    return macd_line, signal_line, hist

def true_range(high: pd.Series, low: pd.Series, close: pd.Series) -> pd.Series:
    h, l, c = _as_series(high), _as_series(low), _as_series(close)
    prev_close = c.shift(1)
    tr1 = h - l
    tr2 = (h - prev_close).abs()
    tr3 = (l - prev_close).abs()
    return pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)

def atr(high, low, close, n: int=14) -> pd.Series:
    tr = true_range(high, low, close)
    # Wilder smoothing
    return tr.ewm(alpha=1/n, adjust=False, min_periods=n).mean()

def stoch_kd(high, low, close, k=14, d=3):
    h, l, c = _as_series(high), _as_series(low), _as_series(close)
    lowest = l.rolling(k, min_periods=k).min()
    highest = h.rolling(k, min_periods=k).max()
    k_line = 100 * (c - lowest) / (highest - lowest + 1e-12)
    d_line = k_line.rolling(d, min_periods=d).mean()
    return k_line, d_line

def adx(high, low, close, n: int=14):
    h, l, c = _as_series(high), _as_series(low), _as_series(close)
    up_move = h.diff()
    down_move = -l.diff()
    plus_dm = np.where((up_move > down_move) & (up_move > 0), up_move, 0.0)
    minus_dm = np.where((down_move > up_move) & (down_move > 0), down_move, 0.0)
    tr = true_range(h, l, c)

    atr_n = atr(h, l, c, n)
    plus_di = 100 * pd.Series(plus_dm, index=h.index).ewm(alpha=1/n, adjust=False).mean() / (atr_n + 1e-12)
    minus_di = 100 * pd.Series(minus_dm, index=h.index).ewm(alpha=1/n, adjust=False).mean() / (atr_n + 1e-12)
    dx = (abs(plus_di - minus_di) / (plus_di + minus_di + 1e-12)) * 100
    adx_val = dx.ewm(alpha=1/n, adjust=False).mean()
    return adx_val, plus_di, minus_di

def bollinger(close: pd.Series, n: int=20, k: float=2.0):
    m = sma(close, n)
    sd = _as_series(close).rolling(n, min_periods=n).std(ddof=0)
    upper = m + k*sd
    lower = m - k*sd
    width = (upper - lower) / (m + 1e-12)
    return m, upper, lower, width

def cci(high, low, close, n: int=20):
    h, l, c = _as_series(high), _as_series(low), _as_series(close)
    tp = (h + l + c) / 3
    ma = tp.rolling(n, min_periods=n).mean()
    md = (tp - ma).abs().rolling(n, min_periods=n).mean()
    return (tp - ma) / (0.015 * (md + 1e-12))

def mfi(high, low, close, volume, n: int=14):
    h, l, c, v = map(_as_series, (high, low, close, volume))
    tp = (h + l + c) / 3
    mf = tp * v
    pos_mf = mf.where(tp > tp.shift(1), 0.0)
    neg_mf = mf.where(tp < tp.shift(1), 0.0)
    mr = pos_mf.rolling(n, min_periods=n).sum() / (neg_mf.rolling(n, min_periods=n).sum() + 1e-12)
    return 100 - 100 / (1 + mr)

def obv(close, volume):
    c, v = _as_series(close), _as_series(volume)
    sign = np.sign(c.diff().fillna(0.0))
    return (sign * v).fillna(0.0).cumsum()

def keltner(high, low, close, ema_period=20, atr_period=10, mult=1.5):
    mid = ema(_as_series(close), ema_period)
    rng = atr(high, low, close, atr_period) * mult
    return mid, mid + rng, mid - rng

def supertrend(high, low, close, atr_period=10, mult=3.0):
    h, l, c = map(_as_series, (high, low, close))
    hl2 = (h + l) / 2.0
    atr_n = atr(h, l, c, atr_period)
    upper = hl2 + mult * atr_n
    lower = hl2 - mult * atr_n

    dir_up = pd.Series(index=c.index, dtype=int)
    final_upper = pd.Series(index=c.index, dtype=float)
    final_lower = pd.Series(index=c.index, dtype=float)

    dir_up.iloc[0] = 1
    final_upper.iloc[0] = upper.iloc[0]
    final_lower.iloc[0] = lower.iloc[0]

    for i in range(1, len(c)):
        final_upper.iloc[i] = min(upper.iloc[i], final_upper.iloc[i-1]) if c.iloc[i-1] > final_upper.iloc[i-1] else upper.iloc[i]
        final_lower.iloc[i] = max(lower.iloc[i], final_lower.iloc[i-1]) if c.iloc[i-1] < final_lower.iloc[i-1] else lower.iloc[i]
        dir_up.iloc[i] = 1 if (c.iloc[i] > final_upper.iloc[i-1]) else (-1 if (c.iloc[i] < final_lower.iloc[i-1]) else dir_up.iloc[i-1])

    line = pd.Series(index=c.index, dtype=float)
    line = np.where(dir_up > 0, final_lower, final_upper)
    return pd.Series(dir_up, index=c.index), pd.Series(line, index=c.index)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\task_efficiency_predictor.py
def predict_task_success(logs):
    prediction = []
    for log in logs:
        mood = log["emotion"]
        strength = log["feeling_strength"]

        # Duygusal gÃ¼ce gÃ¶re baÅŸarÄ± oranÄ±
        if mood in ["ðŸ’¡ Ä°lham", "ðŸ”¥ Tutku"] and strength > 70:
            chance = "ðŸš€ %92 BaÅŸarÄ± Potansiyeli"
        elif mood in ["ðŸŽ¯ Odak"] and strength > 60:
            chance = "ðŸŒŸ %85 Stabil Potansiyel"
        elif mood in ["ðŸŒ«ï¸ Yorgunluk", "ðŸ˜• KararsÄ±zlÄ±k"]:
            chance = "âš ï¸ %40 Riskli GÃ¶rev"
        else:
            chance = "ðŸ” %65 KararsÄ±z Alan"
        
        prediction.append(
            f"ðŸ§­ GÃ¶rev: {log['task_id']} | Zaman: {log['timestamp']} | Duygu: {mood} | GÃ¼Ã§: {strength} â†’ Tahmin: {chance}"
        )
    return prediction



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\temporal_emotion_tracker.py
def track_emotion_over_time(emotion_log):
    timeline = []
    for log in emotion_log:
        intensity = "ðŸ“ˆ YÃ¼ksek" if log["feeling_strength"] > 70 else "ðŸ“‰ DÃ¼ÅŸÃ¼k"
        entry = (
            f"ðŸ§­ GÃ¶rev: {log['task_id']} | â³ Zaman: {log['timestamp']} "
            f"| ðŸŽ­ Duygu: {log['emotion']} | ðŸ”‹ GÃ¼Ã§: {intensity}"
        )
        timeline.append(entry)
    return timeline



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\temporal_strategy_planner.py
from datetime import datetime

class TemporalPlanner:
    def __init__(self):
        self.day_strategies = {
            "Monday": "temkinli alÄ±m",
            "Tuesday": "momentum takip",
            "Wednesday": "fiyat doÄŸrulama",
            "Thursday": "aÅŸÄ±rÄ± analiz",
            "Friday": "risk yÃ¶netimli satÄ±ÅŸ",
            "Saturday": "volatilite beklemesi",
            "Sunday": "pre-market iÃ§gÃ¶rÃ¼sÃ¼"
        }

    def current_strategy(self):
        today = datetime.today().strftime("%A")
        return f"ðŸ§­ BugÃ¼nÃ¼n stratejisi ({today}): {self.day_strategies.get(today, 'standart yaklaÅŸÄ±m')}"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\test_bias_csv.py
import os, csv
from dotenv import load_dotenv
load_dotenv()

def test_bias_csv_schema(tmp_path):
    fn = os.getenv("BIAS_CSV","bias_scan.csv")
    # deneysel bir satÄ±r Ã¼ret:
    with open(fn,"w",newline="") as f:
        w=csv.writer(f); w.writerow(["symbol","score","side","ts"]); w.writerow(["BTCUSDT",0.7,"LONG",1700000000])
    # oku/doÄŸrula
    with open(fn) as f:
        rows=list(csv.reader(f))
    assert rows[0]==["symbol","score","side","ts"]
    assert rows[1][2] in ("LONG","SHORT")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\test_filters.py
import pytest

def clamp_price(price, tick):
    tick=float(tick)
    return int(price/tick)*tick

def clamp_qty(qty, step):
    step=float(step)
    return int(qty/step)*step

def test_price_round():
    assert clamp_price(27345.123, 0.01) == 27345.12

def test_qty_round():
    assert clamp_qty(0.123456, 0.001) == 0.123


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\test_risk.py
import os
from dotenv import load_dotenv
load_dotenv()

def test_limits_exist():
    assert 0 < float(os.getenv("MAX_DAILY_DRAWDOWN","0.03")) <= 0.2
    assert 0 < float(os.getenv("MAX_CAPITAL_PCT_PER_TRADE","0.02")) <= 0.1
    assert 1 <= int(os.getenv("MAX_OPEN_POSITIONS","5")) <= 50


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\test_runner.py
from analysis.scoring import generate_signal
from notify.telegram import send_telegram_message
from tracker.signal_tracker import evaluate_signal

test_news = [
    {"title": "Bitcoin surges after ETF approval", "score": 0.85, "before": 27000, "after": 29000},
    {"title": "Ethereum drops due to scam news", "score": -0.9, "before": 1800, "after": 1700},
    {"title": "Crypto market stable", "score": 0.1, "before": 25000, "after": 25100},
]

for item in test_news:
    signal = generate_signal(item["score"])
    send_telegram_message(f"Sinyal: {signal}\nHaber: {item['title']}")
    evaluate_signal(signal, item["before"], item["after"])
from dashboard.visual_panel import dashboard_view
dashboard_view()




### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\trade_engine.py
from binance.client import Client
import os

API_KEY = os.getenv("BINANCE_API_KEY")
API_SECRET = os.getenv("BINANCE_API_SECRET")

client = Client(API_KEY, API_SECRET)
client.FUTURES_URL = "https://fapi.binance.com/fapi"

def execute_trade(symbol="BTCUSDT", side="BUY", quantity=0.01, leverage=10):
    try:
        client.futures_change_leverage(symbol=symbol, leverage=leverage)

        response = client.futures_create_order(
            symbol=symbol,
            side=side,
            type="MARKET",
            quantity=quantity
        )
        return response
    except Exception as e:
        print(f"ðŸš¨ Ä°ÅŸlem hatasÄ±: {e}")
signal = simple_signal(indicators)  # BUY / SELL / WAIT

if signal != "WAIT":
    execute_trade(symbol="BTCUSDT", side=signal, quantity=0.01, leverage=10)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\trade_executor.py
from services.binance_client import get_client
from config.settings import SYMBOL

client = get_client()

def place_order(signal):
    ticker = client.fetch_ticker(SYMBOL)
    price = ticker["last"]
    amount = 50 / price  # $50 deÄŸerinde iÅŸlem
    side = "buy" if signal == "LONG" else "sell"
    
    client.create_market_order(SYMBOL, side, amount)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\trade_journal.py
# trade_journal.py (Ä°ÅŸlem geÃ§miÅŸi SQLite tabanlÄ± kayÄ±t sistemi)
import sqlite3
from datetime import datetime

DB_NAME = "trade_history.db"

def init_db():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("""
        CREATE TABLE IF NOT EXISTS trades (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT,
            symbol TEXT,
            direction TEXT,
            qty REAL,
            entry_price REAL,
            stop_loss REAL,
            take_profit REAL,
            result TEXT,
            pnl REAL
        )
    """)
    conn.commit()
    conn.close()


def log_trade_to_db(symbol, direction, qty, entry, sl, tp, result, pnl):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    c.execute("""
        INSERT INTO trades (timestamp, symbol, direction, qty, entry_price, stop_loss, take_profit, result, pnl)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    """, (now, symbol, direction, qty, entry, sl, tp, result, pnl))
    conn.commit()
    conn.close()
    print(f"ðŸ“˜ KayÄ±t: {symbol} | {direction} | PnL: {pnl}")


def fetch_all_trades():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("SELECT * FROM trades ORDER BY id DESC")
    rows = c.fetchall()
    conn.close()
    return rows


# Test amaÃ§lÄ± kullanÄ±m
if __name__ == "__main__":
    init_db()
    log_trade_to_db("BTC/USDT", "long", 100, 30000, 29500, 31500, "win", 1500.0)
    trades = fetch_all_trades()
    for trade in trades:
        print(trade)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ultra_elite_echo_multiverse_ai_pro_v2.py
# ultra_elite_echo_multiverse_ai_pro_v2.py
from __future__ import annotations
import argparse, json, os, sys, uuid, time, importlib.util, pathlib
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, List, Any, Callable, Optional

# ====== 3rd party ======
try:
    from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
    import uvicorn
    from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    from starlette.responses import Response
    from starlette.middleware.authentication import AuthenticationMiddleware
except ImportError:
    FastAPI=None

import jsonschema

# ====== i18n (kÄ±saltÄ±lmÄ±ÅŸ) ======
I18N={"en":{"engine_online":"ULTRA ELITE HYBRID ONLINE"},"tr":{"engine_online":"ULTRA ELÄ°T HÄ°BRÄ°T AKTÄ°F"}}
def tr(lang,key,**kw): base=I18N.get(lang)or I18N["en"]; return (base.get(key)or key).format(**kw)

# ====== health & metrics ======
class Health(str): OK="ok"; WARN="warn"; FAIL="fail"
@dataclass
class Metrics: init_ms:float=0; activate_ms:float=0; custom:Dict[str,float]=field(default_factory=dict)

# ====== Module ======
@dataclass
class Module:
    name:str; status:str; payload:Dict[str,Any]; health:str=Health.OK; metrics:Metrics=field(default_factory=Metrics)
    schema:Optional[Dict[str,Any]]=None
    def to_dict(self): return {"name":self.name,"status":self.status,"health":self.health,"metrics":asdict(self.metrics),**self.payload}

# ====== Registry + Plugins ======
REGISTRY:Dict[str,Callable[[str,str],Module]]={}
def register(name:str): 
    def deco(fn): REGISTRY[name]=fn; return fn
    return deco

def discover_plugins(folder="plugins"):
    for path in pathlib.Path(folder).glob("*.py"):
        spec=importlib.util.spec_from_file_location(path.stem,path)
        mod=importlib.util.module_from_spec(spec); spec.loader.exec_module(mod)

# ====== Ã¶rnek fabrika ======
@register("Code")
def m_code(strategy,lang)->Module:
    m=Module("Code","ok",{"msg":f"{strategy} â†’ coded"},schema={"type":"object","properties":{"msg":{"type":"string"}}})
    jsonschema.validate(m.payload,m.schema) # ÅŸema doÄŸrulama
    return m

# ====== System ======
@dataclass
class EchoMeta:
    version:str="Ultra Elit v2.0"; strategy:str="KamalquantX"; lang:str="tr"
    generated_at:str=field(default_factory=lambda:datetime.now(timezone.utc).isoformat())
    uuid:str=field(default_factory=lambda:str(uuid.uuid4()))

@dataclass
class UltraEliteEchoSystem:
    meta:EchoMeta; modules:Dict[str,Module]=field(default_factory=dict)
    @classmethod
    def build(cls,strategy,lang="tr",include:Optional[List[str]]=None):
        discover_plugins() # otomatik plugin yÃ¼kle
        sys=cls(EchoMeta(strategy=strategy,lang=lang))
        wanted=include or list(REGISTRY.keys())
        for k in wanted:
            if k not in REGISTRY:continue
            mod=REGISTRY[k](strategy,lang); sys.modules[k]=mod
        return sys
    def to_dict(self): return {"meta":asdict(self.meta),"engine":tr(self.meta.lang,"engine_online"),"modules":{k:m.to_dict() for k,m in self.modules.items()}}

# ====== API + WebSocket + Prometheus ======
REQUESTS=Counter("echo_requests_total","reqs"); LAT=Histogram("echo_req_latency","latency")
API_KEY=os.getenv("API_KEY","secret123")

def check_key(key:str=Depends(lambda:None)):
    from fastapi import Request
    def inner(req:Request):
        if req.headers.get("x-api-key")!=API_KEY:
            raise HTTPException(status.HTTP_401_UNAUTHORIZED,"Invalid API Key")
    return inner

def run_api(sysobj:UltraEliteEchoSystem,port=8000):
    app=FastAPI(title="UltraEliteEcho",version=sysobj.meta.version)
    @app.get("/health") 
    def h(): REQUESTS.inc(); return {"ok":True,"uuid":sysobj.meta.uuid}
    @app.get("/metrics") 
    def prom(): return Response(generate_latest(),media_type=CONTENT_TYPE_LATEST)
    @app.get("/modules")
    def modules(dep=Depends(check_key())): REQUESTS.inc(); return sysobj.to_dict()["modules"]
    @app.websocket("/ws")
    async def ws(ws:WebSocket):
        await ws.accept()
        while True:
            data=sysobj.to_dict(); await ws.send_json(data); time.sleep(2)
    uvicorn.run(app,host="0.0.0.0",port=port)

# ====== CLI ======
def main():
    p=argparse.ArgumentParser()
    p.add_argument("--strategy","-s",default="KamalquantX")
    p.add_argument("--lang","-l",default="tr")
    p.add_argument("--api",action="store_true")
    p.add_argument("--port",type=int,default=8000)
    args=p.parse_args()
    sysobj=UltraEliteEchoSystem.build(args.strategy,args.lang)
    print(json.dumps(sysobj.to_dict(),ensure_ascii=False,indent=2))
    if args.api: run_api(sysobj,args.port)

if __name__=="__main__": main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ultra_elite_engine.py
from __future__ import annotations
"""
Ultra Elite Strategy Engine â€” Full Stack (MTF + All Indicators + Risk + Binance Testnet)
--------------------------------------------------------------------------------------
- Multiâ€‘timeframe (signal / trend / HTF) with CLOSEDâ€‘bar signals (no repaint)
- Broad indicator pack (RSI, Stoch, MACD, EMA/SMA, Bollinger, Keltner, ATR, ADX,
  CCI, MFI, OBV, VWAP, Ichimoku, SAR, Supertrend) computed efficiently
- ATR SL/TP + breakeven + ATR trailing; volatility/chop filters; cooldown; session filter
- RiskManager: perâ€‘trade risk, min notional guard, daily max drawdown (Zurich reset)
- Fast deques, vectorized calc; optional Numba JIT for EMA & Supertrend
- Binance Futures Testnet executor (isolated, leverage, hedge mode, reduceâ€‘only),
  bracket orders (SL/TP), markâ€‘price working type, DRYâ€‘RUN support

Requires: python>=3.10, pandas, numpy, ta, pytz, python-dotenv, binance-connector, websocket-client, (optional) numba
Install:  pip install "pandas>=2" numpy ta pytz python-dotenv "binance-connector>=3" websocket-client numba

.env template (example):
BINANCE_API_KEY=your_testnet_key_here
BINANCE_API_SECRET=your_testnet_secret_here
USE_TESTNET=true
SYMBOLS=BTCUSDT,DOGEUSDT
BINANCE_HEDGE_MODE=true
BINANCE_MARGIN_TYPE=ISOLATED
BINANCE_LEVERAGE=5
RISK_MAX_DAILY_DRAWDOWN=0.02
RISK_MAX_RISK_PCT_PER_TRADE=0.015
MIN_NOTIONAL_USDT=10
WORKING_TYPE=MARK_PRICE   # MARK_PRICE | CONTRACT_PRICE
DRY_RUN=true

Run example:
python ultra_elite_engine.py --symbols BTCUSDT DOGEUSDT --signal_tf 1m --trend_tf 15m --htf 1h --dry-run
"""

from dataclasses import dataclass, field
from collections import deque
from typing import Deque, Dict, Optional, Literal, Tuple, List
import os
import math
import pandas as pd
import numpy as np
import pytz
import ta
import time
import logging
from datetime import datetime, timezone
from dotenv import load_dotenv

# Optional Numba for speed ----------------------------------------------------
try:
    from numba import njit
except Exception:  # pragma: no cover
    def njit(*args, **kwargs):
        def wrap(fn):
            return fn
        return wrap

# ----------------------------------------------------------------------------
# Logging
# ----------------------------------------------------------------------------
logger = logging.getLogger("UltraElite")
logger.setLevel(logging.INFO)
if not logger.handlers:
    ch = logging.StreamHandler()
    ch.setFormatter(logging.Formatter("%(asctime)s | %(levelname)s | %(message)s"))
    logger.addHandler(ch)

TF = Literal["1m","3m","5m","15m","30m","1h","2h","4h","1d"]
Side = Literal["LONG","SHORT"]

TF_TO_SEC = {"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"2h":7200,"4h":14400,"1d":86400}

# ----------------------------------------------------------------------------
# Data structures
# ----------------------------------------------------------------------------
@dataclass
class Bar:
    ts: pd.Timestamp  # bar close time UTC
    open: float
    high: float
    low: float
    close: float
    volume: float = 0.0

@dataclass
class Signal:
    symbol: str
    side: Side
    price: float
    sl: float
    tp: float
    size: float
    reason: str
    meta: dict = field(default_factory=dict)

# ----------------------------------------------------------------------------
# Helpers
# ----------------------------------------------------------------------------

def as_utc(ts) -> pd.Timestamp:
    if isinstance(ts, pd.Timestamp):
        if ts.tzinfo is None:
            return ts.tz_localize("UTC")
        return ts.tz_convert("UTC")
    # assume seconds since epoch
    return pd.to_datetime(ts, unit="s", utc=True)

# JIT EMA (fast incremental)
@njit(cache=True)
def ema_numba(vals: np.ndarray, period: int) -> np.ndarray:
    out = np.empty_like(vals)
    if len(vals) == 0:
        return out
    alpha = 2.0 / (period + 1.0)
    out[0] = vals[0]
    for i in range(1, len(vals)):
        out[i] = alpha * vals[i] + (1.0 - alpha) * out[i - 1]
    return out

# Supertrend (Numbaâ€‘friendly)
@njit(cache=True)
def supertrend(high, low, close, period=10, multiplier=3.0):
    n = len(close)
    atr = np.empty(n)
    atr[:] = np.nan

    # TR & ATR (RMA)
    tr = np.empty(n)
    tr[0] = high[0] - low[0]
    for i in range(1, n):
        hl = high[i] - low[i]
        hc = abs(high[i] - close[i-1])
        lc = abs(low[i] - close[i-1])
        tr[i] = hl if (hl >= hc and hl >= lc) else (hc if hc >= lc else lc)
    # RMA
    alpha = 1.0/period
    atr[period-1] = np.mean(tr[:period])
    for i in range(period, n):
        atr[i] = (atr[i-1] * (period-1) + tr[i]) / period

    upper = np.empty(n); lower = np.empty(n)
    upper[:] = np.nan; lower[:] = np.nan
    st = np.empty(n); st[:] = np.nan
    trend = np.empty(n); trend[:] = 1

    for i in range(n):
        if np.isnan(atr[i]):
            continue
        basic_upper = (high[i] + low[i]) / 2.0 + multiplier * atr[i]
        basic_lower = (high[i] + low[i]) / 2.0 - multiplier * atr[i]
        if i == 0:
            upper[i] = basic_upper
            lower[i] = basic_lower
            st[i] = basic_lower
            trend[i] = 1
            continue
        upper[i] = basic_upper if (basic_upper < upper[i-1] or close[i-1] > upper[i-1]) else upper[i-1]
        lower[i] = basic_lower if (basic_lower > lower[i-1] or close[i-1] < lower[i-1]) else lower[i-1]
        if close[i] > upper[i-1]:
            trend[i] = 1
        elif close[i] < lower[i-1]:
            trend[i] = -1
        else:
            trend[i] = trend[i-1]
        st[i] = lower[i] if trend[i] == 1 else upper[i]
    return st, trend, atr

# VWAP helper

def vwap_np(high, low, close, volume):
    tp = (high + low + close) / 3.0
    cum_v = np.cumsum(volume)
    cum_tp_v = np.cumsum(tp * volume)
    vwap = cum_tp_v / np.maximum(cum_v, 1e-12)
    return vwap

# ----------------------------------------------------------------------------
# Window state & Aggregators
# ----------------------------------------------------------------------------
@dataclass
class WindowState:
    tf: TF
    maxlen: int
    rows: Deque[Tuple[pd.Timestamp, float, float, float, float, float]] = field(default_factory=deque)

    def append(self, bar: Bar):
        if len(self.rows) == self.maxlen:
            self.rows.popleft()
        self.rows.append((as_utc(bar.ts), bar.open, bar.high, bar.low, bar.close, bar.volume))

    def to_df(self) -> pd.DataFrame:
        return pd.DataFrame(self.rows, columns=["ts","open","high","low","close","volume"])  

# Tick â†’ OHLCV aggregator for a single TF
class TickAggregator:
    def __init__(self, tf: TF):
        self.tf = tf
        self.period = TF_TO_SEC[tf]
        self.reset()

    def reset(self):
        self._open = None; self._high = -math.inf; self._low = math.inf; self._vol = 0.0; self._start = None

    def update(self, ts_sec: float, price: float, qty: float) -> Optional[Bar]:
        # ts_sec: seconds (float) epoch
        if self._start is None:
            self._start = int(ts_sec // self.period) * self.period
            self._open = price
            self._high = price
            self._low = price
        elif ts_sec >= self._start + self.period:
            # close current bar
            bar = Bar(ts=as_utc(self._start + self.period), open=self._open, high=self._high,
                      low=self._low, close=price, volume=self._vol)
            # start new
            self.reset()
            self._start = int(ts_sec // self.period) * self.period
            self._open = price; self._high = price; self._low = price; self._vol = qty
            return bar
        # update inâ€‘bar
        if price > self._high: self._high = price
        if price < self._low: self._low = price
        self._vol += qty
        return None

# ----------------------------------------------------------------------------
# Indicator Engine (broad coverage)
# ----------------------------------------------------------------------------
@dataclass
class IndicatorParams:
    # dynamic + presets together
    ma_periods: Tuple[int, ...] = (7, 25, 99)
    ema_periods: Tuple[int, ...] = (7, 21, 50, 99)
    wma_periods: Tuple[int, ...] = (7, 25)
    mavol_periods: Tuple[int, ...] = (7, 14)
    trix_periods: Tuple[int, ...] = (9,)
    bb_window: int = 20
    kelt_window: int = 20
    kelt_atr: int = 10
    supertrend_period: int = 10
    supertrend_mult: float = 3.0

class IndicatorEngine:
    def __init__(self, rsi_period=14, ema_fast=21, ema_slow=50, atr_period=14, adx_period=14,
                 params: IndicatorParams | None = None):
        self.rsi_period = rsi_period
        self.ema_fast = ema_fast
        self.ema_slow = ema_slow
        self.atr_period = atr_period
        self.adx_period = adx_period
        self.p = params or IndicatorParams()

    def _wma(self, x: pd.Series, period: int) -> pd.Series:
        # weighted moving average (linear weights 1..n)
        if period <= 1:
            return x
        w = np.arange(1, period + 1)
        return x.rolling(period).apply(lambda a: np.dot(a, w) / w.sum(), raw=True)

    def compute_all(self, df: pd.DataFrame) -> pd.DataFrame:
        c = df["close"].to_numpy()
        c = df["close"].to_numpy()
        h = df["high"].to_numpy()
        l = df["low"].to_numpy()
        v = df["volume"].to_numpy()

        out = df.copy()
        # === Core single-pass arrays ===
        out["rsi"] = ta.momentum.RSIIndicator(close=df["close"], window=self.rsi_period).rsi()
        out["ema_fast"] = pd.Series(ema_numba(c, self.ema_fast), index=df.index)
        out["ema_slow"] = pd.Series(ema_numba(c, self.ema_slow), index=df.index)
        out["atr"] = ta.volatility.AverageTrueRange(h, l, c, window=self.atr_period).average_true_range()
        out["adx"] = ta.trend.ADXIndicator(df["high"], df["low"], df["close"], window=self.adx_period).adx()

        # === Dynamic presets (fast loops) ===
        for p in self.p.ma_periods:
            out[f"ma{p}"] = df["close"].rolling(p).mean()
        for p in self.p.ema_periods:
            out[f"ema{p}"] = pd.Series(ema_numba(c, p), index=df.index)
        for p in self.p.wma_periods:
            out[f"wma{p}"] = self._wma(df["close"], p)
        for p in self.p.mavol_periods:
            out[f"mavol{p}"] = df["volume"].rolling(p).mean()
        for p in self.p.trix_periods:
            e1 = pd.Series(ema_numba(c, p), index=df.index)
            e2 = pd.Series(ema_numba(e1.to_numpy(), p), index=df.index)
            e3 = pd.Series(ema_numba(e2.to_numpy(), p), index=df.index)
            out[f"trix{p}"] = e3.pct_change() * 100.0

        # Stoch / KDJ
        stoch = ta.momentum.StochasticOscillator(df["high"], df["low"], df["close"])
        out["stoch_k"], out["stoch_d"] = stoch.stoch(), stoch.stoch_signal()
        out["kdj_k"], out["kdj_d"] = out["stoch_k"], out["stoch_d"]
        out["kdj_j"] = (3 * out["kdj_k"] - 2 * out["kdj_d"]).clip(0, 100)

        # MACD
        macd = ta.trend.MACD(close=df["close"]) 
        out["macd"], out["macd_signal"], out["macd_hist"] = macd.macd(), macd.macd_signal(), macd.macd_diff()

        # Volatility packs
        bb = ta.volatility.BollingerBands(close=df["close"], window=self.p.bb_window)
        out["bb_high"], out["bb_low"], out["bb_mid"] = bb.bollinger_hband(), bb.bollinger_lband(), bb.bollinger_mavg()
        kelt = ta.volatility.KeltnerChannel(h, l, c, window=self.p.kelt_window, original_version=True)
        out["kc_high"], out["kc_low"], out["kc_mid"] = kelt.keltner_channel_hband(), kelt.keltner_channel_lband(), kelt.keltner_channel_mband()

        # Volumeâ€‘based
        out["obv"] = ta.volume.OnBalanceVolumeIndicator(close=df["close"], volume=df["volume"]).on_balance_volume()
        out["mfi"] = ta.volume.MFIIndicator(h, l, c, v).money_flow_index()
        out["vwap"] = pd.Series(vwap_np(h, l, c, v), index=df.index)
        
        # Others
        out["cci"] = ta.trend.CCIIndicator(h, l, c).cci()
        out["sar"] = ta.trend.PSARIndicator(h, l, c).psar()
        try:
            ichi = ta.trend.IchimokuIndicator(h, l)
            out["ichi_base"], out["ichi_conv"] = ichi.ichimoku_base_line(), ichi.ichimoku_conversion_line()
        except Exception:
            out["ichi_base"], out["ichi_conv"] = np.nan, np.nan

        # Supertrend (custom JIT)
        st, trend, atr_rma = supertrend(h.astype(np.float64), l.astype(np.float64), c.astype(np.float64),
                                        period=self.p.supertrend_period, multiplier=self.p.supertrend_mult)
        out["supertrend"], out["supertrend_trend"], out["atr_rma"] = st, trend, atr_rma
        return out

# ----------------------------------------------------------------------------
# Risk management
# ----------------------------------------------------------------------------
@dataclass
class RiskConfig:
    account_equity_usdt: float = 1000.0
    max_risk_pct_per_trade: float = 0.015
    max_daily_drawdown_pct: float = 0.02
    leverage: int = 5
    min_notional_usdt: float = 10.0
    symbol_price_precision: int = 2
    symbol_qty_precision: int = 3
    tz_reset: str = "Europe/Zurich"

class RiskManager:
    def __init__(self, cfg: RiskConfig):
        self.cfg = cfg
        self.daily_pnl = 0.0
        self._current_date = None

    def _roll_date(self, now_utc: pd.Timestamp):
        tz = pytz.timezone(self.cfg.tz_reset)
        d = now_utc.tz_convert(tz).date()
        if self._current_date is None:
            self._current_date = d
        elif d != self._current_date:
            logger.info("[Risk] New day â†’ reset daily PnL")
            self._current_date = d
            self.daily_pnl = 0.0

    def update_realized_pnl(self, pnl: float, now_utc: pd.Timestamp):
        self._roll_date(now_utc)
        self.daily_pnl += pnl

    def hard_guard(self, now_utc: pd.Timestamp) -> bool:
        self._roll_date(now_utc)
        limit = -self.cfg.account_equity_usdt * self.cfg.max_daily_drawdown_pct
        allowed = self.daily_pnl > limit
        if not allowed:
            logger.warning("[Risk] Daily DD reached: pnl=%.2f limit=%.2f", self.daily_pnl, limit)
        return allowed

    def position_size(self, entry: float, sl: float) -> float:
        risk_usdt = self.cfg.account_equity_usdt * self.cfg.max_risk_pct_per_trade
        stop = max(1e-8, abs(entry - sl))
        qty = risk_usdt / stop * self.cfg.leverage
        qty = max(0.0, round(qty, self.cfg.symbol_qty_precision))
        # min notional (margin notionally = entry*qty/leverage)
        if (qty * entry / self.cfg.leverage) < self.cfg.min_notional_usdt:
            qty = round((self.cfg.min_notional_usdt * self.cfg.leverage) / entry, self.cfg.symbol_qty_precision)
        return qty

# ----------------------------------------------------------------------------
# Strategy (MTF + filters)
# ----------------------------------------------------------------------------
@dataclass
class StratConfig:
    symbol: str = "BTCUSDT"
    signal_tf: TF = "1m"
    trend_tf: TF = "15m"
    htf: TF = "1h"

    rsi_period: int = 14
    ema_fast: int = 21
    ema_slow: int = 50
    adx_period: int = 14
    atr_period: int = 14

    rsi_buy: int = 30
    rsi_sell: int = 70
    adx_min: float = 18.0

    atr_sl_mult: float = 1.5
    atr_tp_mult: float = 3.0

    cooldown_bars: int = 3
    min_atr_pct_of_price: float = 0.05 / 100.0

    session_start_utc: Optional[int] = None
    session_end_utc: Optional[int] = None

class StrategyEngine:
    def __init__(self, sc: StratConfig, rc: RiskConfig):
        self.sc = sc
        self.rm = RiskManager(rc)
        self.ind = IndicatorEngine(sc.rsi_period, sc.ema_fast, sc.ema_slow, sc.atr_period, sc.adx_period)

        def _mlen(n):
            return int(max(100, n*6))
        self.win: Dict[TF, WindowState] = {
            sc.signal_tf: WindowState(sc.signal_tf, _mlen(max(sc.ema_slow, sc.rsi_period, sc.atr_period))),
            sc.trend_tf:  WindowState(sc.trend_tf,  _mlen(max(sc.ema_slow, sc.adx_period))),
            sc.htf:       WindowState(sc.htf,       _mlen(sc.ema_slow*2)),
        }
        self.cooldown = 0
        self.last_signal: Optional[Side] = None

    def update_bar_close(self, tf: TF, bar: Bar) -> Optional[Signal]:
        bar.ts = as_utc(bar.ts)
        self.win[tf].append(bar)

        if tf != self.sc.signal_tf:
            return None

        if not self.rm.hard_guard(bar.ts):
            return None

        if self.sc.session_start_utc is not None and self.sc.session_end_utc is not None:
            h = bar.ts.hour
            if not (self.sc.session_start_utc <= h < self.sc.session_end_utc):
                return None

        sdf = self.win[self.sc.signal_tf].to_df()
        tdf = self.win[self.sc.trend_tf].to_df()
        hdf = self.win[self.sc.htf].to_df()
        if min(len(sdf), len(tdf), len(hdf)) < 60:
            return None

        sdf = self.ind.compute_all(sdf)
        last = sdf.iloc[-1]
        prev = sdf.iloc[-2]

        # Volatility floor
        if (last.atr / max(1e-8, last.close)) < self.sc.min_atr_pct_of_price:
            return None

        # Trend TF indicators
        tdf = self.ind.compute_all(tdf)
        t_last = tdf.iloc[-1]
        trend_up = (t_last.ema_fast > t_last.ema_slow) and (t_last.adx >= self.sc.adx_min)
        trend_dn = (t_last.ema_fast < t_last.ema_slow) and (t_last.adx >= self.sc.adx_min)

        # HTF bias via SMA200 slope
        hdf = self.win[self.sc.htf].to_df()
        hdf["sma200"] = hdf["close"].rolling(200).mean()
        if len(hdf) < 202:
            return None
        h_last, h_prev = hdf.iloc[-1], hdf.iloc[-2]
        htf_up = h_last.sma200 > h_prev.sma200
        htf_dn = h_last.sma200 < h_prev.sma200

        # Triggers: RSI exit from OB/OS + EMA_fast cross, supported by Supertrend trend
        long_trig = (prev.rsi < self.sc.rsi_buy) and (last.rsi >= self.sc.rsi_buy) \
                    and (prev.close < prev.ema_fast) and (last.close > last.ema_fast) \
                    and (int(last.supertrend_trend) == 1)
        short_trig = (prev.rsi > self.sc.rsi_sell) and (last.rsi <= self.sc.rsi_sell) \
                     and (prev.close > prev.ema_fast) and (last.close < last.ema_fast) \
                     and (int(last.supertrend_trend) == -1)

        want_long = long_trig and trend_up and htf_up
        want_short = short_trig and trend_dn and htf_dn

        if self.cooldown > 0:
            self.cooldown -= 1
            return None
        if self.last_signal == "LONG" and want_long:
            return None
        if self.last_signal == "SHORT" and want_short:
            return None

        if want_long:
            entry = round(float(last.close), self.rm.cfg.symbol_price_precision)
            sl = round(entry - self.sc.atr_sl_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            tp = round(entry + self.sc.atr_tp_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            qty = self.rm.position_size(entry, sl)
            if qty <= 0: return None
            self.last_signal = "LONG"; self.cooldown = self.sc.cooldown_bars
            return Signal(self.sc.symbol, "LONG", entry, sl, tp, qty,
                          reason="RSI up-cross + EMA_fast break + ST up; Trend/HTF aligned",
                          meta={"rsi": float(last.rsi), "atr": float(last.atr), "adx": float(t_last.adx)})

        if want_short:
            entry = round(float(last.close), self.rm.cfg.symbol_price_precision)
            sl = round(entry + self.sc.atr_sl_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            tp = round(entry - self.sc.atr_tp_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            qty = self.rm.position_size(entry, sl)
            if qty <= 0: return None
            self.last_signal = "SHORT"; self.cooldown = self.sc.cooldown_bars
            return Signal(self.sc.symbol, "SHORT", entry, sl, tp, qty,
                          reason="RSI down-cross + EMA_fast break + ST down; Trend/HTF aligned",
                          meta={"rsi": float(last.rsi), "atr": float(last.atr), "adx": float(t_last.adx)})
        return None

# Trailing stop utility -------------------------------------------------------
def atr_trailing_stop(side: Side, entry: float, best_price: float, atr: float,
                      be_rr: float = 1.0, trail_mult: float = 1.0) -> float:
    if side == "LONG":
        rr = (best_price - entry) / max(1e-8, atr)
        return max(entry, best_price - trail_mult * atr) if rr >= be_rr else entry - 1e-6
    else:
        rr = (entry - best_price) / max(1e-8, atr)
        return min(entry, best_price + trail_mult * atr) if rr >= be_rr else entry + 1e-6

# ----------------------------------------------------------------------------
# Binance Executor (Testnet/Mainnet) â€” bracket orders & settings
# ----------------------------------------------------------------------------
class BinanceExecutor:
    def __init__(self, api_key: str, api_secret: str, testnet: bool = True, dry_run: bool = True,
                 hedge_mode: bool = True, margin_type: str = "ISOLATED", leverage: int = 5,
                 working_type: str = "MARK_PRICE"):
        self.dry_run = dry_run
        self.testnet = testnet
        self.hedge_mode = hedge_mode
        self.margin_type = margin_type
        self.leverage = leverage
        self.working_type = working_type
        try:
            from binance.um_futures import UMFutures
        except Exception as e:
            logger.error("binance-connector missing: %s", e)
            UMFutures = None
        base_url = "https://testnet.binancefuture.com" if testnet else None
        self.client = None
        if UMFutures is not None:
            self.client = UMFutures(api_key=api_key, api_secret=api_secret, base_url=base_url)

    # Defensive account setup
    def ensure_account(self, symbol: str):
        if self.dry_run or self.client is None:
            return
        try:
            if self.hedge_mode:
                self.client.change_position_mode(dualSidePosition="true")
            else:
                self.client.change_position_mode(dualSidePosition="false")
        except Exception as e:
            logger.warning("position mode: %s", e)
        try:
            self.client.change_margin_type(symbol=symbol, marginType=self.margin_type)
        except Exception:
            pass
        try:
            self.client.change_leverage(symbol=symbol, leverage=self.leverage)
        except Exception:
            pass

    def place_bracket(self, symbol: str, side: Side, qty: float, entry: float, sl: float, tp: float):
        logger.info("[ORDER] %s %s qty=%.6f entry=%.4f sl=%.4f tp=%.4f", side, symbol, qty, entry, sl, tp)
        if self.dry_run or self.client is None:
            return {"dry_run": True}
        is_buy = side == "LONG"
        order_side = "BUY" if is_buy else "SELL"
        try:
            # Entry (limit as maker-ish, postOnly yoksa GTC limit; istersen market de atabilirsin)
            self.client.new_order(symbol=symbol, side=order_side, type="LIMIT",
                                  quantity=str(qty), price=str(entry), timeInForce="GTC",
                                  reduceOnly="false")
            # SL
            self.client.new_order(symbol=symbol, side=("SELL" if is_buy else "BUY"), type="STOP_MARKET",
                                  stopPrice=str(sl), closePosition="true", workingType=self.working_type)
            # TP
            self.client.new_order(symbol=symbol, side=("SELL" if is_buy else "BUY"), type="TAKE_PROFIT_MARKET",
                                  stopPrice=str(tp), closePosition="true", workingType=self.working_type)
        except Exception as e:
            logger.error("order error: %s", e)

# ----------------------------------------------------------------------------
# App wiring (example loop; integrate with your WS feed)
# ----------------------------------------------------------------------------
class App:
    def __init__(self, symbols: List[str], sc: StratConfig, rc: RiskConfig, execu: BinanceExecutor):
        self.symbols = symbols
        self.sc = sc
        self.rc = rc
        self.exec = execu
        self.engines: Dict[str, StrategyEngine] = {s: StrategyEngine(StratConfig(symbol=s, signal_tf=sc.signal_tf, trend_tf=sc.trend_tf, htf=sc.htf,
                                                                                 rsi_period=sc.rsi_period, ema_fast=sc.ema_fast, ema_slow=sc.ema_slow,
                                                                                 adx_period=sc.adx_period, atr_period=sc.atr_period,
                                                                                 rsi_buy=sc.rsi_buy, rsi_sell=sc.rsi_sell, adx_min=sc.adx_min,
                                                                                 atr_sl_mult=sc.atr_sl_mult, atr_tp_mult=sc.atr_tp_mult,
                                                                                 cooldown_bars=sc.cooldown_bars, min_atr_pct_of_price=sc.min_atr_pct_of_price,
                                                                                 session_start_utc=sc.session_start_utc, session_end_utc=sc.session_end_utc), rc)
                                            for s in symbols}

    def on_bar(self, symbol: str, tf: TF, bar: Bar):
        sig = self.engines[symbol].update_bar_close(tf, bar)
        if sig:
            self.exec.ensure_account(symbol)
            self.exec.place_bracket(symbol, sig.side, sig.size, sig.price, sig.sl, sig.tp)

# ----------------------------------------------------------------------------
# CLI / bootstrap (offline demo for structure)
# ----------------------------------------------------------------------------
if __name__ == "__main__":
    load_dotenv()
    api_key = os.getenv("BINANCE_API_KEY", "")
    api_secret = os.getenv("BINANCE_API_SECRET", "")
    testnet = os.getenv("USE_TESTNET", "true").lower() == "true"
    hedge_mode = os.getenv("BINANCE_HEDGE_MODE", "true").lower() == "true"
    margin_type = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED")
    leverage = int(os.getenv("BINANCE_LEVERAGE", "5"))
    working_type = os.getenv("WORKING_TYPE", "MARK_PRICE")
    dry_run = os.getenv("DRY_RUN", "true").lower() == "true"

    symbols = [s.strip() for s in os.getenv("SYMBOLS", "BTCUSDT").split(",") if s.strip()]

    sc = StratConfig(symbol=symbols[0], signal_tf="1m", trend_tf="15m", htf="1h")
    rc = RiskConfig(account_equity_usdt=float(os.getenv("ACCOUNT_EQUITY", "5000")),
                    leverage=leverage,
                    min_notional_usdt=float(os.getenv("MIN_NOTIONAL_USDT", "10")))

    executor = BinanceExecutor(api_key, api_secret, testnet, dry_run, hedge_mode, margin_type, leverage, working_type)
    app = App(symbols, sc, rc, executor)

    # NOTE: This is a placeholder demonstration loop. In production, feed CLOSED bars from your data source.
    # Example: iterate over a CSV of candles and call app.on_bar(symbol, tf, Bar(...)).
    logger.info("Ultra Elite engine bootstrapped. Wire your data feed to app.on_bar().")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ultura_elite_engine_full.py
from __future__ import annotations
"""
Ultra Elite Strategy Engine â€” Full Stack (MTF + All Indicators + Risk + Binance Testnet)
--------------------------------------------------------------------------------------
- Multiâ€‘timeframe (signal / trend / HTF) with CLOSEDâ€‘bar signals (no repaint)
- Broad indicator pack (RSI, Stoch, MACD, EMA/SMA, Bollinger, Keltner, ATR, ADX,
  CCI, MFI, OBV, VWAP, Ichimoku, SAR, Supertrend) computed efficiently
- ATR SL/TP + breakeven + ATR trailing; volatility/chop filters; cooldown; session filter
- RiskManager: perâ€‘trade risk, min notional guard, daily max drawdown (Zurich reset)
- Fast deques, vectorized calc; optional Numba JIT for EMA & Supertrend
- Binance Futures Testnet executor (isolated, leverage, hedge mode, reduceâ€‘only),
  bracket orders (SL/TP), markâ€‘price working type, DRYâ€‘RUN support

Requires: python>=3.10, pandas, numpy, ta, pytz, python-dotenv, binance-connector, websocket-client, (optional) numba
Install:  pip install "pandas>=2" numpy ta pytz python-dotenv "binance-connector>=3" websocket-client numba

.env template (example):
BINANCE_API_KEY=your_testnet_key_here
BINANCE_API_SECRET=your_testnet_secret_here
USE_TESTNET=true
SYMBOLS=BTCUSDT,DOGEUSDT
BINANCE_HEDGE_MODE=true
BINANCE_MARGIN_TYPE=ISOLATED
BINANCE_LEVERAGE=5
RISK_MAX_DAILY_DRAWDOWN=0.02
RISK_MAX_RISK_PCT_PER_TRADE=0.015
MIN_NOTIONAL_USDT=10
WORKING_TYPE=MARK_PRICE   # MARK_PRICE | CONTRACT_PRICE
DRY_RUN=true

Run example:
python ultra_elite_engine.py --symbols BTCUSDT DOGEUSDT --signal_tf 1m --trend_tf 15m --htf 1h --dry-run
"""

from dataclasses import dataclass, field
from collections import deque
from typing import Deque, Dict, Optional, Literal, Tuple, List
import os
import math
import pandas as pd
import numpy as np
import pytz
import ta
import time
import logging
from datetime import datetime, timezone
from dotenv import load_dotenv

# Optional Numba for speed ----------------------------------------------------
try:
    from numba import njit
except Exception:  # pragma: no cover
    def njit(*args, **kwargs):
        def wrap(fn):
            return fn
        return wrap

# ----------------------------------------------------------------------------
# Logging
# ----------------------------------------------------------------------------
logger = logging.getLogger("UltraElite")
logger.setLevel(logging.INFO)
if not logger.handlers:
    ch = logging.StreamHandler()
    ch.setFormatter(logging.Formatter("%(asctime)s | %(levelname)s | %(message)s"))
    logger.addHandler(ch)

TF = Literal["1m","3m","5m","15m","30m","1h","2h","4h","6h","8h","12h","1d","3d","1w","1M"]
Side = Literal["LONG","SHORT"]

TF_TO_SEC = {"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"2h":7200,"4h":14400,"6h":21600,"8h":28800,"12h":43200,"1d":86400,"3d":259200,"1w":604800,"1M":2592000}  # 1Mâ‰ˆ30d for aggregation only

# ----------------------------------------------------------------------------
# Data structures
# ----------------------------------------------------------------------------
@dataclass
class Bar:
    ts: pd.Timestamp  # bar close time UTC
    open: float
    high: float
    low: float
    close: float
    volume: float = 0.0

@dataclass
class Signal:
    symbol: str
    side: Side
    price: float
    sl: float
    tp: float
    size: float
    reason: str
    meta: dict = field(default_factory=dict)

# ----------------------------------------------------------------------------
# Helpers
# ----------------------------------------------------------------------------

def as_utc(ts) -> pd.Timestamp:
    if isinstance(ts, pd.Timestamp):
        if ts.tzinfo is None:
            return ts.tz_localize("UTC")
        return ts.tz_convert("UTC")
    # assume seconds since epoch
    return pd.to_datetime(ts, unit="s", utc=True)

# JIT EMA (fast incremental)
@njit(cache=True)
def ema_numba(vals: np.ndarray, period: int) -> np.ndarray:
    out = np.empty_like(vals)
    if len(vals) == 0:
        return out
    alpha = 2.0 / (period + 1.0)
    out[0] = vals[0]
    for i in range(1, len(vals)):
        out[i] = alpha * vals[i] + (1.0 - alpha) * out[i - 1]
    return out

# Supertrend (Numbaâ€‘friendly)
@njit(cache=True)
def supertrend(high, low, close, period=10, multiplier=3.0):
    n = len(close)
    atr = np.empty(n)
    atr[:] = np.nan

    # TR & ATR (RMA)
    tr = np.empty(n)
    tr[0] = high[0] - low[0]
    for i in range(1, n):
        hl = high[i] - low[i]
        hc = abs(high[i] - close[i-1])
        lc = abs(low[i] - close[i-1])
        tr[i] = hl if (hl >= hc and hl >= lc) else (hc if hc >= lc else lc)
    # RMA
    alpha = 1.0/period
    atr[period-1] = np.mean(tr[:period])
    for i in range(period, n):
        atr[i] = (atr[i-1] * (period-1) + tr[i]) / period

    upper = np.empty(n); lower = np.empty(n)
    upper[:] = np.nan; lower[:] = np.nan
    st = np.empty(n); st[:] = np.nan
    trend = np.empty(n); trend[:] = 1

    for i in range(n):
        if np.isnan(atr[i]):
            continue
        basic_upper = (high[i] + low[i]) / 2.0 + multiplier * atr[i]
        basic_lower = (high[i] + low[i]) / 2.0 - multiplier * atr[i]
        if i == 0:
            upper[i] = basic_upper
            lower[i] = basic_lower
            st[i] = basic_lower
            trend[i] = 1
            continue
        upper[i] = basic_upper if (basic_upper < upper[i-1] or close[i-1] > upper[i-1]) else upper[i-1]
        lower[i] = basic_lower if (basic_lower > lower[i-1] or close[i-1] < lower[i-1]) else lower[i-1]
        if close[i] > upper[i-1]:
            trend[i] = 1
        elif close[i] < lower[i-1]:
            trend[i] = -1
        else:
            trend[i] = trend[i-1]
        st[i] = lower[i] if trend[i] == 1 else upper[i]
    return st, trend, atr

# VWAP helper

def vwap_np(high, low, close, volume):
    tp = (high + low + close) / 3.0
    cum_v = np.cumsum(volume)
    cum_tp_v = np.cumsum(tp * volume)
    vwap = cum_tp_v / np.maximum(cum_v, 1e-12)
    return vwap

# ----------------------------------------------------------------------------
# Window state & Aggregators
# ----------------------------------------------------------------------------
@dataclass
class WindowState:
    tf: TF
    maxlen: int
    rows: Deque[Tuple[pd.Timestamp, float, float, float, float, float]] = field(default_factory=deque)

    def append(self, bar: Bar):
        if len(self.rows) == self.maxlen:
            self.rows.popleft()
        self.rows.append((as_utc(bar.ts), bar.open, bar.high, bar.low, bar.close, bar.volume))

    def to_df(self) -> pd.DataFrame:
        return pd.DataFrame(self.rows, columns=["ts","open","high","low","close","volume"])  

# Tick â†’ OHLCV aggregator for a single TF
class TickAggregator:
    def __init__(self, tf: TF):
        self.tf = tf
        self.period = TF_TO_SEC[tf]
        self.reset()

    def reset(self):
        self._open = None; self._high = -math.inf; self._low = math.inf; self._vol = 0.0; self._start = None

    def update(self, ts_sec: float, price: float, qty: float) -> Optional[Bar]:
        # ts_sec: seconds (float) epoch
        if self._start is None:
            self._start = int(ts_sec // self.period) * self.period
            self._open = price
            self._high = price
            self._low = price
        elif ts_sec >= self._start + self.period:
            # close current bar
            bar = Bar(ts=as_utc(self._start + self.period), open=self._open, high=self._high,
                      low=self._low, close=price, volume=self._vol)
            # start new
            self.reset()
            self._start = int(ts_sec // self.period) * self.period
            self._open = price; self._high = price; self._low = price; self._vol = qty
            return bar
        # update inâ€‘bar
        if price > self._high: self._high = price
        if price < self._low: self._low = price
        self._vol += qty
        return None

# ----------------------------------------------------------------------------
# Indicator Engine (broad coverage)
# ----------------------------------------------------------------------------
@dataclass
class IndicatorParams:
    # dynamic + presets together
    ma_periods: Tuple[int, ...] = (7, 25, 99)
    ema_periods: Tuple[int, ...] = (7, 21, 50, 99)
    wma_periods: Tuple[int, ...] = (7, 25)
    mavol_periods: Tuple[int, ...] = (7, 14)
    trix_periods: Tuple[int, ...] = (9,)
    bb_window: int = 20
    kelt_window: int = 20
    kelt_atr: int = 10
    supertrend_period: int = 10
    supertrend_mult: float = 3.0

class IndicatorEngine:
    def __init__(self, rsi_period=14, ema_fast=21, ema_slow=50, atr_period=14, adx_period=14,
                 params: IndicatorParams | None = None):
        self.rsi_period = rsi_period
        self.ema_fast = ema_fast
        self.ema_slow = ema_slow
        self.atr_period = atr_period
        self.adx_period = adx_period
        self.p = params or IndicatorParams()

    def _wma(self, x: pd.Series, period: int) -> pd.Series:
        # weighted moving average (linear weights 1..n)
        if period <= 1:
            return x
        w = np.arange(1, period + 1)
        return x.rolling(period).apply(lambda a: np.dot(a, w) / w.sum(), raw=True)

    def _ema_series(self, arr: np.ndarray, p: int, index) -> pd.Series:
        return pd.Series(ema_numba(arr, p), index=index)

    def _ema(self, s: pd.Series, p: int) -> pd.Series:
        return self._ema_series(s.to_numpy(), p, s.index)

    def compute_all(self, df: pd.DataFrame) -> pd.DataFrame:
        c = df["close"].to_numpy()
        c = df["close"].to_numpy()
        h = df["high"].to_numpy()
        l = df["low"].to_numpy()
        v = df["volume"].to_numpy()

        out = df.copy()
        # === Core single-pass arrays ===
        out["rsi"] = ta.momentum.RSIIndicator(close=df["close"], window=self.rsi_period).rsi()
        out["ema_fast"] = pd.Series(ema_numba(c, self.ema_fast), index=df.index)
        out["ema_slow"] = pd.Series(ema_numba(c, self.ema_slow), index=df.index)
        out["atr"] = ta.volatility.AverageTrueRange(h, l, c, window=self.atr_period).average_true_range()
        out["adx"] = ta.trend.ADXIndicator(df["high"], df["low"], df["close"], window=self.adx_period).adx()

        # === Dynamic presets (fast loops) ===
        for p in self.p.ma_periods:
            out[f"ma{p}"] = df["close"].rolling(p).mean()
        for p in self.p.ema_periods:
            out[f"ema{p}"] = pd.Series(ema_numba(c, p), index=df.index)
        for p in self.p.wma_periods:
            out[f"wma{p}"] = self._wma(df["close"], p)
        for p in self.p.mavol_periods:
            out[f"mavol{p}"] = df["volume"].rolling(p).mean()
        for p in self.p.trix_periods:
            e1 = pd.Series(ema_numba(c, p), index=df.index)
            e2 = pd.Series(ema_numba(e1.to_numpy(), p), index=df.index)
            e3 = pd.Series(ema_numba(e2.to_numpy(), p), index=df.index)
            out[f"trix{p}"] = e3.pct_change() * 100.0

        # Stoch / KDJ
        stoch = ta.momentum.StochasticOscillator(df["high"], df["low"], df["close"])
        out["stoch_k"], out["stoch_d"] = stoch.stoch(), stoch.stoch_signal()
        out["kdj_k"], out["kdj_d"] = out["stoch_k"], out["stoch_d"]
        out["kdj_j"] = (3 * out["kdj_k"] - 2 * out["kdj_d"]).clip(0, 100)

        # MACD
        macd = ta.trend.MACD(close=df["close"]) 
        out["macd"], out["macd_signal"], out["macd_hist"] = macd.macd(), macd.macd_signal(), macd.macd_diff()

        # Williams %R
        try:
            wr = ta.momentum.WilliamsRIndicator(df["high"], df["low"], df["close"], lbp=14)
            out["wr14"] = wr.williams_r()
        except Exception:
            out["wr14"] = np.nan

        # TRIX signal (EMA of TRIX)
        if "trix9" in out.columns:
            out["trix9_signal"] = self._ema(out["trix9"].fillna(0), 9)
            out["trix9_hist"] = out["trix9"] - out["trix9_signal"]

        # Volatility packs
        bb = ta.volatility.BollingerBands(close=df["close"], window=self.p.bb_window)
        out["bb_high"], out["bb_low"], out["bb_mid"] = bb.bollinger_hband(), bb.bollinger_lband(), bb.bollinger_mavg()
        kelt = ta.volatility.KeltnerChannel(h, l, c, window=self.p.kelt_window, original_version=True)
        out["kc_high"], out["kc_low"], out["kc_mid"] = kelt.keltner_channel_hband(), kelt.keltner_channel_lband(), kelt.keltner_channel_mband()

        # Volumeâ€‘based
        out["obv"] = ta.volume.OnBalanceVolumeIndicator(close=df["close"], volume=df["volume"]).on_balance_volume()
        out["mfi"] = ta.volume.MFIIndicator(h, l, c, v).money_flow_index()
        out["vwap"] = pd.Series(vwap_np(h, l, c, v), index=df.index)
        
        # Others
        out["cci"] = ta.trend.CCIIndicator(h, l, c).cci()
        out["sar"] = ta.trend.PSARIndicator(h, l, c).psar()
        try:
            ichi = ta.trend.IchimokuIndicator(h, l)
            out["ichi_base"], out["ichi_conv"] = ichi.ichimoku_base_line(), ichi.ichimoku_conversion_line()
        except Exception:
            out["ichi_base"], out["ichi_conv"] = np.nan, np.nan

        # Supertrend (custom JIT)
        st, trend, atr_rma = supertrend(h.astype(np.float64), l.astype(np.float64), c.astype(np.float64),
                                        period=self.p.supertrend_period, multiplier=self.p.supertrend_mult)
        out["supertrend"], out["supertrend_trend"], out["atr_rma"] = st, trend, atr_rma
        return out

# ----------------------------------------------------------------------------
# Risk management
# ----------------------------------------------------------------------------
@dataclass
class RiskConfig:
    account_equity_usdt: float = 1000.0
    max_risk_pct_per_trade: float = 0.015
    max_daily_drawdown_pct: float = 0.02
    leverage: int = 5
    min_notional_usdt: float = 10.0
    symbol_price_precision: int = 2
    symbol_qty_precision: int = 3
    tz_reset: str = "Europe/Zurich"

class RiskManager:
    def __init__(self, cfg: RiskConfig):
        self.cfg = cfg
        self.daily_pnl = 0.0
        self._current_date = None

    def _roll_date(self, now_utc: pd.Timestamp):
        tz = pytz.timezone(self.cfg.tz_reset)
        d = now_utc.tz_convert(tz).date()
        if self._current_date is None:
            self._current_date = d
        elif d != self._current_date:
            logger.info("[Risk] New day â†’ reset daily PnL")
            self._current_date = d
            self.daily_pnl = 0.0

    def update_realized_pnl(self, pnl: float, now_utc: pd.Timestamp):
        self._roll_date(now_utc)
        self.daily_pnl += pnl

    def hard_guard(self, now_utc: pd.Timestamp) -> bool:
        self._roll_date(now_utc)
        limit = -self.cfg.account_equity_usdt * self.cfg.max_daily_drawdown_pct
        allowed = self.daily_pnl > limit
        if not allowed:
            logger.warning("[Risk] Daily DD reached: pnl=%.2f limit=%.2f", self.daily_pnl, limit)
        return allowed

    def position_size(self, entry: float, sl: float) -> float:
        risk_usdt = self.cfg.account_equity_usdt * self.cfg.max_risk_pct_per_trade
        stop = max(1e-8, abs(entry - sl))
        qty = risk_usdt / stop * self.cfg.leverage
        qty = max(0.0, round(qty, self.cfg.symbol_qty_precision))
        # min notional (margin notionally = entry*qty/leverage)
        if (qty * entry / self.cfg.leverage) < self.cfg.min_notional_usdt:
            qty = round((self.cfg.min_notional_usdt * self.cfg.leverage) / entry, self.cfg.symbol_qty_precision)
        return qty

# ----------------------------------------------------------------------------
# Strategy (MTF + filters)
# ----------------------------------------------------------------------------
@dataclass
class StratConfig:
    symbol: str = "BTCUSDT"
    signal_tf: TF = "1m"
    trend_tf: TF = "15m"
    htf: TF = "1h"

    rsi_period: int = 14
    ema_fast: int = 21
    ema_slow: int = 50
    adx_period: int = 14
    atr_period: int = 14

    rsi_buy: int = 30
    rsi_sell: int = 70
    adx_min: float = 18.0

    atr_sl_mult: float = 1.5
    atr_tp_mult: float = 3.0

    cooldown_bars: int = 3
    min_atr_pct_of_price: float = 0.05 / 100.0

    session_start_utc: Optional[int] = None
    session_end_utc: Optional[int] = None

    # Extra trigger toggles & thresholds
    use_kdj: bool = True
    use_wr: bool = True
    use_trix: bool = True
    wr_buy: float = -80.0
    wr_sell: float = -20.0

class StrategyEngine:
    def __init__(self, sc: StratConfig, rc: RiskConfig):
        self.sc = sc
        self.rm = RiskManager(rc)
        self.ind = IndicatorEngine(sc.rsi_period, sc.ema_fast, sc.ema_slow, sc.atr_period, sc.adx_period)

        def _mlen(n):
            return int(max(100, n*6))
        self.win: Dict[TF, WindowState] = {
            sc.signal_tf: WindowState(sc.signal_tf, _mlen(max(sc.ema_slow, sc.rsi_period, sc.atr_period))),
            sc.trend_tf:  WindowState(sc.trend_tf,  _mlen(max(sc.ema_slow, sc.adx_period))),
            sc.htf:       WindowState(sc.htf,       _mlen(sc.ema_slow*2)),
        }
        self.cooldown = 0
        self.last_signal: Optional[Side] = None

    def update_bar_close(self, tf: TF, bar: Bar) -> Optional[Signal]:
        bar.ts = as_utc(bar.ts)
        self.win[tf].append(bar)

        if tf != self.sc.signal_tf:
            return None

        if not self.rm.hard_guard(bar.ts):
            return None

        if self.sc.session_start_utc is not None and self.sc.session_end_utc is not None:
            h = bar.ts.hour
            if not (self.sc.session_start_utc <= h < self.sc.session_end_utc):
                return None

        sdf = self.win[self.sc.signal_tf].to_df()
        tdf = self.win[self.sc.trend_tf].to_df()
        hdf = self.win[self.sc.htf].to_df()
        if min(len(sdf), len(tdf), len(hdf)) < 60:
            return None

        sdf = self.ind.compute_all(sdf)
        last = sdf.iloc[-1]
        prev = sdf.iloc[-2]

        # Volatility floor
        if (last.atr / max(1e-8, last.close)) < self.sc.min_atr_pct_of_price:
            return None

        # Trend TF indicators
        tdf = self.ind.compute_all(tdf)
        t_last = tdf.iloc[-1]
        trend_up = (t_last.ema_fast > t_last.ema_slow) and (t_last.adx >= self.sc.adx_min)
        trend_dn = (t_last.ema_fast < t_last.ema_slow) and (t_last.adx >= self.sc.adx_min)

        # HTF bias via SMA200 slope
        hdf = self.win[self.sc.htf].to_df()
        hdf["sma200"] = hdf["close"].rolling(200).mean()
        if len(hdf) < 202:
            return None
        h_last, h_prev = hdf.iloc[-1], hdf.iloc[-2]
        htf_up = h_last.sma200 > h_prev.sma200
        htf_dn = h_last.sma200 < h_prev.sma200

        # Triggers: RSI exit from OB/OS + EMA_fast cross, supported by Supertrend trend
        long_trig = (prev.rsi < self.sc.rsi_buy) and (last.rsi >= self.sc.rsi_buy) \
                    and (prev.close < prev.ema_fast) and (last.close > last.ema_fast) \
                    and (int(last.supertrend_trend) == 1)
        short_trig = (prev.rsi > self.sc.rsi_sell) and (last.rsi <= self.sc.rsi_sell) \
                     and (prev.close > prev.ema_fast) and (last.close < last.ema_fast) \
                     and (int(last.supertrend_trend) == -1)

        # Optional extra triggers: KDJ cross / WR thresholds / TRIX cross
        if self.sc.use_kdj:
            kdj_long = (prev.kdj_k < prev.kdj_d) and (last.kdj_k > last.kdj_d) and (last.kdj_k < 40)
            kdj_short = (prev.kdj_k > prev.kdj_d) and (last.kdj_k < last.kdj_d) and (last.kdj_k > 60)
            long_trig = long_trig or kdj_long
            short_trig = short_trig or kdj_short
        if self.sc.use_wr and not np.isnan(last.get("wr14", np.nan)):
            wr_long = last.wr14 <= self.sc.wr_buy
            wr_short = last.wr14 >= self.sc.wr_sell
            long_trig = long_trig or wr_long
            short_trig = short_trig or wr_short
        if self.sc.use_trix and "trix9_signal" in sdf.columns:
            trix_long = (prev.trix9 < prev.trix9_signal) and (last.trix9 > last.trix9_signal)
            trix_short = (prev.trix9 > prev.trix9_signal) and (last.trix9 < last.trix9_signal)
            long_trig = long_trig or trix_long
            short_trig = short_trig or trix_short

        want_long = long_trig and trend_up and htf_up
        want_short = short_trig and trend_dn and htf_dn

        if self.cooldown > 0:
            self.cooldown -= 1
            return None
        if self.last_signal == "LONG" and want_long:
            return None
        if self.last_signal == "SHORT" and want_short:
            return None

        if want_long:
            entry = round(float(last.close), self.rm.cfg.symbol_price_precision)
            sl = round(entry - self.sc.atr_sl_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            tp = round(entry + self.sc.atr_tp_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            qty = self.rm.position_size(entry, sl)
            if qty <= 0: return None
            self.last_signal = "LONG"; self.cooldown = self.sc.cooldown_bars
            return Signal(self.sc.symbol, "LONG", entry, sl, tp, qty,
                          reason="RSI up-cross + EMA_fast break + ST up; Trend/HTF aligned",
                          meta={"rsi": float(last.rsi), "atr": float(last.atr), "adx": float(t_last.adx)})

        if want_short:
            entry = round(float(last.close), self.rm.cfg.symbol_price_precision)
            sl = round(entry + self.sc.atr_sl_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            tp = round(entry - self.sc.atr_tp_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            qty = self.rm.position_size(entry, sl)
            if qty <= 0: return None
            self.last_signal = "SHORT"; self.cooldown = self.sc.cooldown_bars
            return Signal(self.sc.symbol, "SHORT", entry, sl, tp, qty,
                          reason="RSI down-cross + EMA_fast break + ST down; Trend/HTF aligned",
                          meta={"rsi": float(last.rsi), "atr": float(last.atr), "adx": float(t_last.adx)})
        return None

# Trailing stop utility -------------------------------------------------------
def atr_trailing_stop(side: Side, entry: float, best_price: float, atr: float,
                      be_rr: float = 1.0, trail_mult: float = 1.0) -> float:
    if side == "LONG":
        rr = (best_price - entry) / max(1e-8, atr)
        return max(entry, best_price - trail_mult * atr) if rr >= be_rr else entry - 1e-6
    else:
        rr = (entry - best_price) / max(1e-8, atr)
        return min(entry, best_price + trail_mult * atr) if rr >= be_rr else entry + 1e-6

# ----------------------------------------------------------------------------
# Binance Executor (Testnet/Mainnet) â€” bracket orders & settings
# ----------------------------------------------------------------------------
class BinanceExecutor:
    def __init__(self, api_key: str, api_secret: str, testnet: bool = True, dry_run: bool = True,
                 hedge_mode: bool = True, margin_type: str = "ISOLATED", leverage: int = 5,
                 working_type: str = "MARK_PRICE"):
        self.dry_run = dry_run
        self.testnet = testnet
        self.hedge_mode = hedge_mode
        self.margin_type = margin_type
        self.leverage = leverage
        self.working_type = working_type
        try:
            from binance.um_futures import UMFutures
        except Exception as e:
            logger.error("binance-connector missing: %s", e)
            UMFutures = None
        base_url = "https://testnet.binancefuture.com" if testnet else None
        self.client = None
        if UMFutures is not None:
            self.client = UMFutures(api_key=api_key, api_secret=api_secret, base_url=base_url)

    # Defensive account setup
    def ensure_account(self, symbol: str):
        if self.dry_run or self.client is None:
            return
        try:
            if self.hedge_mode:
                self.client.change_position_mode(dualSidePosition="true")
            else:
                self.client.change_position_mode(dualSidePosition="false")
        except Exception as e:
            logger.warning("position mode: %s", e)
        try:
            self.client.change_margin_type(symbol=symbol, marginType=self.margin_type)
        except Exception:
            pass
        try:
            self.client.change_leverage(symbol=symbol, leverage=self.leverage)
        except Exception:
            pass

    def place_bracket(self, symbol: str, side: Side, qty: float, entry: float, sl: float, tp: float):
        logger.info("[ORDER] %s %s qty=%.6f entry=%.4f sl=%.4f tp=%.4f", side, symbol, qty, entry, sl, tp)
        if self.dry_run or self.client is None:
            return {"dry_run": True}
        is_buy = side == "LONG"
        order_side = "BUY" if is_buy else "SELL"
        try:
            self.client.new_order(symbol=symbol, side=order_side, type="LIMIT",
                                  quantity=str(qty), price=str(entry), timeInForce="GTC",
                                  reduceOnly="false")
            # SL / TP as closePosition true (brackets)
            self.client.new_order(symbol=symbol, side=("SELL" if is_buy else "BUY"), type="STOP_MARKET",
                                  stopPrice=str(sl), closePosition="true", workingType=self.working_type)
            self.client.new_order(symbol=symbol, side=("SELL" if is_buy else "BUY"), type="TAKE_PROFIT_MARKET",
                                  stopPrice=str(tp), closePosition="true", workingType=self.working_type)
        except Exception as e:
            logger.error("order error: %s", e)

    def update_trailing_stop(self, symbol: str, side: Side, new_stop: float):
        """Naive trailing: place a fresh STOP_MARKET closePosition (some venues allow multiple). 
        In production you may cancel/replace previous stop to avoid duplicates."""
        logger.info("[TRAIL] %s %s new_stop=%.4f", side, symbol, new_stop)
        if self.dry_run or self.client is None:
            return {"dry_run": True}
        try:
            self.client.new_order(symbol=symbol, side=("SELL" if side == "LONG" else "BUY"), type="STOP_MARKET",
                                  stopPrice=str(new_stop), closePosition="true", workingType=self.working_type)
        except Exception as e:
            logger.error("trail error: %s", e)

# ----------------------------------------------------------------------------
# App wiring (example loop; integrate with your WS feed)
# ----------------------------------------------------------------------------
class App:
    def __init__(self, symbols: List[str], sc: StratConfig, rc: RiskConfig, execu: BinanceExecutor):
        self.symbols = symbols
        self.sc = sc
        self.rc = rc
        self.exec = execu
        self.engines: Dict[str, StrategyEngine] = {s: StrategyEngine(StratConfig(symbol=s, signal_tf=sc.signal_tf, trend_tf=sc.trend_tf, htf=sc.htf,
                                                                                 rsi_period=sc.rsi_period, ema_fast=sc.ema_fast, ema_slow=sc.ema_slow,
                                                                                 adx_period=sc.adx_period, atr_period=sc.atr_period,
                                                                                 rsi_buy=sc.rsi_buy, rsi_sell=sc.rsi_sell, adx_min=sc.adx_min,
                                                                                 atr_sl_mult=sc.atr_sl_mult, atr_tp_mult=sc.atr_tp_mult,
                                                                                 cooldown_bars=sc.cooldown_bars, min_atr_pct_of_price=sc.min_atr_pct_of_price,
                                                                                 session_start_utc=sc.session_start_utc, session_end_utc=sc.session_end_utc,
                                                                                 use_kdj=sc.use_kdj, use_wr=sc.use_wr, use_trix=sc.use_trix,
                                                                                 wr_buy=sc.wr_buy, wr_sell=sc.wr_sell), rc)
                                            for s in symbols}
        # Simple position tracker for trailing
        self.positions: Dict[str, Dict[str, dict]] = {s: {"LONG": None, "SHORT": None} for s in symbols}

    def on_bar(self, symbol: str, tf: TF, bar: Bar):
        sig = self.engines[symbol].update_bar_close(tf, bar)
        if sig:
            self.exec.ensure_account(symbol)
            self.exec.place_bracket(symbol, sig.side, sig.size, sig.price, sig.sl, sig.tp)

# ----------------------------------------------------------------------------
# Binance WebSocket streamer (klines, closed-only) -> feeds App.on_bar
# ----------------------------------------------------------------------------
class BinanceWS:
    def __init__(self, symbols: List[str], tfs: List[TF], app: App, testnet: bool = True):
        self.symbols = [s.lower() for s in symbols]  # binance stream wants lowercase
        self.tfs = tfs
        self.app = app
        self.testnet = testnet
        self.ws_apps: List[object] = []

    def _make_urls(self) -> List[str]:
        base = "wss://stream.binancefuture.com" if self.testnet else "wss://fstream.binance.com"
        streams = [f"{sym}@kline_{tf}" for sym in self.symbols for tf in self.tfs]
        MAX = 200
        urls = []
        for i in range(0, len(streams), MAX):
            chunk = "/".join(streams[i:i+MAX])
            urls.append(f"{base}/stream?streams={chunk}")
        return urls

    def start(self):
        import json, threading
        import websocket

        def make_app(url):
            def on_message(ws, message):
                try:
                    msg = json.loads(message)
                    if "data" not in msg:
                        return
                    d = msg["data"]
                    if d.get("e") != "kline":
                        return
                    k = d.get("k", {})
                    if not k.get("x", False):
                        return
                    symbol = d.get("s", "").upper()
                    tf = k.get("i")
                    bar = Bar(
                        ts=as_utc(k.get("T")/1000),
                        open=float(k.get("o")),
                        high=float(k.get("h")),
                        low=float(k.get("l")),
                        close=float(k.get("c")),
                        volume=float(k.get("q", 0.0)),
                    )
                    self.app.on_bar(symbol, tf, bar)
                except Exception as e:
                    logger.error("WS message error: %s", e)
            def on_error(ws, error):
                logger.error("WS error: %s", error)
            def on_close(ws, code, msg):
                logger.warning("WS closed: %s %s", code, msg)
            def on_open(ws):
                logger.info("WS connected: %s", url)
            return websocket.WebSocketApp(url, on_message=on_message, on_error=on_error, on_close=on_close, on_open=on_open)

        urls = self._make_urls()
        for url in urls:
            app = make_app(url)
            t = threading.Thread(target=lambda: app.run_forever(ping_interval=20, ping_timeout=10), daemon=True)
            t.start()
            self.ws_apps.append(app)
        while True:
            time.sleep(60)

# ----------------------------------------------------------------------------
# Backtest (CSV klines) â€” simple PnL with SL/TP & trailing
# ----------------------------------------------------------------------------
class Backtester:
    def __init__(self, sc: StratConfig, rc: RiskConfig):
        self.engine = StrategyEngine(sc, rc)

    def run_csv(self, path: str, tf: TF) -> Dict[str, float]:
        df = pd.read_csv(path)
        # Expect columns: ts/open/high/low/close/volume (ts in seconds or ISO)
        if 'ts' in df.columns:
            try:
                ts = pd.to_datetime(df['ts'], utc=True)
            except Exception:
                ts = pd.to_datetime(df['ts'], unit='s', utc=True)
        else:
            ts = pd.to_datetime(df['close_time'], unit='ms', utc=True)
        pnl = 0.0; wins=0; losses=0; trades=0
        pos=None
        for i in range(len(df)):
            bar = Bar(ts=ts.iloc[i], open=float(df['open'].iloc[i]), high=float(df['high'].iloc[i]),
                      low=float(df['low'].iloc[i]), close=float(df['close'].iloc[i]), volume=float(df.get('volume', pd.Series([0]*len(df))).iloc[i]))
            sig = self.engine.update_bar_close(tf, bar)
            if sig and pos is None:
                pos = {"side": sig.side, "entry": sig.price, "sl": sig.sl, "tp": sig.tp, "best": sig.price, "atr": sig.meta.get("atr", 0.0)}
                trades += 1
            if pos:
                if pos["side"] == "LONG":
                    pos["best"] = max(pos["best"], bar.close)
                    new_sl = atr_trailing_stop("LONG", pos["entry"], pos["best"], pos["atr"] or max(1e-8, bar.high-bar.low))
                    pos["sl"] = max(pos["sl"], new_sl)
                    if bar.low <= pos["sl"]:
                        pnl += (pos["sl"] - pos["entry"]) ; losses += int(pos["sl"]<pos["entry"]) ; wins += int(pos["sl"]>pos["entry"]) ; pos=None
                    elif bar.high >= pos["tp"]:
                        pnl += (pos["tp"] - pos["entry"]) ; wins += 1 ; pos=None
                else:
                    pos["best"] = min(pos["best"], bar.close)
                    new_sl = atr_trailing_stop("SHORT", pos["entry"], pos["best"], pos["atr"] or max(1e-8, bar.high-bar.low))
                    pos["sl"] = min(pos["sl"], new_sl)
                    if bar.high >= pos["sl"]:
                        pnl += (pos["entry"] - pos["sl"]) ; losses += int(pos["sl"]>pos["entry"]) ; wins += int(pos["sl"]<pos["entry"]) ; pos=None
                    elif bar.low <= pos["tp"]:
                        pnl += (pos["entry"] - pos["tp"]) ; wins += 1 ; pos=None
        return {"pnl": pnl, "trades": trades, "wins": wins, "losses": losses}

# ----------------------------------------------------------------------------
# CLI / bootstrap (live WS demo)
# ----------------------------------------------------------------------------
if __name__ == "__main__":
    load_dotenv()
    api_key = os.getenv("BINANCE_API_KEY", "")
    api_secret = os.getenv("BINANCE_API_SECRET", "")
    testnet = os.getenv("USE_TESTNET", "true").lower() == "true"
    hedge_mode = os.getenv("BINANCE_HEDGE_MODE", "true").lower() == "true"
    margin_type = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED")
    leverage = int(os.getenv("BINANCE_LEVERAGE", "5"))
    working_type = os.getenv("WORKING_TYPE", "MARK_PRICE")
    dry_run = os.getenv("DRY_RUN", "true").lower() == "true"

    # Symbols: ALL â†’ discover all USDT perpetuals
    symbols_env = os.getenv("SYMBOLS", "BTCUSDT")
    discover_all = symbols_env.strip().upper() in ("ALL", "*") or os.getenv("ALL_SYMBOLS", "false").lower()=="true"
    symbols = []
    if discover_all:
        try:
            from binance.um_futures import UMFutures
            base_url = "https://testnet.binancefuture.com" if testnet else None
            client = UMFutures(api_key=api_key, api_secret=api_secret, base_url=base_url)
            info = client.exchange_info()
            for s in info.get('symbols', []):
                if s.get('status') == 'TRADING' and s.get('quoteAsset') == 'USDT':
                    symbols.append(s.get('symbol'))
        except Exception as e:
            logger.error("symbol discovery failed: %s", e)
            symbols = ["BTCUSDT"]
    else:
        symbols = [s.strip().upper() for s in symbols_env.split(',') if s.strip()]

    # Timeframes: ALL â†’ subscribe to all Binance futures klines
    tfs_env = os.getenv("TIMEFRAMES", "ALL")
    all_tfs = ["1m","3m","5m","15m","30m","1h","2h","4h","6h","8h","12h","1d","3d","1w","1M"]
    if tfs_env.strip().upper() in ("ALL", "*"):
        tfs = all_tfs
    else:
        tfs = [tf.strip() for tf in tfs_env.split(',') if tf.strip()]

    sc = StratConfig(symbol=symbols[0], signal_tf="1m", trend_tf="15m", htf="1h")
    rc = RiskConfig(account_equity_usdt=float(os.getenv("ACCOUNT_EQUITY", "5000")),
                    leverage=leverage,
                    min_notional_usdt=float(os.getenv("MIN_NOTIONAL_USDT", "10")))

    executor = BinanceExecutor(api_key, api_secret, testnet, dry_run, hedge_mode, margin_type, leverage, working_type)
    app = App(symbols, sc, rc, executor)

    ws = BinanceWS(symbols, tfs=tfs, app=app, testnet=testnet)
    logger.info("Starting Binance WS for %s on %s", symbols, tfs)
    ws.start()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\visual_panel.py
import pandas as pd
import matplotlib.pyplot as plt

def dashboard_view(csv_file="data/signal_log.csv"):
    df = pd.read_csv(csv_file, names=["signal", "score", "result"])
    
    # 1. Sinyal DaÄŸÄ±lÄ±mÄ±
    signal_count = df["signal"].value_counts()
    signal_count.plot(kind="bar", title="ðŸ” Sinyal DaÄŸÄ±lÄ±mÄ±", color="steelblue")
    plt.ylabel("Adet")
    plt.tight_layout()
    plt.show()

    # 2. BaÅŸarÄ± OranÄ±
    result_count = df["result"].value_counts(normalize=True) * 100
    result_count.plot(kind="pie", title="ðŸŽ¯ BaÅŸarÄ± OranÄ±", autopct="%.1f%%")
    plt.ylabel("")
    plt.tight_layout()
    plt.show()

    # 3. Skor HistogramÄ±
    df["score"].plot(kind="hist", bins=10, title="âš™ï¸ Sinyal Skor YoÄŸunluÄŸu", color="purple")
    plt.xlabel("Skor")
    plt.tight_layout()
    plt.show()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\visualize.py
import pandas as pd
import matplotlib.pyplot as plt

def plot_sentiments(news_data):
    df = pd.DataFrame(news_data)
    
    # Duygu Analizi Uygula
    from sentiment import analyze_sentiment
    df["label"] = df["title"].apply(lambda x: analyze_sentiment(x)[0])

    # GruplandÄ±r ve Say
    sentiment_counts = df["label"].value_counts()

    # Grafikle GÃ¶ster
    plt.figure(figsize=(6,4))
    sentiment_counts.plot(kind="bar", color=["green", "red", "gray"])
    plt.title("Haberlerde Duygu DaÄŸÄ±lÄ±mÄ±")
    plt.ylabel("Haber SayÄ±sÄ±")
    plt.xlabel("Duygu TÃ¼rÃ¼")
    plt.xticks(rotation=0)
    plt.tight_layout()
    plt.show()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\visualizer.py
# visualizer.py

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.ticker import MaxNLocator
import pandas as pd


def plot_signals(df, title="ðŸ“Š Sinyal GrafiÄŸi"):
    df = df.copy()
    df.index = pd.to_datetime(df.index)

    fig, ax = plt.subplots(figsize=(16, 8))
    fig.suptitle(title, fontsize=16, fontweight='bold')

    # Ana fiyat Ã§izgisi
    ax.plot(df.index, df['close'], label='Fiyat', color='black', linewidth=2)

    # BUY sinyalleri
    if 'long_entry' in df.columns:
        long_signals = df[df['long_entry']]
        ax.scatter(long_signals.index, long_signals['close'], marker='^', color='green', label='BUY Sinyali', s=120, zorder=5)

    # SELL sinyalleri
    if 'short_entry' in df.columns:
        short_signals = df[df['short_entry']]
        ax.scatter(short_signals.index, short_signals['close'], marker='v', color='red', label='SELL Sinyali', s=120, zorder=5)

    # Bollinger Bands (varsa)
    if 'BBL_20_2.0' in df.columns and 'BBU_20_2.0' in df.columns:
        ax.plot(df.index, df['BBL_20_2.0'], linestyle='--', color='blue', alpha=0.5, label='BB Alt')
        ax.plot(df.index, df['BBU_20_2.0'], linestyle='--', color='blue', alpha=0.5, label='BB Ãœst')

    # EMA 50 / 200 Ã§izgileri
    if 'EMA_50' in df.columns:
        ax.plot(df.index, df['EMA_50'], linestyle='-', color='orange', alpha=0.7, label='EMA 50')

    if 'EMA_200' in df.columns:
        ax.plot(df.index, df['EMA_200'], linestyle='-', color='purple', alpha=0.5, label='EMA 200')

    # Eksen biÃ§imlendirme
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%m-%d %H:%M'))
    ax.xaxis.set_major_locator(MaxNLocator(nbins=10))
    fig.autofmt_xdate()
    ax.set_xlabel("Zaman", fontsize=12)
    ax.set_ylabel("Fiyat (USDT)", fontsize=12)

    ax.grid(True, linestyle='--', alpha=0.3)
    ax.legend(loc='upper left')
    plt.tight_layout()
    plt.show()
# visualizer.py (Pro versiyon)
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.ticker import MaxNLocator
import pandas as pd
import os
from datetime import datetime

def plot_signals(df, title="ðŸ“Š Sinyal GrafiÄŸi", save=False, filename=None):
    df = df.copy()
    df.index = pd.to_datetime(df.index)

    fig, ax = plt.subplots(figsize=(16, 8))
    fig.suptitle(title, fontsize=16, fontweight='bold')

    # Fiyat Ã§izgisi
    ax.plot(df.index, df['close'], label='Fiyat', color='black', linewidth=2)

    # BUY sinyalleri
    if 'long_entry' in df.columns:
        long_signals = df[df['long_entry']]
        ax.scatter(long_signals.index, long_signals['close'], marker='^', color='green', label='BUY', s=120, zorder=5)

    # SELL sinyalleri
    if 'short_entry' in df.columns:
        short_signals = df[df['short_entry']]
        ax.scatter(short_signals.index, short_signals['close'], marker='v', color='red', label='SELL', s=120, zorder=5)

    # Bollinger Bands
    if 'BBL_20_2.0' in df.columns and 'BBU_20_2.0' in df.columns:
        ax.plot(df.index, df['BBL_20_2.0'], linestyle='--', color='blue', alpha=0.5, label='BB Alt')
        ax.plot(df.index, df['BBU_20_2.0'], linestyle='--', color='blue', alpha=0.5, label='BB Ãœst')

    # EMA'lar
    if 'EMA_50' in df.columns:
        ax.plot(df.index, df['EMA_50'], linestyle='-', color='orange', alpha=0.7, label='EMA 50')
    if 'EMA_200' in df.columns:
        ax.plot(df.index, df['EMA_200'], linestyle='-', color='purple', alpha=0.5, label='EMA 200')

    # BiÃ§imlendirme
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%m-%d %H:%M'))
    ax.xaxis.set_major_locator(MaxNLocator(nbins=10))
    fig.autofmt_xdate()
    ax.set_xlabel("Zaman", fontsize=12)
    ax.set_ylabel("Fiyat (USDT)", fontsize=12)
    ax.grid(True, linestyle='--', alpha=0.3)
    ax.legend(loc='upper left')
    plt.tight_layout()

    if save:
        if not filename:
            filename = f"signal_plot_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        os.makedirs("charts", exist_ok=True)
        filepath = os.path.join("charts", filename)
        plt.savefig(filepath)
        print(f"ðŸ–¼ï¸ Grafik kaydedildi: {filepath}")
    else:
        plt.show()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\wepsocet.py
from websocket import WebSocketApp
import json

symbols = ["btcusdt", "ethusdt", "dogeusdt"]
streams = "/".join([f"{s}@ticker" for s in symbols])
url = f"wss://stream.binance.com:9443/stream?streams={streams}"

def on_message(ws, message):
    data = json.loads(message)
    stream_name = data.get("stream", "")
    payload = data.get("data", {})
    symbol = payload.get("s")
    price = payload.get("c")
    print(f"{symbol}: {price}")

ws = WebSocketApp(url, on_message=on_message)
ws.run_forever()
import websocket, json, time, hmac, hashlib, requests, threading
import pandas as pd
import numpy as np
import ta
from sklearn.ensemble import IsolationForest
from keras.models import Sequential
from keras.layers import LSTM, Dense

# === AYARLAR ===
API_KEY = "YOUR_API_KEY"
SECRET_KEY = "YOUR_SECRET_KEY"
SYMBOLS = ["btcusdt", "ethusdt"]
TRADE_AMOUNT = 0.001
RISK_LIMIT = 0.02  # %2 risk

# === VERÄ° DEPOLAMA ===
price_data = {symbol: pd.DataFrame(columns=["timestamp", "price"]) for symbol in SYMBOLS}
models = {}

# === LOG FONKSÄ°YONU ===
def log(event, msg):
    print(f"[{event}] {msg}")

# === VERÄ° AKIÅžI ===
def create_socket(symbol):
    url = f"wss://stream.binance.com:9443/ws/{symbol}@trade"
    return websocket.WebSocketApp(url,
        on_message=lambda ws, msg: handle_message(symbol, msg),
        on_open=lambda ws: log("OPEN", f"{symbol.upper()} baÄŸlantÄ±sÄ± kuruldu."),
        on_close=lambda ws: log("CLOSE", f"{symbol.upper()} baÄŸlantÄ±sÄ± kapandÄ±.")
    )

def handle_message(symbol, message):
    global price_data, models
    data = json.loads(message)
    price = float(data['p'])
    timestamp = int(data['T'])
    df = price_data[symbol]
    df.loc[len(df)] = [timestamp, price]

    if len(df) > 120:
        df = df.tail(120).copy()
        df = generate_features(df)
        anomaly_score = detect_anomaly(df)
        if symbol not in models:
            models[symbol] = train_model(df)
        prediction = predict_price(models[symbol], df)
        strategy_decision(symbol, df, prediction, anomaly_score)

# === Ã–ZELLÄ°K MÃœHENDÄ°SLÄ°ÄžÄ° ===
def generate_features(df):
    df['rsi'] = ta.momentum.RSIIndicator(df['price']).rsi()
    df['macd'] = ta.trend.MACD(df['price']).macd_diff()
    df['sma20'] = df['price'].rolling(window=20).mean()
    df['volatility'] = df['price'].rolling(window=10).std()
    df.dropna(inplace=True)
    return df

# === ANOMALY DETECTION ===
def detect_anomaly(df):
    iso = IsolationForest(contamination=0.05)
    scores = iso.fit_predict(df[['price', 'rsi', 'macd', 'volatility']])
    return scores[-1]  # -1 = anomaly

# === LSTM MODELÄ° ===
def train_model(df):
    prices = df['price'].values[-100:]
    X, y = [], []
    for i in range(10, len(prices)):
        X.append(prices[i-10:i])
        y.append(prices[i])
    X, y = np.array(X), np.array(y)
    X = X.reshape((X.shape[0], X.shape[1], 1))

    model = Sequential()
    model.add(LSTM(64, activation='relu', input_shape=(10,1)))
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mse')
    model.fit(X, y, epochs=15, verbose=0)
    return model

def predict_price(model, df):
    last_seq = df['price'].values[-10:].reshape((1,10,1))
    return model.predict(last_seq)[0][0]

# === STRATEJÄ° MOTORU ===
def strategy_decision(symbol, df, prediction, anomaly_score):
    latest = df.iloc[-1]
    rsi = latest['rsi']
    macd = latest['macd']
    price = latest['price']
    volatility = latest['volatility']

    log("STRATEGY", f"{symbol.upper()} | RSI: {rsi:.2f} | MACD: {macd:.2f} | Tahmin: {prediction:.2f} | Anomaly: {anomaly_score}")

    if anomaly_score == -1:
        log("ALERT", "Anormal veri tespit edildi. Ä°ÅŸlem yapÄ±lmadÄ±.")
        return

    if rsi < 30 and macd > 0 and prediction > price:
        qty = calculate_position(price, volatility)
        execute_order(symbol.upper(), "BUY", qty)
    elif rsi > 70 and macd < 0 and prediction < price:
        qty = calculate_position(price, volatility)
        execute_order(symbol.upper(), "SELL", qty)
    else:
        log("STATUS", "Beklemede")

# === RÄ°SK YÃ–NETÄ°MÄ° ===
def calculate_position(price, volatility):
    balance = 1000  # Ã¶rnek bakiye
    risk_amount = balance * RISK_LIMIT
    stop_loss = price * 0.01 + volatility
    qty = risk_amount / stop_loss
    return round(qty, 4)

# === EMÄ°R GÃ–NDERÄ°MÄ° ===
def execute_order(symbol, side, quantity):
    url = "https://api.binance.com/api/v3/order"
    timestamp = int(time.time() * 1000)
    params = {
        "symbol": symbol,
        "side": side,
        "type": "MARKET",
        "quantity": quantity,
        "timestamp": timestamp
    }
    query = '&'.join([f"{k}={v}" for k,v in params.items()])
    signature = hmac.new(SECRET_KEY.encode(), query.encode(), hashlib.sha256).hexdigest()
    params['signature'] = signature
    headers = {"X-MBX-APIKEY": API_KEY}
    try:
        response = requests.post(url, headers=headers, params=params)
        log("ORDER", f"{side} {quantity} {symbol} gÃ¶nderildi.")
        log("RESPONSE", str(response.json()))
    except Exception as e:
        log("ERROR", f"Emir gÃ¶nderimi baÅŸarÄ±sÄ±z: {e}")

# === BAÅžLAT ===
if __name__ == "__main__":
    sockets = [create_socket(symbol) for symbol in SYMBOLS]
    for sock in sockets:
        threading.Thread(target=sock.run_forever).start()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\whisper_sync__module.py
def track_silent_moves(chain_log):
    anomalies = []
    for entry in chain_log:
        if entry['volume'] < 100_000 and entry['effect'] > 70:
            anomalies.append(f"ðŸ•µï¸ Sessiz Etki: {entry['id']}")
    return anomalies if anomalies else ["ðŸŒŒ Sessiz ama sakin: risk gÃ¶zÃ¼kmÃ¼yor."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ws_multi_price_stream.py
# ws_multi_price_stream.py (Ã‡oklu sembol WebSocket veri akÄ±ÅŸÄ±)
import json
from websocket import WebSocketApp
from datetime import datetime

# Takip edilecek semboller
SYMBOLS = ["btcusdt", "ethusdt", "dogeusdt", "solusdt", "adausdt"]

# Stream URL'si
streams = "/".join([f"{sym}@ticker" for sym in SYMBOLS])
url = f"wss://stream.binance.com:9443/stream?streams={streams}"

# FiyatlarÄ± saklamak iÃ§in sÃ¶zlÃ¼k
ticker_data = {}


def on_message(ws, message):
    global ticker_data
    data = json.loads(message)
    payload = data.get("data", {})
    symbol = payload.get("s", "").upper()
    price = float(payload.get("c", 0))
    timestamp = datetime.fromtimestamp(payload.get("E", 0)/1000).strftime("%H:%M:%S")

    ticker_data[symbol] = price
    print(f"[{timestamp}] {symbol} â†’ {price:.4f}")


def on_error(ws, error):
    print("âŒ HATA:", error)


def on_close(ws):
    print("ðŸ”Œ BaÄŸlantÄ± kapatÄ±ldÄ±.")


def on_open(ws):
    print("ðŸš€ WebSocket baÄŸlantÄ±sÄ± baÅŸlatÄ±ldÄ±.")


if __name__ == "__main__":
    print(f"ðŸŒ Ã‡oklu sembol WebSocket veri akÄ±ÅŸÄ± baÅŸlÄ±yor...")
    ws = WebSocketApp(url, on_open=on_open, on_message=on_message, on_error=on_error, on_close=on_close)
    try:
        ws.run_forever()
    except KeyboardInterrupt:
        print("ðŸ›‘ KullanÄ±cÄ± tarafÄ±ndan durduruldu.")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ws_price_stream.py
# ws_price_stream.py (WebSocket ile gecikmesiz fiyat veri akÄ±ÅŸÄ±)
import json
import threading
from binance.websocket.spot.websocket_client import SpotWebsocketClient
from datetime import datetime

SYMBOL = "dogeusdt"

def handle_price_stream(msg):
    if "c" in msg:
        price = float(msg["c"])
        ts = datetime.fromtimestamp(msg['E']/1000).strftime('%H:%M:%S')
        print(f"â±ï¸ {ts} | {SYMBOL.upper()} Fiyat: {price:.5f}")


def start_ws_client(symbol=SYMBOL):
    client = SpotWebsocketClient()
    client.start()
    client.ticker(symbol=symbol, id=1, callback=handle_price_stream)
    return client


if __name__ == "__main__":
    print(f"ðŸš€ WebSocket baÅŸlatÄ±lÄ±yor: {SYMBOL.upper()} anlÄ±k fiyat akÄ±ÅŸÄ±...\n")
    ws_client = start_ws_client()

    # Arka planda Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlamak iÃ§in main threadâ€™i tutuyoruz
    try:
        while True:
            pass
    except KeyboardInterrupt:
        print("âŒ WebSocket kapatÄ±lÄ±yor...")
        ws_client.stop()


