### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\.pytest_cache\v\cache\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\.pytest_cache\v\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\.pytest_cache\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\.venv311\Include\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\.venv311\Lib\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\.venv311\Scripts\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\.venv311\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\analysis\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\bots\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\bots\price_tracker.py
import ccxt.async_support as ccxt
import asyncio
from datetime import datetime, timezone

def log(msg, level="INFO"):
    ts = datetime.now(timezone.utc).isoformat()
    print(f"[{ts}] | {level.upper()} | {msg}")

async def fetch_price_loop(symbol="BTC/USDT:USDT", interval=10):
    exchange = ccxt.binanceusdm({
        'enableRateLimit': True,
        'options': {'defaultType': 'future'}
    })

    try:
        while True:
            ticker = await exchange.fetch_ticker(symbol)
            price = ticker['last']
            log(f"{symbol} fiyatı: {price}", level="DATA")
            await asyncio.sleep(interval)

    except ccxt.BaseError as e:
        log(f"Hata oluştu: {str(e)}", level="ERROR")

    finally:
        await exchange.close()

if __name__ == "__main__":
    asyncio.run(fetch_price_loop())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\logs\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\logs\backtest_kamalquantx.py
def backtest(strategy, historical_prices):
    results = []
    for i, price in enumerate(historical_prices):
        ts = f"t{i}"
        signal = strategy.update(price, ts)
        if signal:
            results.append({
                'ts': ts,
                'action': signal['action'],
                'price': signal['price_now'],
                'future': signal['future_price'],
                'confidence': signal['confidence']
            })

    df = pd.DataFrame(results)
    df['return'] = np.where(df['action'] == 'BUY',
                            df['future'] / df['price'] - 1,
                            np.where(df['action'] == 'SELL',
                                     df['price'] / df['future'] - 1,
                                     0))
    total_return = df['return'].sum()
    sharpe = df['return'].mean() / df['return'].std() * np.sqrt(252)
    drawdown = (df['return'].cumsum().cummax() - df['return'].cumsum()).max()

    return {
        'total_return': round(total_return, 3),
        'sharpe_ratio': round(sharpe, 2),
        'max_drawdown': round(drawdown, 2),
        'win_rate': round((df['return'] > 0).mean(), 2)
    }

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\logs\ultra_elite_engine_ai.py
from __future__ import annotations
"""
Ultra Elite Strategy Engine — Full Stack (MTF + All Indicators + Risk + Binance Testnet)
--------------------------------------------------------------------------------------
- Multi‑timeframe (signal / trend / HTF) with CLOSED‑bar signals (no repaint)
- Broad indicator pack (RSI, Stoch, MACD, EMA/SMA, Bollinger, Keltner, ATR, ADX,
  CCI, MFI, OBV, VWAP, Ichimoku, SAR, Supertrend) computed efficiently
- ATR SL/TP + breakeven + ATR trailing; volatility/chop filters; cooldown; session filter
- RiskManager: per‑trade risk, min notional guard, daily max drawdown (Zurich reset)
- Fast deques, vectorized calc; optional Numba JIT for EMA & Supertrend
- Binance Futures Testnet executor (isolated, leverage, hedge mode, reduce‑only),
  bracket orders (SL/TP), mark‑price working type, DRY‑RUN support

Requires: python>=3.10, pandas, numpy, ta, pytz, python-dotenv, binance-connector, websocket-client, (optional) numba
Install:  pip install "pandas>=2" numpy ta pytz python-dotenv "binance-connector>=3" websocket-client numba

.env template (example):
BINANCE_API_KEY=your_testnet_key_here
BINANCE_API_SECRET=your_testnet_secret_here
USE_TESTNET=true
SYMBOLS=BTCUSDT,DOGEUSDT
BINANCE_HEDGE_MODE=true
BINANCE_MARGIN_TYPE=ISOLATED
BINANCE_LEVERAGE=5
RISK_MAX_DAILY_DRAWDOWN=0.02
RISK_MAX_RISK_PCT_PER_TRADE=0.015
MIN_NOTIONAL_USDT=10
WORKING_TYPE=MARK_PRICE   # MARK_PRICE | CONTRACT_PRICE
DRY_RUN=true

Run example:
python ultra_elite_engine.py --symbols BTCUSDT DOGEUSDT --signal_tf 1m --trend_tf 15m --htf 1h --dry-run
"""

from dataclasses import dataclass, field
from collections import deque
from typing import Deque, Dict, Optional, Literal, Tuple, List
import os
import math
import pandas as pd
import numpy as np
import pytz
import ta
import time
import logging
from datetime import datetime, timezone
from dotenv import load_dotenv

# Optional ML deps ------------------------------------------------------------
# Optional ML deps ------------------------------------------------------------
try:
    from sklearn.linear_model import LogisticRegression
    from sklearn.ensemble import IsolationForest
    from sklearn.preprocessing import StandardScaler
    SKLEARN_OK = True
except Exception:
    SKLEARN_OK = False

try:
    import torch
    import torch.nn as nn
    TORCH_OK = True
except Exception:
    TORCH_OK = False

# Optional Numba for speed ----------------------------------------------------
try:
    from numba import njit
except Exception:  # pragma: no cover
    def njit(*args, **kwargs):
        def wrap(fn):
            return fn
        return wrap

# ----------------------------------------------------------------------------
# Logging
# ----------------------------------------------------------------------------
logger = logging.getLogger("UltraElite")
logger.setLevel(logging.INFO)
if not logger.handlers:
    ch = logging.StreamHandler()
    ch.setFormatter(logging.Formatter("%(asctime)s | %(levelname)s | %(message)s"))
    logger.addHandler(ch)

TF = Literal["1m","3m","5m","15m","30m","1h","2h","4h","6h","8h","12h","1d","3d","1w","1M"]
Side = Literal["LONG","SHORT"]

TF_TO_SEC = {"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"2h":7200,"4h":14400,"6h":21600,"8h":28800,"12h":43200,"1d":86400,"3d":259200,"1w":604800,"1M":2592000}  # 1M≈30d for aggregation only

# ----------------------------------------------------------------------------
# Data structures
# ----------------------------------------------------------------------------
@dataclass
class Bar:
    ts: pd.Timestamp  # bar close time UTC
    open: float
    high: float
    low: float
    close: float
    volume: float = 0.0

@dataclass
class Signal:
    symbol: str
    side: Side
    price: float
    sl: float
    tp: float
    size: float
    reason: str
    meta: dict = field(default_factory=dict)

# ----------------------------------------------------------------------------
# Helpers
# ----------------------------------------------------------------------------

def as_utc(ts) -> pd.Timestamp:
    if isinstance(ts, pd.Timestamp):
        if ts.tzinfo is None:
            return ts.tz_localize("UTC")
        return ts.tz_convert("UTC")
    # assume seconds since epoch
    return pd.to_datetime(ts, unit="s", utc=True)

# JIT EMA (fast incremental)
@njit(cache=True)
def ema_numba(vals: np.ndarray, period: int) -> np.ndarray:
    out = np.empty_like(vals)
    if len(vals) == 0:
        return out
    alpha = 2.0 / (period + 1.0)
    out[0] = vals[0]
    for i in range(1, len(vals)):
        out[i] = alpha * vals[i] + (1.0 - alpha) * out[i - 1]
    return out

# Supertrend (Numba‑friendly)
@njit(cache=True)
def supertrend(high, low, close, period=10, multiplier=3.0):
    n = len(close)
    atr = np.empty(n)
    atr[:] = np.nan

    # TR & ATR (RMA)
    tr = np.empty(n)
    tr[0] = high[0] - low[0]
    for i in range(1, n):
        hl = high[i] - low[i]
        hc = abs(high[i] - close[i-1])
        lc = abs(low[i] - close[i-1])
        tr[i] = hl if (hl >= hc and hl >= lc) else (hc if hc >= lc else lc)
    # RMA
    alpha = 1.0/period
    atr[period-1] = np.mean(tr[:period])
    for i in range(period, n):
        atr[i] = (atr[i-1] * (period-1) + tr[i]) / period

    upper = np.empty(n); lower = np.empty(n)
    upper[:] = np.nan; lower[:] = np.nan
    st = np.empty(n); st[:] = np.nan
    trend = np.empty(n); trend[:] = 1

    for i in range(n):
        if np.isnan(atr[i]):
            continue
        basic_upper = (high[i] + low[i]) / 2.0 + multiplier * atr[i]
        basic_lower = (high[i] + low[i]) / 2.0 - multiplier * atr[i]
        if i == 0:
            upper[i] = basic_upper
            lower[i] = basic_lower
            st[i] = basic_lower
            trend[i] = 1
            continue
        upper[i] = basic_upper if (basic_upper < upper[i-1] or close[i-1] > upper[i-1]) else upper[i-1]
        lower[i] = basic_lower if (basic_lower > lower[i-1] or close[i-1] < lower[i-1]) else lower[i-1]
        if close[i] > upper[i-1]:
            trend[i] = 1
        elif close[i] < lower[i-1]:
            trend[i] = -1
        else:
            trend[i] = trend[i-1]
        st[i] = lower[i] if trend[i] == 1 else upper[i]
    return st, trend, atr

# VWAP helper

def vwap_np(high, low, close, volume):
    tp = (high + low + close) / 3.0
    cum_v = np.cumsum(volume)
    cum_tp_v = np.cumsum(tp * volume)
    vwap = cum_tp_v / np.maximum(cum_v, 1e-12)
    return vwap

# ----------------------------------------------------------------------------
# Window state & Aggregators
# ----------------------------------------------------------------------------
@dataclass
class WindowState:
    tf: TF
    maxlen: int
    rows: Deque[Tuple[pd.Timestamp, float, float, float, float, float]] = field(default_factory=deque)

    def append(self, bar: Bar):
        if len(self.rows) == self.maxlen:
            self.rows.popleft()
        self.rows.append((as_utc(bar.ts), bar.open, bar.high, bar.low, bar.close, bar.volume))

    def to_df(self) -> pd.DataFrame:
        return pd.DataFrame(self.rows, columns=["ts","open","high","low","close","volume"])  

# Tick → OHLCV aggregator for a single TF
class TickAggregator:
    def __init__(self, tf: TF):
        self.tf = tf
        self.period = TF_TO_SEC[tf]
        self.reset()

    def reset(self):
        self._open = None; self._high = -math.inf; self._low = math.inf; self._vol = 0.0; self._start = None

    def update(self, ts_sec: float, price: float, qty: float) -> Optional[Bar]:
        # ts_sec: seconds (float) epoch
        if self._start is None:
            self._start = int(ts_sec // self.period) * self.period
            self._open = price
            self._high = price
            self._low = price
        elif ts_sec >= self._start + self.period:
            # close current bar
            bar = Bar(ts=as_utc(self._start + self.period), open=self._open, high=self._high,
                      low=self._low, close=price, volume=self._vol)
            # start new
            self.reset()
            self._start = int(ts_sec // self.period) * self.period
            self._open = price; self._high = price; self._low = price; self._vol = qty
            return bar
        # update in‑bar
        if price > self._high: self._high = price
        if price < self._low: self._low = price
        self._vol += qty
        return None

# ----------------------------------------------------------------------------
# Indicator Engine (broad coverage)
# ----------------------------------------------------------------------------
@dataclass
class IndicatorParams:
    # dynamic + presets together
    ma_periods: Tuple[int, ...] = (7, 25, 99)
    ema_periods: Tuple[int, ...] = (7, 21, 50, 99)
    wma_periods: Tuple[int, ...] = (7, 25)
    mavol_periods: Tuple[int, ...] = (7, 14)
    trix_periods: Tuple[int, ...] = (9,)
    bb_window: int = 20
    kelt_window: int = 20
    kelt_atr: int = 10
    supertrend_period: int = 10
    supertrend_mult: float = 3.0

class IndicatorEngine:
    def __init__(self, rsi_period=14, ema_fast=21, ema_slow=50, atr_period=14, adx_period=14,
                 params: IndicatorParams | None = None):
        self.rsi_period = rsi_period
        self.ema_fast = ema_fast
        self.ema_slow = ema_slow
        self.atr_period = atr_period
        self.adx_period = adx_period
        self.p = params or IndicatorParams()

    def _wma(self, x: pd.Series, period: int) -> pd.Series:
        # weighted moving average (linear weights 1..n)
        if period <= 1:
            return x
        w = np.arange(1, period + 1)
        return x.rolling(period).apply(lambda a: np.dot(a, w) / w.sum(), raw=True)

    def _ema_series(self, arr: np.ndarray, p: int, index) -> pd.Series:
        return pd.Series(ema_numba(arr, p), index=index)

    def _ema(self, s: pd.Series, p: int) -> pd.Series:
        return self._ema_series(s.to_numpy(), p, s.index)

    def compute_all(self, df: pd.DataFrame) -> pd.DataFrame:
        c = df["close"].to_numpy()
        c = df["close"].to_numpy()
        h = df["high"].to_numpy()
        l = df["low"].to_numpy()
        v = df["volume"].to_numpy()

        out = df.copy()
        # === Core single-pass arrays ===
        out["rsi"] = ta.momentum.RSIIndicator(close=df["close"], window=self.rsi_period).rsi()
        out["ema_fast"] = pd.Series(ema_numba(c, self.ema_fast), index=df.index)
        out["ema_slow"] = pd.Series(ema_numba(c, self.ema_slow), index=df.index)
        out["atr"] = ta.volatility.AverageTrueRange(h, l, c, window=self.atr_period).average_true_range()
        out["adx"] = ta.trend.ADXIndicator(df["high"], df["low"], df["close"], window=self.adx_period).adx()

        # === Dynamic presets (fast loops) ===
        for p in self.p.ma_periods:
            out[f"ma{p}"] = df["close"].rolling(p).mean()
        for p in self.p.ema_periods:
            out[f"ema{p}"] = pd.Series(ema_numba(c, p), index=df.index)
        for p in self.p.wma_periods:
            out[f"wma{p}"] = self._wma(df["close"], p)
        for p in self.p.mavol_periods:
            out[f"mavol{p}"] = df["volume"].rolling(p).mean()
        for p in self.p.trix_periods:
            e1 = pd.Series(ema_numba(c, p), index=df.index)
            e2 = pd.Series(ema_numba(e1.to_numpy(), p), index=df.index)
            e3 = pd.Series(ema_numba(e2.to_numpy(), p), index=df.index)
            out[f"trix{p}"] = e3.pct_change() * 100.0

        # Stoch / KDJ
        stoch = ta.momentum.StochasticOscillator(df["high"], df["low"], df["close"])
        out["stoch_k"], out["stoch_d"] = stoch.stoch(), stoch.stoch_signal()
        out["kdj_k"], out["kdj_d"] = out["stoch_k"], out["stoch_d"]
        out["kdj_j"] = (3 * out["kdj_k"] - 2 * out["kdj_d"]).clip(0, 100)

        # MACD
        macd = ta.trend.MACD(close=df["close"]) 
        out["macd"], out["macd_signal"], out["macd_hist"] = macd.macd(), macd.macd_signal(), macd.macd_diff()

        # Williams %R
        try:
            wr = ta.momentum.WilliamsRIndicator(df["high"], df["low"], df["close"], lbp=14)
            out["wr14"] = wr.williams_r()
        except Exception:
            out["wr14"] = np.nan

        # TRIX signal (EMA of TRIX)
        if "trix9" in out.columns:
            out["trix9_signal"] = self._ema(out["trix9"].fillna(0), 9)
            out["trix9_hist"] = out["trix9"] - out["trix9_signal"]

        # Volatility packs
        bb = ta.volatility.BollingerBands(close=df["close"], window=self.p.bb_window)
        out["bb_high"], out["bb_low"], out["bb_mid"] = bb.bollinger_hband(), bb.bollinger_lband(), bb.bollinger_mavg()
        kelt = ta.volatility.KeltnerChannel(h, l, c, window=self.p.kelt_window, original_version=True)
        out["kc_high"], out["kc_low"], out["kc_mid"] = kelt.keltner_channel_hband(), kelt.keltner_channel_lband(), kelt.keltner_channel_mband()

        # Volume‑based
        out["obv"] = ta.volume.OnBalanceVolumeIndicator(close=df["close"], volume=df["volume"]).on_balance_volume()
        out["mfi"] = ta.volume.MFIIndicator(h, l, c, v).money_flow_index()
        out["vwap"] = pd.Series(vwap_np(h, l, c, v), index=df.index)
        
        # Others
        out["cci"] = ta.trend.CCIIndicator(h, l, c).cci()
        out["sar"] = ta.trend.PSARIndicator(h, l, c).psar()
        try:
            ichi = ta.trend.IchimokuIndicator(h, l)
            out["ichi_base"], out["ichi_conv"] = ichi.ichimoku_base_line(), ichi.ichimoku_conversion_line()
        except Exception:
            out["ichi_base"], out["ichi_conv"] = np.nan, np.nan

        # Supertrend (custom JIT)
        st, trend, atr_rma = supertrend(h.astype(np.float64), l.astype(np.float64), c.astype(np.float64),
                                        period=self.p.supertrend_period, multiplier=self.p.supertrend_mult)
        out["supertrend"], out["supertrend_trend"], out["atr_rma"] = st, trend, atr_rma
        return out

# ----------------------------------------------------------------------------
# AI modules (optional, plug & play)
# ----------------------------------------------------------------------------
class FeatureBuilder:
    """Builds a compact feature vector from the latest indicator snapshot.
    Uses only numeric, normalized, low-leakage features.
    """
    def __init__(self):
        self.cols = [
            "rsi","stoch_k","stoch_d","kdj_k","kdj_d","kdj_j",
            "wr14","macd","macd_signal","macd_hist","trix9","trix9_signal","trix9_hist",
            "ema_fast","ema_slow","sma50","sma200","bb_high","bb_low","bb_mid",
            "kc_high","kc_low","kc_mid","atr","adx","vwap","obv","mfi","cci","sar",
            "supertrend","supertrend_trend","atr_rma"
        ]
        # Only keep those that exist
    def build(self, df: pd.DataFrame) -> Tuple[np.ndarray, List[str]]:
        row = df.iloc[-1]
        avail = [c for c in self.cols if c in df.columns]
        x = np.array([float(row[c]) if np.isfinite(row.get(c, np.nan)) else 0.0 for c in avail], dtype=float)
        return x, avail

class AIModule:
    """Ensemble of: (1) Rule-based signal, (2) Logistic classifier on features,
    (3) IsolationForest anomaly veto. Returns accept/reject + score in [0,1].
    """
    def __init__(self, min_samples: int = 500):
        self.min_samples = min_samples
        self.scaler = StandardScaler() if SKLEARN_OK else None
        self.clf = LogisticRegression(max_iter=200) if SKLEARN_OK else None
        self.anom = IsolationForest(n_estimators=100, contamination=0.02, random_state=42) if SKLEARN_OK else None
        self.fb = FeatureBuilder()
        self._trained = False
        self._feat_names: List[str] = []
        self._buffer_X: List[np.ndarray] = []
        self._buffer_y: List[int] = []

    def update_and_maybe_train(self, df: pd.DataFrame, rule_signal: int):
        """rule_signal in {0,1} := whether the rule engine emitted a buy/short intent.
        We use rule labels as pseudo-labels to learn a classifier that mimics/improves timing.
        """
        if not SKLEARN_OK or len(df) < self.min_samples:
            return
        x, names = self.fb.build(df)
        if not self._feat_names:
            self._feat_names = names
        self._buffer_X.append(x)
        self._buffer_y.append(int(rule_signal))
        if len(self._buffer_X) >= self.min_samples and (len(self._buffer_X) % 50 == 0):
            X = np.vstack(self._buffer_X)
            y = np.array(self._buffer_y)
            Xs = self.scaler.fit_transform(X)
            self.clf.fit(Xs, y)
            try:
                self.anom.fit(Xs)
            except Exception:
                pass
            self._trained = True

    def predict_accept(self, df: pd.DataFrame) -> Tuple[bool, float, dict]:
        if not SKLEARN_OK or not self._trained:
            return True, 0.5, {"ai": "bypass"}
        x, _ = self.fb.build(df)
        xs = self.scaler.transform([x])
        prob = float(self.clf.predict_proba(xs)[0,1])
        try:
            an = float(self.anom.score_samples(xs)[0])  # higher is less anomalous
        except Exception:
            an = 0.0
        score = 0.7*prob + 0.3*(1/(1+np.exp(-an)))
        return (score >= 0.5), score, {"prob": prob, "anom": an}

# ----------------------------------------------------------------------------
# Risk management
# ----------------------------------------------------------------------------
@dataclass
class RiskConfig:
    account_equity_usdt: float = 1000.0
    max_risk_pct_per_trade: float = 0.015
    max_daily_drawdown_pct: float = 0.02
    leverage: int = 5
    min_notional_usdt: float = 10.0
    symbol_price_precision: int = 2
    symbol_qty_precision: int = 3
    tz_reset: str = "Europe/Zurich"

class RiskManager:
    def __init__(self, cfg: RiskConfig):
        self.cfg = cfg
        self.daily_pnl = 0.0
        self._current_date = None

    def _roll_date(self, now_utc: pd.Timestamp):
        tz = pytz.timezone(self.cfg.tz_reset)
        d = now_utc.tz_convert(tz).date()
        if self._current_date is None:
            self._current_date = d
        elif d != self._current_date:
            logger.info("[Risk] New day → reset daily PnL")
            self._current_date = d
            self.daily_pnl = 0.0

    def update_realized_pnl(self, pnl: float, now_utc: pd.Timestamp):
        self._roll_date(now_utc)
        self.daily_pnl += pnl

    def hard_guard(self, now_utc: pd.Timestamp) -> bool:
        self._roll_date(now_utc)
        limit = -self.cfg.account_equity_usdt * self.cfg.max_daily_drawdown_pct
        allowed = self.daily_pnl > limit
        if not allowed:
            logger.warning("[Risk] Daily DD reached: pnl=%.2f limit=%.2f", self.daily_pnl, limit)
        return allowed

    def position_size(self, entry: float, sl: float) -> float:
        risk_usdt = self.cfg.account_equity_usdt * self.cfg.max_risk_pct_per_trade
        stop = max(1e-8, abs(entry - sl))
        qty = risk_usdt / stop * self.cfg.leverage
        qty = max(0.0, round(qty, self.cfg.symbol_qty_precision))
        # min notional (margin notionally = entry*qty/leverage)
        if (qty * entry / self.cfg.leverage) < self.cfg.min_notional_usdt:
            qty = round((self.cfg.min_notional_usdt * self.cfg.leverage) / entry, self.cfg.symbol_qty_precision)
        return qty

# ----------------------------------------------------------------------------
# Strategy (MTF + filters)
# ----------------------------------------------------------------------------
@dataclass
class StratConfig:
    symbol: str = "BTCUSDT"
    signal_tf: TF = "1m"
    trend_tf: TF = "15m"
    htf: TF = "1h"

    rsi_period: int = 14
    ema_fast: int = 21
    ema_slow: int = 50
    adx_period: int = 14
    atr_period: int = 14

    rsi_buy: int = 30
    rsi_sell: int = 70
    adx_min: float = 18.0

    atr_sl_mult: float = 1.5
    atr_tp_mult: float = 3.0

    cooldown_bars: int = 3
    min_atr_pct_of_price: float = 0.05 / 100.0

    session_start_utc: Optional[int] = None
    session_end_utc: Optional[int] = None

    # Extra trigger toggles & thresholds
    use_kdj: bool = True
    use_wr: bool = True
    use_trix: bool = True
    wr_buy: float = -80.0
    wr_sell: float = -20.0

    # AI controls
    use_ai: bool = True
    ai_min_samples: int = 800


class StrategyEngine:
    def __init__(self, sc: StratConfig, rc: RiskConfig):
        self.sc = sc
        self.rm = RiskManager(rc)
        self.ind = IndicatorEngine(sc.rsi_period, sc.ema_fast, sc.ema_slow, sc.atr_period, sc.adx_period)

        def _mlen(n):
            return int(max(100, n*6))
        self.win: Dict[TF, WindowState] = {
            sc.signal_tf: WindowState(sc.signal_tf, _mlen(max(sc.ema_slow, sc.rsi_period, sc.atr_period))),
            sc.trend_tf:  WindowState(sc.trend_tf,  _mlen(max(sc.ema_slow, sc.adx_period))),
            sc.htf:       WindowState(sc.htf,       _mlen(sc.ema_slow*2)),
        }
        self.cooldown = 0
        self.last_signal: Optional[Side] = None

    def update_bar_close(self, tf: TF, bar: Bar) -> Optional[Signal]:
        bar.ts = as_utc(bar.ts)
        self.win[tf].append(bar)

        if tf != self.sc.signal_tf:
            return None

        if not self.rm.hard_guard(bar.ts):
            return None

        if self.sc.session_start_utc is not None and self.sc.session_end_utc is not None:
            h = bar.ts.hour
            if not (self.sc.session_start_utc <= h < self.sc.session_end_utc):
                return None

        sdf = self.win[self.sc.signal_tf].to_df()
        tdf = self.win[self.sc.trend_tf].to_df()
        hdf = self.win[self.sc.htf].to_df()
        if min(len(sdf), len(tdf), len(hdf)) < 60:
            return None

        sdf = self.ind.compute_all(sdf)
        last = sdf.iloc[-1]
        prev = sdf.iloc[-2]

        # Volatility floor
        if (last.atr / max(1e-8, last.close)) < self.sc.min_atr_pct_of_price:
            return None

        # Trend TF indicators
        tdf = self.ind.compute_all(tdf)
        t_last = tdf.iloc[-1]
        trend_up = (t_last.ema_fast > t_last.ema_slow) and (t_last.adx >= self.sc.adx_min)
        trend_dn = (t_last.ema_fast < t_last.ema_slow) and (t_last.adx >= self.sc.adx_min)

        # HTF bias via SMA200 slope
        hdf = self.win[self.sc.htf].to_df()
        hdf["sma200"] = hdf["close"].rolling(200).mean()
        if len(hdf) < 202:
            return None
        h_last, h_prev = hdf.iloc[-1], hdf.iloc[-2]
        htf_up = h_last.sma200 > h_prev.sma200
        htf_dn = h_last.sma200 < h_prev.sma200

        # Triggers: RSI exit from OB/OS + EMA_fast cross, supported by Supertrend trend
        long_trig = (prev.rsi < self.sc.rsi_buy) and (last.rsi >= self.sc.rsi_buy) \
                    and (prev.close < prev.ema_fast) and (last.close > last.ema_fast) \
                    and (int(last.supertrend_trend) == 1)
        short_trig = (prev.rsi > self.sc.rsi_sell) and (last.rsi <= self.sc.rsi_sell) \
                     and (prev.close > prev.ema_fast) and (last.close < last.ema_fast) \
                     and (int(last.supertrend_trend) == -1)

        # Optional extra triggers: KDJ cross / WR thresholds / TRIX cross
        if self.sc.use_kdj:
            kdj_long = (prev.kdj_k < prev.kdj_d) and (last.kdj_k > last.kdj_d) and (last.kdj_k < 40)
            kdj_short = (prev.kdj_k > prev.kdj_d) and (last.kdj_k < last.kdj_d) and (last.kdj_k > 60)
            long_trig = long_trig or kdj_long
            short_trig = short_trig or kdj_short
        if self.sc.use_wr and not np.isnan(last.get("wr14", np.nan)):
            wr_long = last.wr14 <= self.sc.wr_buy
            wr_short = last.wr14 >= self.sc.wr_sell
            long_trig = long_trig or wr_long
            short_trig = short_trig or wr_short
        if self.sc.use_trix and "trix9_signal" in sdf.columns:
            trix_long = (prev.trix9 < prev.trix9_signal) and (last.trix9 > last.trix9_signal)
            trix_short = (prev.trix9 > prev.trix9_signal) and (last.trix9 < last.trix9_signal)
            long_trig = long_trig or trix_long
            short_trig = short_trig or trix_short

        want_long = long_trig and trend_up and htf_up
        want_short = short_trig and trend_dn and htf_dn

        if self.cooldown > 0:
            self.cooldown -= 1
            return None
        if self.last_signal == "LONG" and want_long:
            return None
        if self.last_signal == "SHORT" and want_short:
            return None

        if want_long:
            entry = round(float(last.close), self.rm.cfg.symbol_price_precision)
            sl = round(entry - self.sc.atr_sl_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            tp = round(entry + self.sc.atr_tp_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            qty = self.rm.position_size(entry, sl)
            if qty <= 0: return None
            self.last_signal = "LONG"; self.cooldown = self.sc.cooldown_bars
            return Signal(self.sc.symbol, "LONG", entry, sl, tp, qty,
                          reason="RSI up-cross + EMA_fast break + ST up; Trend/HTF aligned",
                          meta={"rsi": float(last.rsi), "atr": float(last.atr), "adx": float(t_last.adx)})

        if want_short:
            entry = round(float(last.close), self.rm.cfg.symbol_price_precision)
            sl = round(entry + self.sc.atr_sl_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            tp = round(entry - self.sc.atr_tp_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            qty = self.rm.position_size(entry, sl)
            if qty <= 0: return None
            self.last_signal = "SHORT"; self.cooldown = self.sc.cooldown_bars
            return Signal(self.sc.symbol, "SHORT", entry, sl, tp, qty,
                          reason="RSI down-cross + EMA_fast break + ST down; Trend/HTF aligned",
                          meta={"rsi": float(last.rsi), "atr": float(last.atr), "adx": float(t_last.adx)})
        return None

# Trailing stop utility -------------------------------------------------------
def atr_trailing_stop(side: Side, entry: float, best_price: float, atr: float,
                      be_rr: float = 1.0, trail_mult: float = 1.0) -> float:
    if side == "LONG":
        rr = (best_price - entry) / max(1e-8, atr)
        return max(entry, best_price - trail_mult * atr) if rr >= be_rr else entry - 1e-6
    else:
        rr = (entry - best_price) / max(1e-8, atr)
        return min(entry, best_price + trail_mult * atr) if rr >= be_rr else entry + 1e-6

# ----------------------------------------------------------------------------
# Binance Executor (Testnet/Mainnet) — bracket orders & settings
# ----------------------------------------------------------------------------
class BinanceExecutor:
    def __init__(self, api_key: str, api_secret: str, testnet: bool = True, dry_run: bool = True,
                 hedge_mode: bool = True, margin_type: str = "ISOLATED", leverage: int = 5,
                 working_type: str = "MARK_PRICE"):
        self.dry_run = dry_run
        self.testnet = testnet
        self.hedge_mode = hedge_mode
        self.margin_type = margin_type
        self.leverage = leverage
        self.working_type = working_type
        try:
            from binance.um_futures import UMFutures
        except Exception as e:
            logger.error("binance-connector missing: %s", e)
            UMFutures = None
        base_url = "https://testnet.binancefuture.com" if testnet else None
        self.client = None
        if UMFutures is not None:
            self.client = UMFutures(api_key=api_key, api_secret=api_secret, base_url=base_url)

    # Defensive account setup
    def ensure_account(self, symbol: str):
        if self.dry_run or self.client is None:
            return
        try:
            if self.hedge_mode:
                self.client.change_position_mode(dualSidePosition="true")
            else:
                self.client.change_position_mode(dualSidePosition="false")
        except Exception as e:
            logger.warning("position mode: %s", e)
        try:
            self.client.change_margin_type(symbol=symbol, marginType=self.margin_type)
        except Exception:
            pass
        try:
            self.client.change_leverage(symbol=symbol, leverage=self.leverage)
        except Exception:
            pass

    def place_bracket(self, symbol: str, side: Side, qty: float, entry: float, sl: float, tp: float):
        logger.info("[ORDER] %s %s qty=%.6f entry=%.4f sl=%.4f tp=%.4f", side, symbol, qty, entry, sl, tp)
        if self.dry_run or self.client is None:
            return {"dry_run": True}
        is_buy = side == "LONG"
        order_side = "BUY" if is_buy else "SELL"
        try:
            self.client.new_order(symbol=symbol, side=order_side, type="LIMIT",
                                  quantity=str(qty), price=str(entry), timeInForce="GTC",
                                  reduceOnly="false")
            # SL / TP as closePosition true (brackets)
            self.client.new_order(symbol=symbol, side=("SELL" if is_buy else "BUY"), type="STOP_MARKET",
                                  stopPrice=str(sl), closePosition="true", workingType=self.working_type)
            self.client.new_order(symbol=symbol, side=("SELL" if is_buy else "BUY"), type="TAKE_PROFIT_MARKET",
                                  stopPrice=str(tp), closePosition="true", workingType=self.working_type)
        except Exception as e:
            logger.error("order error: %s", e)

    def update_trailing_stop(self, symbol: str, side: Side, new_stop: float):
        """Naive trailing: place a fresh STOP_MARKET closePosition (some venues allow multiple). 
        In production you may cancel/replace previous stop to avoid duplicates."""
        logger.info("[TRAIL] %s %s new_stop=%.4f", side, symbol, new_stop)
        if self.dry_run or self.client is None:
            return {"dry_run": True}
        try:
            self.client.new_order(symbol=symbol, side=("SELL" if side == "LONG" else "BUY"), type="STOP_MARKET",
                                  stopPrice=str(new_stop), closePosition="true", workingType=self.working_type)
        except Exception as e:
            logger.error("trail error: %s", e)

# ----------------------------------------------------------------------------
# App wiring (example loop; integrate with your WS feed)
# ----------------------------------------------------------------------------
class App:
    def __init__(self, symbols: List[str], sc: StratConfig, rc: RiskConfig, execu: BinanceExecutor):
        self.symbols = symbols
        self.sc = sc
        self.rc = rc
        self.exec = execu
        self.engines: Dict[str, StrategyEngine] = {s: StrategyEngine(StratConfig(symbol=s, signal_tf=sc.signal_tf, trend_tf=sc.trend_tf, htf=sc.htf,
                                                                                 rsi_period=sc.rsi_period, ema_fast=sc.ema_fast, ema_slow=sc.ema_slow,
                                                                                 adx_period=sc.adx_period, atr_period=sc.atr_period,
                                                                                 rsi_buy=sc.rsi_buy, rsi_sell=sc.rsi_sell, adx_min=sc.adx_min,
                                                                                 atr_sl_mult=sc.atr_sl_mult, atr_tp_mult=sc.atr_tp_mult,
                                                                                 cooldown_bars=sc.cooldown_bars, min_atr_pct_of_price=sc.min_atr_pct_of_price,
                                                                                 session_start_utc=sc.session_start_utc, session_end_utc=sc.session_end_utc,
                                                                                 use_kdj=sc.use_kdj, use_wr=sc.use_wr, use_trix=sc.use_trix,
                                                                                 wr_buy=sc.wr_buy, wr_sell=sc.wr_sell), rc)
                                            for s in symbols}
        # Simple position tracker for trailing
        self.positions: Dict[str, Dict[str, dict]] = {s: {"LONG": None, "SHORT": None} for s in symbols}

    def on_bar(self, symbol: str, tf: TF, bar: Bar):
        sig = self.engines[symbol].update_bar_close(tf, bar)
        if sig:
            self.exec.ensure_account(symbol)
            self.exec.place_bracket(symbol, sig.side, sig.size, sig.price, sig.sl, sig.tp)

# ----------------------------------------------------------------------------
# Binance WebSocket streamer (klines, closed-only) -> feeds App.on_bar
# ----------------------------------------------------------------------------
class BinanceWS:
    def __init__(self, symbols: List[str], tfs: List[TF], app: App, testnet: bool = True):
        self.symbols = [s.lower() for s in symbols]  # binance stream wants lowercase
        self.tfs = tfs
        self.app = app
        self.testnet = testnet
        self.ws_apps: List[object] = []

    def _make_urls(self) -> List[str]:
        base = "wss://stream.binancefuture.com" if self.testnet else "wss://fstream.binance.com"
        streams = [f"{sym}@kline_{tf}" for sym in self.symbols for tf in self.tfs]
        MAX = 200
        urls = []
        for i in range(0, len(streams), MAX):
            chunk = "/".join(streams[i:i+MAX])
            urls.append(f"{base}/stream?streams={chunk}")
        return urls

    def start(self):
        import json, threading
        import websocket

        def make_app(url):
            def on_message(ws, message):
                try:
                    msg = json.loads(message)
                    if "data" not in msg:
                        return
                    d = msg["data"]
                    if d.get("e") != "kline":
                        return
                    k = d.get("k", {})
                    if not k.get("x", False):
                        return
                    symbol = d.get("s", "").upper()
                    tf = k.get("i")
                    bar = Bar(
                        ts=as_utc(k.get("T")/1000),
                        open=float(k.get("o")),
                        high=float(k.get("h")),
                        low=float(k.get("l")),
                        close=float(k.get("c")),
                        volume=float(k.get("q", 0.0)),
                    )
                    self.app.on_bar(symbol, tf, bar)
                except Exception as e:
                    logger.error("WS message error: %s", e)
            def on_error(ws, error):
                logger.error("WS error: %s", error)
            def on_close(ws, code, msg):
                logger.warning("WS closed: %s %s", code, msg)
            def on_open(ws):
                logger.info("WS connected: %s", url)
            return websocket.WebSocketApp(url, on_message=on_message, on_error=on_error, on_close=on_close, on_open=on_open)

        urls = self._make_urls()
        for url in urls:
            app = make_app(url)
            t = threading.Thread(target=lambda: app.run_forever(ping_interval=20, ping_timeout=10), daemon=True)
            t.start()
            self.ws_apps.append(app)
        while True:
            time.sleep(60)

# ----------------------------------------------------------------------------
# Backtest (CSV klines) — simple PnL with SL/TP & trailing
# ----------------------------------------------------------------------------
class Backtester:
    def __init__(self, sc: StratConfig, rc: RiskConfig):
        self.engine = StrategyEngine(sc, rc)

    def run_csv(self, path: str, tf: TF) -> Dict[str, float]:
        df = pd.read_csv(path)
        # Expect columns: ts/open/high/low/close/volume (ts in seconds or ISO)
        if 'ts' in df.columns:
            try:
                ts = pd.to_datetime(df['ts'], utc=True)
            except Exception:
                ts = pd.to_datetime(df['ts'], unit='s', utc=True)
        else:
            ts = pd.to_datetime(df['close_time'], unit='ms', utc=True)
        pnl = 0.0; wins=0; losses=0; trades=0
        pos=None
        for i in range(len(df)):
            bar = Bar(ts=ts.iloc[i], open=float(df['open'].iloc[i]), high=float(df['high'].iloc[i]),
                      low=float(df['low'].iloc[i]), close=float(df['close'].iloc[i]), volume=float(df.get('volume', pd.Series([0]*len(df))).iloc[i]))
            sig = self.engine.update_bar_close(tf, bar)
            if sig and pos is None:
                pos = {"side": sig.side, "entry": sig.price, "sl": sig.sl, "tp": sig.tp, "best": sig.price, "atr": sig.meta.get("atr", 0.0)}
                trades += 1
            if pos:
                if pos["side"] == "LONG":
                    pos["best"] = max(pos["best"], bar.close)
                    new_sl = atr_trailing_stop("LONG", pos["entry"], pos["best"], pos["atr"] or max(1e-8, bar.high-bar.low))
                    pos["sl"] = max(pos["sl"], new_sl)
                    if bar.low <= pos["sl"]:
                        pnl += (pos["sl"] - pos["entry"]) ; losses += int(pos["sl"]<pos["entry"]) ; wins += int(pos["sl"]>pos["entry"]) ; pos=None
                    elif bar.high >= pos["tp"]:
                        pnl += (pos["tp"] - pos["entry"]) ; wins += 1 ; pos=None
                else:
                    pos["best"] = min(pos["best"], bar.close)
                    new_sl = atr_trailing_stop("SHORT", pos["entry"], pos["best"], pos["atr"] or max(1e-8, bar.high-bar.low))
                    pos["sl"] = min(pos["sl"], new_sl)
                    if bar.high >= pos["sl"]:
                        pnl += (pos["entry"] - pos["sl"]) ; losses += int(pos["sl"]>pos["entry"]) ; wins += int(pos["sl"]<pos["entry"]) ; pos=None
                    elif bar.low <= pos["tp"]:
                        pnl += (pos["entry"] - pos["tp"]) ; wins += 1 ; pos=None
        return {"pnl": pnl, "trades": trades, "wins": wins, "losses": losses}

# ----------------------------------------------------------------------------
# CLI / bootstrap (live WS demo)
# ----------------------------------------------------------------------------
if __name__ == "__main__":
    load_dotenv()
    api_key = os.getenv("BINANCE_API_KEY", "")
    api_secret = os.getenv("BINANCE_API_SECRET", "")
    testnet = os.getenv("USE_TESTNET", "true").lower() == "true"
    hedge_mode = os.getenv("BINANCE_HEDGE_MODE", "true").lower() == "true"
    margin_type = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED")
    leverage = int(os.getenv("BINANCE_LEVERAGE", "5"))
    working_type = os.getenv("WORKING_TYPE", "MARK_PRICE")
    dry_run = os.getenv("DRY_RUN", "true").lower() == "true"

    # Symbols: ALL → discover all USDT perpetuals
    symbols_env = os.getenv("SYMBOLS", "BTCUSDT")
    discover_all = symbols_env.strip().upper() in ("ALL", "*") or os.getenv("ALL_SYMBOLS", "false").lower()=="true"
    symbols = []
    if discover_all:
        try:
            from binance.um_futures import UMFutures
            base_url = "https://testnet.binancefuture.com" if testnet else None
            client = UMFutures(api_key=api_key, api_secret=api_secret, base_url=base_url)
            info = client.exchange_info()
            for s in info.get('symbols', []):
                if s.get('status') == 'TRADING' and s.get('quoteAsset') == 'USDT':
                    symbols.append(s.get('symbol'))
        except Exception as e:
            logger.error("symbol discovery failed: %s", e)
            symbols = ["BTCUSDT"]
    else:
        symbols = [s.strip().upper() for s in symbols_env.split(',') if s.strip()]

    # Timeframes: ALL → subscribe to all Binance futures klines
    tfs_env = os.getenv("TIMEFRAMES", "ALL")
all_tfs = ["1m","3m","5m","15m","30m","1h","2h","4h","6h","8h","12h","1d","3d","1w","1M"]
if tfs_env.strip().upper() in ("ALL", "*"):
    tfs = all_tfs
else:
    tfs = [tf.strip() for tf in tfs_env.split(',') if tf.strip()]

# Build configs (Risk reads from .env)
rc = RiskConfig(
    account_equity_usdt=float(os.getenv("ACCOUNT_EQUITY", "5000")),
    leverage=leverage,
    min_notional_usdt=float(os.getenv("MIN_NOTIONAL_USDT", "10")),
    max_risk_pct_per_trade=float(os.getenv("MAX_RISK_PCT_PER_TRADE", "0.015")),
    max_daily_drawdown_pct=float(os.getenv("MAX_DAILY_DRAWDOWN", "0.02"))
)

# Optional: log level from .env
log_level = os.getenv("LOG_LEVEL", "INFO").upper()
try:
    logger.setLevel(getattr(logging, log_level))
except Exception:
    pass

sc = StratConfig(symbol=symbols[0], signal_tf="1m", trend_tf="15m", htf="1h")
executor = BinanceExecutor(api_key, api_secret, testnet=testnet, dry_run=dry_run,
                           hedge_mode=hedge_mode, margin_type=margin_type,
                           leverage=leverage, working_type=working_type)
app = App(symbols, sc, rc, executor)

ws = BinanceWS(symbols, tfs, app, testnet=testnet)
logger.info("Starting Binance WS | symbols=%s | tfs=%s | dry_run=%s", symbols, tfs, dry_run)
ws.start()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\strategic_ai_engine\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\strategic_ai_engine\adaptive_strategy.py
from typing import List, Dict, Callable


import torch
import torch.nn as nn

class NeuralIntegrator(nn.Module):
    def __init__(self):
        super(NeuralIntegrator, self).__init__()
        self.fc1 = nn.Linear(10, 50)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(50, 2)  # Karar yolları

    def forward(self, x):
        x = self.relu(self.fc1(x))
        decision = self.fc2(x)
        return decision



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\agent_commander.py
class AgentCommander:
    def __init__(self):
        self.modules = {
            "data": None,
            "strategy": None,
            "optimizer": None,
            "dashboard": None
        }

    def register_module(self, name, module):
        self.modules[name] = module

    def coordinate(self):
        # Modüller arası iletişim ve kontrol
        signal = self.modules["data"].get_signal()
        decision = self.modules["strategy"].evaluate(signal)
        optimization = self.modules["optimizer"].analyze_module("strategy")

        self.modules["dashboard"].update_view(signal, decision, optimization)
        print("🧠 AI Komutan: Tüm modüller senkronize edildi.")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\crypto_hunter.py
import hashlib, datetime

class CryptoHunter:
    def __init__(self):
        self.traces = []

    def scan_block(self, block_data):
        trace = hashlib.sha256(block_data.encode()).hexdigest()
        timestamp = datetime.datetime.now()
        self.traces.append({"hash": trace, "time": timestamp})
        print(f"🎯 İz bulundu: {trace} - {timestamp}")

    def detect_anomalies(self):
        # Basit davranış analizi
        suspicious = [t for t in self.traces if str(t["hash"]).startswith("00")]
        return suspicious



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\data_feed.py
import websocket
import requests
import schedule
import time

class DataFeed:
    def __init__(self, api_url, ws_url):
        self.api_url = api_url
        self.ws_url = ws_url

    def fetch_http_data(self):
        data = requests.get(self.api_url).json()
        # Gelen verileri analiz için döndür
        return data

    def start_websocket(self):
        def on_message(ws, message):
            # Anlık sinyal yakalama
            print("Websocket verisi:", message)
        
        ws = websocket.WebSocketApp(self.ws_url, on_message=on_message)
        ws.run_forever()

    def run_scheduled_tasks(self):
        schedule.every(5).seconds.do(lambda: print(self.fetch_http_data()))
        while True:
            schedule.run_pending()
            time.sleep(1)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\deep_crypto_hunter.py
import torch
import torch.nn as nn

class DeepCryptoHunter(nn.Module):
    def __init__(self):
        super(DeepCryptoHunter, self).__init__()
        self.fc1 = nn.Linear(64, 128)
        self.relu = nn.LeakyReLU()
        self.fc2 = nn.Linear(128, 2)  # Tehdit / Temiz

    def forward(self, x):
        x = self.relu(self.fc1(x))
        prediction = self.fc2(x)
        return prediction

    def trace_hash(self, data):
        hashed = torch.tensor([ord(c) % 64 for c in data[:64]], dtype=torch.float32)
        decision = self.forward(hashed)
        status = "🛡️ Güvenli" if decision[0] < decision[1] else "⚠️ Şüpheli"
        print(f"{status} | Tahmin: {decision.tolist()}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\log_to_chain.py
import json
from datetime import datetime

class ChainLogger:
    def __init__(self, log_file='activity_chain.json'):
        self.log_file = log_file

    def log_event(self, event_type, module, details):
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "event": event_type,
            "module": module,
            "details": details
        }
        with open(self.log_file, 'a') as f:
            f.write(json.dumps(log_entry) + "\n")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\neuro_sync.py
import torch
import torch.nn as nn

class NeuralIntegrator(nn.Module):
    def __init__(self):
        super(NeuralIntegrator, self).__init__()
        self.fc1 = nn.Linear(10, 50)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(50, 2)  # Karar yolları

    def forward(self, x):
        x = self.relu(self.fc1(x))
        decision = self.fc2(x)
        return decision



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\optimizer.py
import psutil

class CodeOptimizer:
    def __init__(self, module_name):
        self.module = module_name

    def check_performance(self):
        cpu = psutil.cpu_percent()
        ram = psutil.virtual_memory().percent

        if cpu > 80 or ram > 80:
            return f"{self.module}: Yüksek kaynak tüketimi tespit edildi. Optimize edilmeli."
        return f"{self.module}: Performans normal."

    def suggest_optimization(self):
        analysis = self.check_performance()
        if "Optimize" in analysis:
            return "Kodun async yapılması, döngülerin sadeleştirilmesi veya cache eklenmesi önerilir."
        else:
            return "Kod şu anda verimli çalışıyor."



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\strategy_engine.py
def evaluate_signal(signal_data):
    if signal_data['volume'] > THRESHOLD and signal_data['sentiment'] > 0.7:
        return "BUY"
    elif signal_data['volume'] < LOW_THRESHOLD:
        return "HOLD"
    else:
        return "SELL"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\tactical_decision_simulator.py
def run_simulation(strategies, market_data):
    results = {}
    for name, strategy in strategies.items():
        score = 0
        for data in market_data:
            action = strategy(data)
            if action == data["optimal"]:
                score += 1
        results[name] = round(score / len(market_data), 3)
    return results



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\ai_kod_sistemi\trainer.py
class SignalTrainer:
    def __init__(self):
        self.model = SomeRLModel()

    def train_on_result(self, result):
        reward = calculate_reward(result)
        self.model.update(reward)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\test_modules.py\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\test_modules.py\test_modules.py
from emotion_sync_adapter import sync_emotion_to_task

task = "Yeni Proje Başlat"
emotion = "💡 İlham"

print(sync_emotion_to_task(emotion, task))



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\adaptive_signal_trainer.py
class SignalTrainer:
    def __init__(self):
        self.performance_log = {}

    def update_performance(self, wallet, signal, outcome):
        if wallet not in self.performance_log:
            self.performance_log[wallet] = []
        self.performance_log[wallet].append({
            "signal": signal,
            "outcome": outcome
        })

    def optimize_signal(self, wallet):
        log = self.performance_log.get(wallet, [])
        if not log:
            return "HOLD"

        buy_success = sum(1 for entry in log if entry["signal"] == "BUY" and entry["outcome"] == "success")
        buy_total = sum(1 for entry in log if entry["signal"] == "BUY")
        success_rate = buy_success / buy_total if buy_total else 0

        return "BUY" if success_rate > 0.6 else "HOLD"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\adaptive_task_engine.py
def adaptive_task_engine(logs, previous_success, boost_emotion="💡 İlham"):
    task_scores = {}
    for log in logs:
        task = log["task_id"]
        strength = log["feeling_strength"]
        emotion = log["emotion"]

        # Duygu gücü + geçmiş başarıya göre puanlama
        base_score = strength
        if previous_success.get(task, False):
            base_score += 20  # başarı bonusu

        if emotion == boost_emotion:
            base_score *= 1.3  # motivasyon etkisi

        task_scores[task] = round(base_score, 2)

    # Görevleri en yüksek puana göre sırala
    sorted_tasks = sorted(task_scores.items(), key=lambda x: x[1], reverse=True)
    return sorted_tasks



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\adaptive_trader_gui.py
from PyQt5 import QtWidgets, QtCore

class TraderDashboard(QtWidgets.QWidget):
    def __init__(self, user_profile):
        super().__init__()
        self.setWindowTitle("📊 Kamal Trading Panel")
        self.layout = QtWidgets.QVBoxLayout()

        self.label = QtWidgets.QLabel(f"Hoş geldin Komutan {user_profile['name']}")
        self.layout.addWidget(self.label)

        self.risk_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.risk_slider.setMinimum(1)
        self.risk_slider.setMaximum(10)
        self.risk_slider.setValue(user_profile["risk_level"])
        self.layout.addWidget(QtWidgets.QLabel("⚙️ Risk Seviyesi"))
        self.layout.addWidget(self.risk_slider)

        self.signal_box = QtWidgets.QTextEdit()
        self.signal_box.setReadOnly(True)
        self.layout.addWidget(QtWidgets.QLabel("📡 Gelen Sinyaller"))
        self.layout.addWidget(self.signal_box)

        self.setLayout(self.layout)
        self.resize(400, 300)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\anamaly_trade_orchestrator.py
def trade_orchestrator(chainsignals, risk_threshold=0.6):
    trades = []
    for signal in chainsignals:
        asset = signal["asset"]
        volatility = signal["volatility"]
        momentum = signal["momentum"]
        anomaly_score = signal["anomaly_score"]

        risk = round(volatility * anomaly_score * (1 - momentum), 2)

        if risk > risk_threshold:
            decision = f"⛔ {asset}: Ticaret Askıya Alındı (Risk={risk})"
        else:
            decision = f"✅ {asset}: İşlem Aktifleştirildi (Risk={risk})"
        
        trades.append(decision)
    return trades



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\autonomous_trade_initiator.py
import random

def generate_trade_signal(predictions):
    signals = {}
    for wallet, note in predictions.items():
        if "büyük hareket" in note:
            signals[wallet] = {
                "action": "BUY",
                "confidence": round(random.uniform(0.8, 0.95), 2),
                "leverage": 3
            }
        else:
            signals[wallet] = {
                "action": "HOLD",
                "confidence": round(random.uniform(0.5, 0.7), 2),
                "leverage": 1
            }
    return signals



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\chain_listener.py
from web3 import Web3
import threading

eth_node = "wss://mainnet.infura.io/ws/v3/YOUR_PROJECT_ID"
web3 = Web3(Web3.WebsocketProvider(eth_node))

def handle_block(block_hash):
    block = web3.eth.get_block(block_hash, full_transactions=True)
    print(f"🧿 Yeni Blok: {block.number} — İşlem Sayısı: {len(block.transactions)}")

def listener():
    print("📡 Ethereum zincir dinleyicisi başlatılıyor...")
    sub = web3.eth.subscribe("newHeads", {}, lambda event: handle_block(event['hash']))

listener_thread = threading.Thread(target=listener)
listener_thread.start()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\chain_momentum_bot.py
class ChainMomentumBot:
    def __init__(self, transactions):
        self.transactions = transactions
        self.predictions = predict_wallet_behavior(transactions)
        self.signals = generate_trade_signal(self.predictions)
        self.executed_trades = []

    def execute_trades(self):
        for wallet, signal in self.signals.items():
            action = signal["action"]
            confidence = signal["confidence"]
            if action == "BUY" and confidence > 0.85:
                self.executed_trades.append({
                    "wallet": wallet,
                    "action": action,
                    "confidence": confidence
                })
    
    def react_to_live_tx(self, tx):
        eth_value = Web3.fromWei(tx["value"], 'ether')
        if eth_value > 5:
            print(f"🚨 Canlı Tepki: {tx['from']} ➡️ {tx['to']} | Değer: {eth_value} ETH")
            self.executed_trades.append({
                "wallet": tx["to"],
                "action": "BUY",
                "confidence": 0.9
            })



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\chain_sentiment_translator.py
def translate_sentiment(posts):
    sentiment_map = {
        "bullish": 1,
        "bearish": -1,
        "neutral": 0
    }

    asset_sentiments = {}
    for post in posts:
        asset = post["asset"]
        sentiment = sentiment_map.get(post["sentiment"], 0)

        if asset not in asset_sentiments:
            asset_sentiments[asset] = 0
        asset_sentiments[asset] += sentiment

    sorted_assets = sorted(asset_sentiments.items(), key=lambda x: x[1], reverse=True)
    return sorted_assets



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\cognitive_flow_optimizer.py
if emotion == "🔥 Tutku" and focus_level > 75:
    flow_mode = "🎯 Hedefe kilitlen – Kod akışı başlasın!"
else:
    flow_mode = "🌙 Yavaş mod – Hazırlık aşaması"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\cryptXSentinel.py
"""Yüksek Güvenlikli Kripto Veri Taraması ve İstihbarat Filtreleme"""

class CryptXSentinel:
    def __init__(self):
        self.logs = []

    def record_signal(self, origin, hash_signature, entropy, timestamp):
        self.logs.append({
            "origin": origin,
            "hash_signature": hash_signature,
            "entropy": entropy,
            "timestamp": timestamp
        })

    def shield_scan(self):
        return [
            log for log in self.logs
            if log["entropy"] > 0.85 and log["origin"] != "authorized_zone"
        ]

    def stealth_metric(self):
        import statistics
        entropy_values = [log["entropy"] for log in self.logs]
        return round(statistics.median(entropy_values), 4)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\data_reinforcement_unit.py
def reinforce_from_logs(logs):
    patterns = detect_efficiency_patterns(logs)
    return f"📈 Öğrenildi: {patterns} — Yeni görev önerilecek"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\emotion_sync_adapter.py
if current_mission == "Yeni Proje Başlat":
    emotion_check = "✅ Uyumluysa senkronize et, değilse beklet"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\emotive_flux_visualizer.py
import matplotlib.pyplot as plt
from datetime import datetime

def visualize_emotions(logs):
    times = [datetime.strptime(log["timestamp"], "%Y-%m-%dT%H:%M") for log in logs]
    strengths = [log["feeling_strength"] for log in logs]
    emotions = [log["emotion"] for log in logs]

    plt.figure(figsize=(10, 6))
    plt.plot(times, strengths, marker='o', linestyle='-', color='skyblue')
    for i, emotion in enumerate(emotions):
        plt.text(times[i], strengths[i]+2, emotion, fontsize=10, ha='center')

    plt.title("🧭 Duygu Akışı Zaman Çizelgesi", fontsize=14)
    plt.xlabel("⏱ Zaman")
    plt.ylabel("⚡ Duygu Gücü")
    plt.grid(True)
    plt.tight_layout()
    plt.show()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\futures_bot.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\galactic_emotion_pluse.py
"""Galaktik Görev Analitiği ve Çok Katmanlı Duygu Dinamikleri"""

import datetime

class GalacticEngine:
    def __init__(self):
        self.records = []

    def log_event(self, task_id, emotion, strength, timestamp=None):
        if not timestamp:
            timestamp = datetime.datetime.now()
        self.records.append({
            "task_id": task_id,
            "emotion": emotion,
            "strength": strength,
            "timestamp": timestamp
        })

    def deep_scan(self):
        from collections import defaultdict
        import statistics

        emotion_clusters = defaultdict(list)
        for record in self.records:
            emotion_clusters[record["emotion"]].append(record["strength"])

        report = {}
        for emotion, values in emotion_clusters.items():
            report[emotion] = {
                "average_strength": round(statistics.mean(values), 2),
                "peak_strength": max(values),
                "count": len(values)
            }

        return report


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\insight_predictor.py
if fatigue_rising and emotional_drop:
    prediction = "⚠️ Olası tıkanma – Dinlenme önerisi"
else:
    prediction = "🔮 Açılım yaklaşıyor – Görev öner"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\liquidity_wave_detector.py
def detect_liquidity_wave(blocks, threshold=3):
    wave_alerts = []
    for i in range(1, len(blocks)):
        prev_volume = blocks[i - 1]["volume"]
        curr_volume = blocks[i]["volume"]
        delta = curr_volume - prev_volume

        if delta > threshold * prev_volume:
            wave_alerts.append({
                "block": blocks[i]["number"],
                "delta": delta,
                "risk_level": "HIGH",
                "message": f"⚠️ Likidite Dalgası Algılandı: Blok {blocks[i]['number']} | Artış: {delta}"
            })
    return wave_alerts



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\market_shock_predictor.py
from textblob import TextBlob

def predict_market_impact(news_feed):
    impact_scores = []
    for news in news_feed:
        sentiment = TextBlob(news["content"]).sentiment.polarity
        if sentiment > 0.3:
            impact_scores.append({
                "source": news["source"],
                "impact": "Bullish",
                "score": round(sentiment, 2)
            })
        elif sentiment < -0.3:
            impact_scores.append({
                "source": news["source"],
                "impact": "Bearish",
                "score": round(sentiment, 2)
            })
        else:
            impact_scores.append({
                "source": news["source"],
                "impact": "Neutral",
                "score": round(sentiment, 2)
            })
    return impact_scores



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\mission_trigger_resolver.py
def resolve_triggers(logs):
    triggers = {}
    for log in logs:
        emotion = log["emotion"]
        task = log["task_id"]
        if emotion not in triggers:
            triggers[emotion] = []
        triggers[emotion].append(task)
    return triggers



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\multi_chain_oracle.py
def multi_chain_oracle(chain_data):
    unified_signals = {}
    for chain_name, signals in chain_data.items():
        for asset, signal in signals.items():
            if asset not in unified_signals:
                unified_signals[asset] = {"BUY": 0, "HOLD": 0, "SELL": 0}
            unified_signals[asset][signal] += 1

    final_decisions = {}
    for asset, votes in unified_signals.items():
        decision = max(votes, key=votes.get)
        confidence = round(votes[decision] / sum(votes.values()), 2)
        final_decisions[asset] = {
            "decision": decision,
            "confidence": confidence
        }
    return final_decisions



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\neural_tactical_engine.py
"""Stratejik Görev Analizi ve Veri İstihbaratı"""

class StrategicProject:
    def __init__(self):
        self.tasks = []
    
    def add_task(self, task_id, emotion, strength, timestamp):
        self.tasks.append({
            "task_id": task_id,
            "emotion": emotion,
            "strength": strength,
            "timestamp": timestamp
        })

    def analyze(self):
        from collections import Counter
        import statistics

        summary = {}
        task_counter = Counter([task["task_id"] for task in self.tasks])
        strength_values = [task["strength"] for task in self.tasks]

        summary["top_tasks"] = task_counter.most_common(3)
        summary["average_strength"] = round(statistics.mean(strength_values), 3)
        summary["max_strength"] = max(strength_values)

        return summary



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\next_mission_oracle.py
def suggest_mission(logs, intuition_map):
    for log in logs:
        task = log["task_id"]
        if intuition_map[task] == "🔮 Fırsat Penceresi":
            print(f"✅ Görev {task}: Şimdi Başla! İlham zirvede.")
        elif intuition_map[task] == "⚠️ Kararsızlık Engeli":
            print(f"🧘 Görev {task}: Beklet – Önce zihinsel rahatlama gerek.")
        else:
            print(f"📌 Görev {task}: Nötr verim – Stratejik zamanlama uygula.")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\Nova_Strategos_v10_offchain.py
# NovaStrategosPrime_v10.py
# Ultra hibrit, pro-elit, AI destekli duygu-strateji paneli (tek dosya)

import sys, csv, json, random, statistics, os
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from PyQt5 import QtWidgets, QtCore

# ====== Veri Modeli ======

@dataclass
class EmotionLog:
    task_id: str
    emotion: str
    feeling_strength: float
    timestamp: datetime

# ====== Yardımcılar ======

class NotificationBus:
    def send(self, message: str):
        # Gerekirse burada Telegram/Email entegrasyonu bağlanabilir
        print(f"[NOTIFY] {message}")

class Persist:
    def __init__(self, path: str = "nova_config.json"):
        self.path = path
        self.data = {}
        self.load()

    def load(self):
        if os.path.exists(self.path):
            try:
                with open(self.path, "r", encoding="utf-8") as f:
                    self.data = json.load(f)
            except Exception:
                self.data = {}
        else:
            self.data = {}

    def save(self):
        try:
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump(self.data, f, ensure_ascii=False, indent=2, default=str)
        except Exception as e:
            print(f"[Persist] Kaydetme hatası: {e}")

# ====== CSV Köprüsü ======

class CSVBridge:
    @staticmethod
    def load_logs(path: str) -> List[EmotionLog]:
        logs = []
        with open(path, "r", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            for row in reader:
                try:
                    ts = row.get("timestamp") or datetime.utcnow().isoformat()
                    logs.append(
                        EmotionLog(
                            task_id=row["task_id"],
                            emotion=row.get("emotion", "Neutral"),
                            feeling_strength=float(row["feeling_strength"]),
                            timestamp=datetime.fromisoformat(ts.replace("Z",""))
                        )
                    )
                except Exception:
                    # Hatalı satırlar atlanır
                    continue
        return logs

    @staticmethod
    def save_report(path: str, report: Dict[str, Any]):
        keys = ["task_id", "avg", "max", "vol", "risk", "count"]
        with open(path, "w", encoding="utf-8", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(keys)
            for task, m in report.items():
                writer.writerow([task, m["avg"], m["max"], m["vol"], m["risk"], m["count"]])

# ====== Ultra Hibrit Çekirdek ======

class NovaEmotionStrategos:
    def __init__(self):
        self.logs: List[EmotionLog] = []
        self._cache_report: Optional[Dict[str, Any]] = None

    def ingest(self, log: EmotionLog):
        self.logs.append(log)
        self._cache_report = None  # cache invalidation

    def _series(self, task_id: str) -> List[float]:
        return [l.feeling_strength for l in self.logs if l.task_id == task_id]

    def analyze(self) -> Dict[str, Any]:
        if self._cache_report is not None:
            return self._cache_report
        report = {}
        by_task = {}
        for l in self.logs:
            by_task.setdefault(l.task_id, []).append(l.feeling_strength)

        for task, strengths in by_task.items():
            avg = round(statistics.mean(strengths), 2) if strengths else 0
            mx = max(strengths) if strengths else 0
            vol = round(statistics.stdev(strengths), 2) if len(strengths) > 1 else 0
            risk = self.classify_risk(avg, vol)
            report[task] = {"avg": avg, "max": mx, "vol": vol, "risk": risk, "count": len(strengths)}
        self._cache_report = report
        return report

    def classify_risk(self, avg: float, vol: float) -> str:
        if avg >= 7 and vol >= 2:
            return "Yüksek"
        if avg >= 5:
            return "Orta"
        return "Düşük"

class SignalEngine:
    def __init__(self, cooldown_sec: int = 20):
        self.last_signal_at: Dict[str, datetime] = {}
        self.cooldown = timedelta(seconds=cooldown_sec)

    def can_signal(self, task_id: str) -> bool:
        t = self.last_signal_at.get(task_id)
        return (t is None) or (datetime.utcnow() - t >= self.cooldown)

    def mark_signaled(self, task_id: str):
        self.last_signal_at[task_id] = datetime.utcnow()

    def generate(self, task_id: str, metrics: Dict[str, Any], user_risk: int) -> str:
        risk = metrics["risk"]
        avg, vol = metrics["avg"], metrics["vol"]
        # Kullanıcı risk seviyesi eşikleri kaydırır
        sens = max(0.5, min(1.5, 1 + (user_risk - 5) * 0.08))  # 1 = nötr
        score = avg * 0.6 + vol * 0.4
        score *= sens

        if risk == "Yüksek" and score > 7:
            return f"⚠️ {task_id}: Duygusal stres yüksek (avg:{avg}, vol:{vol}). Hızlı müdahale önerilir."
        if risk == "Orta" and score > 5.5:
            return f"🔍 {task_id}: Dalgalanma mevcut (avg:{avg}, vol:{vol}). Yakın izleme önerilir."
        return f"✅ {task_id}: Stabil (avg:{avg}, vol:{vol})."

class RiskManager:
    def size(self, confidence: float, user_risk: int) -> Dict[str, Any]:
        # Simülasyon: pozisyon boyutu ve SL/TP önerisi (gerçek işlem yapmaz)
        base = min(max(confidence, 0.5), 0.95)
        risk_factor = 0.5 + (user_risk / 20)  # 0.5..1.0
        size = round(1000 * base * risk_factor, 0)
        sl = round(1.0 + (1.0 - base) * 0.5, 3)   # 1.0x–1.25x
        tp = round(1.0 + base * 1.2, 3)          # 1.6x’a kadar
        return {"size": size, "sl_mult": sl, "tp_mult": tp}

# ====== Canlı Akış Simülatörü ======

class StreamSimulator(QtCore.QObject):
    newLog = QtCore.pyqtSignal(EmotionLog)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.timer = QtCore.QTimer(self)
        self.timer.timeout.connect(self._tick)
        self.tasks = ["ALPHA", "BETA", "GAMMA"]

    def start(self, interval_ms=1500):
        self.timer.start(interval_ms)

    def stop(self):
        self.timer.stop()

    def _tick(self):
        task = random.choice(self.tasks)
        emotion = random.choice(["Stress", "Focus", "Anxiety", "Calm"])
        strength = round(random.uniform(3.0, 9.5), 2)
        log = EmotionLog(task, emotion, strength, datetime.utcnow())
        self.newLog.emit(log)

# ====== UI Panel ======

class TraderDashboard(QtWidgets.QWidget):
    def __init__(self, user_profile: Dict[str, Any], core: NovaEmotionStrategos,
                 signals: SignalEngine, risk: RiskManager, persist: Persist, bus: NotificationBus):
        super().__init__()
        self.setWindowTitle("📊 Nova Strategos Prime — Zirve Panel")
        self.core = core
        self.signals = signals
        self.risk = risk
        self.persist = persist
        self.bus = bus

        self.layout = QtWidgets.QVBoxLayout(self)
        # Üst başlık
        self.title = QtWidgets.QLabel(f"Hoş geldin Komutan {user_profile['name']}")
        self.title.setStyleSheet("font-weight:600;font-size:16px;")
        self.layout.addWidget(self.title)

        # Risk seviyesi
        self.layout.addWidget(QtWidgets.QLabel("⚙️ Risk Seviyesi"))
        self.risk_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.risk_slider.setMinimum(1); self.risk_slider.setMaximum(10)
        self.risk_slider.setValue(user_profile.get("risk_level", 5))
        self.layout.addWidget(self.risk_slider)

        # Butonlar
        btns = QtWidgets.QHBoxLayout()
        self.btn_load = QtWidgets.QPushButton("📥 CSV Yükle")
        self.btn_export = QtWidgets.QPushButton("📤 Raporu CSV'ye Yaz")
        self.btn_analyze = QtWidgets.QPushButton("🧠 Analiz Yap")
        self.btn_stream = QtWidgets.QPushButton("▶️ Canlı Akış")
        self.btn_stop = QtWidgets.QPushButton("⏸️ Durdur")
        btns.addWidget(self.btn_load); btns.addWidget(self.btn_export)
        btns.addWidget(self.btn_analyze); btns.addWidget(self.btn_stream); btns.addWidget(self.btn_stop)
        self.layout.addLayout(btns)

        # Sinyaller ve metrikler
        self.layout.addWidget(QtWidgets.QLabel("📡 Gelen Sinyaller"))
        self.signal_box = QtWidgets.QTextEdit(); self.signal_box.setReadOnly(True)
        self.layout.addWidget(self.signal_box)

        self.layout.addWidget(QtWidgets.QLabel("📈 Metrikler"))
        self.metrics = QtWidgets.QTextEdit(); self.metrics.setReadOnly(True)
        self.layout.addWidget(self.metrics)

        # Durum çubuğu
        self.status = QtWidgets.QLabel("Hazır.")
        self.layout.addWidget(self.status)

        # Bağlantılar
        self.btn_load.clicked.connect(self.on_load_csv)
        self.btn_export.clicked.connect(self.on_export_csv)
        self.btn_analyze.clicked.connect(self.on_analyze)
        self.btn_stream.clicked.connect(self.on_stream)
        self.btn_stop.clicked.connect(self.on_stop)
        self.risk_slider.valueChanged.connect(self.on_risk_change)

        # Simülatör
        self.sim = StreamSimulator(self)
        self.sim.newLog.connect(self.on_new_log)

        # Kullanıcı profili
        self.user_profile = user_profile

        # İlk durum
        self.refresh_metrics()

    # --- Event handlers ---

    def on_risk_change(self, v: int):
        self.user_profile["risk_level"] = v
        self.persist.data["user_profile"] = self.user_profile
        self.persist.save()
        self.status.setText(f"Risk seviyesi güncellendi: {v}")

    def on_load_csv(self):
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "CSV Dosyası Seç", "", "CSV Files (*.csv)")
        if not path: 
            return
        logs = CSVBridge.load_logs(path)
        for l in logs:
            self.core.ingest(l)
        self.refresh_metrics()
        self.status.setText(f"{len(logs)} kayıt yüklendi.")
        self.bus.send(f"{len(logs)} CSV kaydı panele aktarıldı.")

    def on_export_csv(self):
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Raporu Kaydet", "nova_report.csv", "CSV Files (*.csv)")
        if not path:
            return
        report = self.core.analyze()
        CSVBridge.save_report(path, report)
        self.status.setText(f"Rapor kaydedildi: {os.path.basename(path)}")
        self.bus.send("Rapor CSV’ye yazıldı.")

    def on_analyze(self):
        self.refresh_metrics()
        self.emit_signals()

    def on_stream(self):
        self.sim.start(1200)
        self.status.setText("Canlı akış başlatıldı.")
        self.bus.send("Simülasyon akışı aktif.")

    def on_stop(self):
        self.sim.stop()
        self.status.setText("Akış durduruldu.")
        self.bus.send("Simülasyon akışı durduruldu.")

    def on_new_log(self, log: EmotionLog):
        self.core.ingest(log)
        # Anlık mikro-sinyal (cooldown kontrolü)
        rep = self.core.analyze()
        m = rep.get(log.task_id)
        if m and self.signals.can_signal(log.task_id):
            msg = self.signals.generate(log.task_id, m, self.user_profile["risk_level"])
            self.signal_box.append(f"{datetime.utcnow().isoformat()} — {msg}")
            self.signals.mark_signaled(log.task_id)
        # Metrikleri periyodik güncelle
        self.refresh_metrics()

    # --- Yardımcılar ---

    def refresh_metrics(self):
        rep = self.core.analyze()
        lines = []
        for task, m in sorted(rep.items()):
            lines.append(f"[Görev: {task}] avg:{m['avg']} | max:{m['max']} | vol:{m['vol']} | risk:{m['risk']} | n:{m['count']}")
        self.metrics.setText("\n".join(lines) if lines else "Henüz veri yok.")

    def emit_signals(self):
        rep = self.core.analyze()
        for task_id, m in rep.items():
            if self.signals.can_signal(task_id):
                msg = self.signals.generate(task_id, m, self.user_profile["risk_level"])
                # Pozisyon boyutu önerisi (simülasyon)
                conf = self._confidence_from_metrics(m)
                sizing = self.risk.size(conf, self.user_profile["risk_level"])
                enriched = f"{msg} | size:{sizing['size']} | SLx:{sizing['sl_mult']} | TPx:{sizing['tp_mult']}"
                self.signal_box.append(f"{datetime.utcnow().isoformat()} — {enriched}")
                self.signals.mark_signaled(task_id)

    def _confidence_from_metrics(self, m: Dict[str, Any]) -> float:
        # Basit güven skoru: düşük risk -> daha yüksek güven
        base = 0.7 if m["risk"] == "Düşük" else 0.6 if m["risk"] == "Orta" else 0.55
        adj = max(0.9, min(1.1, 1 - (m["vol"] / 10)))
        return round(base * adj, 2)

# ====== Uygulama Girişi ======

def main():
    # Varsayılan profil
    persist = Persist()
    user_profile = persist.data.get("user_profile") or {"name": "Kamal", "risk_level": 6}

    core = NovaEmotionStrategos()
    signals = SignalEngine(cooldown_sec=20)
    risk = RiskManager()
    bus = NotificationBus()

    app = QtWidgets.QApplication(sys.argv)
    panel = TraderDashboard(user_profile, core, signals, risk, persist, bus)

    # Örnek başlangıç verisi
    seed = [
        EmotionLog("ALPHA", "Stress", 7.8, datetime.utcnow()),
        EmotionLog("ALPHA", "Anxiety", 6.9, datetime.utcnow()),
        EmotionLog("BETA", "Focus", 4.2, datetime.utcnow()),
        EmotionLog("GAMMA", "Calm", 3.8, datetime.utcnow()),
    ]
    for l in seed: core.ingest(l)

    panel.resize(720, 600)
    panel.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\Nova_StrategosPrime_v12_onchain.py
# NovaStrategosPrime_v12_onchain.py
# Ultra hibrit ALTRA AI + On-Chain entegrasyonlu tek dosya zirve paneli

import sys, csv, json, os, math, random, statistics, hashlib, webbrowser
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from PyQt5 import QtWidgets, QtCore, QtGui

# --- Web3 isteğe bağlı ---
try:
    from web3 import Web3
    from eth_account import Account
    from eth_account.messages import encode_structured_data
    HAS_WEB3 = True
except Exception:
    HAS_WEB3 = False

# =========================
# Veri modeli
# =========================

@dataclass
class EmotionLog:
    task_id: str
    emotion: str
    feeling_strength: float
    timestamp: datetime

# =========================
# Yardımcılar / Kalıcılık
# =========================

class NotificationBus:
    def __init__(self, sound_on=True):
        self.sound_on = sound_on
    def send(self, msg: str, widget: Optional[QtWidgets.QWidget]=None):
        ts = datetime.utcnow().strftime("%H:%M:%S")
        print(f"[{ts}] {msg}")
        if widget and self.sound_on:
            QtWidgets.QApplication.beep()

class Persist:
    def __init__(self, path="nova_config.json"):
        self.path = path
        self.data: Dict[str, Any] = {}
        self.load()
    def load(self):
        if os.path.exists(self.path):
            try:
                with open(self.path, "r", encoding="utf-8") as f:
                    self.data = json.load(f)
            except Exception:
                self.data = {}
    def save(self):
        try:
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump(self.data, f, ensure_ascii=False, indent=2, default=str)
        except Exception as e:
            print(f"[Persist] save error: {e}")

# =========================
# IO Köprüsü (CSV/JSON/HTML)
# =========================

class IOBridge:
    @staticmethod
    def load_logs_csv(path: str) -> List[EmotionLog]:
        logs = []
        with open(path, "r", encoding="utf-8") as f:
            r = csv.DictReader(f)
            for row in r:
                try:
                    ts = row.get("timestamp") or datetime.utcnow().isoformat()
                    logs.append(EmotionLog(
                        task_id=row["task_id"],
                        emotion=row.get("emotion","Neutral"),
                        feeling_strength=float(row["feeling_strength"]),
                        timestamp=datetime.fromisoformat(ts.replace("Z",""))
                    ))
                except Exception:
                    continue
        return logs

    @staticmethod
    def save_report_csv(path: str, report: Dict[str, Any]):
        keys = ["task_id","avg","max","vol","risk","regime","count"]
        with open(path, "w", encoding="utf-8", newline="") as f:
            w = csv.writer(f); w.writerow(keys)
            for t,m in report.items():
                w.writerow([t, m["avg"], m["max"], m["vol"], m["risk"], m.get("regime","-"), m["count"]])

    @staticmethod
    def save_snapshot_json(path: str, payload: Dict[str, Any]):
        with open(path, "w", encoding="utf-8") as f:
            json.dump(payload, f, ensure_ascii=False, indent=2, default=str)

    @staticmethod
    def save_html_overview(path: str, overview: Dict[str, Any]):
        head = "<style>body{font-family:Segoe UI,Arial}table{border-collapse:collapse}td,th{border:1px solid #ccc;padding:6px}</style>"
        rows = ""
        for task, m in overview["report"].items():
            rows += f"<tr><td>{task}</td><td>{m['avg']}</td><td>{m['max']}</td><td>{m['vol']}</td><td>{m['risk']}</td><td>{m.get('regime','-')}</td></tr>"
        html = f"""<html><head>{head}</head><body>
        <h2>Nova Strategos Prime — Özet</h2>
        <p>Kullanıcı: {overview['user']['name']} | Risk: {overview['user']['risk_level']} | Tarih: {datetime.utcnow().isoformat()}</p>
        <table><tr><th>Görev</th><th>Ortalama</th><th>Maks</th><th>Vol</th><th>Risk</th><th>Rejim</th></tr>{rows}</table>
        <h3>Notlar</h3><pre>{overview.get('notes','')}</pre></body></html>"""
        with open(path,"w",encoding="utf-8") as f: f.write(html)

# =========================
# Çekirdek analiz/gösterge
# =========================

class NovaEmotionStrategos:
    def __init__(self):
        self.logs: List[EmotionLog] = []
        self._cache: Optional[Dict[str, Any]] = None
    def ingest(self, log: EmotionLog):
        self.logs.append(log); self._cache = None
    def series(self, task_id: str) -> List[float]:
        return [l.feeling_strength for l in self.logs if l.task_id==task_id]
    def analyze(self) -> Dict[str, Any]:
        if self._cache is not None: return self._cache
        out: Dict[str, Any] = {}; bucket: Dict[str, List[float]] = {}
        for l in self.logs: bucket.setdefault(l.task_id, []).append(l.feeling_strength)
        for t, arr in bucket.items():
            avg = round(statistics.mean(arr),2) if arr else 0
            mx  = max(arr) if arr else 0
            vol = round(statistics.stdev(arr),2) if len(arr)>1 else 0
            risk = "Yüksek" if (avg>=7 and vol>=2) else "Orta" if avg>=5 else "Düşük"
            out[t] = {"avg":avg,"max":mx,"vol":vol,"risk":risk,"count":len(arr)}
        self._cache = out
        return out

class IndicatorEngine:
    def __init__(self, core: NovaEmotionStrategos):
        self.core = core
        self.alpha_fast = 2/(5+1); self.alpha_slow = 2/(12+1)
    def _ema(self, vals, a):
        if not vals: return 0.0
        ema = vals[0]
        for v in vals[1:]: ema = a*v + (1-a)*ema
        return round(ema,3)
    def _rsi(self, vals, p=14):
        if len(vals)<2: return 50.0
        g,l = [],[]
        for i in range(1,len(vals)):
            d = vals[i]-vals[i-1]; g.append(max(0,d)); l.append(max(0,-d))
        pg = sum(g[-p:])/max(1,min(p,len(g))); pl = sum(l[-p:])/max(1,min(p,len(l)))
        rs = pg/(pl if pl!=0 else 1e-6); rsi = 100 - (100/(1+rs))
        return round(max(0,min(100,rsi)),2)
    def _ew_vol(self, vals, a=0.2):
        if len(vals)<2: return 0.0
        mean=vals[0]; var=0.0
        for v in vals[1:]:
            mean = a*v + (1-a)*mean
            var = a*((v-mean)**2) + (1-a)*var
        return round(math.sqrt(var),3)
    def _z(self, vals, w=20):
        if not vals: return 0.0
        sl = vals[-w:]; mu = statistics.mean(sl); sd = statistics.pstdev(sl) if len(sl)>1 else 1.0
        return round((vals[-1]-mu)/(sd if sd>1e-6 else 1.0),3)
    def features(self, task_id: str) -> Dict[str,float]:
        s = self.core.series(task_id)
        fast = self._ema(s,self.alpha_fast); slow = self._ema(s,self.alpha_slow)
        macd = round(fast-slow,3); rsi=self._rsi(s); ewv=self._ew_vol(s); z=self._z(s)
        return {"ema_fast":fast,"ema_slow":slow,"macd":macd,"rsi":rsi,"ew_vol":ewv,"z":z}

class RegimeDetector:
    def detect(self, f: Dict[str,float]) -> str:
        if f["rsi"]>65 or (f["ew_vol"]>2 and f["z"]>1): return "Stres"
        if 45<=f["rsi"]<=65 and (0.5<f["ew_vol"]<2.5):   return "Dalgalı"
        return "Sakin"

class SignalEngine:
    def __init__(self, cooldown_sec=20):
        self.cooldown = timedelta(seconds=cooldown_sec)
        self.last_at: Dict[str, datetime] = {}
    def can_signal(self, task_id: str)->bool:
        t=self.last_at.get(task_id); return (t is None) or (datetime.utcnow()-t>=self.cooldown)
    def mark(self, task_id: str): self.last_at[task_id]=datetime.utcnow()
    def generate(self, task_id, m, user_risk, regime, f) -> str:
        avg, vol = m["avg"], m["vol"]
        sens = max(0.5,min(1.5,1+(user_risk-5)*0.08))
        base = avg*0.5 + vol*0.3 + max(0,f["z"])*0.2
        if regime=="Stres": base += 1.0
        score = base*sens
        if score>7:   return f"⚠️ {task_id}: Yüksek stres (avg:{avg}, vol:{vol}, z:{f['z']}, rejim:{regime})"
        if score>5.5: return f"🔍 {task_id}: Dalgalanma izlenmeli (avg:{avg}, vol:{vol}, rejim:{regime})"
        return f"✅ {task_id}: Stabil (avg:{avg}, vol:{vol}, rejim:{regime})"

class AIAdvisor:
    def __init__(self, persist: Persist):
        self.persist = persist
        self.w = persist.data.get("ai_weights") or {"macd":0.8,"rsi":0.5,"z":0.6,"ew_vol":0.4,"bias":-0.5}
        self.lr = persist.data.get("ai_lr") or 0.05
    def _vec(self, f): return {"macd":f["macd"], "rsi":(f["rsi"]-50)/25, "z":f["z"], "ew_vol":f["ew_vol"]/3.0}
    def score(self, f)->float:
        x=self._vec(f); s=sum(self.w.get(k,0)*x[k] for k in x)+self.w.get("bias",0); return round(s,3)
    def advise(self, f, regime):
        s=self.score(f)
        if s>1.2 or regime=="Stres": return "Deeskalasyon: mola, görev rotasyonu, nefes."
        if s>0.4: return "Yakın izleme: kısa check-in, odak teknikleri."
        return "Devam: akışta kal, küçük kazanımları pekiştir."
    def feedback(self, f, good: bool):
        y=1 if good else -1; x=self._vec(f)
        margin = y*(sum(self.w.get(k,0)*x[k] for k in x)+self.w.get("bias",0))
        if margin<1:
            for k in x: self.w[k]=self.w.get(k,0)+self.lr*y*x[k]
            self.w["bias"]=self.w.get("bias",0)+self.lr*y
            self.persist.data["ai_weights"]=self.w; self.persist.save()

class RiskManager:
    def size(self, conf: float, user_risk: int)->Dict[str,Any]:
        base=min(max(conf,0.5),0.95); rf=0.5+(user_risk/20); size=round(1000*base*rf,0)
        sl=round(1.0+(1.0-base)*0.5,3); tp=round(1.0+base*1.2,3)
        return {"size":size,"sl_mult":sl,"tp_mult":tp}

# =========================
# Backtester
# =========================

class Backtester:
    def __init__(self, core: NovaEmotionStrategos, ind: IndicatorEngine, regime: RegimeDetector, ai: AIAdvisor):
        self.core=core; self.ind=ind; self.regime=regime; self.ai=ai
    def run(self)->Dict[str,Any]:
        logs=sorted(self.core.logs,key=lambda x:x.timestamp)
        if not logs: return {"trades":0,"win_rate":0,"pnl":0,"sharpe_like":0}
        pnl=[]; wins=0; trades=0; last={}
        for l in logs:
            f=self.ind.features(l.task_id); r=self.regime.detect(f); s=self.ai.score(f)
            action = (s>0.4) or (r=="Stres")
            prev = last.get(l.task_id, l.feeling_strength); d=l.feeling_strength-prev
            reward = -abs(d) if not action else -abs(d)*0.5
            pnl.append(reward); trades+=1; wins+=1 if reward>-0.2 else 0; last[l.task_id]=l.feeling_strength
        total = round(sum(pnl),2); wr = round(100*wins/max(1,trades),1)
        mu = statistics.mean(pnl); sd=statistics.pstdev(pnl) if len(pnl)>1 else 1.0
        sr = round((mu/(sd if sd>1e-6 else 1.0))*math.sqrt(252),2)
        return {"trades":trades,"win_rate":wr,"pnl":total,"sharpe_like":sr}

# =========================
# On-Chain katman
# =========================

DEFAULT_NETWORKS = {
    "Ethereum Sepolia": {"rpc": os.environ.get("RPC_SEPOLIA",""), "chainId": 11155111},
    "Polygon Amoy":     {"rpc": os.environ.get("RPC_AMOY",""),    "chainId": 80002},
    "BSC Testnet":      {"rpc": os.environ.get("RPC_BSCT",""),    "chainId": 97},
}

def keccak_hex(data: bytes)->str:
    return "0x"+hashlib.sha3_256(data).hexdigest()

class MockChain:
    def __init__(self):
        self.ledger = {"signals":{}, "stakes":{}, "votes":{}, "rewards":{}}
        self.tx_counter = 0
    def submit_signal(self, addr: str, sig_hash: str, meta: Dict[str,Any])->str:
        self.tx_counter+=1; tx=f"mocktx_{self.tx_counter}"
        self.ledger["signals"].setdefault(addr,[]).append({"hash":sig_hash,"meta":meta,"tx":tx,"ts":datetime.utcnow().isoformat()})
        return tx
    def stake(self, addr: str, amount: int)->str:
        self.ledger["stakes"][addr]=self.ledger["stakes"].get(addr,0)+amount; self.tx_counter+=1
        return f"mocktx_{self.tx_counter}"
    def vote(self, addr: str, pid: int, support: bool)->str:
        self.ledger["votes"].setdefault(pid,[]).append({"addr":addr,"support":support}); self.tx_counter+=1
        return f"mocktx_{self.tx_counter}"
    def reward(self, addr: str, amount: int)->str:
        self.ledger["rewards"][addr]=self.ledger["rewards"].get(addr,0)+amount; self.tx_counter+=1
        return f"mocktx_{self.tx_counter}"

class OnChainClient:
    def __init__(self, persist: Persist, bus: NotificationBus):
        self.persist=persist; self.bus=bus
        self.networks = DEFAULT_NETWORKS
        self.active_net = None
        self.address = None
        self._w3 = None
        self._acct = None
        self.mock = MockChain()

    def connect(self, net_name: str, privkey: Optional[str]):
        cfg = self.networks.get(net_name)
        if not cfg or not cfg["rpc"]:
            self.bus.send("RPC bulunamadı, MockChain devrede.")
            self.active_net = {"name":"Mock","chainId":0}
            self._w3=None; self._acct=None; self.address="0xMOCK"
            return
        if not HAS_WEB3:
            self.bus.send("web3 bulunamadı, MockChain devrede.")
            self.active_net = {"name":net_name,"chainId":cfg["chainId"]}
            self._w3=None; self._acct=None; self.address="0xMOCK"
            return
        try:
            w3 = Web3(Web3.HTTPProvider(cfg["rpc"]))
            if not w3.is_connected():
                self.bus.send("RPC bağlantısı başarısız, MockChain devrede.")
                self._w3=None; self.address="0xMOCK"
            else:
                self._w3 = w3
                if privkey:
                    acct = Account.from_key(privkey)
                    self._acct = acct; self.address = acct.address
                else:
                    self._acct=None; self.address=None
                self.active_net = {"name":net_name,"chainId":cfg["chainId"]}
                self.bus.send(f"Ağa bağlandı: {net_name} (chainId {cfg['chainId']})")
        except Exception as e:
            self.bus.send(f"Bağlantı hatası, MockChain: {e}")
            self._w3=None; self.address="0xMOCK"; self.active_net={"name":"Mock","chainId":0}

    def gas_info(self)->Dict[str,Any]:
        if self._w3:
            try:
                gp = self._w3.eth.gas_price
                blk = self._w3.eth.get_block("latest")
                base = blk.get("baseFeePerGas", gp)
                return {"gas_price": int(gp), "base_fee": int(base), "block": blk.number}
            except Exception:
                pass
        # Mock
        return {"gas_price": 1_000_000_000, "base_fee": 1_000_000_000, "block": 0}

    def anchor_signal(self, payload: Dict[str,Any])->Dict[str,str]:
        # 1) Hashle
        data = json.dumps(payload, sort_keys=True, ensure_ascii=False).encode("utf-8")
        sig_hash = keccak_hex(data)
        # 2) EIP-712 imza (off-chain kanıt)
        signature = ""
        if HAS_WEB3 and self._acct:
            try:
                typed = {
                    "types": {
                        "EIP712Domain":[{"name":"name","type":"string"}],
                        "Signal":[
                            {"name":"task","type":"string"},
                            {"name":"hash","type":"bytes32"},
                            {"name":"timestamp","type":"string"}
                        ]
                    },
                    "domain":{"name":"NovaStrategosPrime"},
                    "primaryType":"Signal",
                    "message":{"task":payload["task_id"],"hash":sig_hash,"timestamp":payload["timestamp"]}
                }
                msg = encode_structured_data(primitive=typed)
                signature = self._acct.sign_message(msg).signature.hex()
            except Exception:
                signature = ""
        # 3) Zincire yaz (varsa) yoksa Mock
        meta = {"risk": payload.get("risk","-"), "score": payload.get("score",0)}
        if self._w3 and self._acct:
            # Örnek: bir kontrata submitSignal(bytes32,uint8,uint256) çağrısı yapılabilir.
            # Bu örnekte mock tx üretelim; gerçek kontrat adres/ABI eklenince kullanılabilir.
            tx = f"0x{sig_hash[2:10]}_sim"
        else:
            tx = self.mock.submit_signal(self.address or "0xMOCK", sig_hash, meta)
        return {"hash": sig_hash, "signature": signature, "tx": tx}

    def stake(self, amount: int)->str:
        if self._w3 and self._acct:
            return f"0xstake_sim_{amount}"
        return self.mock.stake(self.address or "0xMOCK", amount)

    def vote(self, proposal_id: int, support: bool)->str:
        if self._w3 and self._acct:
            return f"0xvote_sim_{proposal_id}_{int(support)}"
        return self.mock.vote(self.address or "0xMOCK", proposal_id, support)

    def reward(self, amount: int)->str:
        if self._w3 and self._acct:
            return f"0xreward_sim_{amount}"
        return self.mock.reward(self.address or "0xMOCK", amount)

# =========================
# Akış simülatörü
# =========================

class StreamSimulator(QtCore.QObject):
    newLog = QtCore.pyqtSignal(EmotionLog)
    def __init__(self, parent=None, tasks=None):
        super().__init__(parent)
        self.timer = QtCore.QTimer(self); self.timer.timeout.connect(self._tick)
        self.tasks = tasks or ["ALPHA","BETA","GAMMA"]
        self.speed_ms = 1200
    def start(self, ms=None):
        self.speed_ms = ms or self.speed_ms; self.timer.start(self.speed_ms)
    def stop(self): self.timer.stop()
    def _tick(self):
        t=random.choice(self.tasks); e=random.choice(["Stress","Focus","Anxiety","Calm"])
        s=round(random.uniform(3.0,9.5),2)
        self.newLog.emit(EmotionLog(t,e,s,datetime.utcnow()))

# =========================
# UI Panel
# =========================

class TraderDashboard(QtWidgets.QWidget):
    def __init__(self, user: Dict[str,Any], core: NovaEmotionStrategos,
                 ind: IndicatorEngine, regime: RegimeDetector,
                 sig: SignalEngine, ai: AIAdvisor, risk: RiskManager,
                 persist: Persist, bus: NotificationBus, chain: OnChainClient):
        super().__init__()
        self.setWindowTitle("📊 Nova Strategos Prime — Ultra Hibrit On‑Chain")
        self.user=user; self.core=core; self.ind=ind; self.regime=regime
        self.sig=sig; self.ai=ai; self.risk=risk; self.persist=persist; self.bus=bus; self.chain=chain
        self.sim = StreamSimulator(self); self.sim.newLog.connect(self.on_new_log)
        self._build_ui(); self._bind(); self.refresh_all()

    def _build_ui(self):
        lay = QtWidgets.QVBoxLayout(self)
        title = QtWidgets.QLabel(f"Hoş geldin {self.user['name']}"); title.setStyleSheet("font-weight:700;font-size:16px;")
        lay.addWidget(title)
        self.tabs = QtWidgets.QTabWidget(); lay.addWidget(self.tabs)

        # Dashboard
        dash = QtWidgets.QWidget(); d = QtWidgets.QVBoxLayout(dash)
        ctr = QtWidgets.QHBoxLayout()
        self.risk_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal); self.risk_slider.setRange(1,10); self.risk_slider.setValue(self.user.get("risk_level",6))
        self.chk_anchor = QtWidgets.QCheckBox("Sinyali zincire çapala"); self.chk_anchor.setChecked(True)
        self.btn_stream = QtWidgets.QPushButton("▶️ Canlı"); self.btn_stop = QtWidgets.QPushButton("⏸️ Durdur")
        self.btn_analyze= QtWidgets.QPushButton("🧠 Analiz"); self.btn_signal= QtWidgets.QPushButton("📡 Sinyal Bas")
        ctr.addWidget(QtWidgets.QLabel("⚙️ Risk:")); ctr.addWidget(self.risk_slider); ctr.addWidget(self.chk_anchor)
        ctr.addWidget(self.btn_stream); ctr.addWidget(self.btn_stop); ctr.addWidget(self.btn_analyze); ctr.addWidget(self.btn_signal)
        d.addLayout(ctr)
        split = QtWidgets.QSplitter()
        left = QtWidgets.QWidget(); ll = QtWidgets.QVBoxLayout(left)
        ll.addWidget(QtWidgets.QLabel("📡 Sinyaller")); self.signal_box = QtWidgets.QTextEdit(); self.signal_box.setReadOnly(True); ll.addWidget(self.signal_box)
        ll.addWidget(QtWidgets.QLabel("🧭 AI Danışman")); self.ai_box=QtWidgets.QTextEdit(); self.ai_box.setReadOnly(True); ll.addWidget(self.ai_box)
        fb = QtWidgets.QHBoxLayout(); self.btn_good=QtWidgets.QPushButton("👍 İyi"); self.btn_bad=QtWidgets.QPushButton("👎 Kötü"); fb.addWidget(self.btn_good); fb.addWidget(self.btn_bad); ll.addLayout(fb)
        right = QtWidgets.QWidget(); rr = QtWidgets.QVBoxLayout(right)
        rr.addWidget(QtWidgets.QLabel("📈 Görev Metrikleri")); self.metrics=QtWidgets.QTextEdit(); self.metrics.setReadOnly(True); rr.addWidget(self.metrics)
        rr.addWidget(QtWidgets.QLabel("📊 Göstergeler")); self.inds=QtWidgets.QTextEdit(); self.inds.setReadOnly(True); rr.addWidget(self.inds)
        split.addWidget(left); split.addWidget(right); d.addWidget(split)
        self.status = QtWidgets.QLabel("Hazır."); d.addWidget(self.status)
        self.tabs.addTab(dash,"Dashboard")

        # Veri
        dataw = QtWidgets.QWidget(); dv = QtWidgets.QVBoxLayout(dataw)
        btns = QtWidgets.QHBoxLayout()
        self.btn_load=QtWidgets.QPushButton("📥 CSV Yükle"); self.btn_export=QtWidgets.QPushButton("📤 CSV Rapor"); self.btn_snap=QtWidgets.QPushButton("🧾 JSON Snapshot"); self.btn_html=QtWidgets.QPushButton("🖨️ HTML Özet")
        btns.addWidget(self.btn_load); btns.addWidget(self.btn_export); btns.addWidget(self.btn_snap); btns.addWidget(self.btn_html); dv.addLayout(btns)
        self.table = QtWidgets.QTableWidget(0,4); self.table.setHorizontalHeaderLabels(["timestamp","task_id","emotion","feeling_strength"]); self.table.horizontalHeader().setStretchLastSection(True)
        dv.addWidget(self.table)
        self.tabs.addTab(dataw,"Veri")

        # Backtest
        btw = QtWidgets.QWidget(); bv = QtWidgets.QVBoxLayout(btw)
        self.btn_back=QtWidgets.QPushButton("⏱️ Backtest"); self.bt_out=QtWidgets.QTextEdit(); self.bt_out.setReadOnly(True)
        bv.addWidget(self.btn_back); bv.addWidget(self.bt_out)
        self.tabs.addTab(btw,"Backtest")

        # On-Chain
        chw = QtWidgets.QWidget(); chv = QtWidgets.QFormLayout(chw)
        self.cmb_net = QtWidgets.QComboBox(); self.cmb_net.addItems(list(DEFAULT_NETWORKS.keys())+["Mock"])
        self.ed_priv = QtWidgets.QLineEdit(); self.ed_priv.setEchoMode(QtWidgets.QLineEdit.Password); self.ed_priv.setPlaceholderText("Özel anahtar (0x...) — opsiyonel")
        self.btn_connect = QtWidgets.QPushButton("🔗 Bağlan")
        self.lbl_addr = QtWidgets.QLabel("Adres: -")
        self.lbl_chain = QtWidgets.QLabel("Ağ: -"); self.lbl_gas = QtWidgets.QLabel("Gas: -")
        self.ed_stake = QtWidgets.QSpinBox(); self.ed_stake.setRange(0,1_000_000); self.btn_stake=QtWidgets.QPushButton("🪙 Stake")
        self.ed_pid = QtWidgets.QSpinBox(); self.ed_pid.setRange(0,1_000_000); self.chk_support=QtWidgets.QCheckBox("Destekle"); self.btn_vote=QtWidgets.QPushButton("🗳️ Oy Ver")
        self.btn_reward=QtWidgets.QPushButton("🎁 Ödül Talep (simülasyon)")
        self.tx_log = QtWidgets.QTextEdit(); self.tx_log.setReadOnly(True); self.tx_log.setMaximumHeight(140)
        chv.addRow("Ağ", self.cmb_net); chv.addRow("Özel anahtar", self.ed_priv); chv.addRow(self.btn_connect)
        chv.addRow(self.lbl_chain); chv.addRow(self.lbl_addr); chv.addRow(self.lbl_gas)
        chv.addRow("Stake miktarı", self.ed_stake); chv.addRow(self.btn_stake)
        chv.addRow("Teklif ID", self.ed_pid); chv.addRow(self.chk_support); chv.addRow(self.btn_vote)
        chv.addRow(self.btn_reward); chv.addRow(QtWidgets.QLabel("İşlem Günlüğü")); chv.addRow(self.tx_log)
        self.tabs.addTab(chw,"On‑Chain")

        # Ayarlar
        stw = QtWidgets.QWidget(); sf = QtWidgets.QFormLayout(stw)
        self.chk_sound=QtWidgets.QCheckBox("Bildirim sesi"); self.chk_sound.setChecked(True)
        self.spin_cd=QtWidgets.QSpinBox(); self.spin_cd.setRange(5,120); self.spin_cd.setValue(20)
        self.spin_speed=QtWidgets.QSpinBox(); self.spin_speed.setRange(200,5000); self.spin_speed.setValue(1200)
        self.chk_ind=QtWidgets.QCheckBox("Göstergeleri kullan"); self.chk_ind.setChecked(True)
        self.chk_ai=QtWidgets.QCheckBox("AI danışmanı aktif"); self.chk_ai.setChecked(True)
        self.btn_save=QtWidgets.QPushButton("💾 Ayarları Kaydet")
        sf.addRow(self.chk_sound); sf.addRow("Soğuma (sn)", self.spin_cd); sf.addRow("Akış (ms)", self.spin_speed); sf.addRow(self.chk_ind); sf.addRow(self.chk_ai); sf.addRow(self.btn_save)
        self.tabs.addTab(stw,"Ayarlar")

        # Kısayollar
        QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+L"), self, activated=self.on_load_csv)
        QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+E"), self, activated=self.on_export_csv)
        QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+B"), self, activated=self.on_backtest)

    def _bind(self):
        self.btn_stream.clicked.connect(self.on_stream)
        self.btn_stop.clicked.connect(self.on_stop)
        self.btn_analyze.clicked.connect(self.on_analyze)
        self.btn_signal.clicked.connect(self.emit_signals)
        self.btn_load.clicked.connect(self.on_load_csv)
        self.btn_export.clicked.connect(self.on_export_csv)
        self.btn_snap.clicked.connect(self.on_snapshot)
        self.btn_html.clicked.connect(self.on_html)
        self.btn_back.clicked.connect(self.on_backtest)
        self.btn_good.clicked.connect(lambda: self.on_feedback(True))
        self.btn_bad.clicked.connect(lambda: self.on_feedback(False))
        self.btn_save.clicked.connect(self.on_save)
        self.risk_slider.valueChanged.connect(self.on_risk)
        self.btn_connect.clicked.connect(self.on_connect)
        self.btn_stake.clicked.connect(self.on_stake)
        self.btn_vote.clicked.connect(self.on_vote)
        self.btn_reward.clicked.connect(self.on_reward)

    # ---- event handlers ----

    def on_stream(self):
        self.sim.start(self.spin_speed.value()); self.status.setText("Akış başlatıldı."); self.bus.send("Sim akışı açık.", self)
    def on_stop(self):
        self.sim.stop(); self.status.setText("Akış durdu."); self.bus.send("Sim akışı kapalı.", self)
    def on_analyze(self):
        self.refresh_all(); self.emit_signals()
    def on_new_log(self, log: EmotionLog):
        self.core.ingest(log); self._append_row(log)
        rep=self.core.analyze(); m=rep.get(log.task_id); 
        if not m: return
        f = self.ind.features(log.task_id) if self.chk_ind.isChecked() else {"z":0,"ew_vol":0,"rsi":50,"macd":0,"ema_fast":0,"ema_slow":0}
        reg = self.regime.detect(f)
        if self.sig.can_signal(log.task_id):
            msg = self.sig.generate(log.task_id, m, self.user.get("risk_level",6), reg, f)
            conf = self._confidence(m,f,reg); sizing = risk.size(conf, self.user.get("risk_level",6))
            enriched = f"{msg} | size:{sizing['size']} | SLx:{sizing['sl_mult']} | TPx:{sizing['tp_mult']}"
            self.signal_box.append(f"{datetime.utcnow().isoformat()} — {enriched}")
            if self.chk_ai.isChecked(): self.ai_box.append(f"{datetime.utcnow().isoformat()} — {self.ai.advise(f,reg)}")
            self.sig.mark(log.task_id)
            if self.chk_anchor.isChecked(): self._anchor_signal(log.task_id, m, f, enriched)
        self.refresh_panels(task_hint=log.task_id)

    def on_load_csv(self):
        path,_=QtWidgets.QFileDialog.getOpenFileName(self,"CSV Seç","","CSV (*.csv)")
        if not path: return
        logs = IOBridge.load_logs_csv(path)
        for l in logs: self.core.ingest(l); self._append_row(l)
        self.refresh_all(); self.status.setText(f"{len(logs)} kayıt yüklendi."); self.bus.send("CSV yüklendi.", self)

    def on_export_csv(self):
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"Rapor Kaydet","nova_report.csv","CSV (*.csv)")
        if not path: return
        IOBridge.save_report_csv(path, self._rep_reg())
        self.status.setText("Rapor kaydedildi."); self.bus.send("CSV rapor yazıldı.", self)

    def on_snapshot(self):
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"Snapshot","nova_snapshot.json","JSON (*.json)")
        if not path: return
        payload={"user":self.user,"report":self._rep_reg(),"ai_weights":self.ai.w,"timestamp":datetime.utcnow().isoformat()}
        IOBridge.save_snapshot_json(path,payload); self.status.setText("Snapshot kaydedildi."); self.bus.send("JSON snapshot.", self)

    def on_html(self):
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"HTML Özet","nova_overview.html","HTML (*.html)")
        if not path: return
        IOBridge.save_html_overview(path, {"user":self.user,"report":self._rep_reg(),"notes":self.ai_box.toPlainText()[-1000:]})
        self.status.setText("HTML özet kaydedildi."); self.bus.send("HTML özet yazıldı.", self)
        try: webbrowser.open(f"file://{os.path.abspath(path)}")
        except Exception: pass

    def on_backtest(self):
        res = Backtester(self.core,self.ind,self.regime,self.ai).run()
        self.bt_out.setText(f"İşlem: {res['trades']}\nİsabet: %{res['win_rate']}\nSim PnL: {res['pnl']}\nSharpe-benzeri: {res['sharpe_like']}")
        self.bus.send("Backtest tamam.", self)

    def on_feedback(self, good: bool):
        rep=self.core.analyze()
        if not rep: return
        task=max(rep.items(), key=lambda kv: kv[1]["count"])[0]
        f=self.ind.features(task); self.ai.feedback(f, good)
        self.ai_box.append(f"{datetime.utcnow().isoformat()} — Geri bildirim işlendi ({'iyi' if good else 'kötü'}).")
        self.status.setText("AI ağırlıkları güncellendi."); self.bus.send("AI feedback.", self)

    def on_save(self):
        self.bus.sound_on=self.chk_sound.isChecked()
        self.sig.cooldown=timedelta(seconds=self.spin_cd.value())
        self.sim.speed_ms=self.spin_speed.value()
        self.persist.data["settings"]={"sound_on":self.bus.sound_on,"cooldown":self.spin_cd.value(),"speed_ms":self.sim.speed_ms,"use_ind":self.chk_ind.isChecked(),"use_ai":self.chk_ai.isChecked()}
        self.persist.save(); self.status.setText("Ayarlar kaydedildi.")

    def on_risk(self, v: int):
        self.user["risk_level"]=v; self.persist.data["user_profile"]=self.user; self.persist.save()
        self.status.setText(f"Risk seviyesi: {v}")

    # --- On‑Chain handlers ---
    def on_connect(self):
        net = self.cmb_net.currentText()
        priv = self.ed_priv.text().strip() or None
        self.chain.connect(net, priv)
        info = self.chain.gas_info()
        self.lbl_chain.setText(f"Ağ: {self.chain.active_net['name'] if self.chain.active_net else '-'}")
        self.lbl_addr.setText(f"Adres: {self.chain.address or '-'}")
        self.lbl_gas.setText(f"Gas/base: {info['gas_price']}/{info['base_fee']} | Blok: {info['block']}")
        # Gaz / ağ gürültüsüne göre dinamik hassasiyet ayarı: yüksek baseFee -> biraz daha temkinli
        if info["base_fee"]>5_000_000_000:
            self.sig.cooldown = timedelta(seconds=max(10, self.spin_cd.value()+10))
            self.status.setText("Ağ yoğun: soğuma süresi artırıldı.")

    def on_stake(self):
        amt = int(self.ed_stake.value()); 
        tx = self.chain.stake(amt)
        self.tx_log.append(f"{datetime.utcnow().isoformat()} — Stake tx: {tx}")
        self.bus.send("Stake gönderildi.", self)

    def on_vote(self):
        pid = int(self.ed_pid.value()); sup = self.chk_support.isChecked()
        tx = self.chain.vote(pid, sup)
        self.tx_log.append(f"{datetime.utcnow().isoformat()} — Vote tx: {tx}")
        self.bus.send("Oy gönderildi.", self)

    def on_reward(self):
        tx = self.chain.reward(100)  # simülasyon
        self.tx_log.append(f"{datetime.utcnow().isoformat()} — Reward tx: {tx}")
        self.bus.send("Ödül talep edildi.", self)

    # --- yardımcılar ---

    def _anchor_signal(self, task_id: str, m: Dict[str,Any], f: Dict[str,float], text: str):
        payload = {
            "task_id": task_id,
            "metrics": m,
            "features": f,
            "message": text,
            "risk": m["risk"],
            "score": round(f.get("z",0)*100),
            "timestamp": datetime.utcnow().isoformat()
        }
        # snapshot’ı yaz ve hasha dayalı isimle sakla
        snap_name = f"nova_signal_{task_id}_{int(datetime.utcnow().timestamp())}.json"
        IOBridge.save_snapshot_json(snap_name, payload)
        res = self.chain.anchor_signal(payload)
        self.tx_log.append(f"{datetime.utcnow().isoformat()} — Anchor: hash={res['hash']} tx={res['tx']} sig={res['signature'][:14]}...")
        self.bus.send("Sinyal zincire çapalandı.", self)

    def refresh_all(self):
        self.refresh_panels(); self._reload_table()

    def refresh_panels(self, task_hint: Optional[str]=None):
        rep = self._rep_reg(); lines=[]
        for t,m in sorted(rep.items()):
            lines.append(f"[{t}] avg:{m['avg']} | max:{m['max']} | vol:{m['vol']} | risk:{m['risk']} | rejim:{m['regime']} | n:{m['count']}")
        self.metrics.setText("\n".join(lines) if lines else "Henüz veri yok.")
        if rep:
            t = task_hint or next(iter(rep.keys()))
            f=self.ind.features(t)
            self.inds.setText(f"Görev: {t}\nEMAf:{f['ema_fast']} EMAs:{f['ema_slow']} MACD:{f['macd']}\nRSI:{f['rsi']} EWVol:{f['ew_vol']} Z:{f['z']}\nRejim:{self.regime.detect(f)} | AI skor:{self.ai.score(f)}")

    def emit_signals(self):
        rep=self.core.analyze()
        for t,m in rep.items():
            if not self.sig.can_signal(t): continue
            f = self.ind.features(t) if self.chk_ind.isChecked() else {"z":0,"ew_vol":0,"rsi":50,"macd":0,"ema_fast":0,"ema_slow":0}
            reg = self.regime.detect(f)
            msg = self.sig.generate(t, m, self.user.get("risk_level",6), reg, f)
            conf = self._confidence(m,f,reg); sizing = risk.size(conf, self.user.get("risk_level",6))
            enriched = f"{msg} | size:{sizing['size']} | SLx:{sizing['sl_mult']} | TPx:{sizing['tp_mult']}"
            self.signal_box.append(f"{datetime.utcnow().isoformat()} — {enriched}")
            if self.chk_ai.isChecked(): self.ai_box.append(f"{datetime.utcnow().isoformat()} — {self.ai.advise(f,reg)}")
            self.sig.mark(t)
            if self.chk_anchor.isChecked(): self._anchor_signal(t, m, f, enriched)
        self.bus.send("Toplu sinyaller üretildi.", self)

    def _rep_reg(self)->Dict[str,Any]:
        rep=self.core.analyze(); out={}
        for t,m in rep.items():
            f=self.ind.features(t); out[t]={**m,"regime":self.regime.detect(f)}
        return out

    def _reload_table(self):
        self.table.setRowCount(0)
        for l in sorted(self.core.logs, key=lambda x: x.timestamp)[-1000:]:
            self._append_row(l)

    def _append_row(self, l: EmotionLog):
        r=self.table.rowCount(); self.table.insertRow(r)
        self.table.setItem(r,0,QtWidgets.QTableWidgetItem(l.timestamp.isoformat()))
        self.table.setItem(r,1,QtWidgets.QTableWidgetItem(l.task_id))
        self.table.setItem(r,2,QtWidgets.QTableWidgetItem(l.emotion))
        self.table.setItem(r,3,QtWidgets.QTableWidgetItem(str(l.feeling_strength)))

    def _confidence(self, m: Dict[str,Any], f: Dict[str,float], regime: str)->float:
        base = 0.7 if m["risk"]=="Düşük" else 0.6 if m["risk"]=="Orta" else 0.55
        adj = max(0.85,min(1.15, 1-(m["vol"]/10) + (max(0, -abs(f['z'])+1)*0.05) + (0.03 if regime=="Sakin" else 0)))
        # Ağ yoğunluğuna göre mikro ayar
        g = chain.gas_info()
        if g["base_fee"]>5_000_000_000: adj -= 0.02
        return round(min(0.95,max(0.5,base*adj)),2)

# =========================
# Giriş noktası
# =========================

def main():
    persist=Persist()
    user = persist.data.get("user_profile") or {"name":"Kamal","risk_level":6}
    core=NovaEmotionStrategos(); ind=IndicatorEngine(core); regime=RegimeDetector()
    sig=SignalEngine(cooldown_sec=persist.data.get("settings",{}).get("cooldown",20))
    ai=AIAdvisor(persist); global risk; risk=RiskManager()
    bus=NotificationBus(sound_on=persist.data.get("settings",{}).get("sound_on",True))
    global chain; chain=OnChainClient(persist,bus)

    app = QtWidgets.QApplication(sys.argv)
    panel = TraderDashboard(user, core, ind, regime, sig, ai, risk, persist, bus, chain)

    # Tohum veri
    seed=[EmotionLog("ALPHA","Stress",7.8,datetime.utcnow()),
          EmotionLog("ALPHA","Anxiety",6.9,datetime.utcnow()),
          EmotionLog("BETA","Focus",4.2,datetime.utcnow()),
          EmotionLog("GAMMA","Calm",3.8,datetime.utcnow()),
          EmotionLog("BETA","Stress",6.1,datetime.utcnow()),
          EmotionLog("GAMMA","Anxiety",5.5,datetime.utcnow())]
    for l in seed: core.ingest(l)

    panel.resize(980, 700); panel.show()
    sys.exit(app.exec_())

if __name__=="__main__":
    main()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\nova_ultra_single.py
# nova_ultra_single.py
# Tek dosya: 20+ TA, ultra hibrit strateji, AI, risk, backtest, on‑chain (mock), CCXT broker, async canlı döngü

import os, sys, csv, json, math, time, asyncio, statistics, argparse
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional, Tuple

# Opsiyonel hızlandırmalar
HAS_NP=False; HAS_PD=False; HAS_CCXT=False
try:
    import numpy as np
    HAS_NP=True
except Exception:
    HAS_NP=False
try:
    import pandas as pd
    HAS_PD=True
except Exception:
    HAS_PD=False
try:
    import ccxt  # type: ignore
    HAS_CCXT=True
except Exception:
    HAS_CCXT=False

# =======================
# Tipler
# =======================

@dataclass
class MarketBar:
    ts: datetime
    symbol: str
    open: float
    high: float
    low: float
    close: float
    volume: float

@dataclass
class Signal:
    symbol: str
    action: str         # BUY | SELL | HOLD
    confidence: float   # 0..1
    regime: str         # Trend | Range | Unknown
    features: Dict[str, float]
    timestamp: datetime

@dataclass
class BacktestReport:
    trades: int
    win_rate: float
    pnl: float
    sharpe_like: float
    notes: Optional[str] = None

# =======================
# IO yardımcıları
# =======================

def load_ohlcv_csv(path: str, symbol_col: str="symbol") -> List[MarketBar]:
    out=[]
    with open(path,"r",encoding="utf-8") as f:
        r=csv.DictReader(f)
        for row in r:
            ts=row.get("timestamp") or row.get("time") or row.get("date")
            dt=datetime.fromisoformat(ts.replace("Z","")) if ts else datetime.utcnow()
            out.append(MarketBar(
                ts=dt,
                symbol=row.get(symbol_col,"SYMBOL"),
                open=float(row["open"]),
                high=float(row["high"]),
                low=float(row["low"]),
                close=float(row["close"]),
                volume=float(row.get("volume",0))
            ))
    return sorted(out, key=lambda b: b.ts)

def save_html_report(path: str, overview: Dict[str,Any]) -> None:
    head="<style>body{font-family:Segoe UI,Arial}table{border-collapse:collapse}td,th{border:1px solid #ccc;padding:6px}</style>"
    rows="".join(f"<tr><td>{k}</td><td>{v}</td></tr>" for k,v in overview["metrics"].items())
    html=f"<html><head>{head}</head><body><h2>{overview['symbol']} — Özet</h2><p>Tarih: {datetime.utcnow().isoformat()}</p><table><tr><th>Ad</th><th>Değer</th></tr>{rows}</table><pre>{overview.get('notes','')}</pre></body></html>"
    with open(path,"w",encoding="utf-8") as f: f.write(html)

# =======================
# 20+ Teknik indikatörler
# =======================

class TA:
    @staticmethod
    def SMA(vals: List[float], n:int)->float:
        if len(vals)<n: return float('nan')
        if HAS_NP:
            return float(np.mean(np.array(vals[-n:], dtype=float)))
        return sum(vals[-n:])/n

    @staticmethod
    def EMA(vals: List[float], n:int)->float:
        if not vals: return float('nan')
        if HAS_NP:
            arr=np.array(vals, dtype=float)
            k=2.0/(n+1.0)
            ema=arr[0]
            for v in arr[1:]:
                ema=k*v+(1-k)*ema
            return float(ema)
        k=2/(n+1); ema=vals[0]
        for v in vals[1:]: ema=k*v+(1-k)*ema
        return ema

    @staticmethod
    def _ema_series(vals: List[float], n:int)->List[float]:
        if not vals: return []
        k=2/(n+1); out=[vals[0]]
        for v in vals[1:]: out.append(k*v+(1-k)*out[-1])
        return out

    @staticmethod
    def MACD(close: List[float], fast=12, slow=26, signal=9)->Tuple[float,float,float]:
        if len(close)<slow: return float('nan'),float('nan'),float('nan')
        ef=TA._ema_series(close, fast)
        es=TA._ema_series(close, slow)
        ln=min(len(ef), len(es))
        macd_series=[ef[i]-es[i] for i in range(-ln,0)]
        sig=TA._ema_series(macd_series, signal)[-1] if macd_series else float('nan')
        macd=macd_series[-1] if macd_series else float('nan')
        hist=macd - sig if macd==macd and sig==sig else float('nan')
        return macd, sig, hist

    @staticmethod
    def RSI(close: List[float], period=14)->float:
        if len(close)<2: return float('nan')
        gains=[]; losses=[]
        for i in range(1,len(close)):
            d=close[i]-close[i-1]
            gains.append(max(0,d)); losses.append(max(0,-d))
        pg=sum(gains[-period:])/max(1, min(period, len(gains)))
        pl=sum(losses[-period:])/max(1, min(period, len(losses)))
        rs=pg/(pl if pl>0 else 1e-6)
        return 100-(100/(1+rs))

    @staticmethod
    def Stochastic(high: List[float], low: List[float], close: List[float], k_period=14, d_period=3)->Tuple[float,float]:
        if len(close)<k_period: return float('nan'),float('nan')
        hh=max(high[-k_period:]); ll=min(low[-k_period:])
        k=100*(close[-1]-ll)/(hh-ll if hh!=ll else 1e-6)
        return k, k

    @staticmethod
    def StochRSI(close: List[float], period=14, k=14, d=3)->Tuple[float,float]:
        if len(close)<period+1: return float('nan'),float('nan')
        rsival=[]
        for i in range(2,len(close)+1):
            rsival.append(TA.RSI(close[:i], period))
        if len(rsival)<k: return float('nan'),float('nan')
        ll=min(rsival[-k:]); hh=max(rsival[-k:])
        stoch=100*(rsival[-1]-ll)/(hh-ll if hh!=ll else 1e-6)
        return stoch, stoch

    @staticmethod
    def CCI(high: List[float], low: List[float], close: List[float], period=20)->float:
        if len(close)<period: return float('nan')
        tp=[(h+l+c)/3 for h,l,c in zip(high,low,close)]
        sma=TA.SMA(tp,period)
        md=sum(abs(x-sma) for x in tp[-period:])/period
        return (tp[-1]-sma)/(0.015*md if md!=0 else 1e-6)

    @staticmethod
    def WilliamsR(high: List[float], low: List[float], close: List[float], period=14)->float:
        if len(close)<period: return float('nan')
        hh=max(high[-period:]); ll=min(low[-period:])
        return -100*(hh-close[-1])/(hh-ll if hh!=ll else 1e-6)

    @staticmethod
    def Bollinger(close: List[float], period=20, mult=2)->Tuple[float,float,float]:
        if len(close)<period: return float('nan'),float('nan'),float('nan')
        ma=TA.SMA(close,period)
        sd=statistics.pstdev(close[-period:]) if period>1 else 0
        return ma-mult*sd, ma, ma+mult*sd

    @staticmethod
    def ATR(high: List[float], low: List[float], close: List[float], period=14)->float:
        if len(close)<2: return float('nan')
        trs=[]
        for i in range(1,len(close)):
            tr=max(high[i]-low[i], abs(high[i]-close[i-1]), abs(low[i]-close[i-1]))
            trs.append(tr)
        if len(trs)<period: return statistics.mean(trs) if trs else float('nan')
        return statistics.mean(trs[-period:])

    @staticmethod
    def Keltner(high: List[float], low: List[float], close: List[float], ema_period=20, atr_period=10, mult=2)->Tuple[float,float,float]:
        ema=TA.EMA(close, ema_period)
        atr=TA.ATR(high, low, close, atr_period)
        return ema-mult*atr, ema, ema+mult*atr

    @staticmethod
    def DMI_ADX(high: List[float], low: List[float], close: List[float], period=14)->Tuple[float,float,float]:
        if len(close)<period+1: return float('nan'),float('nan'),float('nan')
        plusDM=[]; minusDM=[]; TR=[]
        for i in range(1,len(close)):
            up=high[i]-high[i-1]; dn=low[i-1]-low[i]
            plusDM.append(up if (up>dn and up>0) else 0)
            minusDM.append(dn if (dn>up and dn>0) else 0)
            TR.append(max(high[i]-low[i], abs(high[i]-close[i-1]), abs(low[i]-close[i-1])))
        def smooth(x,n):
            if not x: return []
            k=2/(n+1); out=[x[0]]
            for v in x[1:]: out.append(k*v+(1-k)*out[-1])
            return out
        smTR=smooth(TR, period); smPlus=smooth(plusDM, period); smMinus=smooth(minusDM, period)
        if not smTR or not smPlus or not smMinus: return float('nan'),float('nan'),float('nan')
        plusDI=100*(smPlus[-1]/(smTR[-1] if smTR[-1]!=0 else 1e-6))
        minusDI=100*(smMinus[-1]/(smTR[-1] if smTR[-1]!=0 else 1e-6))
        dx=100*abs(plusDI-minusDI)/(plusDI+minusDI if (plusDI+minusDI)!=0 else 1e-6)
        adx_series=[dx]
        for _ in range(1,period):
            adx_series.append( (adx_series[-1]*(period-1)+dx)/period )
        return plusDI, minusDI, adx_series[-1]

    @staticmethod
    def OBV(close: List[float], volume: List[float])->float:
        if not close: return 0.0
        obv=0.0
        for i in range(1,len(close)):
            obv += (volume[i] if close[i]>close[i-1] else (-volume[i] if close[i]<close[i-1] else 0))
        return obv

    @staticmethod
    def VWAP(high: List[float], low: List[float], close: List[float], volume: List[float])->float:
        if not close or not volume: return float('nan')
        tp=[(h+l+c)/3 for h,l,c in zip(high,low,close)]
        cum_pv=sum(p*v for p,v in zip(tp,volume))
        cum_v=sum(volume)
        return cum_pv/(cum_v if cum_v!=0 else 1e-6)

    @staticmethod
    def CMF(high: List[float], low: List[float], close: List[float], volume: List[float], period=20)->float:
        if len(close)<period: return float('nan')
        mfv=[]
        for h,l,c,v in zip(high,low,close,volume):
            mfm=((c-l)-(h-c))/((h-l) if h!=l else 1e-6)
            mfv.append(mfm*v)
        return sum(mfv[-period:])/(sum(volume[-period:]) if sum(volume[-period:])!=0 else 1e-6)

    @staticmethod
    def Donchian(high: List[float], low: List[float], period=20)->Tuple[float,float]:
        if len(high)<period: return float('nan'),float('nan')
        return max(high[-period:]), min(low[-period:])

    @staticmethod
    def PSAR(high: List[float], low: List[float], af_start=0.02, af_step=0.02, af_max=0.2)->float:
        if len(high)<2: return float('nan')
        uptrend=True
        sar=low[0]; ep=high[0]; af=af_start
        for i in range(1,len(high)):
            prev_sar=sar
            sar = prev_sar + af*(ep - prev_sar)
            if uptrend:
                sar=min(sar, low[i-1], low[i])
                if high[i]>ep:
                    ep=high[i]; af=min(af+af_step, af_max)
                if low[i]<sar:
                    uptrend=False; sar=ep; ep=low[i]; af=af_start
            else:
                sar=max(sar, high[i-1], high[i])
                if low[i]<ep:
                    ep=low[i]; af=min(af+af_step, af_max)
                if high[i]>sar:
                    uptrend=True; sar=ep; ep=high[i]; af=af_start
        return sar

    @staticmethod
    def Ichimoku(high: List[float], low: List[float], close: List[float])->Dict[str,float]:
        def mid(vals, n): 
            if len(vals)<n: return float('nan')
            return (max(vals[-n:])+min(vals[-n:]))/2
        tenkan=mid(high,9); tenkan=(tenkan+mid(low,9))/2 if not math.isnan(tenkan) else float('nan')
        kijun=mid(high,26); kijun=(kijun+mid(low,26))/2 if not math.isnan(kijun) else float('nan')
        spanA=(tenkan+kijun)/2 if not math.isnan(tenkan) and not math.isnan(kijun) else float('nan')
        spanB=(max(high[-52:])+min(low[-52:]))/2 if len(high)>=52 else float('nan')
        chikou=close[-26] if len(close)>=26 else float('nan')
        return {"tenkan":tenkan,"kijun":kijun,"spanA":spanA,"spanB":spanB,"chikou":chikou}

# =======================
# Strateji ve AI
# =======================

class StrategyPro:
    """
    Ultra hibrit: rejim tespiti (ADX), trend bloğu (EMA/MACD/Ichimoku),
    range bloğu (RSI/W%R/Bollinger), AI skoruyla ağırlıklandırma.
    """
    def regime(self, high: List[float], low: List[float], close: List[float]) -> str:
        _,_,adx = TA.DMI_ADX(high, low, close, 14)
        if adx!=adx: return "Unknown"
        return "Trend" if adx>=22 else "Range"

    def score(self, high: List[float], low: List[float], close: List[float], volume: List[float]) -> Tuple[str,float,Dict[str,float]]:
        ema12=TA.EMA(close,12); ema26=TA.EMA(close,26)
        macd, macds, hist = TA.MACD(close)
        _,_,adx = TA.DMI_ADX(high, low, close, 14)
        rsi=TA.RSI(close,14)
        bbL, bbM, bbU = TA.Bollinger(close,20,2)
        ich=TA.Ichimoku(high, low, close)

        reg=self.regime(high,low,close)
        s=0.0
        if reg=="Trend":
            if ema12>ema26: s+=1
            if macd>macds: s+=1
            if adx>=22: s+=1
            if not math.isnan(ich["spanA"]) and not math.isnan(ich["spanB"]) and close[-1]>max(ich["spanA"],ich["spanB"]): s+=1
        else:
            if rsi<30: s+=1
            if bbL==bbL and close[-1]<=bbL: s+=1
            stK,_=TA.Stochastic(high, low, close, 14, 3)
            if stK<20: s+=1

        if reg=="Trend" and ema12<ema26: s-=0.5
        if reg=="Range" and rsi>70: s-=0.5

        conf=max(0.0, min(1.0, (s+0.5)/4.0))
        action="BUY" if conf>=0.6 else ("HOLD" if conf>=0.4 else "SELL")
        feats={"rsi":rsi, "adx":adx, "macd_hist":hist, "last_price": close[-1]}
        return action, conf, feats

class AIAdvisorPro:
    """
    Ultra hibrit: kural tabanlı skor + öğrenen ağırlıklar + momentum/mean-reversion karması.
    Bot karar verir; bu sınıf sadece tavsiye/sayı üretir.
    """
    def __init__(self, w=None, lr:float=0.02):
        self.w=w or {"trend":0.7,"range":0.6,"momentum":0.5,"oversold":0.4,"bias":0.0}
        self.lr=lr

    def _features_to_x(self, feats: Dict[str,float]) -> Dict[str,float]:
        rsi=feats.get("rsi",50.0); adx=feats.get("adx",15.0); hist=feats.get("macd_hist",0.0)
        return {
            "trend": adx/30.0,
            "range": (100.0 - rsi)/100.0,
            "momentum": max(0.0, hist)/2.0,
            "oversold": (30.0 - min(30.0, rsi))/30.0,
            "bias": 1.0
        }

    def score(self, feats: Dict[str,float]) -> float:
        x=self._features_to_x(feats)
        return sum(self.w[k]*x[k] for k in x)

    def advise(self, proto_action:str, confidence:float, feats:Dict[str,float]) -> str:
        s=self.score(feats)
        if proto_action=="BUY" and (confidence>0.65 or s>0.6): return "Kademeli giriş, teyitli devam"
        if proto_action=="SELL" and (confidence>0.6): return "Kademeli çıkış, koruma odaklı"
        return "İzle ve teyit arayışı"

    def feedback(self, feats: Dict[str,float], good: bool) -> Dict[str,float]:
        y=1 if good else -1
        x=self._features_to_x(feats)
        margin=y*(sum(self.w.get(k,0)*x[k] for k in x))
        if margin<1:
            for k in x:
                self.w[k]=self.w.get(k,0)+self.lr*y*x[k]
        return self.w

# =======================
# Risk ve backtest
# =======================

class RiskManager:
    def position_size(self, equity: float, risk_per_trade: float, atr: float, tick_value: float=1.0) -> float:
        if atr!=atr or atr<=0: return 0.0
        risk_amount=equity*risk_per_trade
        size=risk_amount/(atr*tick_value)
        return max(0.0, size)

    def stops(self, price: float, atr: float, mult_sl: float=1.5, mult_tp: float=2.5) -> Dict[str,float]:
        if atr!=atr or atr<=0: return {"sl": None, "tp": None}
        return {"sl": round(price - mult_sl*atr, 8), "tp": round(price + mult_tp*atr, 8)}

class Backtester:
    def run(self, bars: List[MarketBar], strat: StrategyPro) -> BacktestReport:
        if len(bars)<50: return BacktestReport(0,0,0,0,"veri yetersiz")
        pnl=[]; wins=0; trades=0; pos=0.0; entry=0.0
        for i in range(30,len(bars)):
            window=bars[:i+1]
            h=[b.high for b in window]; l=[b.low for b in window]; c=[b.close for b in window]; v=[b.volume for b in window]
            action, conf, feats = strat.score(h,l,c,v)
            if action=="BUY" and pos<=0:
                pos=1.0; entry=c[-1]; trades+=1
            elif action=="SELL" and pos>0:
                r=c[-1]-entry; pnl.append(r); wins+=1 if r>0 else 0; pos=0.0
        if pos>0:
            r=bars[-1].close-entry; pnl.append(r); wins+=1 if r>0 else 0
        total=sum(pnl); wr=round(100*wins/max(1,len(pnl)),1)
        mu=statistics.mean(pnl) if pnl else 0; sd=statistics.pstdev(pnl) if len(pnl)>1 else 1
        sharpe=round((mu/(sd if sd!=0 else 1))*math.sqrt(252),2) if pnl else 0
        return BacktestReport(trades, wr, round(total,2), sharpe)

# =======================
# On‑chain (mock)
# =======================

DEFAULT_NETWORKS={
    "Mock":{"rpc":"","chainId":0}
}

def keccak_hex(data:bytes)->str:
    try:
        from web3 import Web3
        return Web3.keccak(data).hex()
    except Exception:
        import hashlib
        return "0x"+hashlib.sha3_256(data).hexdigest()

class MockChain:
    def __init__(self):
        self.ledger={"signals":[]} ; self.tx=0
    def submit_signal(self, addr, h, meta):
        self.tx+=1; tid=f"mocktx_{self.tx}"
        self.ledger["signals"].append({"addr":addr,"hash":h,"meta":meta,"tx":tid})
        return tid

class OnChainClient:
    def __init__(self):
        self.address="0xMOCK"; self.active={"name":"Mock","chainId":0}
        self.mock=MockChain()
    def connect(self, name:str="Mock", priv:Optional[str]=None):
        self.address="0xMOCK"; self.active={"name":name if name in DEFAULT_NETWORKS else "Mock","chainId":DEFAULT_NETWORKS.get(name,{}).get("chainId",0)}
    def anchor(self, payload:Dict[str,Any])->Dict[str,str]:
        data=json.dumps(payload, ensure_ascii=False, sort_keys=True, default=str).encode("utf-8")
        h=keccak_hex(data)
        tx=self.mock.submit_signal(self.address,h,{"act":payload.get("action"),"conf":payload.get("confidence")})
        return {"hash":h,"tx":tx,"address":self.address}

# =======================
# Broker arayüzleri
# =======================

class DummyBroker:
    def __init__(self, equity: float=10_000.0): self._eq=equity
    def send_order(self, symbol, side, size, price=None): 
        print(f"[ORDER] {symbol} {side} size={round(size,6)} price={price}")
        return {"ok":True, "symbol":symbol, "side":side, "size":size, "price":price, "ts":datetime.utcnow().isoformat()}
    def get_equity(self)->float: return self._eq

class CCXTBroker:
    def __init__(self, exchange_id: str, apiKey: Optional[str]=None, secret: Optional[str]=None, password: Optional[str]=None, sandbox: bool=False):
        if not HAS_CCXT: raise RuntimeError("ccxt kurulu değil. `pip install ccxt`")
        ex_class=getattr(ccxt, exchange_id)
        self.ex=ex_class({'apiKey': apiKey, 'secret': secret, 'password': password, 'enableRateLimit': True})
        if sandbox and hasattr(self.ex, 'set_sandbox_mode'): self.ex.set_sandbox_mode(True)
    def send_order(self, symbol: str, side: str, size: float, price: float|None=None, order_type: str="market"):
        params={}
        if order_type.lower()=="market":
            return self.ex.create_order(symbol, "market", side.lower(), size, None, params)
        else:
            if price is None: raise ValueError("Limit emir için price gerekli")
            return self.ex.create_order(symbol, "limit", side.lower(), size, price, params)
    def get_equity(self)->float:
        try:
            bal=self.ex.fetch_balance()
            # Spot için "total" veya "USD" benzeri; basitçe toplamlaştır
            total=0.0
            for k,v in bal.get("total", {}).items():
                if isinstance(v,(int,float)): total+=float(v)
            return total
        except Exception:
            return 0.0
    def fetch_ohlcv(self, symbol: str, timeframe: str="1m", limit: int=200):
        return self.ex.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)

# =======================
# Bot kontrolü
# =======================

class TradingBot:
    def __init__(self, broker):
        self.broker=broker
        self.strat=StrategyPro()
        self.ai=AIAdvisorPro()
        self.risk=RiskManager()
        self.onchain=OnChainClient()

    def decide(self, bars: List[MarketBar]) -> Signal:
        h=[b.high for b in bars]; l=[b.low for b in bars]; c=[b.close for b in bars]; v=[b.volume for b in bars]
        action, conf, feats = self.strat.score(h,l,c,v)
        reg="Trend" if feats.get("adx",0)>=22 else "Range"
        return Signal(bars[-1].symbol, action, conf, reg, feats, bars[-1].ts)

    def act(self, sig: Signal, atr: float=1.0, risk_per_trade: float=0.01, order_type: str="market", dryrun: bool=True):
        price=sig.features.get("last_price")
        size=self.risk.position_size(self.broker.get_equity(), risk_per_trade, atr=atr, tick_value=1.0)
        if sig.action in ("BUY","SELL") and size>0:
            if dryrun:
                print(f"[DRYRUN] {sig.symbol} {sig.action} size={round(size,6)} price={price} type={order_type}")
                return {"ok":True,"dryrun":True}
            return self.broker.send_order(sig.symbol, "BUY" if sig.action=="BUY" else "SELL", size, price=price)

    def anchor_signal(self, sig: Signal):
        payload={"symbol":sig.symbol,"action":sig.action,"confidence":sig.confidence,"regime":sig.regime,"timestamp":sig.timestamp.isoformat()}
        ack=self.onchain.anchor(payload)
        print("[ONCHAIN]", ack)

# =======================
# Dönüşümler ve yardımcılar
# =======================

def df_to_bars(df, symbol: Optional[str]=None) -> List[MarketBar]:
    bars=[]
    for _,row in df.iterrows():
        bars.append(MarketBar(
            ts=pd.to_datetime(row["timestamp"]).to_pydatetime(),
            symbol=symbol or row.get("symbol","SYMBOL") if hasattr(row,'get') else (symbol or "SYMBOL"),
            open=float(row["open"]),
            high=float(row["high"]),
            low=float(row["low"]),
            close=float(row["close"]),
            volume=float(row.get("volume",0.0) if hasattr(row,'get') else row["volume"] if "volume" in df.columns else 0.0)
        ))
    return bars

def list_to_bars(rows: List[List[Any]], symbol: str) -> List[MarketBar]:
    # rows: [ms, open, high, low, close, volume]
    out=[]
    for r in rows:
        ts=datetime.utcfromtimestamp(int(r[0])/1000)
        out.append(MarketBar(ts, symbol, float(r[1]), float(r[2]), float(r[3]), float(r[4]), float(r[5] if len(r)>5 else 0)))
    return out

# =======================
# Async canlı döngü (opsiyonel hızlandırma)
# =======================

async def live_loop(exchange_id: str, symbol: str, timeframe: str="1m", apiKey: Optional[str]=None, secret: Optional[str]=None, dryrun: bool=True, sandbox: bool=False, onchain: bool=False, use_mp: bool=False, risk_per_trade: float=0.01):
    if not HAS_CCXT: raise RuntimeError("ccxt gerekli. `pip install ccxt`")
    broker=CCXTBroker(exchange_id, apiKey=apiKey, secret=secret, sandbox=sandbox)
    bot=TradingBot(broker)
    bot.onchain.connect("Mock", None)

    last_ts=None
    while True:
        try:
            raw=broker.fetch_ohlcv(symbol, timeframe=timeframe, limit=200)
            bars=list_to_bars(raw, symbol)
            if not bars: 
                await asyncio.sleep(1); 
                continue
            if last_ts is not None and bars[-1].ts<=last_ts:
                await asyncio.sleep(0.5)
                continue
            last_ts=bars[-1].ts

            # Hesaplamayı istenirse ayrı süreçte yap
            if use_mp:
                from concurrent.futures import ProcessPoolExecutor
                loop=asyncio.get_running_loop()
                with ProcessPoolExecutor(max_workers=1) as pool:
                    sig=await loop.run_in_executor(pool, _decide_sync, bars)
            else:
                sig=bot.decide(bars)

            print(f"[SIGNAL] {sig.symbol} {sig.action} conf={round(sig.confidence,3)} reg={sig.regime} t={sig.timestamp}")

            # ATR kabaca son 14 bar üzerinden
            atr=TA.ATR([b.high for b in bars], [b.low for b in bars], [b.close for b in bars], 14)
            bot.act(sig, atr=atr if atr==atr else 1.0, risk_per_trade=risk_per_trade, order_type="market", dryrun=dryrun)
            if onchain: bot.anchor_signal(sig)

            # timeframe’e göre uyku
            await asyncio.sleep(1.0)
        except Exception as e:
            print("[LIVE ERROR]", e)
            await asyncio.sleep(2.0)

def _decide_sync(bars: List[MarketBar]) -> Signal:
    # Ayrı süreçte çağrılabilir
    tb=TradingBot(DummyBroker())
    return tb.decide(bars)

# =======================
# CLI
# =======================

def main():
    p=argparse.ArgumentParser(description="Nova Ultra (tek dosya) — 20+ TA, AI, backtest, on‑chain, CCXT")
    sub=p.add_subparsers(dest="cmd")

    a=sub.add_parser("analyze", help="CSV analiz ve sinyal")
    a.add_argument("--csv", required=True)
    a.add_argument("--symbol", required=False)

    b=sub.add_parser("backtest", help="CSV backtest")
    b.add_argument("--csv", required=True)
    b.add_argument("--symbol", required=False)
    b.add_argument("--html", required=False, help="HTML rapor yolu")

    l=sub.add_parser("live", help="Canlı CCXT döngü")
    l.add_argument("--exchange", required=True, help="örn. binance, bybit, okx")
    l.add_argument("--symbol", required=True, help="örn. BTC/USDT")
    l.add_argument("--timeframe", default="1m")
    l.add_argument("--apikey", default=None)
    l.add_argument("--secret", default=None)
    l.add_argument("--sandbox", action="store_true")
    l.add_argument("--dryrun", action="store_true")
    l.add_argument("--onchain", action="store_true")
    l.add_argument("--use-mp", action="store_true")
    l.add_argument("--risk", type=float, default=0.01, help="işlem başına risk oranı (0.01=%%1)")

    args=p.parse_args()
    if args.cmd=="analyze":
        bars=load_ohlcv_csv(args.csv)
        if args.symbol:
            bars=[b for b in bars if b.symbol==args.symbol]
        if not bars:
            print("Veri bulunamadı."); sys.exit(1)
        strat=StrategyPro()
        h=[b.high for b in bars]; l=[b.low for b in bars]; c=[b.close for b in bars]; v=[b.volume for b in bars]
        action, conf, feats=strat.score(h,l,c,v)
        reg="Trend" if feats.get("adx",0)>=22 else "Range"
        sig=Signal(bars[-1].symbol, action, conf, reg, feats, bars[-1].ts)
        print(json.dumps({
            "symbol":sig.symbol,"action":sig.action,"confidence":round(sig.confidence,3),
            "regime":sig.regime,"features":{k: (round(v,6) if isinstance(v,float) else v) for k,v in sig.features.items()},
            "timestamp":sig.timestamp.isoformat()
        }, ensure_ascii=False, indent=2))
    elif args.cmd=="backtest":
        bars=load_ohlcv_csv(args.csv)
        if args.symbol:
            bars=[b for b in bars if b.symbol==args.symbol]
        if not bars:
            print("Veri bulunamadı."); sys.exit(1)
        rep=Backtester().run(bars, StrategyPro())
        print(json.dumps({
            "trades":rep.trades,"win_rate":rep.win_rate,"pnl":rep.pnl,"sharpe_like":rep.sharpe_like,"notes":rep.notes
        }, ensure_ascii=False, indent=2))
        if args.html:
            overview={"symbol": bars[-1].symbol if bars else "SYMBOL", "metrics":{
                "İşlem sayısı": rep.trades,
                "Kazanma oranı %": rep.win_rate,
                "PNL": rep.pnl,
                "Sharpe-benzeri": rep.sharpe_like
            }}
            save_html_report(args.html, overview)
            print(f"HTML rapor yazıldı: {args.html}")
    elif args.cmd=="live":
        asyncio.run(live_loop(args.exchange, args.symbol, timeframe=args.timeframe, apiKey=args.apikey, secret=args.secret, dryrun=args.dryrun, sandbox=args.sandbox, onchain=args.onchain, use_mp=args.use_mp, risk_per_trade=args.risk))
    else:
        p.print_help()

if __name__=="__main__":
    main()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\NovaStrategos_v10X_ultra_onchain.py
# NovaStrategos_v10X_ultra_onchain.py
# Ultra hibrit v10 — tek dosyada on‑chain + off‑chain mükemmeliyetçi strateji paneli

import sys, csv, json, os, math, random, statistics, hashlib, webbrowser
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from PyQt5 import QtWidgets, QtCore, QtGui

# --- Web3 / Keccak isteğe bağlı ---
HAS_WEB3 = False
HAS_KECCAK = False
try:
    from web3 import Web3
    from eth_account import Account
    from eth_account.messages import encode_structured_data
    HAS_WEB3 = True
except Exception:
    HAS_WEB3 = False

try:
    from eth_utils import keccak as ethutils_keccak
    HAS_KECCAK = True
except Exception:
    HAS_KECCAK = False

# =========================
# Veri modeli
# =========================

@dataclass
class EmotionLog:
    task_id: str
    emotion: str
    feeling_strength: float
    timestamp: datetime

# =========================
# Yardımcılar / Kalıcılık
# =========================

class NotificationBus:
    def __init__(self, sound_on=True):
        self.sound_on = sound_on
    def send(self, msg: str, widget: Optional[QtWidgets.QWidget]=None):
        ts = datetime.utcnow().strftime("%H:%M:%S")
        print(f"[{ts}] {msg}")
        if widget and self.sound_on:
            QtWidgets.QApplication.beep()

class Persist:
    def __init__(self, path="nova_config.json"):
        self.path = path
        self.data: Dict[str, Any] = {}
        self.load()
    def load(self):
        if os.path.exists(self.path):
            try:
                with open(self.path, "r", encoding="utf-8") as f:
                    self.data = json.load(f)
            except Exception:
                self.data = {}
    def save(self):
        try:
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump(self.data, f, ensure_ascii=False, indent=2, default=str)
        except Exception as e:
            print(f"[Persist] save error: {e}")

# =========================
# IO Köprüsü (CSV/JSON/HTML)
# =========================

class IOBridge:
    @staticmethod
    def load_logs_csv(path: str) -> List[EmotionLog]:
        logs = []
        with open(path, "r", encoding="utf-8") as f:
            r = csv.DictReader(f)
            for row in r:
                try:
                    ts = row.get("timestamp") or datetime.utcnow().isoformat()
                    logs.append(EmotionLog(
                        task_id=row["task_id"],
                        emotion=row.get("emotion","Neutral"),
                        feeling_strength=float(row["feeling_strength"]),
                        timestamp=datetime.fromisoformat(ts.replace("Z",""))
                    ))
                except Exception:
                    continue
        return logs

    @staticmethod
    def save_report_csv(path: str, report: Dict[str, Any]):
        keys = ["task_id","avg","max","vol","risk","regime","count"]
        with open(path, "w", encoding="utf-8", newline="") as f:
            w = csv.writer(f); w.writerow(keys)
            for t,m in report.items():
                w.writerow([t, m["avg"], m["max"], m["vol"], m["risk"], m.get("regime","-"), m["count"]])

    @staticmethod
    def save_snapshot_json(path: str, payload: Dict[str, Any]):
        with open(path, "w", encoding="utf-8") as f:
            json.dump(payload, f, ensure_ascii=False, indent=2, default=str)

    @staticmethod
    def save_html_overview(path: str, overview: Dict[str, Any]):
        head = "<style>body{font-family:Segoe UI,Arial}table{border-collapse:collapse}td,th{border:1px solid #ccc;padding:6px}</style>"
        rows = ""
        for task, m in overview["report"].items():
            rows += f"<tr><td>{task}</td><td>{m['avg']}</td><td>{m['max']}</td><td>{m['vol']}</td><td>{m['risk']}</td><td>{m.get('regime','-')}</td></tr>"
        html = f"""<html><head>{head}</head><body>
        <h2>Nova Strategos — Özet</h2>
        <p>Kullanıcı: {overview['user']['name']} | Risk: {overview['user']['risk_level']} | Tarih: {datetime.utcnow().isoformat()}</p>
        <table><tr><th>Görev</th><th>Ortalama</th><th>Maks</th><th>Vol</th><th>Risk</th><th>Rejim</th></tr>{rows}</table>
        <h3>Notlar</h3><pre>{overview.get('notes','')}</pre></body></html>"""
        with open(path,"w",encoding="utf-8") as f: f.write(html)

# =========================
# Çekirdek analiz/gösterge
# =========================

class NovaEmotionStrategos:
    def __init__(self):
        self.logs: List[EmotionLog] = []
        self._cache: Optional[Dict[str, Any]] = None
    def ingest(self, log: EmotionLog):
        self.logs.append(log); self._cache = None
    def series(self, task_id: str) -> List[float]:
        return [l.feeling_strength for l in self.logs if l.task_id==task_id]
    def analyze(self) -> Dict[str, Any]:
        if self._cache is not None: return self._cache
        out: Dict[str, Any] = {}; bucket: Dict[str, List[float]] = {}
        for l in self.logs: bucket.setdefault(l.task_id, []).append(l.feeling_strength)
        for t, arr in bucket.items():
            avg = round(statistics.mean(arr),2) if arr else 0
            mx  = max(arr) if arr else 0
            vol = round(statistics.stdev(arr),2) if len(arr)>1 else 0
            risk = "Yüksek" if (avg>=7 and vol>=2) else "Orta" if avg>=5 else "Düşük"
            out[t] = {"avg":avg,"max":mx,"vol":vol,"risk":risk,"count":len(arr)}
        self._cache = out
        return out

class IndicatorEngine:
    def __init__(self, core: NovaEmotionStrategos):
        self.core = core
        self.alpha_fast = 2/(5+1); self.alpha_slow = 2/(12+1)
    def _ema(self, vals, a):
        if not vals: return 0.0
        ema = vals[0]
        for v in vals[1:]: ema = a*v + (1-a)*ema
        return round(ema,3)
    def _rsi(self, vals, p=14):
        if len(vals)<2: return 50.0
        g,l = [],[]
        for i in range(1,len(vals)):
            d = vals[i]-vals[i-1]; g.append(max(0,d)); l.append(max(0,-d))
        pg = sum(g[-p:])/max(1,min(p,len(g))); pl = sum(l[-p:])/max(1,min(p,len(l)))
        rs = pg/(pl if pl!=0 else 1e-6); rsi = 100 - (100/(1+rs))
        return round(max(0,min(100,rsi)),2)
    def _ew_vol(self, vals, a=0.2):
        if len(vals)<2: return 0.0
        mean=vals[0]; var=0.0
        for v in vals[1:]:
            mean = a*v + (1-a)*mean
            var = a*((v-mean)**2) + (1-a)*var
        return round(math.sqrt(var),3)
    def _z(self, vals, w=20):
        if not vals: return 0.0
        sl = vals[-w:]; mu = statistics.mean(sl); sd = statistics.pstdev(sl) if len(sl)>1 else 1.0
        return round((vals[-1]-mu)/(sd if sd>1e-6 else 1.0),3)
    def features(self, task_id: str) -> Dict[str,float]:
        s = self.core.series(task_id)
        fast = self._ema(s,self.alpha_fast); slow = self._ema(s,self.alpha_slow)
        macd = round(fast-slow,3); rsi=self._rsi(s); ewv=self._ew_vol(s); z=self._z(s)
        return {"ema_fast":fast,"ema_slow":slow,"macd":macd,"rsi":rsi,"ew_vol":ewv,"z":z}

class RegimeDetector:
    def detect(self, f: Dict[str,float]) -> str:
        if f["rsi"]>65 or (f["ew_vol"]>2 and f["z"]>1): return "Stres"
        if 45<=f["rsi"]<=65 and (0.5<f["ew_vol"]<2.5):   return "Dalgalı"
        return "Sakin"

class SignalEngine:
    def __init__(self, cooldown_sec=20):
        self.cooldown = timedelta(seconds=cooldown_sec)
        self.last_at: Dict[str, datetime] = {}
    def can_signal(self, task_id: str)->bool:
        t=self.last_at.get(task_id); return (t is None) or (datetime.utcnow()-t>=self.cooldown)
    def mark(self, task_id: str): self.last_at[task_id]=datetime.utcnow()
    def generate(self, task_id, m, user_risk, regime, f) -> str:
        avg, vol = m["avg"], m["vol"]
        sens = max(0.5,min(1.5,1+(user_risk-5)*0.08))
        base = avg*0.5 + vol*0.3 + max(0,f["z"])*0.2
        if regime=="Stres": base += 1.0
        score = base*sens
        if score>7:   return f"⚠️ {task_id}: Yüksek stres (avg:{avg}, vol:{vol}, z:{f['z']}, rejim:{regime})"
        if score>5.5: return f"🔍 {task_id}: Dalgalanma izlenmeli (avg:{avg}, vol:{vol}, rejim:{regime})"
        return f"✅ {task_id}: Stabil (avg:{avg}, vol:{vol}, rejim:{regime})"

class AIAdvisor:
    def __init__(self, persist: Persist):
        self.persist = persist
        self.w = persist.data.get("ai_weights") or {"macd":0.8,"rsi":0.5,"z":0.6,"ew_vol":0.4,"bias":-0.5}
        self.lr = persist.data.get("ai_lr") or 0.05
    def _vec(self, f): return {"macd":f["macd"], "rsi":(f["rsi"]-50)/25, "z":f["z"], "ew_vol":f["ew_vol"]/3.0}
    def score(self, f)->float:
        x=self._vec(f); s=sum(self.w.get(k,0)*x[k] for k in x)+self.w.get("bias",0); return round(s,3)
    def advise(self, f, regime):
        s=self.score(f)
        if s>1.2 or regime=="Stres": return "Deeskalasyon: kısa mola, görev rotasyonu, nefes."
        if s>0.4: return "Yakın izleme: mikro check-in, odak teknikleri."
        return "Devam: akışta kal, küçük kazanımları pekiştir."
    def feedback(self, f, good: bool):
        y=1 if good else -1; x=self._vec(f)
        margin = y*(sum(self.w.get(k,0)*x[k] for k in x)+self.w.get("bias",0))
        if margin<1:
            for k in x: self.w[k]=self.w.get(k,0)+self.lr*y*x[k]
            self.w["bias"]=self.w.get("bias",0)+self.lr*y
            self.persist.data["ai_weights"]=self.w; self.persist.save()

class RiskManager:
    def size(self, conf: float, user_risk: int)->Dict[str,Any]:
        base=min(max(conf,0.5),0.95); rf=0.5+(user_risk/20); size=round(1000*base*rf,0)
        sl=round(1.0+(1.0-base)*0.5,3); tp=round(1.0+base*1.2,3)
        return {"size":size,"sl_mult":sl,"tp_mult":tp}

# =========================
# Backtester
# =========================

class Backtester:
    def __init__(self, core: NovaEmotionStrategos, ind: IndicatorEngine, regime: RegimeDetector, ai: AIAdvisor):
        self.core=core; self.ind=ind; self.regime=regime; self.ai=ai
    def run(self)->Dict[str,Any]:
        logs=sorted(self.core.logs,key=lambda x:x.timestamp)
        if not logs: return {"trades":0,"win_rate":0,"pnl":0,"sharpe_like":0}
        pnl=[]; wins=0; trades=0; last={}
        for l in logs:
            f=self.ind.features(l.task_id); r=self.regime.detect(f); s=self.ai.score(f)
            action = (s>0.4) or (r=="Stres")
            prev = last.get(l.task_id, l.feeling_strength); d=l.feeling_strength-prev
            reward = -abs(d) if not action else -abs(d)*0.5
            pnl.append(reward); trades+=1; wins+=1 if reward>-0.2 else 0; last[l.task_id]=l.feeling_strength
        total = round(sum(pnl),2); wr = round(100*wins/max(1,trades),1)
        mu = statistics.mean(pnl); sd=statistics.pstdev(pnl) if len(pnl)>1 else 1.0
        sr = round((mu/(sd if sd>1e-6 else 1.0))*math.sqrt(252),2)
        return {"trades":trades,"win_rate":wr,"pnl":total,"sharpe_like":sr}

# =========================
# On-Chain katman
# =========================

DEFAULT_NETWORKS = {
    "Ethereum Sepolia": {"rpc": os.environ.get("RPC_SEPOLIA",""), "chainId": 11155111},
    "Polygon Amoy":     {"rpc": os.environ.get("RPC_AMOY",""),    "chainId": 80002},
    "BSC Testnet":      {"rpc": os.environ.get("RPC_BSCT",""),    "chainId": 97},
}

def keccak_hex(data: bytes)->str:
    if HAS_WEB3:
        try:
            return Web3.keccak(data).hex()
        except Exception:
            pass
    if HAS_KECCAK:
        try:
            return "0x"+ethutils_keccak(data).hex()
        except Exception:
            pass
    # Fallback: SHA3-256 (Ethereum keccak'tan küçük farkı vardır; Mock için yeterli)
    return "0x"+hashlib.sha3_256(data).hexdigest()

class MockChain:
    def __init__(self):
        self.ledger = {"signals":{}, "stakes":{}, "votes":{}, "rewards":{}}
        self.tx_counter = 0
    def submit_signal(self, addr: str, sig_hash: str, meta: Dict[str,Any])->str:
        self.tx_counter+=1; tx=f"mocktx_{self.tx_counter}"
        self.ledger["signals"].setdefault(addr,[]).append({"hash":sig_hash,"meta":meta,"tx":tx,"ts":datetime.utcnow().isoformat()})
        return tx
    def stake(self, addr: str, amount: int)->str:
        self.ledger["stakes"][addr]=self.ledger["stakes"].get(addr,0)+amount; self.tx_counter+=1
        return f"mocktx_{self.tx_counter}"
    def vote(self, addr: str, pid: int, support: bool)->str:
        self.ledger["votes"].setdefault(pid,[]).append({"addr":addr,"support":support}); self.tx_counter+=1
        return f"mocktx_{self.tx_counter}"
    def reward(self, addr: str, amount: int)->str:
        self.ledger["rewards"][addr]=self.ledger["rewards"].get(addr,0)+amount; self.tx_counter+=1
        return f"mocktx_{self.tx_counter}"

class OnChainClient:
    def __init__(self, persist: Persist, bus: NotificationBus):
        self.persist=persist; self.bus=bus
        self.networks = DEFAULT_NETWORKS
        self.active_net = None
        self.address = None
        self._w3 = None
        self._acct = None
        self.mock = MockChain()

    def connect(self, net_name: str, privkey: Optional[str]):
        cfg = self.networks.get(net_name)
        if (not cfg) or (not cfg["rpc"]):
            self.bus.send("RPC bulunamadı, MockChain devrede.")
            self.active_net = {"name":"Mock","chainId":0}
            self._w3=None; self._acct=None; self.address="0xMOCK"
            return
        if not HAS_WEB3:
            self.bus.send("web3 yok, MockChain devrede.")
            self.active_net = {"name":net_name,"chainId":cfg["chainId"]}
            self._w3=None; self._acct=None; self.address="0xMOCK"
            return
        try:
            w3 = Web3(Web3.HTTPProvider(cfg["rpc"]))
            if not w3.is_connected():
                self.bus.send("RPC bağlantısı başarısız, MockChain devrede.")
                self._w3=None; self.address="0xMOCK"
            else:
                self._w3 = w3
                if privkey:
                    acct = Account.from_key(privkey)
                    self._acct = acct; self.address = acct.address
                else:
                    self._acct=None; self.address=None
                self.active_net = {"name":net_name,"chainId":cfg["chainId"]}
                self.bus.send(f"Ağa bağlandı: {net_name} (chainId {cfg['chainId']})")
        except Exception as e:
            self.bus.send(f"Bağlantı hatası, MockChain: {e}")
            self._w3=None; self.address="0xMOCK"; self.active_net={"name":"Mock","chainId":0}

    def gas_info(self)->Dict[str,Any]:
        if self._w3:
            try:
                gp = self._w3.eth.gas_price
                blk = self._w3.eth.get_block("latest")
                base = blk.get("baseFeePerGas", gp)
                return {"gas_price": int(gp), "base_fee": int(base), "block": blk.number}
            except Exception:
                pass
        # Mock
        return {"gas_price": 1_000_000_000, "base_fee": 1_000_000_000, "block": 0}

    def anchor_signal(self, payload: Dict[str,Any])->Dict[str,str]:
        data = json.dumps(payload, sort_keys=True, ensure_ascii=False).encode("utf-8")
        sig_hash = keccak_hex(data)
        signature = ""
        if HAS_WEB3 and self._acct:
            try:
                typed = {
                    "types": {
                        "EIP712Domain":[{"name":"name","type":"string"}],
                        "Signal":[
                            {"name":"task","type":"string"},
                            {"name":"hash","type":"bytes32"},
                            {"name":"timestamp","type":"string"}
                        ]
                    },
                    "domain":{"name":"NovaStrategos"},
                    "primaryType":"Signal",
                    "message":{"task":payload["task_id"],"hash":sig_hash,"timestamp":payload["timestamp"]}
                }
                msg = encode_structured_data(primitive=typed)
                signature = self._acct.sign_message(msg).signature.hex()
            except Exception:
                signature = ""
        meta = {"risk": payload.get("risk","-"), "score": payload.get("score",0)}
        if self._w3 and self._acct:
            tx = f"0x{sig_hash[2:10]}_sim"  # Kontrat entegrasyonu eklenince gerçek tx
        else:
            tx = self.mock.submit_signal(self.address or "0xMOCK", sig_hash, meta)
        return {"hash": sig_hash, "signature": signature, "tx": tx}

    def stake(self, amount: int)->str:
        if self._w3 and self._acct:
            return f"0xstake_sim_{amount}"
        return self.mock.stake(self.address or "0xMOCK", amount)

    def vote(self, proposal_id: int, support: bool)->str:
        if self._w3 and self._acct:
            return f"0xvote_sim_{proposal_id}_{int(support)}"
        return self.mock.vote(self.address or "0xMOCK", proposal_id, support)

    def reward(self, amount: int)->str:
        if self._w3 and self._acct:
            return f"0xreward_sim_{amount}"
        return self.mock.reward(self.address or "0xMOCK", amount)

# =========================
# Akış simülatörü
# =========================

class StreamSimulator(QtCore.QObject):
    newLog = QtCore.pyqtSignal(EmotionLog)
    def __init__(self, parent=None, tasks=None):
        super().__init__(parent)
        self.timer = QtCore.QTimer(self); self.timer.timeout.connect(self._tick)
        self.tasks = tasks or ["ALPHA","BETA","GAMMA"]
        self.speed_ms = 1200
    def start(self, ms=None):
        self.speed_ms = ms or self.speed_ms; self.timer.start(self.speed_ms)
    def stop(self): self.timer.stop()
    def _tick(self):
        t=random.choice(self.tasks); e=random.choice(["Stress","Focus","Anxiety","Calm"])
        s=round(random.uniform(3.0,9.5),2)
        self.newLog.emit(EmotionLog(t,e,s,datetime.utcnow()))

# =========================
# UI Panel
# =========================

class TraderDashboard(QtWidgets.QWidget):
    def __init__(self, user: Dict[str,Any], core: NovaEmotionStrategos,
                 ind: IndicatorEngine, regime: RegimeDetector,
                 sig: SignalEngine, ai: AIAdvisor, risk: RiskManager,
                 persist: Persist, bus: NotificationBus, chain: OnChainClient):
        super().__init__()
        self.setWindowTitle("📊 Nova Strategos v10X — Ultra Hibrit On‑Chain")
        self.user=user; self.core=core; self.ind=ind; self.regime=regime
        self.sig=sig; self.ai=ai; self.risk=risk; self.persist=persist; self.bus=bus; self.chain=chain
        self.sim = StreamSimulator(self); self.sim.newLog.connect(self.on_new_log)
        self._build_ui(); self._bind(); self.refresh_all()

    def _build_ui(self):
        lay = QtWidgets.QVBoxLayout(self)
        title = QtWidgets.QLabel(f"Hoş geldin {self.user['name']}"); title.setStyleSheet("font-weight:700;font-size:16px;")
        lay.addWidget(title)
        self.tabs = QtWidgets.QTabWidget(); lay.addWidget(self.tabs)

        # Dashboard
        dash = QtWidgets.QWidget(); d = QtWidgets.QVBoxLayout(dash)
        ctr = QtWidgets.QHBoxLayout()
        self.risk_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal); self.risk_slider.setRange(1,10); self.risk_slider.setValue(self.user.get("risk_level",6))
        self.chk_anchor = QtWidgets.QCheckBox("Sinyali zincire çapala"); self.chk_anchor.setChecked(True)
        self.btn_stream = QtWidgets.QPushButton("▶️ Canlı"); self.btn_stop = QtWidgets.QPushButton("⏸️ Durdur")
        self.btn_analyze= QtWidgets.QPushButton("🧠 Analiz"); self.btn_signal= QtWidgets.QPushButton("📡 Sinyal Bas")
        ctr.addWidget(QtWidgets.QLabel("⚙️ Risk:")); ctr.addWidget(self.risk_slider); ctr.addWidget(self.chk_anchor)
        ctr.addWidget(self.btn_stream); ctr.addWidget(self.btn_stop); ctr.addWidget(self.btn_analyze); ctr.addWidget(self.btn_signal)
        d.addLayout(ctr)
        split = QtWidgets.QSplitter()
        left = QtWidgets.QWidget(); ll = QtWidgets.QVBoxLayout(left)
        ll.addWidget(QtWidgets.QLabel("📡 Sinyaller")); self.signal_box = QtWidgets.QTextEdit(); self.signal_box.setReadOnly(True); ll.addWidget(self.signal_box)
        ll.addWidget(QtWidgets.QLabel("🧭 AI Danışman")); self.ai_box=QtWidgets.QTextEdit(); self.ai_box.setReadOnly(True); ll.addWidget(self.ai_box)
        fb = QtWidgets.QHBoxLayout(); self.btn_good=QtWidgets.QPushButton("👍 İyi"); self.btn_bad=QtWidgets.QPushButton("👎 Kötü"); fb.addWidget(self.btn_good); fb.addWidget(self.btn_bad); ll.addLayout(fb)
        right = QtWidgets.QWidget(); rr = QtWidgets.QVBoxLayout(right)
        rr.addWidget(QtWidgets.QLabel("📈 Görev Metrikleri")); self.metrics=QtWidgets.QTextEdit(); self.metrics.setReadOnly(True); rr.addWidget(self.metrics)
        rr.addWidget(QtWidgets.QLabel("📊 Göstergeler")); self.inds=QtWidgets.QTextEdit(); self.inds.setReadOnly(True); rr.addWidget(self.inds)
        split.addWidget(left); split.addWidget(right); d.addWidget(split)
        self.status = QtWidgets.QLabel("Hazır."); d.addWidget(self.status)
        self.tabs.addTab(dash,"Dashboard")

        # Veri
        dataw = QtWidgets.QWidget(); dv = QtWidgets.QVBoxLayout(dataw)
        btns = QtWidgets.QHBoxLayout()
        self.btn_load=QtWidgets.QPushButton("📥 CSV Yükle"); self.btn_export=QtWidgets.QPushButton("📤 CSV Rapor"); self.btn_snap=QtWidgets.QPushButton("🧾 JSON Snapshot"); self.btn_html=QtWidgets.QPushButton("🖨️ HTML Özet")
        btns.addWidget(self.btn_load); btns.addWidget(self.btn_export); btns.addWidget(self.btn_snap); btns.addWidget(self.btn_html); dv.addLayout(btns)
        self.table = QtWidgets.QTableWidget(0,4); self.table.setHorizontalHeaderLabels(["timestamp","task_id","emotion","feeling_strength"]); self.table.horizontalHeader().setStretchLastSection(True)
        dv.addWidget(self.table)
        self.tabs.addTab(dataw,"Veri")

        # Backtest
        btw = QtWidgets.QWidget(); bv = QtWidgets.QVBoxLayout(btw)
        self.btn_back=QtWidgets.QPushButton("⏱️ Backtest"); self.bt_out=QtWidgets.QTextEdit(); self.bt_out.setReadOnly(True)
        bv.addWidget(self.btn_back); bv.addWidget(self.bt_out)
        self.tabs.addTab(btw,"Backtest")

        # On-Chain
        chw = QtWidgets.QWidget(); chv = QtWidgets.QFormLayout(chw)
        self.cmb_net = QtWidgets.QComboBox(); self.cmb_net.addItems(list(DEFAULT_NETWORKS.keys())+["Mock"])
        self.ed_priv = QtWidgets.QLineEdit(); self.ed_priv.setEchoMode(QtWidgets.QLineEdit.Password); self.ed_priv.setPlaceholderText("Özel anahtar (0x...) — opsiyonel")
        self.btn_connect = QtWidgets.QPushButton("🔗 Bağlan")
        self.lbl_addr = QtWidgets.QLabel("Adres: -")
        self.lbl_chain = QtWidgets.QLabel("Ağ: -"); self.lbl_gas = QtWidgets.QLabel("Gas: -")
        self.ed_stake = QtWidgets.QSpinBox(); self.ed_stake.setRange(0,1_000_000); self.btn_stake=QtWidgets.QPushButton("🪙 Stake")
        self.ed_pid = QtWidgets.QSpinBox(); self.ed_pid.setRange(0,1_000_000); self.chk_support=QtWidgets.QCheckBox("Destekle"); self.btn_vote=QtWidgets.QPushButton("🗳️ Oy Ver")
        self.btn_reward=QtWidgets.QPushButton("🎁 Ödül Talep (simülasyon)")
        self.tx_log = QtWidgets.QTextEdit(); self.tx_log.setReadOnly(True); self.tx_log.setMaximumHeight(140)
        chv.addRow("Ağ", self.cmb_net); chv.addRow("Özel anahtar", self.ed_priv); chv.addRow(self.btn_connect)
        chv.addRow(self.lbl_chain); chv.addRow(self.lbl_addr); chv.addRow(self.lbl_gas)
        chv.addRow("Stake miktarı", self.ed_stake); chv.addRow(self.btn_stake)
        chv.addRow("Teklif ID", self.ed_pid); chv.addRow(self.chk_support); chv.addRow(self.btn_vote)
        chv.addRow(self.btn_reward); chv.addRow(QtWidgets.QLabel("İşlem Günlüğü")); chv.addRow(self.tx_log)
        self.tabs.addTab(chw,"On‑Chain")

        # Ayarlar
        stw = QtWidgets.QWidget(); sf = QtWidgets.QFormLayout(stw)
        self.chk_sound=QtWidgets.QCheckBox("Bildirim sesi"); self.chk_sound.setChecked(True)
        self.spin_cd=QtWidgets.QSpinBox(); self.spin_cd.setRange(5,120); self.spin_cd.setValue(20)
        self.spin_speed=QtWidgets.QSpinBox(); self.spin_speed.setRange(200,5000); self.spin_speed.setValue(1200)
        self.chk_ind=QtWidgets.QCheckBox("Göstergeleri kullan"); self.chk_ind.setChecked(True)
        self.chk_ai=QtWidgets.QCheckBox("AI danışmanı aktif"); self.chk_ai.setChecked(True)
        self.btn_save=QtWidgets.QPushButton("💾 Ayarları Kaydet")
        sf.addRow(self.chk_sound); sf.addRow("Soğuma (sn)", self.spin_cd); sf.addRow("Akış (ms)", self.spin_speed); sf.addRow(self.chk_ind); sf.addRow(self.chk_ai); sf.addRow(self.btn_save)
        self.tabs.addTab(stw,"Ayarlar")

        # Kısayollar
        QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+L"), self, activated=self.on_load_csv)
        QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+E"), self, activated=self.on_export_csv)
        QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+B"), self, activated=self.on_backtest)

    def _bind(self):
        self.btn_stream.clicked.connect(self.on_stream)
        self.btn_stop.clicked.connect(self.on_stop)
        self.btn_analyze.clicked.connect(self.on_analyze)
        self.btn_signal.clicked.connect(self.emit_signals)
        self.btn_load.clicked.connect(self.on_load_csv)
        self.btn_export.clicked.connect(self.on_export_csv)
        self.btn_snap.clicked.connect(self.on_snapshot)
        self.btn_html.clicked.connect(self.on_html)
        self.btn_back.clicked.connect(self.on_backtest)
        self.btn_good.clicked.connect(lambda: self.on_feedback(True))
        self.btn_bad.clicked.connect(lambda: self.on_feedback(False))
        self.btn_save.clicked.connect(self.on_save)
        self.risk_slider.valueChanged.connect(self.on_risk)
        self.btn_connect.clicked.connect(self.on_connect)
        self.btn_stake.clicked.connect(self.on_stake)
        self.btn_vote.clicked.connect(self.on_vote)
        self.btn_reward.clicked.connect(self.on_reward)

    # ---- event handlers ----

    def on_stream(self):
        self.sim.start(self.spin_speed.value()); self.status.setText("Akış başlatıldı."); self.bus.send("Sim akışı açık.", self)
    def on_stop(self):
        self.sim.stop(); self.status.setText("Akış durdu."); self.bus.send("Sim akışı kapalı.", self)
    def on_analyze(self):
        self.refresh_all(); self.emit_signals()
    def on_new_log(self, log: EmotionLog):
        self.core.ingest(log); self._append_row(log)
        rep=self.core.analyze(); m=rep.get(log.task_id)
        if not m: return
        f = self.ind.features(log.task_id) if self.chk_ind.isChecked() else {"z":0,"ew_vol":0,"rsi":50,"macd":0,"ema_fast":0,"ema_slow":0}
        reg = self.regime.detect(f)
        if self.sig.can_signal(log.task_id):
            msg = self.sig.generate(log.task_id, m, self.user.get("risk_level",6), reg, f)
            conf = self._confidence(m,f,reg); sizing = self.risk.size(conf, self.user.get("risk_level",6))
            enriched = f"{msg} | size:{sizing['size']} | SLx:{sizing['sl_mult']} | TPx:{sizing['tp_mult']}"
            self.signal_box.append(f"{datetime.utcnow().isoformat()} — {enriched}")
            if self.chk_ai.isChecked(): self.ai_box.append(f"{datetime.utcnow().isoformat()} — {self.ai.advise(f,reg)}")
            self.sig.mark(log.task_id)
            if self.chk_anchor.isChecked(): self._anchor_signal(log.task_id, m, f, enriched)
        self.refresh_panels(task_hint=log.task_id)

    def on_load_csv(self):
        path,_=QtWidgets.QFileDialog.getOpenFileName(self,"CSV Seç","","CSV (*.csv)")
        if not path: return
        logs = IOBridge.load_logs_csv(path)
        for l in logs: self.core.ingest(l); self._append_row(l)
        self.refresh_all(); self.status.setText(f"{len(logs)} kayıt yüklendi."); self.bus.send("CSV yüklendi.", self)

    def on_export_csv(self):
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"Rapor Kaydet","nova_report.csv","CSV (*.csv)")
        if not path: return
        IOBridge.save_report_csv(path, self._rep_reg())
        self.status.setText("Rapor kaydedildi."); self.bus.send("CSV rapor yazıldı.", self)

    def on_snapshot(self):
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"Snapshot","nova_snapshot.json","JSON (*.json)")
        if not path: return
        payload={"user":self.user,"report":self._rep_reg(),"ai_weights":self.ai.w,"timestamp":datetime.utcnow().isoformat()}
        IOBridge.save_snapshot_json(path,payload); self.status.setText("Snapshot kaydedildi."); self.bus.send("JSON snapshot.", self)

    def on_html(self):
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"HTML Özet","nova_overview.html","HTML (*.html)")
        if not path: return
        IOBridge.save_html_overview(path, {"user":self.user,"report":self._rep_reg(),"notes":self.ai_box.toPlainText()[-1000:]})
        self.status.setText("HTML özet kaydedildi."); self.bus.send("HTML özet yazıldı.", self)
        try: webbrowser.open(f"file://{os.path.abspath(path)}")
        except Exception: pass

    def on_backtest(self):
        res = Backtester(self.core,self.ind,self.regime,self.ai).run()
        self.bt_out.setText(f"İşlem: {res['trades']}\nİsabet: %{res['win_rate']}\nSim PnL: {res['pnl']}\nSharpe-benzeri: {res['sharpe_like']}")
        self.bus.send("Backtest tamam.", self)

    def on_feedback(self, good: bool):
        rep=self.core.analyze()
        if not rep: return
        task=max(rep.items(), key=lambda kv: kv[1]["count"])[0]
        f=self.ind.features(task); self.ai.feedback(f, good)
        self.ai_box.append(f"{datetime.utcnow().isoformat()} — Geri bildirim işlendi ({'iyi' if good else 'kötü'}).")
        self.status.setText("AI ağırlıkları güncellendi."); self.bus.send("AI feedback.", self)

    def on_save(self):
        self.bus.sound_on=self.chk_sound.isChecked()
        self.sig.cooldown=timedelta(seconds=self.spin_cd.value())
        self.sim.speed_ms=self.spin_speed.value()
        self.persist.data["settings"]={"sound_on":self.bus.sound_on,"cooldown":self.spin_cd.value(),"speed_ms":self.sim.speed_ms,"use_ind":self.chk_ind.isChecked(),"use_ai":self.chk_ai.isChecked()}
        self.persist.save(); self.status.setText("Ayarlar kaydedildi.")

    def on_risk(self, v: int):
        self.user["risk_level"]=v; self.persist.data["user_profile"]=self.user; self.persist.save()
        self.status.setText(f"Risk seviyesi: {v}")

    # --- On‑Chain handlers ---
    def on_connect(self):
        net = self.cmb_net.currentText()
        priv = self.ed_priv.text().strip() or None
        self.chain.connect(net, priv)
        info = self.chain.gas_info()
        self.lbl_chain.setText(f"Ağ: {self.chain.active_net['name'] if self.chain.active_net else '-'}")
        self.lbl_addr.setText(f"Adres: {self.chain.address or '-'}")
        self.lbl_gas.setText(f"Gas/base: {info['gas_price']}/{info['base_fee']} | Blok: {info['block']}")
        # Ağ yoğunluğu -> daha temkinli sinyal temposu
        if info["base_fee"]>5_000_000_000:
            self.sig.cooldown = timedelta(seconds=max(10, self.spin_cd.value()+10))
            self.status.setText("Ağ yoğun: soğuma süresi artırıldı.")

    def on_stake(self):
        amt = int(self.ed_stake.value())
        tx = self.chain.stake(amt)
        self.tx_log.append(f"{datetime.utcnow().isoformat()} — Stake tx: {tx}")
        self.bus.send("Stake gönderildi.", self)

    def on_vote(self):
        pid = int(self.ed_pid.value()); sup = self.chk_support.isChecked()
        tx =

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\NovaTraderDashboard_vX.py
from PyQt5 import QtWidgets, QtCore
import statistics
from collections import defaultdict

class NovaEmotionStrategos:
    def __init__(self):
        self.task_emotions = defaultdict(list)

    def ingest_log(self, log):
        task = log['task_id']
        strength = log['feeling_strength']
        self.task_emotions[task].append(strength)

    def analyze(self):
        report = {}
        for task, strengths in self.task_emotions.items():
            avg = round(statistics.mean(strengths), 2)
            max_val = max(strengths)
            vol = round(statistics.stdev(strengths), 2) if len(strengths) > 1 else 0
            risk = self.classify_risk(avg, vol)
            report[task] = {
                "Ortalama": avg,
                "Maks": max_val,
                "Volatilite": vol,
                "Risk": risk
            }
        return report

    def classify_risk(self, avg, vol):
        if avg > 7 and vol > 2:
            return "Yüksek Risk"
        elif avg > 5:
            return "Orta Risk"
        else:
            return "Düşük Risk"

    def generate_signal(self, task_id):
        data = self.analyze().get(task_id)
        if not data:
            return "Veri yok"
        if data["Risk"] == "Yüksek Risk":
            return f"⚠️ Görev '{task_id}': Duygusal stres yüksek. Müdahale önerilir."
        elif data["Risk"] == "Orta Risk":
            return f"🔍 Görev '{task_id}': İzleme önerilir."
        else:
            return f"✅ Görev '{task_id}': Stabil."

class TraderDashboard(QtWidgets.QWidget):
    def __init__(self, user_profile, emotion_engine):
        super().__init__()
        self.setWindowTitle("📊 Nova Zirve Paneli")
        self.layout = QtWidgets.QVBoxLayout()

        self.label = QtWidgets.QLabel(f"Hoş geldin Komutan {user_profile['name']}")
        self.layout.addWidget(self.label)

        self.risk_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.risk_slider.setMinimum(1)
        self.risk_slider.setMaximum(10)
        self.risk_slider.setValue(user_profile["risk_level"])
        self.risk_slider.valueChanged.connect(self.update_risk_level)
        self.layout.addWidget(QtWidgets.QLabel("⚙️ Risk Seviyesi"))
        self.layout.addWidget(self.risk_slider)

        self.signal_box = QtWidgets.QTextEdit()
        self.signal_box.setReadOnly(True)
        self.layout.addWidget(QtWidgets.QLabel("📡 Gelen Sinyaller"))
        self.layout.addWidget(self.signal_box)

        self.refresh_button = QtWidgets.QPushButton("🔄 Sinyalleri Güncelle")
        self.refresh_button.clicked.connect(self.refresh_signals)
        self.layout.addWidget(self.refresh_button)

        self.setLayout(self.layout)
        self.resize(500, 350)

        self.emotion_engine = emotion_engine
        self.user_profile = user_profile

    def update_risk_level(self):
        self.user_profile["risk_level"] = self.risk_slider.value()

    def refresh_signals(self):
        self.signal_box.clear()
        report = self.emotion_engine.analyze()
        for task_id in report:
            signal = self.emotion_engine.generate_signal(task_id)
            self.signal_box.append(signal)

# Örnek kullanım:
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)

    user_profile = {"name": "Kamal", "risk_level": 6}
    engine = NovaEmotionStrategos()

    # Örnek veri girişi
    logs = [
        {"task_id": "X-Alpha", "emotion": "Stres", "feeling_strength": 8},
        {"task_id": "X-Alpha", "emotion": "Kaygı", "feeling_strength": 7},
        {"task_id": "Y-Beta", "emotion": "Odak", "feeling_strength": 4}
    ]
    for log in logs:
        engine.ingest_log(log)

    panel = TraderDashboard(user_profile, engine)
    panel.show()
    sys.exit(app.exec_())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\realtime_chain_listener.py
bot = ChainMomentumBot(transactions)
bot.execute_trades()

# Canlı zincirden gelen bir örnek işlem
tx_example = {
    "from": "0xGamma",
    "to": "0xDelta",
    "value": Web3.toWei(7, 'ether')
}

bot.react_to_live_tx(tx_example)

for trade in bot.executed_trades:
    print(f"⚡ {trade['wallet']} işlem aldı: {trade['action']} | Güven: {trade['confidence']}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\signal_broadcast_bot.py
from telegram import Bot

def broadcast_signal(signal, token, chat_id):
    bot = Bot(token=token)
    message = f"📡 Yeni Sinyal: {signal['asset']} → {signal['decision']}\n🧠 Güven: {signal['confidence']}\n🕒 Zaman: {signal['time']}"
    bot.send_message(chat_id=chat_id, text=message)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\signal_dashboard_streamlit_plotly.py
import streamlit as st
import plotly.express as px
import pandas as pd

st.set_page_config(page_title="Signal Command Center", layout="wide")

st.markdown("<h1 style='text-align: center;'>🧭 Chain Signal Command Center 🚀</h1>", unsafe_allow_html=True)

theme_colors = {
    "Ethereum": "#627eea",
    "Solana": "#00ffa3",
    "Arbitrum": "#28a0f0",
    "Goerli": "#ffcc00"
}

chain = st.selectbox("🔗 Zincir Seçimi", list(theme_colors.keys()))
color = theme_colors[chain]

st.markdown(f"<div style='background-color:{color};padding:10px;border-radius:10px;color:white'>🎯 Aktif Zincir: {chain}</div>", unsafe_allow_html=True)

if st.button("⏺️ Dinlemeyi Başlat"):
    st.success(f"{chain} sinyalleri yakalanıyor...")

signal_history = pd.DataFrame({
    "Zaman": ["12:24", "12:26", "12:28"],
    "Varlık": ["ETH", "SOL", "ETH"],
    "Sinyal": ["BUY", "SELL", "BUY"],
    "Güven": [0.95, 0.67, 1.0]
})

fig = px.bar(signal_history, x="Zaman", y="Güven", color="Sinyal", text="Varlık", title="📊 Sinyal Güven Grafiği")
st.plotly_chart(fig, use_container_width=True)

oracle_decisions = {
    "ETH": {"decision": "BUY", "confidence": 1.0},
    "SOL": {"decision": "SELL", "confidence": 0.67}
}

positions = {
    asset: {
        "Pozisyon": data["decision"],
        "Güven": f"{data['confidence']*100:.1f}%",
        "Tip": "LONG" if data["decision"] == "BUY" else "SHORT" if data["decision"] == "SELL" else "HOLD",
        "Kar Hedefi": "12%" if data["decision"] == "BUY" else "10%" if data["decision"] == "SELL" else "-",
        "Stop Loss": "6%" if data["decision"] == "BUY" else "5%" if data["decision"] == "SELL" else "-"
    }
    for asset, data in oracle_decisions.items()
}

st.subheader("📌 Aktif Pozisyonlar")
st.dataframe(pd.DataFrame.from_dict(positions, orient="index"))



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\signal_dashboard.py
import streamlit as st
import pandas as pd

st.set_page_config(page_title="Signal Dashboard", layout="wide")

st.title("🧠 Chain Signal Dashboard")
chain = st.selectbox("🔗 Zincir Seçimi", ["Ethereum", "Arbitrum", "Solana", "Goerli"])

if st.button("⏺️ Dinlemeyi Başlat"):
    st.success(f"{chain} dinleyicisi aktif!")

# Örnek veriler
oracle_decisions = {
    "ETH": {"decision": "BUY", "confidence": 1.0},
    "SOL": {"decision": "SELL", "confidence": 0.67}
}

positions = {
    asset: {
        "Pozisyon": data["decision"],
        "Güven": f"{data['confidence']*100:.1f}%",
        "Tip": "LONG" if data["decision"] == "BUY" else "SHORT" if data["decision"] == "SELL" else "HOLD",
        "Kar Hedefi": "12%" if data["decision"] == "BUY" else "10%" if data["decision"] == "SELL" else "-",
        "Stop Loss": "6%" if data["decision"] == "BUY" else "5%" if data["decision"] == "SELL" else "-"
    }
    for asset, data in oracle_decisions.items()
}

st.subheader("📈 Aktif Pozisyonlar")
df = pd.DataFrame.from_dict(positions, orient="index")
st.dataframe(df)

st.markdown("⛓️ Zincir aktifliği gerçek zamanlı bloklardan beslenecek. Daha gelişmiş versiyonda cüzdan etkileşimi ve token listesi de eklenebilir.")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\signal_report_generator.py
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from datetime import datetime

def generate_signal_report(signals, filename="signal_report.pdf"):
    c = canvas.Canvas(filename, pagesize=A4)
    width, height = A4
    c.setFont("Helvetica", 14)
    c.drawString(50, height - 50, "📊 Chain Signal Raporu")

    c.setFont("Helvetica", 10)
    c.drawString(50, height - 70, f"Tarih: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    y = height - 100

    for signal in signals:
        line = f"{signal['time']} | {signal['asset']} → {signal['decision']} | Güven: {signal['confidence']}"
        c.drawString(50, y, line)
        y -= 20
        if y < 50:
            c.showPage()
            y = height - 50

    c.save()
    print(f"✅ PDF raporu oluşturuldu: {filename}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\signal_tokenizer.py
import json
import hashlib
from datetime import datetime

def tokenize_signal(signal):
    metadata = {
        "name": f"{signal['asset']} Trade Signal",
        "description": f"Trade decision: {signal['decision']} with confidence {signal['confidence']}",
        "timestamp": signal["time"],
        "uuid": hashlib.md5(json.dumps(signal).encode()).hexdigest()
    }

    filename = f"{metadata['uuid']}.json"
    with open(filename, "w") as f:
        json.dump(metadata, f, indent=4)
    
    print(f"🪙 Token dosyası oluşturuldu: {filename}")
    return filename



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\strategic_position_builder.py
def build_positions(oracle_decisions, capital=10000, risk_profile="medium"):
    position_book = {}

    risk_multiplier = {"low": 0.2, "medium": 0.5, "high": 0.8}[risk_profile]

    for asset, data in oracle_decisions.items():
        allocation = capital * risk_multiplier * data["confidence"]

        if data["decision"] == "BUY":
            position_book[asset] = {
                "type": "LONG",
                "capital_allocated": round(allocation, 2),
                "target_profit": "12%", 
                "stop_loss": "6%"
            }

        elif data["decision"] == "SELL":
            position_book[asset] = {
                "type": "SHORT",
                "capital_allocated": round(allocation, 2),
                "target_profit": "10%",
                "stop_loss": "5%"
            }

        else:
            position_book[asset] = {
                "type": "HOLD",
                "capital_allocated": 0,
                "note": "Sinyal belirsiz, pozisyon alınmadı."
            }

    return position_book



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\strategy_trainer.py
import random

def evaluate_strategy(strategy_func, historical_data):
    wins = 0
    for data in historical_data:
        decision = strategy_func(data)
        if decision == "BUY" and data["result"] == "profit":
            wins += 1
    success_rate = wins / len(historical_data)
    print(f"🎯 Stratejinin başarı oranı: %{round(success_rate * 100, 2)}")
    return success_rate



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\synaptic_command_matrix.py
def synaptic_command(logs, emotion_focus="💡 İlham", threshold=75):
    commands = []
    for log in logs:
        task = log["task_id"]
        strength = log["feeling_strength"]
        emotion = log["emotion"]

        if emotion == emotion_focus and strength >= threshold:
            decision = f"🔝 Görev {task} → Ana Operasyon Moduna Al!"
        elif strength < 50:
            decision = f"🛌 Görev {task} → Dinlenme Aralığına Taşı"
        else:
            decision = f"📌 Görev {task} → İzlenmeye Devam Et"

        commands.append({
            "task": task,
            "timestamp": log["timestamp"],
            "decision": decision
        })

    return commands



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\tx_executor.py
from web3 import Web3
from eth_account import Account

web3 = Web3(Web3.HTTPProvider("https://mainnet.infura.io/v3/YOUR_PROJECT_ID"))

def execute_trade(wallet_private_key, recipient_address, amount_eth):
    account = Account.from_key(wallet_private_key)
    sender = account.address

    nonce = web3.eth.get_transaction_count(sender)
    tx = {
        'nonce': nonce,
        'to': recipient_address,
        'value': web3.toWei(amount_eth, 'ether'),
        'gas': 21000,
        'gasPrice': web3.toWei('35', 'gwei')
    }

    signed_tx = web3.eth.account.sign_transaction(tx, wallet_private_key)
    tx_hash = web3.eth.send_raw_transaction(signed_tx.rawTransaction)
    print(f"🚀 İşlem Başlatıldı → {web3.toHex(tx_hash)}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\universal_chain_listener.py
def get_provider(chain):
    providers = {
        "Ethereum": "wss://mainnet.infura.io/ws/v3/YOUR_PROJECT_ID",
        "Arbitrum": "wss://arbitrum-mainnet.infura.io/ws/v3/YOUR_PROJECT_ID",
        "Solana": "wss://api.mainnet-beta.solana.com",  # Solana özel istemci gerekir
        "Goerli": "wss://goerli.infura.io/ws/v3/YOUR_PROJECT_ID"
    }
    return providers.get(chain)

def start_chain_listener(chain_name):
    provider_url = get_provider(chain_name)
    if not provider_url:
        print(f"❌ Desteklenmeyen zincir: {chain_name}")
        return

    print(f"📡 {chain_name} dinleyici başlatılıyor...")

    # Ethereum/Arbitrum örneği (Web3.py ile)
    from web3 import Web3
    web3 = Web3(Web3.WebsocketProvider(provider_url))

    def on_new_block(event):
        block = web3.eth.get_block(event['hash'], full_transactions=True)
        print(f"🧿 {chain_name} Blok #{block.number} | İşlem: {len(block.transactions)}")

        # Sinyal analizi & karar modülleriyle entegre:
        if len(block.transactions) > 120:
            oracle_input = {chain_name[:3].upper(): "BUY"}
            decisions = multi_chain_oracle({chain_name: oracle_input})
            positions = build_positions(decisions)
            print("📈 Pozisyonlar:", positions)

    web3.eth.subscribe("newHeads", {}, on_new_block)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\wallet_behavior_predictor.py
def predict_wallet_behavior(transactions, activity_threshold=0.6):
    predictions = {}
    for wallet, history in transactions.items():
        tx_count = len(history)
        high_value = sum(1 for tx in history if tx["value"] > 10000)
        recurring = sum(1 for tx in history if tx["type"] == "recurring")

        score = round((high_value * 0.4 + recurring * 0.3 + tx_count * 0.3) / tx_count, 2)

        if score >= activity_threshold:
            predictions[wallet] = f"🔥 Tahmin: Yakında büyük hareket bekleniyor (Skor={score})"
        else:
            predictions[wallet] = f"🌙 Tahmin: Durgun profil (Skor={score})"
    return predictions



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_symphony_engine.py\wallet_signal_connector.py
from web3 import Web3

def connect_wallet(wallet_address):
    web3 = Web3(Web3.HTTPProvider("https://mainnet.infura.io/v3/YOUR_PROJECT_ID"))

    # Cüzdan bakiyesi
    balance_wei = web3.eth.get_balance(wallet_address)
    balance_eth = web3.fromWei(balance_wei, 'ether')
    print(f"👛 {wallet_address} → ETH Bakiye: {balance_eth}")

    # Token pozisyonları için ERC20 kontratları taranabilir
    # (Burada örnek olarak sadece ETH bakiyesi alınıyor)

    return balance_eth



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_network\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_network\main.py
import os, time, logging
import pandas as pd
from dotenv import load_dotenv
from datetime import datetime

# Binance API
from services.binance_client import get_client
from strategies.basic_macd_rsi import generate_signal
from core.trade_executor import place_order

# Haber ve duygu analizi
from kiripto_nova.signals.get_news import get_crypto_news
from sentiment import analyze_sentiment
from explainer import explain_signal
from csv_writer import save_to_csv
from kiripto_nova.apps.telegram_bot import send_signal_to_telegram
from kiripto_nova.signals.signal_tracker import analyze_signal_effect
from dashboard.visual_panel import dashboard_view

# Strateji filtreleri ve yöneticiler
from regime import regime
from cooldown import cooldown
from kiripto_nova.execution.position_manager import pos_mgr
from atr import atr_levels
from kiripto_nova.ai.ml_engine import ml_engine
from ta_engine import ta_engine
from news_engine import news_engine

# Log yapılandırması
logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")

# Ortam değişkenleri
load_dotenv(dotenv_path="my_env_file.env")
API_KEY = os.getenv("BINANCE_API_KEY")
SECRET_KEY = os.getenv("BINANCE_SECRET_KEY")
client = get_client()

def fetch_data(symbol: str, limit: int = 100) -> pd.DataFrame:
    try:
        ohlcv = client.fetch_ohlcv(symbol, timeframe="5m", limit=limit)
        df = pd.DataFrame(ohlcv, columns=['time', 'open', 'high', 'low', 'close', 'volume'])
        df['time'] = pd.to_datetime(df['time'], unit='ms')
        return df
    except Exception as e:
        logging.error(f"Veri çekme hatası: {e}")
        return pd.DataFrame()

def run_news_analysis():
    news_data = get_crypto_news()
    signals = []

    for news in news_data:
        title = news.get("title", "")
        description = news.get("description", "")
        label, score = analyze_sentiment(f"{title} {description}")

        if label == "positive" and score > 0.7:
            signal = "AL"
        elif label == "negative" and score > 0.6:
            signal = "SAT"
        else:
            signal = "BEKLE"

        note = explain_signal(title, description)
        send_signal_to_telegram(title, signal, score)

        signals.append({
            "title": title,
            "signal": signal,
            "sentiment": label,
            "score": round(score, 3),
            "note": note
        })

    save_to_csv(signals)
    logging.info(f"{len(signals)} haber sinyali işlendi ve kaydedildi.")

def run_trading_cycle(symbol="DOGE/USDT"):
    df = fetch_data(symbol)
    if df.empty:
        logging.warning("Veri alınamadı, işlem döngüsü atlandı.")
        return

    ta_sig = ta_engine.decide(df)
    ml_sig = ml_engine.decide(df)
    news = news_engine.bias()
    tdrdir, vol = regime.allow(df)
    cooldown.tick()

    direction, entry, conf = None, None, 0.5

    if ta_sig:
        direction, entry = ta_sig
        if ml_sig and ml_sig[0] == direction: conf += 0.2 * ml_sig[1]
        if news and news[0] == direction: conf += 0.2 * news[1]

        if tdrdir == 1 and direction in ["LONG", "SHORT"]: conf -= 0.3
        if vol[df['close'].pct_change().rolling(36).std().median()]: conf -= 0.1

        if conf >= 0.65 and cooldown.ok() and pos_mgr.can_open(direction):
            sl, tp = atr_levels(df, entry, direction)
            place_order({"direction": direction, "entry": entry, "sl": sl, "tp": tp})
            pos_mgr.on_open(direction)
            cooldown.trigger()
            logging.info(f"✅ İşlem açıldı: {direction} @ {entry} | SL: {sl} | TP: {tp}")
        else:
            logging.info("⏳ Sinyal yeterince güçlü değil veya pozisyon açılamaz.")
    else:
        logging.info("❌ Teknik sinyal bulunamadı.")

def main():
    logging.info("🚀 Nova Chain Komuta Sistemi vX.1 başlatılıyor...")
    run_news_analysis()

    while True:
        run_trading_cycle()
        effect = analyze_signal_effect("DOGE", datetime.utcnow().isoformat())
        logging.info(f"📊 Sinyal etkisi: {effect}")
        dashboard_view()
        time.sleep(60)

if __name__ == "__main__":
    main()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_network\nova_trader.py
# NovaQuantX - Ticaret Motoru (pozisyon yönetimi + sinyal işleme)
from dataclasses import dataclass

@dataclass
class Position:
    symbol: str
    side: str  # 'LONG' or 'SHORT'
    entry_price: float
    leverage: int
    qty: float
    open_ts: int

class NovaTrader:
    def __init__(self, leverage=10, rsi_buy=30, rsi_sell=70):
        self.positions = {}
        self.leverage = leverage
        self.rsi_buy = rsi_buy
        self.rsi_sell = rsi_sell

    def process_signal(self, symbol: str, price: float, rsi: float, ts: int):
        pos = self.positions.get(symbol)

        # LONG sinyali
        if rsi <= self.rsi_buy and pos is None:
            qty = self.calculate_qty(price)
            self.positions[symbol] = Position(
                symbol=symbol,
                side='LONG',
                entry_price=price,
                leverage=self.leverage,
                qty=qty,
                open_ts=ts
            )
            print(f"🟢 LONG açıldı: {symbol} @ {price:.2f} x{self.leverage}")

        # SHORT sinyali
        elif rsi >= self.rsi_sell and pos is None:
            qty = self.calculate_qty(price)
            self.positions[symbol] = Position(
                symbol=symbol,
                side='SHORT',
                entry_price=price,
                leverage=self.leverage,
                qty=qty,
                open_ts=ts
            )
            print(f🔴 SHORT açıldı: {symbol} @ {price:.2f} x{self.leverage}")

        # Pozisyon kapatma mantığı (örnek: RSI nötr bölgeye girerse)
        elif pos:
            if (pos.side == 'LONG' and rsi >= 50) or (pos.side == 'SHORT' and rsi <= 50):
                pnl = self.calculate_pnl(pos, price)
                print(f"⚪ Pozisyon kapandı: {symbol} {pos.side} PnL={pnl:.2f}")
                del self.positions[symbol]

    def calculate_qty(self, price: float):
        capital = 100  # sabit sermaye (örnek)
        return (capital * self.leverage) / price

    def calculate_pnl(self, pos: Position, current_price: float):
        if pos.side == 'LONG':
            return (current_price - pos.entry_price) * pos.qty
        else:
            return (pos.entry_price - current_price) * pos.qty

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_network\novaSovereignCore.py
import random

# === AI MODELLERİ ===
def predict_lstm(market_data):
    return {"action": random.choice(["buy", "sell", "hold"]), "confidence": random.uniform(0.7, 0.95)}

def predict_transformer(market_data):
    return {"action": random.choice(["buy", "sell", "hold"]), "confidence": random.uniform(0.75, 0.98)}

def predict_rl(market_data):
    return {"action": random.choice(["buy", "sell", "hold"]), "confidence": random.uniform(0.65, 0.9)}

# === DAVRANIŞ ANALİZİ ===
def analyze_behavior(market_data):
    # Basit davranış skoru: 0.0 (panik) - 1.0 (rasyonel)
    volatility = market_data.get("volatility", 0.5)
    fomo_index = market_data.get("fomo", 0.5)
    return max(0.0, 1.0 - (volatility + fomo_index) / 2)

# === STRATEJİ PORTFÖYÜ ===
def allocate(action, confidence):
    allocation = {
        "buy": confidence * 1000,
        "sell": confidence * 800,
        "hold": confidence * 500
    }
    return allocation.get(action, 0)

# === META KARAR MOTORU ===
class MetaDecisionEngine:
    def resolve(self, lstm_sig, transformer_sig, rl_sig, behavior_score, sentiment, onchain_score):
        votes = [lstm_sig, transformer_sig, rl_sig]
        confidence = sum([sig["confidence"] for sig in votes]) / len(votes)

        if behavior_score < 0.4: confidence -= 0.1
        if sentiment == "negative": confidence -= 0.1
        if onchain_score < 0.5: confidence -= 0.1

        final_action = max(set([sig["action"] for sig in votes]), key=[sig["action"] for sig in votes].count)
        return {"action": final_action, "confidence": round(confidence, 3)}

# === ZİNCİR ÜSTÜ DOĞRULAMA ===
class Layer2Chain:
    def __init__(self):
        self.strategies = {}

    def submit_strategy(self, strategy_id, action, confidence):
        approved = confidence > 0.8
        self.strategies[strategy_id] = {
            "action": action,
            "confidence": confidence,
            "approved": approved
        }
        print(f"📡 Zincir üstü strateji gönderildi: {strategy_id} | {action} | Güven: {confidence} | Onay: {approved}")

# === STRATEJİ EVRİMİ ===
class ReinforcementOptimizer:
    def train(self, strategy_history):
        print("🔁 Strateji geçmişi optimize ediliyor...")
        # Basit evrimsel mantık (placeholder)
        evolved = [s for s in strategy_history if s["confidence"] > 0.75]
        print(f"✅ Evrimleşen stratejiler: {len(evolved)}")

# === ANA SİSTEM ===
class NovaSovereignCore:
    def __init__(self):
        self.meta = MetaDecisionEngine()
        self.chain = Layer2Chain()
        self.optimizer = ReinforcementOptimizer()

    def run(self, market_data):
        print("🚀 Nova Intelligence Sovereign Core başlatılıyor...\n")

        lstm_sig = predict_lstm(market_data)
        transformer_sig = predict_transformer(market_data)
        rl_sig = predict_rl(market_data)
        behavior_score = analyze_behavior(market_data)
        sentiment = market_data.get("sentiment", "neutral")
        onchain_score = market_data.get("onchain", 0.6)

        print(f"📊 AI Sinyalleri:\nLSTM: {lstm_sig}\nTransformer: {transformer_sig}\nRL: {rl_sig}")
        print(f"🧠 Davranış Skoru: {behavior_score} | Duygu: {sentiment} | Zincir Skoru: {onchain_score}\n")

        decision = self.meta.resolve(lstm_sig, transformer_sig, rl_sig, behavior_score, sentiment, onchain_score)
        allocation = allocate(decision["action"], decision["confidence"])

        print(f"🎯 Nihai Karar: {decision['action']} | Güven: {decision['confidence']} | Tahsis: {allocation} birim\n")

        strategy_id = f"nova_{random.randint(1000,9999)}"
        self.chain.submit_strategy(strategy_id, decision["action"], decision["confidence"])
        self.optimizer.train([lstm_sig, transformer_sig, rl_sig])

        print("\n✅ Nova operasyonu tamamlandı.")

# === ÇALIŞTIR ===
if __name__ == "__main__":
    market_data = {
        "volatility": 0.6,
        "fomo": 0.4,
        "sentiment": "positive",
        "onchain": 0.7
    }

    nova = NovaSovereignCore()
    nova.run(market_data)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_network\rsi.py
# NovaQuantX - RSI modülü (tick bazlı, ultra hassas)
from collections import deque

class TickRSI:
    def __init__(self, period=14):
        self.period = period
        self.gains = deque(maxlen=period)
        self.losses = deque(maxlen=period)
        self.last_price = None
        self.rsi = None

    def update(self, price: float):
        if self.last_price is None:
            self.last_price = price
            return None

        delta = price - self.last_price
        self.last_price = price

        gain = max(delta, 0)
        loss = max(-delta, 0)

        self.gains.append(gain)
        self.losses.append(loss)

        if len(self.gains) < self.period:
            return None  # Yeterli veri yok

        avg_gain = sum(self.gains) / self.period
        avg_loss = sum(self.losses) / self.period

        if avg_loss == 0:
            self.rsi = 100
        else:
            rs = avg_gain / avg_loss
            self.rsi = 100 - (100 / (1 + rs))

        return round(self.rsi, 2)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\ai\__init__.py
# auto-added


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\ai\ai_advisor.py
def explain_market_reaction(title, description):
    prompt = f"Başlık: {title}\nAçıklama: {description}\nBu haber yatırımcılar için ne ifade eder?"
    # Gerçek LLM çağrısı ile açıklama alınabilir (OpenAI, Azure, vb.)
    return "Bu haber yatırımcı güvenini artırır, AL sinyali desteklenebilir."



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\ai\ai_strategy.py
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
import pandas as pd

def train_ai_model(data):
    X = data.drop("target", axis=1)
    y = data["target"]

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

    model = RandomForestClassifier(n_estimators=100)
    model.fit(X_train, y_train)

    accuracy = model.score(X_test, y_test)
    print(f"🔍 Model doğruluğu: %{round(accuracy * 100, 2)}")

    return model
def get_signal_from_model(model, new_data_row):
    prediction = model.predict([new_data_row])
    return "BUY" if prediction[0] == 1 else "SELL"


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\ai\ml_engine.py
# main.py içinde karar
df = klines_to_df(ex.klines(limit=600))   # kendin df çevir
ta_sig = ta_engine.decide(kl)             # ("LONG"/"SHORT", entry)
ml_sig = ml_engine.decide(df)             # ("LONG"/"SHORT", p)
news = news_engine.bias()                 # ("LONG"/"SHORT", conf)

# Rejim & vol filtreleri
trdir, vol = regime.allow(df)
cooldown.tick()

direction, entry = None, None
if ta_sig:
    direction, entry = ta_sig
    conf = 0.5
    if ml_sig and ml_sig[0]==direction: conf += 0.2*ml_sig[1]
    if news  and news[0]==direction:    conf += 0.2*news[1]
    # Rejim filtresi
    if (trdir==1 and direction=="SHORT") or (trdir==-1 and direction=="LONG"):
        conf -= 0.3
    if vol<df["close"].pct_change().rolling(50).std().median(): conf -= 0.1

    if conf>=0.65 and cooldown.ok() and pos_mgr.can_open(direction):
        sl,tp = atr_levels(df, entry, direction)
        execu.open_trade(direction, entry, sl, tp)
        pos_mgr.on_open(direction)
        cooldown.trigger()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\ai\ml_filter.py
# ml_filter.py (Yapay zeka destekli sinyal doğrulayıcı)
import pandas as pd
import joblib
from sklearn.ensemble import RandomForestClassifier

# Örnek model eğitimi için kullanılır (gerçekte bu offline yapılmalı)
def train_model(train_df):
    features = ["RSI_14", "MACD_12_26_9", "MACDs_12_26_9", "EMA_50", "EMA_200", "BBU_20_2.0", "BBL_20_2.0"]
    X = train_df[features]
    y = train_df["label"]  # 1 = başarılı sinyal, 0 = başarısız

    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X, y)
    joblib.dump(model, "ml_signal_model.pkl")
    print("✅ Model eğitildi ve kaydedildi.")


# Eğitilmiş modelle sinyal doğrulama
class MLFilter:
    def __init__(self, model_path="ml_signal_model.pkl"):
        self.model = joblib.load(model_path)

    def evaluate(self, df):
        features = ["RSI_14", "MACD_12_26_9", "MACDs_12_26_9", "EMA_50", "EMA_200", "BBU_20_2.0", "BBL_20_2.0"]
        row = df.iloc[-1:]
        X = row[features]
        prediction = self.model.predict(X)[0]
        confidence = self.model.predict_proba(X)[0][1]  # 1. sınıfın olasılığı
        return prediction, round(confidence, 3)


# Kullanım örneği
if __name__ == "__main__":
    # (Gerçek kullanımda train_df geçmiş etiketli veriden gelir)
    df = pd.read_csv("example_labeled_data.csv")  # RSI, MACD, EMA, BB + label sütunu
    train_model(df)

    # Tahmin örneği
    latest = df.copy()
    model = MLFilter()
    result, conf = model.evaluate(latest)
    print(f"🤖 Tahmin: {result} | Güven: {conf}")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\ai\neuro_decision_engine.py
def neuro_decision(sentiment, score, keywords, time_hour, source_reputation):
    weight = 0
    weight += score * 2
    if sentiment == "positive":
        weight += 1
    if "rally" in keywords:
        weight += 1
    if time_hour in range(8, 12):  # Sabah saatleri
        weight += 0.5
    if source_reputation == "high":
        weight += 1
    return "AL" if weight >= 3.5 else "SAT" if weight <= -2 else "BEKLE"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_chronovision.py
class ProjectEvent:
    def __init__(self, name, timestamp, impact, event_type):
        self.name = name
        self.timestamp = timestamp  # 'YYYY-MM-DD'
        self.impact = impact  # 'low', 'medium', 'high'
        self.event_type = event_type  # 'launch', 'update', 'crisis', 'forecast'

def create_timeline(events):
    timeline = sorted(events, key=lambda e: e.timestamp)
    print("🕰️ Zincir Zaman Ekseni:")
    for e in timeline:
        print(f"{e.timestamp} | [{e.event_type.upper()}] {e.name} - Etki: {e.impact}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_convergence_forge.py
class ChainProfile:
    def __init__(self, name, launch_date, alliances, impact_score):
        self.name = name
        self.launch_date = launch_date  # 'YYYY-MM-DD'
        self.alliances = alliances      # ['ZetaCore', 'ShadowNet']
        self.impact_score = impact_score  # 0-100

def forge_convergence_map(profiles):
    profiles_sorted = sorted(profiles, key=lambda p: (p.launch_date, -p.impact_score))
    print("🌌 Zincir Birleşim Haritası:")
    for profile in profiles_sorted:
        print(f"{profile.launch_date} | {profile.name} 🔗 İttifaklar: {profile.alliances} 💥 Etki: {profile.impact_score}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_destiny_mapper.py
def map_chain_destiny(event_matrix):
    destiny_paths = []
    for evt in event_matrix:
        if evt['emotion'] == 'ascension' and evt['flux_level'] > 70:
            destiny_paths.append(f"🌠 Evrim Rotası: {evt['id']}")
        elif evt['risk'] > 80 and evt['potential'] > 85:
            destiny_paths.append(f"⚠️ Kader Krizi: {evt['id']} → Müdahale gerekebilir")
    return destiny_paths if destiny_paths else ["🧘 Veri sakin. Kader açık ama hareketsiz."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_emotion_canvas.py
import matplotlib.pyplot as plt
import numpy as np

def emotion_wave(emotion):
    t = np.linspace(0, 4*np.pi, 1000)
    if emotion == "positive":
        y = np.sin(t) * np.exp(-0.05*t)
        color = "gold"
    elif emotion == "negative":
        y = np.sin(3*t)
        color = "purple"
    else:
        y = np.sin(2*t) * 0.5
        color = "gray"

    plt.plot(t, y, color=color)
    plt.title(f"{emotion.upper()} Dalga Formu")
    plt.show()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_epic_mapper.py
def map_chain_epic(project_name, mythos, events, emotion_tone):
    epic = f"🛡️ {project_name} - {mythos}:\n"
    for event in events:
        epic += f"📍 {event['timestamp']}: {event['description']}\n"
    epic += f"🎶 Topluluk hissi: {emotion_tone}\n"
    return epic



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_galaxy_atlas.py
class ChainPlanet:
    def __init__(self, name, orbit_level, alliance_tags, mood):
        self.name = name
        self.orbit_level = orbit_level  # 1 = merkez, 5 = uzak sınır
        self.alliance_tags = alliance_tags  # ['DeFi', 'Privacy']
        self.mood = mood  # 'volatile', 'growing', 'stable'

def create_galaxy(planets):
    galaxy_map = {}
    for planet in planets:
        key = planet.orbit_level
        if key not in galaxy_map:
            galaxy_map[key] = []
        galaxy_map[key].append(planet.name)
    return galaxy_map



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_hunt_protocol.py
class ChainProject:
    def __init__(self, name, sector, risk, growth_rate, alliances):
        self.name = name
        self.sector = sector
        self.risk = risk
        self.growth_rate = growth_rate
        self.alliances = alliances

def hunt_targets(projects, desired_sector, max_risk, min_growth):
    targets = []
    for proj in projects:
        if proj.sector == desired_sector and proj.risk != 'high' and proj.growth_rate >= min_growth:
            targets.append(proj.name)
    return targets

# 🔬 Simülasyon için örnek projeler:
if __name__ == "__main__":
    p1 = ChainProject("SyntheVault", "DeFi", "medium", 18.7, ["Arbitrum"])
    p2 = ChainProject("ZetaCore", "ZK", "high", 24.2, ["StarkNet"])
    p3 = ChainProject("PlayVerseX", "GameFi", "low", 15.5, ["Immutable"])
    p4 = ChainProject("FlowForge", "DeFi", "low", 22.1, ["Optimism"])

    hunt = hunt_targets([p1, p2, p3, p4], "DeFi", "medium", 20.0)
    print("🎯 Stratejik Av Listesi:")
    for target in hunt:
        print(f"- {target}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_hunter.py
def chain_hunter(code_base):
    if "obfuscation" in code_base:
        print("💣 Gizlenmiş yapı bulundu: Kod manipülasyonu şüphesi!")
    elif "loop trigger" in code_base:
        print("🎯 Döngü tetikleyici aktif: Zaman bazlı strateji kodu.")
    else:
        print("🔍 Temiz yapı: Standart fonksiyon mantığı.")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_mutation_tracker.py
def track_mutation(old_code, new_code):
    changes = []
    old_lines = old_code.splitlines()
    new_lines = new_code.splitlines()

    for i, (old, new) in enumerate(zip(old_lines, new_lines)):
        if old != new:
            changes.append(f"🔄 Satır {i+1} değişmiş:\nEski: {old}\nYeni: {new}")

    extra = new_lines[len(old_lines):]
    for i, line in enumerate(extra, start=len(old_lines)+1):
        changes.append(f"➕ Yeni satır {i}: {line}")

    return changes if changes else ["✅ Kod yapısında belirgin mutasyon yok."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_mythos_engine.py
def map_to_arketype(emotion_score, risk_profile, utility_type):
    if emotion_score > 0.7 and utility_type == "innovation":
        return "🌟 Kahraman"
    elif risk_profile < 0.3 and utility_type == "guidance":
        return "🧙‍♂️ Bilge"
    elif risk_profile > 0.7 and utility_type == "chaos":
        return "🐍 Trickster"
    else:
        return "🛡️ Bekçi"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_radar_gui.py
import tkinter as tk

def draw_radar(projects):
    root = tk.Tk()
    root.title("🧭 Kripto Radar Ekranı")

    canvas = tk.Canvas(root, width=500, height=500, bg="black")
    canvas.pack()

    canvas.create_oval(100, 100, 400, 400, outline="green")  # radar çerçevesi

    for i, proj in enumerate(projects):
        x = 250 + proj['x_offset']
        y = 250 + proj['y_offset']
        canvas.create_oval(x-10, y-10, x+10, y+10, fill="lime")
        canvas.create_text(x, y-15, text=proj['name'], fill="white")

    root.mainloop()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\onchain\chain_voice_empath.py
def generate_voice_profile(emotion_state):
    profiles = {
        "positive": "SoothingTone.wav",
        "negative": "IntenseAlert.wav",
        "neutral": "InformativeFlat.wav"
    }
    return profiles.get(emotion_state, "DefaultVoice.wav")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\analysis_graphs.py
import pandas as pd
import matplotlib.pyplot as plt

def plot_signal_density(csv_file):
    df = pd.read_csv(csv_file)
    df['publishedAt'] = pd.to_datetime(df['publishedAt'])
    df['hour'] = df['publishedAt'].dt.hour
    df['signal'] = df['signal'].fillna("BEKLE")

    signal_counts = df.groupby(['hour', 'signal']).size().unstack(fill_value=0)
    signal_counts.plot(kind='bar', stacked=True)
    plt.title("Saat Bazlı Sinyal Yoğunluğu")
    plt.xlabel("Saat")
    plt.ylabel("Sinyal Sayısı")
    plt.tight_layout()
    plt.show()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\dashboard_app.py
# dashboard_app.py (Streamlit ile canlı performans kontrol paneli)
import streamlit as st
import pandas as pd
import sqlite3
import matplotlib.pyplot as plt

DB_NAME = "trade_history.db"

st.set_page_config(page_title="Kripto Bot Paneli", layout="wide")
st.title("📊 Otomatik Kripto Bot Kontrol Paneli")

@st.cache_data()
def load_data():
    conn = sqlite3.connect(DB_NAME)
    df = pd.read_sql("SELECT * FROM trades ORDER BY timestamp DESC", conn)
    conn.close()
    return df

def draw_cumulative(df):
    df = df.sort_values("timestamp")
    df["cumulative_pnl"] = df["pnl"].cumsum()
    st.subheader("📈 Kümülatif Kâr/Zarar")
    st.line_chart(df.set_index("timestamp")["cumulative_pnl"])

def trade_table(df):
    st.subheader("📋 İşlem Geçmişi")
    st.dataframe(df)

def stats(df):
    wins = df[df["result"] == "win"]
    losses = df[df["result"] == "loss"]
    winrate = len(wins) / len(df) * 100 if len(df) > 0 else 0

    col1, col2, col3 = st.columns(3)
    col1.metric("Toplam İşlem", len(df))
    col2.metric("Winrate", f"{winrate:.2f}%")
    col3.metric("Net PnL", f"{df['pnl'].sum():.2f} USDT")


if __name__ == "__main__":
    try:
        df = load_data()
        stats(df)
        draw_cumulative(df)
        trade_table(df)
    except Exception as e:
        st.error("Veri yüklenemedi. Lütfen işlem geçmişi oluşturduğunuzdan emin olun.")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\plot_performance.py
# plot_performance.py (İşlem günlüğü istatistik ve grafik analizi)
import sqlite3
import pandas as pd
import matplotlib.pyplot as plt

DB_NAME = "trade_history.db"

def load_trade_data():
    conn = sqlite3.connect(DB_NAME)
    df = pd.read_sql("SELECT * FROM trades ORDER BY timestamp", conn)
    conn.close()
    return df

def analyze_performance(df):
    df['cumulative_pnl'] = df['pnl'].cumsum()
    win_rate = (df['result'] == 'win').mean() * 100
    avg_win = df[df['result'] == 'win']['pnl'].mean()
    avg_loss = df[df['result'] == 'loss']['pnl'].mean()
    max_drawdown = (df['cumulative_pnl'].cummax() - df['cumulative_pnl']).max()

    print(f"🔎 Toplam İşlem: {len(df)}")
    print(f"✅ Win Rate: {win_rate:.2f}%")
    print(f"💰 Ortalama Kazanç: {avg_win:.2f}")
    print(f"❌ Ortalama Kayıp: {avg_loss:.2f}")
    print(f"📉 Max Drawdown: {max_drawdown:.2f}")

    return df

def plot_cumulative_pnl(df):
    plt.figure(figsize=(12,6))
    plt.plot(df['timestamp'], df['cumulative_pnl'], label='Cumulative PnL', color='green')
    plt.title("💹 Kümülatif Kâr/Zarar Grafiği")
    plt.xlabel("Tarih")
    plt.ylabel("USDT")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.xticks(rotation=45)
    plt.show()

if __name__ == "__main__":
    df = load_trade_data()
    if len(df) == 0:
        print("❗Veri yok. Önce trade_journal ile işlem kaydı gir.")
    else:
        df = analyze_performance(df)
        plot_cumulative_pnl(df)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\plot_success.py
import pandas as pd
import matplotlib.pyplot as plt

def plot_signal_results(csv_file="data/signal_log.csv"):
    df = pd.read_csv(csv_file, names=["signal", "score", "result"])
    success_rate = df["result"].value_counts(normalize=True) * 100
    success_rate.plot(kind="bar", color=["green", "red"])
    plt.title("Sinyal Başarı Oranı")
    plt.ylabel("%")
    plt.tight_layout()
    plt.show()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\report_generator.py
def generate_daily_signal_report(csv_file):
    import pandas as pd
    df = pd.read_csv(csv_file)
    summary = df.groupby("signal").size()
    print("🔎 Günlük Sinyal Dağılımı:\n", summary)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\analytics\wallet_activity_analyzer.py
import json

def analyze_wallet_activity(wallet_address, tx_data):
    swap_count = sum(1 for tx in tx_data if tx["type"] == "swap")
    dormant_periods = [tx["timestamp"] for tx in tx_data if tx["value"] == 0]

    report = []
    report.append(f"📊 Toplam Swap Sayısı: {swap_count}")
    report.append(f"🛌 Pasif İşlemler: {len(dormant_periods)}")
    
    high_freq = [tx for tx in tx_data if tx["frequency"] > 10]
    if high_freq:
        report.append(f"⚡ Yüksek frekanslı işlem davranışı tespit edildi.")

    contract_interactions = {tx["to"] for tx in tx_data if tx["type"] == "contract_call"}
    if contract_interactions:
        report.append(f"📡 Etkileşimde bulunulan kontratlar: {len(contract_interactions)} adet.")

    return report



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\apps\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\apps\nova_ai_elite_bot.py
# Gerekli kütüphaneleri içe aktarıyoruz.
# os: Ortam değişkenlerini okumak için
# ccxt: Kripto para borsalarına bağlanmak için
# pandas & pandas_ta: Veri analizi ve teknik göstergeler için
# numpy: Sayısal işlemler için
# asyncio: Eşzamansız işlemler için (gerçek zamanlı veri çekimi simülasyonu)
# datetime: Zaman damgalı loglama için
# xgboost: Makine öğrenimi modeli olarak kullanılacak
import os
import ccxt.async_support as ccxt
import pandas as pd
import pandas_ta as ta
import asyncio
import numpy as np
import xgboost as xgb
from datetime import datetime, timezone
import logging
import traceback
import matplotlib.pyplot as plt

# Gelişmiş loglama ayarları
logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s.%(msecs)03d] | %(levelname)s | %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)

class NovaAIEliiteBot:
    """
    Ultra hibrit ve profesyonel seviye bir kripto ticaret botu sınıfı.
    Gelişmiş AI, hibrit strateji ve sağlam risk yönetimi içerir.
    """
    def __init__(self, symbol="BTC/USDT", timeframe="1m", limit=300, amount=0.01, api_key=None, secret_key=None):
        """
        Botun temel ayarlarını ve bileşenlerini başlatır.
        API anahtarları ile Binance'e bağlanır.
        """
        self.exchange = ccxt.binance({
            'apiKey': api_key,
            'secret': secret_key,
            'enableRateLimit': True,
            'rateLimit': 1000  # ccxt API kısıtlama hızını 1000ms'ye ayarlar
        })
        self.symbol = symbol
        self.timeframe = timeframe
        self.limit = limit
        self.amount = amount
        self.model = xgb.XGBClassifier(use_label_encoder=False, eval_metric='mlogloss')
        self.trained = False
        self.position = None  # Botun o anki pozisyonunu takip eder: None, 'LONG' (AL), 'SHORT' (SAT)
        self.entry_price = 0.0  # Pozisyona giriş fiyatı
        
        # Risk Yönetimi Ayarları
        self.SL_PERCENTAGE = 0.02  # %2 Zarar Durdur (Stop-Loss)
        self.TP_PERCENTAGE = 0.03  # %3 Kâr Al (Take-Profit)
        self.sl_price = 0.0
        self.tp_price = 0.0

    async def fetch_ohlcv(self):
        """
        Borsadan mum (OHLCV) verilerini çeker.
        """
        try:
            ohlcv = await self.exchange.fetch_ohlcv(self.symbol, self.timeframe, limit=self.limit)
            df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
            df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
            df = df.set_index("timestamp")
            return df
        except Exception as e:
            logging.error(f"Veri çekme hatası: {e}")
            return pd.DataFrame()

    def apply_indicators(self, df):
        """
        Ticaret stratejisi için gerekli tüm teknik göstergeleri uygular.
        Yeni eklenenler: OBV ve ATR.
        """
        if df.empty:
            return df
        
        # Hibrit strateji için temel göstergeler
        df.ta.rsi(length=14, append=True)
        df.ta.macd(append=True)
        df.ta.ema(length=20, append=True)
        df.ta.bbands(append=True)
        df.ta.adx(append=True)
        df.ta.obv(append=True)  # Yeni gösterge: On-Balance Volume
        df.ta.atr(length=14, append=True) # Yeni gösterge: Average True Range
        
        # Ek göstergeler
        df.ta.mom(append=True)
        df.ta.cci(append=True)
        
        # Modeli beslemek için gerekli sütunlar
        required_cols = ["RSI_14", "MACD_12_26_9", "ADX_14", "BBL_5_2.0", "BBM_5_2.0", "BBU_5_2.0", "MOM_10", "CCI_14", "OBV", "ATR_14"]
        
        # Eğer bir gösterge sütunu eksikse, boş bir DataFrame döndür.
        if not all(col in df.columns for col in required_cols):
            logging.warning("Bazı göstergeler hesaplanamadı, veri boyutu yetersiz olabilir.")
            return pd.DataFrame()

        return df.dropna().copy()

    def create_labels(self, df):
        """
        Mükemmeliyetçi etiketleme mantığı: Üçlü Onay Sistemi.
        Sinyal üretmek için birden fazla koşulu kontrol eder.
        1: Yükseliş (AL), -1: Düşüş (SAT), 0: Yatay/Bekle (BEKLE)
        """
        # Gelecekteki fiyat hareketini tahmin etmek için 1 mum ileri kaydırma
        df['future_close'] = df['close'].shift(-1)
        
        # Etiketleme mantığı
        df['label'] = 0
        
        # AL (Long) sinyali için üçlü onay
        # 1. Trend: Fiyat EMA 20'nin üzerinde olmalı
        # 2. Momentum: RSI 60'ın üzerinde olmalı (aşırı alım bölgesinde olmamalı)
        # 3. Hacim: OBV yükselişte olmalı
        long_condition = (df['close'] > df['EMA_20']) & \
                         (df['RSI_14'] < 70) & \
                         (df['OBV'] > df['OBV'].shift(1))
        
        df.loc[long_condition, 'label'] = 1

        # SAT (Short) sinyali için üçlü onay
        # 1. Trend: Fiyat EMA 20'nin altında olmalı
        # 2. Momentum: RSI 40'ın altında olmalı (aşırı satım bölgesinde olmamalı)
        # 3. Hacim: OBV düşüşte olmalı
        short_condition = (df['close'] < df['EMA_20']) & \
                          (df['RSI_14'] > 30) & \
                          (df['OBV'] < df['OBV'].shift(1))
                          
        df.loc[short_condition, 'label'] = -1
        
        return df.dropna().copy()

    def train_model(self, df):
        """
        Hazırlanan verilerle XGBoost modelini eğitir.
        """
        if df.empty:
            logging.error("Eğitim için yeterli veri yok.")
            return

        features = ["RSI_14", "MACD_12_26_9", "ADX_14", "BBL_5_2.0", "BBM_5_2.0", "BBU_5_2.0", "MOM_10", "CCI_14", "OBV", "ATR_14"]
        X = df[features]
        y = df['label']

        try:
            self.model.fit(X, y)
            self.trained = True
            logging.info("🧠 AI modeli başarıyla eğitildi.")
        except Exception as e:
            logging.error(f"AI modeli eğitim hatası: {e}")
            traceback.print_exc()

    def predict_signal(self, latest_row):
        """
        En son veriyi kullanarak AI'dan alım, satım veya bekle sinyali alır.
        """
        if not self.trained:
            logging.warning("AI modeli henüz eğitilmemiş. Bekle sinyali veriliyor.")
            return "BEKLE"

        try:
            features = ["RSI_14", "MACD_12_26_9", "ADX_14", "BBL_5_2.0", "BBM_5_2.0", "BBU_5_2.0", "MOM_10", "CCI_14", "OBV", "ATR_14"]
            X = latest_row[features].values.reshape(1, -1)
            pred = self.model.predict(X)[0]

            if pred == 1:
                return "AL"
            elif pred == -1:
                return "SAT"
            else:
                return "BEKLE"
        except Exception as e:
            logging.error(f"Sinyal tahmini hatası: {e}")
            return "BEKLE"

    async def execute_trade(self, signal, current_price):
        """
        Gelen sinyale göre ticaret emrini gönderir ve pozisyonu yönetir.
        Risk yönetimi (stop-loss ve take-profit) burada uygulanır.
        """
        if self.position is None:
            # Henüz pozisyonda değiliz, yeni emir verebiliriz.
            try:
                if signal == "AL":
                    logging.info(f"🚀 AL sinyali alındı. Fiyat: {current_price:.2f}")
                    # Gerçek canlı ticaret emri için aşağıdaki satırın yorumunu kaldırın.
                    # await self.exchange.create_market_buy_order(self.symbol, self.amount) 
                    self.position = 'LONG'
                    self.entry_price = current_price
                    self.sl_price = current_price * (1 - self.SL_PERCENTAGE)
                    self.tp_price = current_price * (1 + self.TP_PERCENTAGE)
                    logging.info(f"🟢 LONG pozisyon açıldı. Giriş Fiyatı: {self.entry_price:.2f} | TP: {self.tp_price:.2f} | SL: {self.sl_price:.2f}")
                
                elif signal == "SAT":
                    logging.info(f"🔻 SAT sinyali alındı. Fiyat: {current_price:.2f}")
                    # Gerçek canlı ticaret emri için aşağıdaki satırın yorumunu kaldırın.
                    # await self.exchange.create_market_sell_order(self.symbol, self.amount) 
                    self.position = 'SHORT'
                    self.entry_price = current_price
                    self.sl_price = current_price * (1 + self.SL_PERCENTAGE)
                    self.tp_price = current_price * (1 - self.TP_PERCENTAGE)
                    logging.info(f"🔴 SHORT pozisyon açıldı. Giriş Fiyatı: {self.entry_price:.2f} | TP: {self.tp_price:.2f} | SL: {self.sl_price:.2f}")
                
                else:
                    logging.info("⏸️ BEKLE sinyali — işlem yapılmadı.")
            except Exception as e:
                logging.error(f"❌ Emir gönderme hatası: {e}")
                traceback.print_exc()

        else:
            # Zaten pozisyondayız, pozisyonu yönetiyoruz.
            if self.position == 'LONG':
                # Zarar Durdur kontrolü
                if current_price <= self.sl_price:
                    logging.warning(f"🛑 LONG pozisyonu SL'e ulaştı. Pozisyon kapatılıyor. Fiyat: {current_price:.2f}")
                    # Gerçek canlı emir için
                    # await self.exchange.create_market_sell_order(self.symbol, self.amount) 
                    self.position = None
                    self.entry_price = 0.0
                # Kâr Al kontrolü
                elif current_price >= self.tp_price:
                    logging.info(f"✅ LONG pozisyonu TP'ye ulaştı. Pozisyon kapatılıyor. Fiyat: {current_price:.2f}")
                    # Gerçek canlı emir için
                    # await self.exchange.create_market_sell_order(self.symbol, self.amount) 
                    self.position = None
                    self.entry_price = 0.0

            elif self.position == 'SHORT':
                # Zarar Durdur kontrolü
                if current_price >= self.sl_price:
                    logging.warning(f"🛑 SHORT pozisyonu SL'e ulaştı. Pozisyon kapatılıyor. Fiyat: {current_price:.2f}")
                    # Gerçek canlı emir için
                    # await self.exchange.create_market_buy_order(self.symbol, self.amount) 
                    self.position = None
                    self.entry_price = 0.0
                # Kâr Al kontrolü
                elif current_price <= self.tp_price:
                    logging.info(f"✅ SHORT pozisyonu TP'ye ulaştı. Pozisyon kapatılıyor. Fiyat: {current_price:.2f}")
                    # Gerçek canlı emir için
                    # await self.exchange.create_market_buy_order(self.symbol, self.amount) 
                    self.position = None
                    self.entry_price = 0.0

    async def run(self):
        """
        Botun ana döngüsünü çalıştırır. Sürekli veri çeker, sinyal üretir ve işlem yapar.
        """
        logging.info("🔥 Nova AI Elite Bot başlatılıyor...")
        
        # Model eğitimi için ilk verileri çekme
        df = await self.fetch_ohlcv()
        if df.empty:
            logging.error("Bot başlatılamadı: Veri alınamıyor.")
            return

        df = self.apply_indicators(df)
        df_labeled = self.create_labels(df)
        self.train_model(df_labeled)
        
        while True:
            try:
                # Periyodik olarak yeni verileri çekme
                latest_df = await self.fetch_ohlcv()
                latest_df = self.apply_indicators(latest_df)

                if latest_df.empty:
                    logging.warning("Yeni veri bulunamadı, bir sonraki döngü bekleniyor...")
                    await asyncio.sleep(60) # 1 dakika bekle
                    continue
                
                latest_row = latest_df.iloc[-1]
                current_price = latest_row["close"]
                
                # Sinyal tahmini
                signal = self.predict_signal(latest_row)
                logging.info(f"{self.symbol} fiyatı: {current_price:.2f} | AI Sinyal: {signal} | Pozisyon: {self.position}")

                # Ticaret emri gönderme ve pozisyon yönetimi
                await self.execute_trade(signal, current_price)

            except Exception as e:
                logging.error(f"Ana döngüde beklenmedik hata: {e}")
                traceback.print_exc()

            await asyncio.sleep(60)  # Her 1 dakikada bir çalıştır (timeframe'e göre ayarlanabilir)

    def backtest_strategy(self, df):
        """
        Geliştirilmiş stratejinin geçmiş veriler üzerinde kapsamlı bir geri testi.
        Bu fonksiyon, performansı değerlendirmek için çeşitli metrikler hesaplar.
        """
        logging.info("📈 Strateji geriye dönük testi başlatılıyor...")
        
        # Geriye dönük test için modelin eğitilmesi
        df = self.apply_indicators(df)
        df = self.create_labels(df)
        self.train_model(df)
        
        test_df = df.dropna().copy()
        
        initial_balance = 1000
        balance = initial_balance
        position_size = 0
        portfolio_value = [initial_balance]
        trades = []
        
        for i, row in test_df.iterrows():
            signal = self.predict_signal(row)
            current_price = row['close']
            
            # Sadece pozisyonda değilken AL veya SAT sinyallerine bak
            if position_size == 0:
                if signal == 'AL':
                    position_size = balance / current_price
                    entry_price = current_price
                    balance = 0
                    logging.info(f"✅ Gerçek zamanlı test: LONG pozisyon açıldı @ {current_price:.2f}")
                elif signal == 'SAT':
                    position_size = -1 * (balance / current_price)
                    entry_price = current_price
                    balance = 0
                    logging.info(f"❌ Gerçek zamanlı test: SHORT pozisyon açıldı @ {current_price:.2f}")
            # Pozisyonda iken, pozisyonu kapatma sinyali bekle
            elif position_size > 0 and signal == 'SAT':
                exit_price = current_price
                balance = position_size * exit_price
                profit = (exit_price - entry_price) / entry_price
                trades.append(profit)
                position_size = 0
                logging.info(f"💰 Gerçek zamanlı test: LONG pozisyon kapatıldı @ {exit_price:.2f} | Kâr: {profit:.2%}")
            elif position_size < 0 and signal == 'AL':
                exit_price = current_price
                profit = (entry_price - exit_price) / entry_price
                balance = -1 * (position_size * exit_price)
                trades.append(profit)
                position_size = 0
                logging.info(f"💰 Gerçek zamanlı test: SHORT pozisyon kapatıldı @ {exit_price:.2f} | Kâr: {profit:.2%}")

            # Anlık portföy değerini takip et
            current_value = balance + (position_size * current_price)
            portfolio_value.append(current_value)
                
        final_balance = balance + (position_size * test_df.iloc[-1]['close'] if position_size != 0 else 0)
        
        # Performans Metriklerini Hesapla
        total_return = (final_balance - initial_balance) / initial_balance if initial_balance > 0 else 0
        
        portfolio_series = pd.Series(portfolio_value)
        peak = portfolio_series.cummax()
        drawdown = (portfolio_series - peak) / peak
        max_drawdown = drawdown.min()
        
        # Risk-free rate (risksiz getiri) için basit bir varsayım: %0
        # Sharpe Ratio = (Strateji Getirisi - Risksiz Getiri) / Strateji Volatilitesi
        # Günlük getiri, burada mum getirisini kullanıyoruz
        daily_returns = portfolio_series.pct_change().dropna()
        if daily_returns.std() != 0:
            sharpe_ratio = daily_returns.mean() / daily_returns.std() * np.sqrt(252) # Yıllıklandırma
        else:
            sharpe_ratio = np.nan
            
        win_rate = sum(1 for p in trades if p > 0) / len(trades) if len(trades) > 0 else 0
        
        logging.info("--- Geriye Dönük Test Sonuçları ---")
        logging.info(f"Başlangıç Bakiyesi: {initial_balance:.2f} USDT")
        logging.info(f"Son Bakiye: {final_balance:.2f} USDT")
        logging.info(f"Toplam Getiri (ROI): {total_return:.2%}")
        logging.info(f"Maksimum Düşüş (Max Drawdown): {max_drawdown:.2%}")
        logging.info(f"Sharpe Oranı: {sharpe_ratio:.2f}")
        logging.info(f"Kazanma Oranı (Win Rate): {win_rate:.2%}")

        # Portföy Değeri ve Düşüş Grafiği (Portfolio Value and Drawdown Plot)
        plt.style.use('dark_background')
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10), sharex=True)

        # Portföy Değeri Grafiği
        ax1.plot(portfolio_series.index, portfolio_series, color='cyan', label='Portfolio Value')
        ax1.axhline(y=initial_balance, color='gray', linestyle='--', label='Initial Balance')
        ax1.set_title('Portfolio Value Over Time')
        ax1.set_ylabel('Portfolio Value (USDT)')
        ax1.legend()
        ax1.grid(True, linestyle=':', alpha=0.6)

        # Max Drawdown Grafiği
        ax2.fill_between(drawdown.index, drawdown, 0, color='red', alpha=0.3)
        ax2.plot(drawdown.index, drawdown, color='red', label='Drawdown')
        ax2.set_title('Portfolio Drawdown')
        ax2.set_xlabel('Time (Candles)')
        ax2.set_ylabel('Drawdown (%)')
        ax2.legend()
        ax2.grid(True, linestyle=':', alpha=0.6)

        plt.tight_layout()
        plt.show()
        # Matplotlib grafiğini kaydetmek için
        # Bu ortamda görselleştirme doğrudan gösterilemediği için
        # dosyaya kaydedilir. Gerçek bir senaryoda bu grafiği doğrudan bir web arayüzüne entegre edebilirsiniz.
        plt.savefig('backtest_performance.png')
        logging.info("Grafik başarıyla 'backtest_performance.png' olarak kaydedildi.")
        
    async def close(self):
        """
        Botun bağlantılarını kapatır.
        """
        await self.exchange.close()
        logging.info("👋 Bot kapatıldı.")

# Botu başlatmak için ana işlev
async def main():
    # --- API ANAHTARLARINI ORTAM DEĞİŞKENLERİNDEN OKUYUN ---
    # Bu yöntem, anahtarları doğrudan koda yazmaktan daha güvenlidir.
    try:
        # ".env" dosyasından anahtarları okumak için python-dotenv kütüphanesi kurulu olmalıdır.
        # "pip install python-dotenv" komutunu kullanarak kurabilirsiniz.
        # Daha sonra, "dotenv.load_dotenv()" komutunu çalıştırarak dosyayı yükleyebilirsiniz.
        # import dotenv
        # dotenv.load_dotenv()
        BINANCE_API_KEY = os.getenv("BINANCE_API_KEY")
        BINANCE_SECRET_KEY = os.getenv("BINANCE_SECRET_KEY")
        
        if not BINANCE_API_KEY or not BINANCE_SECRET_KEY:
            raise ValueError("API anahtarları ortam değişkenlerinde bulunamadı.")
            
    except Exception as e:
        logging.error(f"Ortam değişkenleri yüklenirken hata oluştu: {e}")
        return # Anahtarlar olmadan bot çalışamaz.

    # Canlı işlem modunu başlatmak için aşağıdaki parametreyi True yapın.
    # False bırakırsanız, bot hala sinyal üretir ancak gerçek işlem yapmaz.
    LIVE_TRADING_ENABLED = False 

    # Botu API anahtarları ile başlatıyoruz
    bot = NovaAIEliiteBot(api_key=BINANCE_API_KEY, secret_key=BINANCE_SECRET_KEY)
    
    if LIVE_TRADING_ENABLED:
        await bot.run()
    else:
        # Geriye dönük test (Backtesting)
        df_for_backtest = await bot.fetch_ohlcv()
        if not df_for_backtest.empty:
            bot.backtest_strategy(df_for_backtest.copy())
    
    await bot.close()

if __name__ == "__main__":
    asyncio.run(main())


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\apps\nova_quantum_bot.py
import asyncio
from modules.data_collector import DataCollector
from modules.strategy_manager import StrategyManager
from modules.meta_decision_engine import MetaDecisionEngine
from modules.execution_engine import ExecutionEngine
from modules.reinforcement_trainer import ReinforcementTrainer
from modules.news_analyzer import NewsAnalyzer
from modules.onchain_analyzer import OnChainAnalyzer
from modules.ai_predictor import AIPredictor
from modules.performance_tracker import PerformanceTracker

class NovaQuantumBot:
    def __init__(self, symbol="BTC/USDT", timeframe="1m"):
        self.symbol = symbol
        self.timeframe = timeframe
        self.data_collector = DataCollector(symbol, timeframe)
        self.strategy_manager = StrategyManager()
        self.meta_engine = MetaDecisionEngine()
        self.execution_engine = ExecutionEngine()
        self.reinforcement_trainer = ReinforcementTrainer()
        self.news_analyzer = NewsAnalyzer()
        self.onchain_analyzer = OnChainAnalyzer()
        self.ai_predictor = AIPredictor()
        self.performance_tracker = PerformanceTracker()

    async def run(self):
        while True:
            df = await self.data_collector.fetch()
            news_sentiment = await self.news_analyzer.analyze()
            onchain_score = await self.onchain_analyzer.evaluate()
            ai_signal = await self.ai_predictor.predict(df)
            strategy_signals = await self.strategy_manager.evaluate_all(df)

            decision = self.meta_engine.resolve(
                strategy_signals,
                news_sentiment,
                onchain_score,
                ai_signal
            )

            await self.execution_engine.execute(decision)
            self.performance_tracker.log(decision)
            await self.reinforcement_trainer.train(self.performance_tracker.get_metrics())
            await asyncio.sleep(1)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\apps\nova_super_bot.py
import asyncio
import pandas as pd
import pandas_ta as ta
import numpy as np
import ccxt.async_support as ccxt
from datetime import datetime, timezone

# 🔗 Entegre modüller
from kiripto_nova.apps.nova_ai_elite_bot import NovaAI
from kiripto_nova.ai.neuro_decision_engine import NeuroEngine
from kiripto_nova.execution.position_manager import PositionManager
from nova_trader import NovaTrader
from kiripto_nova.signals.news_data import fetch_sentiment
from manipulation_detector import detect_anomaly
from kiripto_nova.ai.ml_filter import apply_filters

class NovaSuperBot:
    def __init__(self, symbol="BTC/USDT", timeframe="1m", limit=200, amount=0.01):
        self.symbol = symbol
        self.timeframe = timeframe
        self.limit = limit
        self.amount = amount
        self.exchange = ccxt.binance({'enableRateLimit': True})
        self.ai = NovaAI()
        self.neuro = NeuroEngine()
        self.trader = NovaTrader()
        self.position_manager = PositionManager()

    def log(self, msg, level="INFO"):
        ts = datetime.now(timezone.utc).isoformat()
        print(f"[{ts}] | {level.upper()} | {msg}")

    async def fetch_data(self):
        ohlcv = await self.exchange.fetch_ohlcv(self.symbol, self.timeframe, limit=self.limit)
        df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
        df.ta.rsi(length=14, append=True)
        df.ta.macd(append=True)
        df.ta.ema(length=20, append=True)
        df.ta.sma(length=50, append=True)
        df.ta.mom(append=True)
        return df.dropna()

    async def run(self):
        while True:
            df = await self.fetch_data()
            latest = df.iloc[-1]
            sentiment = fetch_sentiment()
            anomaly = detect_anomaly(df)
            filtered = apply_filters(latest)

            signal_ai = self.ai.predict(latest)
            signal_neuro = self.neuro.evaluate(df)
            signal_final = self.resolve_signals(signal_ai, signal_neuro, sentiment, anomaly, filtered)

            price = latest["close"]
            self.log(f"{self.symbol} fiyatı: {price:.2f} | Sinyal: {signal_final}", "DATA")

            if self.position_manager.validate(signal_final):
                await self.trader.execute_trade(signal_final)

            await asyncio.sleep(1)  # Mikrosaniyeye yakın döngü

    def resolve_signals(self, ai, neuro, sentiment, anomaly, filtered):
        if anomaly or not filtered:
            return "BEKLE"
        if ai == neuro and sentiment == "positive":
            return ai
        if ai != neuro:
            return "BEKLE"
        return ai

    async def close(self):
        await self.exchange.close()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\apps\nova_supreme_bot.py
import asyncio
from modules.data_collector import DataCollector
from modules.strategy_manager import StrategyManager
from modules.meta_decision_engine import MetaDecisionEngine
from modules.execution_engine import ExecutionEngine
from modules.reinforcement_trainer import ReinforcementTrainer
from modules.news_analyzer import NewsAnalyzer
from modules.onchain_analyzer import OnChainAnalyzer
from modules.ai_predictor import AIPredictor
from modules.performance_tracker import PerformanceTracker
from modules.genetic_optimizer import GeneticOptimizer
from modules.dashboard_connector import DashboardConnector
from modules.dao_interface import DAOInterface

class NovaSupremeBot:
    def __init__(self, symbol="BTC/USDT", timeframe="1m", elite_mode=True):
        self.symbol = symbol
        self.timeframe = timeframe
        self.elite_mode = elite_mode

        # Modüller
        self.data_collector = DataCollector(symbol, timeframe)
        self.news_analyzer = NewsAnalyzer()
        self.onchain_analyzer = OnChainAnalyzer()
        self.ai_predictor = AIPredictor()
        self.strategy_manager = StrategyManager()
        self.meta_engine = MetaDecisionEngine()
        self.execution_engine = ExecutionEngine()
        self.reinforcement_trainer = ReinforcementTrainer()
        self.performance_tracker = PerformanceTracker()
        self.genetic_optimizer = GeneticOptimizer()
        self.dashboard = DashboardConnector()
        self.dao = DAOInterface()

    async def run(self):
        while True:
            df = await self.data_collector.fetch()
            news_sentiment = await self.news_analyzer.analyze()
            onchain_score = await self.onchain_analyzer.evaluate()
            ai_signals = await self.ai_predictor.predict_all(df)
            strategy_signals = await self.strategy_manager.evaluate_all(df)

            decision = self.meta_engine.resolve(
                strategy_signals,
                news_sentiment,
                onchain_score,
                ai_signals
            )

            if self.elite_mode:
                decision = self.execution_engine.elite_filter(decision, df)

            await self.execution_engine.execute(decision)
            self.performance_tracker.log(decision)
            self.reinforcement_trainer.train(self.performance_tracker.get_metrics())
            self.genetic_optimizer.evolve(self.strategy_manager.get_strategies())
            self.dashboard.update(self.symbol, decision, df)
            self.dao.sync(decision)

            await asyncio.sleep(1)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\apps\telegram_alert.py
# telegram_alert.py
import requests
from config import TELEGRAM_TOKEN, TELEGRAM_CHAT_ID

def send_telegram_message(message):
    url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
    payload = {
        "chat_id": TELEGRAM_CHAT_ID,
        "text": message,
        "parse_mode": "Markdown"
    }
    try:
        response = requests.post(url, json=payload)
        if response.status_code == 200:
            print("📲 Telegram mesajı gönderildi.")
        else:
            print("⚠️ Telegram mesaj hatası:", response.text)
    except Exception as e:
        print("❌ Telegram bağlantı hatası:", str(e))

def notify_trade(action, symbol, qty, price, sl, tp):
    msg = (
        f"🚨 *Yeni İşlem*
"
        f"*Aksiyon:* {action.upper()}\n"
        f"*Sembol:* {symbol}\n"
        f"*Miktar:* {qty}\n"
        f"*Fiyat:* {price}\n"
        f"*SL:* {sl}  |  *TP:* {tp}"
    )
    send_telegram_message(msg)

def notify_signal(signal_type, symbol):
    msg = f"📡 *Yeni Sinyal:* {signal_type.upper()} için {symbol}"
    send_telegram_message(msg)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\apps\telegram_bot.py
def send_signal_message(signal, title, source):
    message = f"{signal} 📢\nBaşlık: {title}\nKaynak: {source}"
    send_to_telegram(message)
import os
import requests

def send_telegram_message(message):
    bot_token = os.getenv("TELEGRAM_BOT_TOKEN")
    chat_id = os.getenv("TELEGRAM_CHAT_ID")
    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
    payload = {"chat_id": chat_id, "text": message}
    requests.post(url, data=payload)
📡 SINYAL: AL  
🧠 YORUM: Haber yatırımcı güvenini artırıyor. Sabah saatinde, güvenilir kaynakta yayınlandı. Beklenti yükseliş yönünde.




### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\backtesting\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\backtesting\backtester.py
# backtester.py
import pandas as pd
from kiripto_nova.signals.signal_engine import SignalEngine
from kiripto_nova.risk.risk_manager import calculate_position_size, calculate_stop_loss, calculate_take_profit

class Backtester:
    def __init__(self, df, balance=1000, risk=0.01, stop_pct=0.03, reward_ratio=2):
        self.df = df.copy()
        self.balance = balance
        self.initial_balance = balance
        self.risk = risk
        self.stop_pct = stop_pct
        self.reward_ratio = reward_ratio
        self.trades = []

    def run(self):
        engine = SignalEngine(self.df)
        df_with_indicators = engine.get_dataframe()

        for i in range(50, len(df_with_indicators)):
            sliced = df_with_indicators.iloc[:i]
            engine.df = sliced
            signal = engine.generate_signal()
            close = sliced.iloc[-1]['close']

            if signal == "BUY":
                size = calculate_position_size(self.balance, self.risk, self.stop_pct)
                sl = calculate_stop_loss(close, self.stop_pct, direction="long")
                tp = calculate_take_profit(close, self.reward_ratio, self.stop_pct, direction="long")
                self._simulate_trade(close, sl, tp, size, direction="long")

            elif signal == "SELL":
                size = calculate_position_size(self.balance, self.risk, self.stop_pct)
                sl = calculate_stop_loss(close, self.stop_pct, direction="short")
                tp = calculate_take_profit(close, self.reward_ratio, self.stop_pct, direction="short")
                self._simulate_trade(close, sl, tp, size, direction="short")

        return self._results()

    def _simulate_trade(self, entry, sl, tp, size, direction="long"):
        result = {
            "entry": entry,
            "sl": sl,
            "tp": tp,
            "size": size,
            "type": direction,
            "outcome": None
        }
        # Basit simülasyon: fiyata ulaşıldı mı kontrolü (gerçek backtest için candle içi detay gerekir)
        if direction == "long":
            result["outcome"] = "win" if tp > entry else "loss"
        else:
            result["outcome"] = "win" if tp < entry else "loss"

        self.trades.append(result)
        if result["outcome"] == "win":
            self.balance += size * self.stop_pct * self.reward_ratio
        else:
            self.balance -= size * self.stop_pct

    def _results(self):
        total = len(self.trades)
        wins = len([t for t in self.trades if t['outcome'] == 'win'])
        losses = total - wins
        winrate = (wins / total * 100) if total else 0
        profit = self.balance - self.initial_balance
        return {
            "Toplam İşlem": total,
            "Kazanma Oranı": f"{winrate:.2f}%",
            "Net Kâr/Zarar": round(profit, 2),
            "Son Bakiye": round(self.balance, 2)
        }


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\backtesting\testnet_trade_bot.py
import os
import math
import time
import logging
from decimal import Decimal, ROUND_DOWN

from binance.client import Client
from dotenv import load_dotenv

# --------------------------
# Yardımcılar
# --------------------------

def d(v):  # güvenli decimal
    return Decimal(str(v))

def round_step(value, step):
    if step is None:
        return value
    return (d(value) // d(step)) * d(step)

def get_filters(client, symbol):
    info = client.futures_exchange_info()
    md = next(s for s in info["symbols"] if s["symbol"] == symbol)

    tick = float(next(f["tickSize"] for f in md["filters"] if f["filterType"] == "PRICE_FILTER"))
    lotf = next((f for f in md["filters"] if f["filterType"] == "MARKET_LOT_SIZE"), None)
    if not lotf:
        lotf = next(f for f in md["filters"] if f["filterType"] == "LOT_SIZE")
    step = float(lotf["stepSize"])
    min_qty = float(lotf["minQty"])
    min_notional = float(next(f["notional"] for f in md["filters"] if f["filterType"] == "MIN_NOTIONAL"))
    return tick, step, min_qty, min_notional

def to_price_tick(price, tick):
    return float(round_step(price, tick))

def to_qty_step(qty, step, min_qty):
    q = float(round_step(qty, step))
    return q if q >= min_qty else 0.0

# --------------------------
# Ana uygulama
# --------------------------

def main():
    load_dotenv()

    KEY    = os.getenv("BINANCE_API_KEY", "")
    SECRET = os.getenv("BINANCE_API_SECRET", "")
    USE_TESTNET = os.getenv("BINANCE_USE_TESTNET", "false").lower() == "true"
    FUT_URL = os.getenv("BINANCE_FUTURES_URL", "").strip()
    HEDGE  = os.getenv("BINANCE_HEDGE_MODE", "true").lower() == "true"
    MARGIN = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED").upper()
    LEV    = int(os.getenv("BINANCE_LEVERAGE", "10"))

    SYMBOLS = [s.strip().upper() for s in os.getenv("SYMBOLS", "BTCUSDT,ETHUSDT").split(",") if s.strip()]
    DRY_RUN = os.getenv("DRY_RUN", "true").lower() == "true"

    MAX_PCT_TRADE = float(os.getenv("MAX_CAPITAL_PCT_PER_TRADE", "0.02"))
    MIN_NOTIONAL  = float(os.getenv("MIN_NOTIONAL_USDT", "10"))
    LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()

    logging.basicConfig(level=getattr(logging, LOG_LEVEL, logging.INFO), format="%(asctime)s | %(levelname)s | %(message)s")

    if not KEY or not SECRET:
        raise SystemExit("API anahtarları boş: .env dosyanı doldur.")

    # Binance Client
    c = Client(KEY, SECRET, testnet=USE_TESTNET)
    if USE_TESTNET and FUT_URL:
        c.FUTURES_URL = FUT_URL

    # bağlantı testi
    t = c.futures_time()["serverTime"]
    logging.info(f"Bağlantı OK | serverTime={t} | testnet={USE_TESTNET}")

    # Hedge mode
    try:
        c.futures_change_position_mode(dualSidePosition="true" if HEDGE else "false")
        logging.info(f"Hedge mode: {'DUAL' if HEDGE else 'ONE-WAY'}")
    except Exception as e:
        logging.warning(f"Hedge mode ayarlanamadı (devam ediyorum): {e}")

    # Her sembol için kaldıraç ve margin tipi kur
    for sym in SYMBOLS:
        try:
            c.futures_change_margin_type(symbol=sym, marginType=MARGIN)
        except Exception as e:
            # Aynı türde ise hata döner; sorun değil
            logging.debug(f"{sym} margin tipi: {e}")
        try:
            c.futures_change_leverage(symbol=sym, leverage=LEV)
        except Exception as e:
            logging.debug(f"{sym} leverage: {e}")

    # Toplam USDT bakiyesi
    bal = c.futures_account_balance()
    usdt = float(next(float(b["balance"]) for b in bal if b["asset"] == "USDT"))
    logging.info(f"USDT bakiye: {usdt}")

    # Basit bir örnek: hızlı karar kuralları (tamamen örnek)
    # - Son fiyat son 1 dakikada %0.2 üzeri artıyorsa LONG, %0.2 üzeri düşüyorsa SHORT
    # Gerçekte buraya kendi stratejini/sinyalini koyacaksın.
    for sym in SYMBOLS:
        # borsanın kurallarını al
        tick, step, min_qty, min_notional = get_filters(c, sym)

        # fiyat verisi
        klines = c.futures_klines(symbol=sym, interval=Client.KLINE_INTERVAL_1MINUTE, limit=2)
        p_old = float(klines[-2][4])  # önceki kapanış
        p_now = float(klines[-1][4])  # son kapanış
        change = (p_now - p_old) / p_old

        logging.info(f"{sym} price {p_old:.2f} -> {p_now:.2f} | change={change*100:.3f}%")

        side = None
        position_side = None
        if change >= 0.002:  # +%0.2
            side = "BUY"
            position_side = "LONG" if HEDGE else None
        elif change <= -0.002:  # -%0.2
            side = "SELL"
            position_side = "SHORT" if HEDGE else None
        else:
            logging.info(f"{sym}: değişim eşik altında, işlem yok.")
            continue

        # Risk: işleme ayıracağımız tutar
        notional = max(MIN_NOTIONAL, usdt * MAX_PCT_TRADE)
        qty_raw = notional / p_now * LEV  # kaldıraçla efektif miktar
        qty = to_qty_step(qty_raw, step, min_qty)
        if qty <= 0:
            logging.warning(f"{sym}: miktar adımına/minQty’e uymuyor (hesaplanan={qty_raw}). Atlanıyor.")
            continue

        params = dict(
            symbol=sym,
            side=side,
            type="MARKET",
            quantity=qty,
        )
        if HEDGE:
            params["positionSide"] = position_side  # LONG/SHORT

        logging.info(f"{sym} emir: {params} | DRY_RUN={DRY_RUN}")

        if DRY_RUN:
            continue

        try:
            resp = c.futures_create_order(**params)
            order_id = resp.get("orderId")
            avg_price = resp.get("avgPrice") or resp.get("price") or "?"
            logging.info(f"{sym} emir gönderildi | id={order_id} avgPrice={avg_price}")
        except Exception as e:
            logging.error(f"{sym} emir HATASI: {e}")

    logging.info("Tur tamamlandı.")

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\core\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\core\config_loader.py
import os
from dotenv import load_dotenv

load_dotenv()  # .env dosyasını yükler

BINANCE_API_KEY = os.getenv("BINANCE_API_KEY")
BINANCE_API_SECRET = os.getenv("BINANCE_API_SECRET")
BINANCE_USE_TESTNET = os.getenv("BINANCE_USE_TESTNET", "true").lower() == "true"
BINANCE_FUTURES_URL = os.getenv("BINANCE_FUTURES_URL")

print("Binance Key:", BINANCE_API_KEY[:5] + "...")
print("Testnet mi?:", BINANCE_USE_TESTNET)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\data\pipelines\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\data\pipelines\data_loader.py
# data_loader.py
import ccxt
import pandas as pd
from datetime import datetime

def load_binance_data(symbol="DOGE/USDT", timeframe="15m", limit=500):
    binance = ccxt.binance()
    ohlcv = binance.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    return df


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\data\pipelines\twitter_data.py
import tweepy

auth = tweepy.OAuth1UserHandler("API_KEY", "API_SECRET", "ACCESS_TOKEN", "ACCESS_SECRET")
api = auth.get_api()

def get_crypto_tweets(keyword="bitcoin"):
    tweets = api.search_tweets(q=keyword, lang='en', count=10)
    return [t.text for t in tweets]


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\data\raw\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\data\__init__.py
# auto-added


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\exchanges\binance\__init__.py
# auto-added


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\exchanges\binance\binance_futures_boot.py
import os
from dotenv import load_dotenv
from binance.client import Client

load_dotenv()

API_KEY = os.getenv("BINANCE_API_KEY")
API_SECRET = os.getenv("BINANCE_API_SECRET")
USE_TESTNET = os.getenv("BINANCE_USE_TESTNET", "true").lower() == "true"
FAPI_URL = os.getenv("BINANCE_FUTURES_URL")  # testnet url'ini geçeceğiz
HEDGE = os.getenv("BINANCE_HEDGE_MODE", "true").lower() == "true"
MARGIN_TYPE = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED")
LEVERAGE = int(os.getenv("BINANCE_LEVERAGE", "5"))
SYMBOLS = [s.strip() for s in os.getenv("SYMBOLS", "BTCUSDT").split(",")]

client = Client(API_KEY, API_SECRET, testnet=USE_TESTNET)
if FAPI_URL:
    client.FUTURES_URL = FAPI_URL

# Başlangıç konfigürasyonları
try:
    client.futures_change_position_mode(dualSidePosition=HEDGE)
except Exception as e:
    print("Hedge mode ayarlanamadı:", e)

for sym in SYMBOLS:
    try:
        client.futures_change_margin_type(symbol=sym, marginType=MARGIN_TYPE)
    except Exception as e:
        # Zaten aynı ise hata dönebilir; sorun değil
        pass
    try:
        client.futures_change_leverage(symbol=sym, leverage=LEVERAGE)
    except Exception as e:
        print(f"Leverage ayarlanamadı {sym}:", e)

print("Futures boot OK. Symbols:", SYMBOLS)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\exchanges\binance\binance_order_test.py
from binance.client import Client
from dotenv import load_dotenv
import os

# Ortam değişkenlerini yükle
load_dotenv()

api_key = os.getenv("BINANCE_API_KEY")
api_secret = os.getenv("BINANCE_SECRET_KEY")

# Binance client oluştur
client = Client(api_key, api_secret)

# Test amaçlı küçük bir emir oluştur (gerçek para ile)
try:
    order = client.futures_create_order(
        symbol='BTCUSDT',
        side='BUY',           # Satın al
        type='MARKET',        # Piyasa emri
        quantity=0.001        # Çok düşük miktarda test
    )
    print("✅ Emir başarıyla gönderildi:")
    print(order)

except Exception as e:
    print("❌ Hata oluştu:")
    print(e)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\exchanges\binance\client.py
import ccxt
from config.settings import BINANCE_API_KEY, BINANCE_SECRET

def get_client():
    return ccxt.binance({
        'apiKey': BINANCE_API_KEY,
        'secret': BINANCE_SECRET,
        'enableRateLimit': True,
        'options': {'defaultType': 'future'}
    })


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\exchanges\binance\data.py
from binance.client import Client
import os

API_KEY = os.getenv("BINANCE_API_KEY")
API_SECRET = os.getenv("BINANCE_API_SECRET")

client = Client(API_KEY, API_SECRET)

def get_price(symbol="BTCUSDT"):
    ticker = client.get_symbol_ticker(symbol=symbol)
    return ticker['price']
import binance.client
client.futures_create_order(
    symbol='BTCUSDT',
    side='BUY',
    type='MARKET',
    quantity=0.01,
    leverage=10
)
from analysis_engine.indicators import prepare_indicators
from data_fetcher.binance_data import get_historical_data  # tarihsel fiyatları çeken fonksiyon

df = get_historical_data("BTCUSDT", interval="1h", limit=100)
indicators = prepare_indicators(df)

print(indicators)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\exchanges\__init__.py
# auto-added


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\execution\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\execution\orchestrator_stream.py
# orchestrator_stream.py
# Yüksek frekans Binance Futures veri toplayıcı + modüler analiz orkestratörü (emir YOK)

import os, sys, json, asyncio, time, importlib, traceback
from collections import deque, defaultdict
from dataclasses import dataclass, field
from typing import Callable, Dict, List, Optional, Any, Tuple

import aiohttp
import numpy as np
from dotenv import load_dotenv

# ----------------------- Config -----------------------

load_dotenv()

USE_TESTNET = os.getenv("BINANCE_USE_TESTNET", "true").strip().lower() == "true"
WS_MAIN = os.getenv("WS_MAIN", "wss://fstream.binance.com/stream").strip()
WS_TEST = os.getenv("WS_TEST", "wss://stream.binancefuture.com/stream").strip()
WS_BASE = WS_TEST if USE_TESTNET else WS_MAIN

SYMBOLS = [s.strip().upper() for s in os.getenv("SYMBOLS", "BTCUSDT").split(",") if s.strip()]
STREAMS = []
for s in SYMBOLS:
    STREAMS += [f"{s.lower()}@aggTrade", f"{s.lower()}@bookTicker"]

MICRO_BATCH_MS = int(os.getenv("MICRO_BATCH_MS", "5"))     # mikro-batch penceresi (ms)
SNAPSHOT_SEC   = int(os.getenv("SNAPSHOT_SEC", "2"))       # özet/snapshot aralığı (s)
BUFF_LEN       = int(os.getenv("BUFF_LEN", "5000"))        # hafızada tutulan son olay sayısı
PRINT_HOOK_ERR = True

# ----------------------- Online indicators -----------------------

class OnlineEMA:
    def __init__(self, period: int):
        self.alpha = 2.0 / (period + 1.0)
        self.value = None
    def update(self, x: float) -> float:
        if self.value is None:
            self.value = float(x)
        else:
            self.value = self.alpha * float(x) + (1 - self.alpha) * self.value
        return self.value

class OnlineRSI:
    # Wilder RSI (ortalama kazanç/kayıp EMA ile)
    def __init__(self, period: int = 14):
        self.period = period
        self.avg_gain = None
        self.avg_loss = None
        self.prev = None
        self.ready = False
        self.count = 0
    def update(self, price: float) -> Optional[float]:
        p = float(price)
        if self.prev is None:
            self.prev = p
            return None
        change = p - self.prev
        gain = max(change, 0.0)
        loss = max(-change, 0.0)
        self.prev = p

        if self.avg_gain is None:
            self.avg_gain = gain
            self.avg_loss = loss
            self.count = 1
            return None

        # Wilder smoothing
        self.avg_gain = (self.avg_gain * (self.period - 1) + gain) / self.period
        self.avg_loss = (self.avg_loss * (self.period - 1) + loss) / self.period

        self.count += 1
        if not self.ready and self.count >= self.period:
            self.ready = True

        if self.avg_loss == 0:
            return 100.0 if self.avg_gain > 0 else 50.0

        rs = self.avg_gain / self.avg_loss
        rsi = 100 - (100 / (1 + rs))
        return float(rsi) if self.ready else None

class OnlineVol:
    # Basit kayan vol: son N kapanış değişimlerinin std tahmini
    def __init__(self, window: int = 60):
        self.window = window
        self.buf = deque(maxlen=window)
    def update(self, price: float) -> Optional[float]:
        p = float(price)
        if len(self.buf) > 0:
            ret = np.log(p) - np.log(self.buf[-1])
        else:
            ret = 0.0
        self.buf.append(p)
        if len(self.buf) >= 3:
            rets = np.diff(np.log(np.array(self.buf)))
            return float(np.std(rets))
        return None

# ----------------------- Data model -----------------------

@dataclass
class Tick:
    symbol: str
    kind: str            # 'trade' or 'book'
    server_ts: int       # Binance ms
    local_ns: int        # local receive time, ns
    price: float
    qty: float = 0.0
    bid: float = 0.0
    ask: float = 0.0

@dataclass
class SymbolState:
    trades: deque = field(default_factory=lambda: deque(maxlen=BUFF_LEN))
    books:  deque = field(default_factory=lambda: deque(maxlen=BUFF_LEN))
    ema_fast: OnlineEMA = field(default_factory=lambda: OnlineEMA(20))
    ema_slow: OnlineEMA = field(default_factory=lambda: OnlineEMA(50))
    rsi14: OnlineRSI = field(default_factory=lambda: OnlineRSI(14))
    vol60: OnlineVol = field(default_factory=lambda: OnlineVol(60))
    last_price: float = 0.0
    last_bid: float = 0.0
    last_ask: float = 0.0
    last_features: Dict[str, float] = field(default_factory=dict)

# ----------------------- Plugin loader -----------------------

class PluginBus:
    def __init__(self):
        self.hooks = {
            "on_tick": [],
            "on_microbatch": [],
            "on_snapshot": []
        }

    def load_project_plugins(self):
        # Çalışma dizinindeki .py dosyalarını tarar (orchestrator hariç)
        for fname in os.listdir("."):
            if not fname.endswith(".py"):
                continue
            modname = fname[:-3]
            if modname in ("orchestrator_stream",):
                continue
            try:
                mod = importlib.import_module(modname)
                if hasattr(mod, "register"):
                    reg = mod.register()
                    for k in self.hooks:
                        fn = reg.get(k)
                        if callable(fn):
                            self.hooks[k].append(fn)
                    print(f"🔌 Plugin yüklendi: {modname}")
            except Exception as e:
                print(f"⚠️ Plugin yüklenemedi: {modname}: {e}")

    async def emit(self, hook: str, *args, **kwargs):
        for fn in self.hooks.get(hook, []):
            try:
                if asyncio.iscoroutinefunction(fn):
                    await fn(*args, **kwargs)
                else:
                    fn(*args, **kwargs)
            except Exception as e:
                if PRINT_HOOK_ERR:
                    print(f"⚠️ Hook hata ({hook}): {fn.__name__}: {e}")

# ----------------------- Orchestrator -----------------------

class Orchestrator:
    def __init__(self):
        self.states: Dict[str, SymbolState] = {s: SymbolState() for s in SYMBOLS}
        self.bus = PluginBus()
        self.bus.load_project_plugins()
        self._mbuf: Dict[str, List[Tick]] = defaultdict(list)

    def _update_features(self, sym: str, px: float):
        st = self.states[sym]
        st.last_price = px
        f = {}
        f["ema_fast"] = st.ema_fast.update(px)
        f["ema_slow"] = st.ema_slow.update(px)
        f["rsi14"] = st.rsi14.update(px)
        f["vol60"] = st.vol60.update(px)
        st.last_features = {k: v for k, v in f.items() if v is not None}

    def _ingest_trade(self, sym: str, data: dict):
        px = float(data["p"]); q = float(data["q"])
        t = Tick(
            symbol=sym, kind="trade",
            server_ts=int(data.get("E") or data.get("T") or 0),
            local_ns=time.perf_counter_ns(),
            price=px, qty=q
        )
        self.states[sym].trades.append(t)
        self._update_features(sym, px)
        self._mbuf[sym].append(t)

    def _ingest_book(self, sym: str, data: dict):
        bid = float(data["b"]); ask = float(data["a"])
        mid = (bid + ask) / 2.0
        t = Tick(
            symbol=sym, kind="book",
            server_ts=int(data.get("E") or 0),
            local_ns=time.perf_counter_ns(),
            price=mid, bid=bid, ask=ask
        )
        st = self.states[sym]
        st.books.append(t)
        st.last_bid, st.last_ask = bid, ask
        self._update_features(sym, mid)
        self._mbuf[sym].append(t)

    async def _microbatch_loop(self):
        # Belirli aralıklarla biriken mikro-tikleri işleyip modüllere iletir
        while True:
            await asyncio.sleep(MICRO_BATCH_MS / 1000.0)
            now_ns = time.perf_counter_ns()
            for sym, buf in list(self._mbuf.items()):
                if not buf:
                    continue
                batch = buf[:]
                self._mbuf[sym].clear()
                # Hook: on_microbatch(symbol, batch, state, features)
                await self.bus.emit("on_microbatch", sym, batch, self.states[sym], dict(self.states[sym].last_features))

    async def _snapshot_loop(self):
        while True:
            await asyncio.sleep(SNAPSHOT_SEC)
            # Periodik özet: modüllere son durum ver
            for sym, st in self.states.items():
                snap = {
                    "price": st.last_price,
                    "bid": st.last_bid,
                    "ask": st.last_ask,
                    "features": dict(st.last_features)
                }
                await self.bus.emit("on_snapshot", sym, snap, st)

    async def _ws_loop(self):
        # Combined streams
        streams = "/".join(STREAMS)
        url = f"{WS_BASE}?streams={streams}"
        print(f"🌐 WS bağlanıyor: {url}")
        # Otomatik reconnect
        while True:
            try:
                timeout = aiohttp.ClientTimeout(total=None, sock_read=120)
                async with aiohttp.ClientSession(timeout=timeout) as sess:
                    async with sess.ws_connect(url, heartbeat=30) as ws:
                        print("✅ WS bağlı.")
                        async for msg in ws:
                            if msg.type == aiohttp.WSMsgType.TEXT:
                                try:
                                    payload = json.loads(msg.data)
                                    stream = payload.get("stream", "")
                                    data = payload.get("data", {})
                                    if not stream or not data:
                                        continue
                                    # stream: "btcusdt@aggTrade" / "btcusdt@bookTicker"
                                    sname, skind = stream.split("@", 1)
                                    sym = sname.upper()
                                    if skind == "aggTrade":
                                        self._ingest_trade(sym, data)
                                        await self.bus.emit("on_tick", sym, "trade", data)
                                    elif skind == "bookTicker":
                                        self._ingest_book(sym, data)
                                        await self.bus.emit("on_tick", sym, "book", data)
                                except Exception as e:
                                    if PRINT_HOOK_ERR:
                                        print("⚠️ WS parse hata:", e)
                            elif msg.type == aiohttp.WSMsgType.ERROR:
                                print("⚠️ WS hata:", msg)
                                break
            except Exception as e:
                print("⚠️ WS bağlantı hatası, yeniden dene:", e)
                await asyncio.sleep(1.0)

    async def run(self):
        tasks = [
            asyncio.create_task(self._ws_loop()),
            asyncio.create_task(self._microbatch_loop()),
            asyncio.create_task(self._snapshot_loop())
        ]
        await asyncio.gather(*tasks)

# ----------------------- Basit dahili plugin (örnek) -----------------------

def register():
    # Bu dosya da plugin gibi basit bir metrik yazsın (örnek)
    def on_snapshot(symbol: str, snap: dict, state: SymbolState):
        f = snap["features"]
        ema_ok = ("ema_fast" in f and "ema_slow" in f)
        if ema_ok:
            trend = "UP" if f["ema_fast"] > f["ema_slow"] else "DOWN"
        else:
            trend = "NA"
        print(f"📊 {symbol} mid={snap['price']:.4f} trend={trend} rsi={f.get('rsi14')} vol={f.get('vol60')}")

    return {
        "on_snapshot": on_snapshot
    }

# ----------------------- Main -----------------------

async def main():
    print(f"Env: {'TESTNET' if USE_TESTNET else 'MAINNET'}  Symbols: {', '.join(SYMBOLS)}")
    orch = Orchestrator()
    await orch.run()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("🛑 Durduruldu")

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\execution\position_manager.py
# position_manager.py
from __future__ import annotations
from decimal import Decimal
from typing import Any, Dict, Optional
import time
import uuid
import logging

from ex_filters import SymbolFilters  # önceki yardımcı modül
# Not: binance client'ını dışarıdan veriyoruz (dependency injection)

log = logging.getLogger("position_manager")

class PositionManager:
    def __init__(self, client, risk_mgr, filters: SymbolFilters, max_retries: int = 3):
        self.client = client
        self.risk = risk_mgr
        self.filters = filters
        self.max_retries = max_retries

    # ————— PUBLIC API ————— #

    def place_limit(self, symbol: str, side: str, price: float, qty: float,
                    tif: str = "GTC", client_order_id: Optional[str] = None) -> Dict[str, Any]:
        """Limit emri: fiyat/lot yuvarlama + minNotional kontrol + risk onayı + retry."""
        self.filters.refresh_if_stale(self.client)
        clean = self.filters.conform_order(symbol, side, "LIMIT", price, qty)

        self._risk_guard(symbol, side, clean["price"], clean["quantity"])
        return self._submit_with_retry({
            "symbol": symbol,
            "side": side,
            "type": "LIMIT",
            "timeInForce": tif,
            "quantity": clean["quantity"],
            "price": f'{clean["price"]:.10f}',
            "newClientOrderId": client_order_id or self._cid("LIM")
        })

    def place_market(self, symbol: str, side: str, qty: float,
                     last_price: Optional[float] = None,
                     client_order_id: Optional[str] = None) -> Dict[str, Any]:
        """Market emri: lot yuvarlama + minNotional (last_price ile) + risk onayı + retry."""
        self.filters.refresh_if_stale(self.client)
        clean = self.filters.conform_order(symbol, side, "MARKET", None, qty, last_price=last_price)

        # Market’te fiyat yok, riskte last_price kullan
        use_price = float(last_price or self._get_last_price(symbol))
        self._risk_guard(symbol, side, use_price, clean["quantity"])

        # Not: SPOT için base quantity kullanıyoruz. (quoteOrderQty kullanacaksan ayrıca ekle)
        return self._submit_with_retry({
            "symbol": symbol,
            "side": side,
            "type": "MARKET",
            "quantity": clean["quantity"],
            "newClientOrderId": client_order_id or self._cid("MKT")
        })

    def cancel(self, symbol: str, order_id: Optional[int] = None,
               client_order_id: Optional[str] = None):
        return self.client.cancel_order(symbol=symbol, orderId=order_id,
                                        origClientOrderId=client_order_id)

    def watch_until_filled(self, symbol: str, order_id: int, timeout_s: int = 30,
                           poll_ms: int = 500) -> Dict[str, Any]:
        """Basit watcher: kısmi/filled durumunu takip eder."""
        start = time.time()
        while True:
            o = self.client.get_order(symbol=symbol, orderId=order_id)
            status = o.get("status")
            if status in ("FILLED", "CANCELED", "REJECTED", "EXPIRED"):
                return o
            if time.time() - start > timeout_s:
                return o  # zaman aşımında mevcut durumu döndür
            time.sleep(poll_ms / 1000)

    # ————— INTERNALS ————— #

    def _risk_guard(self, symbol: str, side: str, price: float, qty: float):
        """Risk yönetişimi: tek noktadan geçsin (pozisyon limitleri, max % sermaye, PnL stop, vb.)."""
        self.risk.assert_order_allowed(symbol=symbol, side=side, price=price, qty=qty)

    def _get_last_price(self, symbol: str) -> float:
        return float(self.client.get_symbol_ticker(symbol=symbol)["price"])

    def _cid(self, prefix: str) -> str:
        return f"{prefix}-{int(time.time()*1000)}-{uuid.uuid4().hex[:6]}"

    def _submit_with_retry(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """429/rate limit ve geçici ağ hataları için basit retry + backoff."""
        delay = 0.3
        for attempt in range(1, self.max_retries + 1):
            try:
                # create_order param isimleri Binance Python SDK’n ile uyumlu olmalı
                resp = self.client.create_order(**params)
                log.info("order_submitted ok %s", {k: params[k] for k in ("symbol", "side", "type")})
                return resp
            except Exception as e:
                msg = str(e)
                log.warning("submit attempt %s failed: %s", attempt, msg)
                if "429" in msg or "Too many requests" in msg or "recvWindow" in msg:
                    time.sleep(delay)
                    delay *= 2
                    continue
                # filtre/risk/validation gibi kesin hatalarda retry etme
                raise
        # buraya normalde düşmez
        raise RuntimeError("order submission failed after retries")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\execution\scheduler_pro.py
# scheduler_pro.py (1 saniyelik yüksek frekanslı stratejik döngü)
import time
from datetime import datetime
from kiripto_nova.data.pipelines.data_loader import load_binance_data
from multi_strategy import MultiStrategyEngine
from trade_executor import execute_trade
from kiripto_nova.risk.risk_manager import calculate_position_size, calculate_stop_loss, calculate_take_profit
from kiripto_nova.apps.telegram_alert import notify_signal, notify_trade
from logger import log_trade, log_error

# Kullanıcı ayarları
SYMBOL = "DOGE/USDT"
TIMEFRAME = "1m"
BALANCE = 1000
RISK = 0.01
STOP_LOSS_PCT = 0.01  # daha dar SL (1%)
REWARD_RATIO = 2
FREQ_SECONDS = 1  # döngü sıklığı (her 1 saniyede kontrol)

LAST_SIGNAL = None


def run_cycle():
    global LAST_SIGNAL
    try:
        now = datetime.now().strftime('%H:%M:%S')
        print(f"⏱️ [{now}] Tarama başlıyor...")

        df = load_binance_data(SYMBOL, TIMEFRAME, limit=200)
        engine = MultiStrategyEngine(df)
        signal = engine.evaluate()

        # Aynı sinyali tekrar etme
        if signal == LAST_SIGNAL:
            print("🔁 Sinyal tekrarı, işlem yok.")
            return

        notify_signal(signal, SYMBOL)
        LAST_SIGNAL = signal

        if signal in ["BUY", "SELL"]:
            direction = "long" if signal == "BUY" else "short"
            entry = df['close'].iloc[-1]
            qty = calculate_position_size(BALANCE, RISK, STOP_LOSS_PCT)
            sl = calculate_stop_loss(entry, STOP_LOSS_PCT, direction)
            tp = calculate_take_profit(entry, REWARD_RATIO, STOP_LOSS_PCT, direction)

            result = execute_trade(SYMBOL, side="buy" if direction == "long" else "sell", amount=qty)
            log_trade(signal, SYMBOL, qty, entry, sl, tp)
            notify_trade(signal, SYMBOL, qty, entry, sl, tp)
        else:
            print("🔍 Sinyal yok veya nötr.")

    except Exception as e:
        log_error(e)


if __name__ == "__main__":
    while True:
        run_cycle()
        time.sleep(FREQ_SECONDS)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\indicators\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\network\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\risk\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\risk\risk_engine.py
def calculate_risk(current_price, max_risk_pct=2, take_profit_pct=5, stop_loss_pct=3):
    quantity = 0.01  # örnek sabit hacim
    stop_loss = current_price * (1 - stop_loss_pct / 100)
    take_profit = current_price * (1 + take_profit_pct / 100)

    return {
        "stop_loss": round(stop_loss, 2),
        "take_profit": round(take_profit, 2),
        "quantity": quantity
    }


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\risk\risk_grid_intelligence.py
def analyze_risk_grid(contract_metadata):
    risks = []
    if "oracle" in contract_metadata and not contract_metadata['oracle'].get('redundancy'):
        risks.append("🧨 Zayıf Oracle bağımlılığı")

    if "admin_keys" in contract_metadata and contract_metadata['admin_keys'] < 3:
        risks.append("🗝️ Yetersiz admin anahtar sayısı")

    if "emergency_switch" not in contract_metadata:
        risks.append("🚫 Acil durum refleksi eksik")

    return risks if risks else ["✅ Kritik savunma refleksleri aktif."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\risk\risk_guard.py
# risk_guard.py
# Günlük max drawdown kontrolü. Limit aşılırsa:
#  - Tüm bekleyen emirleri iptal eder + tüm pozisyonları kapatır (panic flatten)
#  - Trading'i belirli süre kilitler (cooldown).
#
# Çalışma modları:
#   python risk_guard.py --check     -> sadece durum yazdır
#   python risk_guard.py --enforce   -> kontrol et, aşım varsa FLATTEN + kilit
#   python risk_guard.py --unlock    -> kilidi kaldır

from __future__ import annotations
import os, json, time, argparse
from decimal import Decimal
from datetime import datetime, timedelta
try:
    from zoneinfo import ZoneInfo
except Exception:
    ZoneInfo = None

from dotenv import load_dotenv

# Bot içindeki hazır client + yardımcıları kullanıyoruz
from bot import client, tg, retry
# Panic flatten’i (daha önce verdiğim) kullanıyoruz
try:
    from panic_flatten import flatten
except Exception:
    flatten = None

STATE_DIR = "state"
LOCK_FILE = os.path.join(STATE_DIR, "drawdown_lock.json")

def _bool(v: str, default=False) -> bool:
    return (v or str(default)).strip().lower() in ("1","true","yes","on")

def _dec(x) -> Decimal:
    try: return Decimal(str(x))
    except: return Decimal(0)

def ensure_state_dir():
    os.makedirs(STATE_DIR, exist_ok=True)

def now_tz():
    tzname = os.getenv("TIMEZONE", "Europe/Zurich")
    if ZoneInfo:
        return datetime.now(ZoneInfo(tzname))
    return datetime.now()

def today_range_ms():
    t = now_tz()
    start = t.replace(hour=0, minute=0, second=0, microsecond=0)
    end = start + timedelta(days=1)
    return int(start.timestamp()*1000), int(end.timestamp()*1000), start.strftime("%Y-%m-%d")

def wallet_and_available():
    acct = retry(client.futures_account, desc="futures_account")
    wallet = _dec(acct.get("totalWalletBalance", "0"))
    # available
    avail = Decimal(0)
    try:
        bals = retry(client.futures_account_balance, desc="futures_account_balance")
        usdt = next((b for b in bals if b.get("asset")=="USDT"), None)
        if usdt: avail = _dec(usdt.get("availableBalance","0"))
    except: pass
    return wallet, avail

def income_sum_today():
    start, end, _ = today_range_ms()
    cursor = start
    s = Decimal(0)
    while True:
        page = retry(client.futures_income_history, startTime=cursor, endTime=end, limit=1000, desc="income_history")
        if not page: break
        for r in page:
            s += _dec(r.get("income","0"))
        if len(page) < 1000: break
        cursor = max(int(r["time"]) for r in page) + 1
        time.sleep(0.05)
    return s

def lock_for_minutes(mins: int, reason: str):
    ensure_state_dir()
    until = int((now_tz() + timedelta(minutes=mins)).timestamp())
    with open(LOCK_FILE, "w", encoding="utf-8") as f:
        json.dump({"lock_until": until, "reason": reason}, f)
    return until

def is_locked():
    try:
        with open(LOCK_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        return int(data.get("lock_until", 0)) > int(now_tz().timestamp()), data
    except:
        return False, {}

def unlock():
    try:
        os.remove(LOCK_FILE)
        return True
    except:
        return False

def trading_allowed() -> bool:
    locked, _ = is_locked()
    return not locked

def enforce():
    # parametreler
    dd_pct = float(os.getenv("MAX_DAILY_DRAWDOWN", "0.03") or 0.03)
    cooldown = int(os.getenv("GUARD_COOLDOWN_MIN", "120") or 120)

    # cüzdan & income
    wallet, avail = wallet_and_available()
    inc = income_sum_today()  # net realized (funding/fee dahil)

    limit_usdt = Decimal(wallet) * Decimal(dd_pct)
    breached = inc <= -limit_usdt

    # Durum raporu
    msg = (
        f"🛡️ Guard check | Wallet:{wallet:.2f} Avail:{avail:.2f} | "
        f"Realized(today):{inc:+.2f} | Limit:{-limit_usdt:.2f}"
    )
    print(msg)

    if not breached:
        tg(f"{msg} → ✅ Limit aşılmadı.")
        return

    # Kilitli mi?
    locked, data = is_locked()
    if locked:
        until_ts = data.get("lock_until")
        eta = datetime.fromtimestamp(until_ts).strftime("%H:%M")
        tg(f"{msg} → ❗Aşım var ama zaten kilitli (unlock @ {eta}).")
        return

    # AŞIM → Flatten + kilit
    tg(f"{msg} → 🚨 AŞIM! Tüm pozisyonlar kapatılıyor; bekleyen emirler iptal.")
    if flatten:
        try:
            flatten()  # hepsini kapat
        except Exception as e:
            tg(f"⚠️ Flatten sırasında uyarı: {e}")

    until_ts = lock_for_minutes(cooldown, reason="daily_drawdown")
    eta = datetime.fromtimestamp(until_ts).strftime("%H:%M")
    tg(f"⏸️ Trading {cooldown} dk kilitlendi. (unlock @ {eta})")

if __name__ == "__main__":
    load_dotenv()
    ap = argparse.ArgumentParser()
    ap.add_argument("--check", action="store_true", help="Sadece durumu yazdır")
    ap.add_argument("--enforce", action="store_true", help="Kontrol et, aşılmışsa FLATTEN + kilit")
    ap.add_argument("--unlock", action="store_true", help="Kilit dosyasını sil")
    args = ap.parse_args()

    if args.unlock:
        ok = unlock()
        print("🔓 Unlock:", "OK" if ok else "yoktu")
    elif args.check:
        w, a = wallet_and_available()
        inc = income_sum_today()
        locked, data = is_locked()
        print(f"Wallet:{w:.2f} Avail:{a:.2f} | Realized(today):{inc:+.2f}")
        print("Locked:", locked, data)
    else:
        # varsayılan enforce gibi çalışsın istersen:
        if args.enforce or True:
            enforce()
# --- Windows konsolda UTF-8 yazdırma düzeltmesi ---
import sys, os
if os.name == "nt":
    try:
        sys.stdout.reconfigure(encoding="utf-8", errors="replace")
        sys.stderr.reconfigure(encoding="utf-8", errors="replace")
    except Exception:
        pass
# ---------------------------------------------------


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\risk\risk_manager.py
# risk_manager.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, Any, Optional
import math
import time

# --- Basit portföy arayüzü (sen kendi implementasyonunu geçebilirsin) ---
class Portfolio:
    def get_equity_usdt(self) -> float: ...
    def get_open_exposure(self, symbol: str) -> float: ...
    def get_open_positions_count(self) -> int: ...
    def get_symbol_price(self, symbol: str) -> float: ...

# --- Konfig ve durum ---
@dataclass
class RiskConfig:
    max_capital_pct_per_trade: float = 0.02          # işlem başına sermaye %
    max_daily_loss_pct: float = 0.04                 # günlük max düşüş %
    max_open_positions: int = 8                      # aynı anda açık pozisyon limiti
    max_symbol_exposure_pct: float = 0.25            # sembol başı toplam maruziyet %
    min_notional_usdt: float = 10.0                  # borsa MIN_NOTIONAL ile uyumlu tut
    slippage_buffer_pct: float = 0.001               # sizing sırasında güvenlik tamponu
    hard_qty_floor: float = 1e-8                     # yuvarlanınca 0 olmasın diye taban

class RiskViolation(Exception): pass

class RiskManager:
    def __init__(self, portfolio: Portfolio, cfg: Optional[RiskConfig] = None):
        self.pf = portfolio
        self.cfg = cfg or RiskConfig()
        # günlük PnL takibi için çok basit sayaç (daha iyisi: gerçek PnL defteri)
        self._day = self._day_key()
        self._equity_start = self.pf.get_equity_usdt()
        self._realized_pnl = 0.0

    # ---------- Public API ----------
    def suggest_qty(self, symbol: str, price: float, max_capital_pct: Optional[float],
                    side: str, equity: Optional[float] = None) -> float:
        """
        Harcanacak USDT = equity * min(config.max_capital_pct_per_trade, max_capital_pct)
        qty = usdt / price, slippage buffer ile aşağı yönlü ayarlanır.
        """
        eq = float(equity if equity is not None else self.pf.get_equity_usdt())
        cap_pct = min(
            self.cfg.max_capital_pct_per_trade,
            float(max_capital_pct if max_capital_pct is not None else self.cfg.max_capital_pct_per_trade)
        )
        spend_usdt = max(eq * cap_pct, 0.0)
        spend_usdt *= (1.0 - self.cfg.slippage_buffer_pct)

        # min notional güvenliği
        if spend_usdt < self.cfg.min_notional_usdt:
            # yine de min notional kadar deneyelim, equity yetmiyorsa 0 döner
            spend_usdt = min(self.cfg.min_notional_usdt, eq * cap_pct)

        qty = spend_usdt / max(price, 1e-12)
        qty = max(qty, self.cfg.hard_qty_floor)
        return float(qty)

    def assert_order_allowed(self, symbol: str, side: str, price: float, qty: float):
        """
        Emirden önce tüm risk kurallarını doğrular. İhlalde RiskViolation fırlatır.
        """
        self._roll_daily_if_needed()

        eq = self.pf.get_equity_usdt()
        notional = price * qty

        # 1) İşlem başı sermaye yüzdesi
        max_per_trade_usdt = eq * self.cfg.max_capital_pct_per_trade
        if notional > max_per_trade_usdt * 1.01:  # hafif tolerans
            raise RiskViolation(f"Order notional {notional:.2f} > per-trade cap {max_per_trade_usdt:.2f}")

        # 2) Günlük zarar limiti
        max_daily_loss_usdt = self._equity_start * self.cfg.max_daily_loss_pct
        if self._realized_pnl <= -max_daily_loss_usdt:
            raise RiskViolation(f"Daily loss limit reached: {self._realized_pnl:.2f} USDT")

        # 3) Açık pozisyon sayısı
        if self.pf.get_open_positions_count() >= self.cfg.max_open_positions:
            raise RiskViolation("Too many open positions")

        # 4) Sembol başı maruziyet limiti
        symbol_exposure = self.pf.get_open_exposure(symbol) + notional
        if symbol_exposure > eq * self.cfg.max_symbol_exposure_pct:
            raise RiskViolation(f"Symbol exposure {symbol_exposure:.2f} exceeds cap")

        # 5) Borsa min notional eşiği (ek güvenlik)
        if notional < self.cfg.min_notional_usdt:
            raise RiskViolation(f"Notional {notional:.2f} < min_notional {self.cfg.min_notional_usdt:.2f}")

        # (opsiyonel) 6) Trend filtresi / saat filtresi / haber filtresi gibi ek kontrolleri buraya ekleyebilirsin.

    # ---------- Gün sonu & PnL muhasebesi ----------
    def on_fill(self, symbol: str, side: str, fill_price: float, qty: float,
                commission_usdt: float = 0.0, realized_pnl_usdt: float = 0.0):
        """
        Pozisyon kapanışlarında veya kısmi kapanışlarda çağır.
        realized_pnl_usdt borsadan/hesaptan gelen net PnL olmalı (fee dahil).
        """
        self._roll_daily_if_needed()
        self._realized_pnl += float(realized_pnl_usdt) - float(commission_usdt)

    # ---------- Helpers ----------
    def _day_key(self) -> str:
        return time.strftime("%Y-%m-%d", time.gmtime())  # UTC gün

    def _roll_daily_if_needed(self):
        today = self._day_key()
        if today != self._day:
            # yeni güne geçtik: başlangıç equity'yi yenile, PnL sayaçlarını sıfırla
            self._day = today
            self._equity_start = self.pf.get_equity_usdt()
            self._realized_pnl = 0.0


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\get_news.py
import os
import requests
from dotenv import load_dotenv
from datetime import datetime, timedelta
from textblob import TextBlob
import csv

load_dotenv()
GNEWS_API_KEY = os.getenv("GNEWS_API_KEY")

# 💬 DUYGU ANALİZİ FONKSİYONU
def analyze_sentiment(text):
    blob = TextBlob(text)
    polarity = blob.sentiment.polarity
    if polarity > 0.2:
        return "positive"
    elif polarity < -0.2:
        return "negative"
    else:
        return "neutral"

# ⏱ YENİ HABER Mİ KONTROLÜ
def is_recent(published_at):
    try:
        pub_date = datetime.strptime(published_at, "%Y-%m-%dT%H:%M:%SZ")
        return datetime.utcnow() - pub_date < timedelta(hours=12)
    except:
        return False

# 📰 HABERLERİ ÇEKME FONKSİYONU
def get_crypto_news():
    url = "https://gnews.io/api/v4/search"
    params = {
        "q": "crypto OR bitcoin OR ethereum",
        "lang": "en",
        "max": 10,
        "apikey": GNEWS_API_KEY
    }

    response = requests.get(url, params=params)
    if response.status_code != 200:
        print(f"⛔ GNews erişim hatası: {response.status_code}")
        return []

    data = response.json()
    articles = []

    for article in data.get("articles", []):
        title = article.get("title", "No Title")
        description = article.get("description", "")
        published_at = article.get("publishedAt", "")
        source = article.get("source", {}).get("name", "Unknown")
        sentiment = analyze_sentiment(description)
        recent = is_recent(published_at)

        articles.append({
            "title": title,
            "description": description,
            "publishedAt": published_at,
            "source": source,
            "sentiment": sentiment,
            "is_recent": recent
        })

    return articles

# 📁 CSV’YE KAYDETME FONKSİYONU
def export_to_csv(articles, filename="crypto_news.csv"):
    if not articles:
        print("📭 Kayıt edilecek haber yok.")
        return
    keys = articles[0].keys()
    with open(filename, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=keys)
        writer.writeheader()
        writer.writerows(articles)
    print(f"📄 Haberler {filename} dosyasına yazıldı.")

# 🎯 ANA AKIŞ
if __name__ == "__main__":
    news_data = get_crypto_news()
    export_to_csv(news_data)
for article in data.get("articles", []):
    # ... önceki alanlar ...
    sentiment = analyze_sentiment(description)
    recent = is_recent(published_at)
    score = signal_score(sentiment, recent)

    articles.append({
        "title": title,
        "description": description,
        "publishedAt": published_at,
        "source": source,
        "sentiment": sentiment,
        "is_recent": recent,
        "signal_score": score
    })
# DUYGU ANALİZİ FONKSİYONU
def analyze_sentiment(text):
    ...

# HABER YENİ Mİ? FİLTRESİ
def is_recent(published_at):
    ...

# 🔥 SİNYAL SKORU FONKSİYONU — Buraya ekle!
def signal_score(sentiment, is_recent):
    score = 0
    if sentiment == "positive":
        score += 2
    elif sentiment == "negative":
        score -= 2
    if is_recent:
        score += 1
    return score



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\news_data.py
from newsapi import NewsApiClient

newsapi = NewsApiClient(api_key='YOUR_NEWS_API_KEY')

def get_crypto_news():
    articles = newsapi.get_everything(q='bitcoin OR ethereum', language='en', sort_by='publishedAt')
    return [a['title'] for a in articles['articles'][:5]]
from transformers import pipeline

classifier = pipeline("sentiment-analysis")

def analyze_sentiment(news_text):
    result = classifier(news_text[:512])
    return result[0]['label'], result[0]['score']


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\sentiment_matrix_orchestrator.py
def build_sentiment_matrix(tasks, feelings):
    matrix = []
    for task in tasks:
        emotion = feelings.get(task["id"], "🔍 Belirsiz His")
        entry = f"🧭 Görev: {task['mission']} | 🎭 Duygu: {emotion}"
        matrix.append(entry)
    return matrix



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_engine.py
import pandas as pd
import pandas_ta as ta

class SignalEngine:
    def __init__(self, data: pd.DataFrame):
        self.df = data.copy()

    def calculate_indicators(self):
        self.df.ta.rsi(length=14, append=True)
        self.df.ta.macd(append=True)
        self.df.ta.ema(length=50, append=True)
        self.df.ta.ema(length=200, append=True)
        self.df.ta.bbands(length=20, append=True)
        self.df.ta.stochrsi(append=True)

    def generate_signal(self):
        self.calculate_indicators()

        latest = self.df.iloc[-1]
        signal = "NEUTRAL"

        rsi = latest["RSI_14"]
        macd = latest["MACD_12_26_9"]
        signal_line = latest["MACDs_12_26_9"]
        close_price = latest["close"]
        ema50 = latest["EMA_50"]
        ema200 = latest["EMA_200"]

        # Basit strateji örneği
        if (
            rsi < 30
            and macd > signal_line
            and close_price > ema50 > ema200
        ):
            signal = "BUY"

        elif (
            rsi > 70
            and macd < signal_line
            and close_price < ema50 < ema200
        ):
            signal = "SELL"

        return signal

    def get_dataframe(self):
        return self.df
# main.py
from kiripto_nova.data.pipelines.data_loader import load_binance_data
from kiripto_nova.signals.signal_engine import SignalEngine

symbol = "DOGE/USDT"
timeframe = "15m"

# 1. Binance'ten veri al
df = load_binance_data(symbol, timeframe)

# 2. Sinyal motorunu başlat
engine = SignalEngine(df)
signal = engine.generate_signal()

# 3. Sonucu yazdır
print("Gelen Sinyal:", signal)

# 4. (Opsiyonel) Göstergeli veri çerçevesini görmek istersen:
# enriched_df = engine.get_dataframe()
# print(enriched_df.tail())


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_evaluator.py
from datetime import datetime, timedelta

def get_price_data(ticker, signal_time):
    # Örnek veri fonksiyonu — API bağlantısı ile alınmalı
    return {
        "day1": 102.5,
        "day3": 106.3,
        "day7": 98.4,
        "baseline": 100.0
    }

def price_diff(prices, day):
    return round((prices[f"day{day}"] - prices["baseline"]) / prices["baseline"] * 100, 2)

def evaluate_signal_effect(signal_time, ticker):
    prices = get_price_data(ticker, signal_time)
    return {
        "day1_change": price_diff(prices, 1),
        "day3_change": price_diff(prices, 3),
        "day7_change": price_diff(prices, 7),
        "successful": any(price_diff(prices, d) > 5 for d in [1,3,7])
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_loop.py
# signal_loop.py
import os
import time
from decimal import Decimal, ROUND_DOWN

from dotenv import load_dotenv
load_dotenv()

from bot import (
    client, USE_TESTNET,
    bracket_market, apply_account_settings,
    round_qty, get_equity, get_filters
)

try:
    import notify as nt
except Exception:
    nt = None

# ====== Parametreler ======
SYMBOL      = os.getenv("SYMBOLS", "BTCUSDT").split(",")[0].strip().upper()
INTERVAL    = os.getenv("TECH_INTERVAL", "1m").strip()
EMA_FAST    = int(os.getenv("EMA_FAST", "9"))
EMA_SLOW    = int(os.getenv("EMA_SLOW", "21"))
COOLDOWN    = int(os.getenv("COOLDOWN_BARS", "3"))
SL_PCT      = float(os.getenv("SL_PCT", "0.01"))
TP_PCT      = float(os.getenv("TP_PCT", "0.02"))
TRAIL_PCT   = float(os.getenv("TRAIL_PCT", "0.0"))
CAP_PCT     = float(os.getenv("MAX_CAPITAL_PCT_PER_TRADE", "0.02"))

def ema_series(values, length):
    k = 2 / (length + 1)
    out, e = [], None
    for v in values:
        e = v if e is None else (v * k + e * (1 - k))
        out.append(e)
    return out

def last_closed_klines(symbol: str, interval: str, need: int):
    # fazladan al, son (açık) mumu at
    k = client.futures_klines(symbol=symbol, interval=interval, limit=max(need + 3, 50))
    if len(k) < 3:
        return []
    return k[:-1]  # son mumu (hala oluşuyor olabilir) çıkar

def side_has_open(symbol: str, want_side: str) -> bool:
    # want_side: "BUY" -> LONG, "SELL" -> SHORT
    desired = "LONG" if want_side.upper() == "BUY" else "SHORT"
    pos = client.futures_position_information(symbol=symbol)
    for p in pos:
        if p.get("positionSide") == desired and float(p.get("positionAmt", 0)) != 0.0:
            return True
    return False

def calc_qty(symbol: str, cap_pct: float) -> float:
    eq = get_equity()
    last = float(client.futures_symbol_ticker(symbol=symbol)["price"])
    raw = (eq * cap_pct) / last
    q = round_qty(symbol, raw)
    # en az step kadar olsun
    step = get_filters(symbol)["step"]
    if q < step:
        q = float(Decimal(str(step)).quantize(Decimal(str(step)), rounding=ROUND_DOWN))
    return q

def push(msg: str):
    print(msg)
    if nt and nt.tg_enabled():
        try: nt.send(msg)
        except: pass

def main():
    push(f"🔁 EMA Cross loop started | {SYMBOL} | {INTERVAL} | TESTNET={USE_TESTNET}")
    apply_account_settings(SYMBOL)

    last_bar_open_time = None
    cooldown_left = 0
    last_signal = None  # "BUY" / "SELL" / None

    while True:
        try:
            closed = last_closed_klines(SYMBOL, INTERVAL, need=max(EMA_SLOW, EMA_FAST) + 5)
            if len(closed) < EMA_SLOW + 2:
                time.sleep(2); continue

            # yeni kapanmış bar?
            cur_open = closed[-1][0]  # open_time
            if cur_open == last_bar_open_time:
                time.sleep(2); continue  # aynı bar, bekle
            last_bar_open_time = cur_open

            closes = [float(x[4]) for x in closed]  # close fiyatları
            f = ema_series(closes, EMA_FAST)
            s = ema_series(closes, EMA_SLOW)

            f_prev, f_now = f[-2], f[-1]
            s_prev, s_now = s[-2], s[-1]

            signal = None
            if f_prev < s_prev and f_now > s_now:
                signal = "BUY"
            elif f_prev > s_prev and f_now < s_now:
                signal = "SELL"

            # cooldown
            if cooldown_left > 0:
                push(f"⏳ cooldown {cooldown_left} bar… (son sinyal: {last_signal})")
                cooldown_left -= 1
                continue

            if signal:
                # aynı yönden tekrarı engelle
                if signal == last_signal:
                    push(f"↔️ aynı sinyal tekrar ({signal}), bekliyorum.")
                    continue
                # açık pozisyon varken aynı yöne girmeyelim
                if side_has_open(SYMBOL, signal):
                    push(f"🧯 {signal} yönü zaten açık pozisyona sahip, atlıyorum.")
                    last_signal = signal
                    cooldown_left = COOLDOWN
                    continue

                qty = calc_qty(SYMBOL, CAP_PCT)
                push(f"📈 Sinyal {signal} | qty≈{qty}")
                try:
                    res = bracket_market(
                        sym=SYMBOL,
                        side=signal,
                        qty=qty,
                        sl_pct=max(SL_PCT, 0.0),
                        tp_pct=max(TP_PCT, 0.0),
                        trail_pct=max(TRAIL_PCT, 0.0),
                    )
                    if res:
                        ep = res.get("entry_price")
                        push(f"✅ Emir gönderildi: {signal} {SYMBOL} qty={qty} EP≈{ep:.2f}")
                except Exception as e:
                    push(f"❌ Emir hatası: {e}")

                last_signal = signal
                cooldown_left = COOLDOWN
            else:
                push("… sinyal yok")

        except Exception as loop_err:
            push(f"⚠️ loop err: {loop_err}")
            time.sleep(3)

        # çok sık istek atmayalım
        time.sleep(1.5)

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_predictor.py
def predict_signal_success(sentiment, score, keywords_used):
    if sentiment == "positive" and score >= 2 and "rally" in keywords_used:
        return "yüksek başarı olasılığı"
    elif sentiment == "negative" and score <= -2 and "plunge" in keywords_used:
        return "yüksek risk sinyali"
    else:
        return "ölçümsüz sinyal"
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
import pandas as pd

def train_model(csv_file="data/signal_log.csv"):
    df = pd.read_csv(csv_file)
    X = df[["signal", "score"]]  # Özellikler
    y = df["result"]             # Hedef (başarı: 1, başarısız: 0)

    model = RandomForestClassifier(n_estimators=100)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

    model.fit(X_train, y_train)
    print(f"🔍 Doğruluk Skoru: {model.score(X_test, y_test):.2f}")
    return model




### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_router.py
# signal_router.py (Sinyalden işleme geçiş sistemi)
from kiripto_nova.signals.signal_scanner_multi import scan_symbols_timeframes, summarize
from kiripto_nova.risk.risk_manager import calculate_position_size, calculate_stop_loss, calculate_take_profit
from trade_executor import execute_trade
from kiripto_nova.apps.telegram_alert import notify_trade, notify_signal
from logger import log_trade, log_error

RISK = 0.01
STOP_LOSS_PCT = 0.015
REWARD_RATIO = 2
BALANCE = 1000

TRADE_TIMEFRAME = "5m"  # hangi zaman diliminden gelen sinyal işleme sokulacak
TRIGGER_SIGNAL = "BUY"  # sadece BUY ya da SELL tetiklesin


def route_signals():
    try:
        print("🔁 Sinyaller alınıyor ve filtreleniyor...")
        signals = scan_symbols_timeframes()
        summary = summarize(signals)

        for symbol, tf_data in signals.items():
            signal = tf_data.get(TRADE_TIMEFRAME)
            if signal == TRIGGER_SIGNAL:
                print(f"🚨 {symbol} → {TRADE_TIMEFRAME} → {signal}")
                price = get_latest_price(symbol)
                direction = "long" if signal == "BUY" else "short"
                qty = calculate_position_size(BALANCE, RISK, STOP_LOSS_PCT)
                sl = calculate_stop_loss(price, STOP_LOSS_PCT, direction)
                tp = calculate_take_profit(price, REWARD_RATIO, STOP_LOSS_PCT, direction)

                # Gerçek emir gönderimi
                result = execute_trade(symbol, side="buy" if direction == "long" else "sell", amount=qty)
                log_trade(signal, symbol, qty, price, sl, tp)
                notify_signal(signal, symbol)
                notify_trade(signal, symbol, qty, price, sl, tp)

            else:
                print(f"⏸️ {symbol} için uygun sinyal yok.")

    except Exception as e:
        log_error(e)


def get_latest_price(symbol):
    from ccxt import binance
    client = binance()
    ticker = client.fetch_ticker(symbol)
    return ticker['last']


if __name__ == "__main__":
    import time
    from datetime import datetime
    while True:
        print(f"\n🧠 ROUTER ÇALIŞIYOR: {datetime.now().strftime('%H:%M:%S')}")
        route_signals()
        time.sleep(5)  # her 5 saniyede sinyal kontrolü


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_scanner_multi.py
# signal_scanner_multi.py
from multi_strategy import MultiStrategyEngine
from kiripto_nova.data.pipelines.data_loader import load_binance_data
import pandas as pd
import time
from datetime import datetime

# Tarama yapılacak pariteler
SYMBOLS = [
    "BTC/USDT", "ETH/USDT", "DOGE/USDT",
    "SOL/USDT", "AVAX/USDT", "ADA/USDT",
    "XRP/USDT", "LINK/USDT", "MATIC/USDT"
]

# Zaman dilimleri
TIMEFRAMES = ["1m", "5m", "15m", "1h"]


def scan_symbols_timeframes():
    all_signals = {}
    for symbol in SYMBOLS:
        time.sleep(0.5)  # Binance API rate limit'e saygı
        all_signals[symbol] = {}
        for tf in TIMEFRAMES:
            try:
                df = load_binance_data(symbol, tf, limit=200)
                engine = MultiStrategyEngine(df)
                signal = engine.evaluate()
                all_signals[symbol][tf] = signal
            except Exception as e:
                all_signals[symbol][tf] = f"HATA: {str(e)}"
    return all_signals


def summarize(signals):
    summary = {}
    for symbol, tf_data in signals.items():
        counts = {"BUY": 0, "SELL": 0, "NEUTRAL": 0, "HATA": 0}
        for sig in tf_data.values():
            if sig in counts:
                counts[sig] += 1
            elif str(sig).startswith("HATA"):
                counts["HATA"] += 1
            else:
                counts["NEUTRAL"] += 1
        summary[symbol] = counts
    return summary


if __name__ == "__main__":
    while True:
        now = datetime.now().strftime("%H:%M:%S")
        print(f"\n⏱️ [{now}] Çoklu coin & zaman taraması başlıyor...")

        results = scan_symbols_timeframes()
        summary = summarize(results)

        for symbol, tf_data in results.items():
            print(f"\n🔍 {symbol}:")
            for tf, signal in tf_data.items():
                print(f"  🕒 {tf}: {signal}")

        print(f"\n📊 Genel Özet:")
        for sym, counts in summary.items():
            print(f"{sym}: {counts}")

        time.sleep(5)  # Düşük frekanslı çoklu tarama


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_scanner.py
# signal_scanner.py
from multi_strategy import MultiStrategyEngine
from kiripto_nova.data.pipelines.data_loader import load_binance_data
import pandas as pd

# Desteklenen zaman dilimleri
TIMEFRAMES = ["1m", "5m", "15m", "1h", "4h", "1d"]


def scan_all_timeframes(symbol="DOGE/USDT"):
    signals = {}
    for tf in TIMEFRAMES:
        try:
            df = load_binance_data(symbol, tf, limit=200)
            engine = MultiStrategyEngine(df)
            signal = engine.evaluate()
            signals[tf] = signal
        except Exception as e:
            signals[tf] = f"HATA: {str(e)}"
    return signals


def summarize_signals(signals):
    summary = {"BUY": 0, "SELL": 0, "NEUTRAL": 0, "HATA": 0}
    for tf, sig in signals.items():
        if sig in summary:
            summary[sig] += 1
        elif sig.startswith("HATA"):
            summary["HATA"] += 1
        else:
            summary["NEUTRAL"] += 1
    return summary


if __name__ == "__main__":
    import time
    from datetime import datetime

    SYMBOL = "DOGE/USDT"

    while True:
        now = datetime.now().strftime("%H:%M:%S")
        print(f"\n⏱️ [{now}] {SYMBOL} tüm zaman dilimlerinde taranıyor...")

        result = scan_all_timeframes(SYMBOL)
        summary = summarize_signals(result)

        for tf, signal in result.items():
            print(f"🕒 {tf}: {signal}")

        print(f"🔍 Özet: {summary}")
        time.sleep(1)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_symphony_engine.py
def generate_signal_composition(project_profile):
    score = ""
    if project_profile['impact'] > 80:
        score += "🎺 Başlangıç: Etki trompeti\n"
    if project_profile['crisis'] > 70:
        score += "🥁 Ara geçiş: Kriz davulları\n"
    if project_profile['growth'] > 20:
        score += "🎻 Zirve: Büyüme yaylıları\n"
    if project_profile['emotion'] == "positive":
        score += "🎶 Kapanış: Umut melodisi\n"
    else:
        score += "🎵 Kapanış: Dengeli tonlar\n"
    return score



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\signals\signal_tracker.py
from datetime import datetime, timedelta

def get_mock_price_data(ticker, signal_time):
    # Bu örnek işlevde gerçek API yok – sen ileride CoinGecko, Binance, vs. bağlayabilirsin
    return {
        "baseline": 100.0,
        "day1": 103.5,
        "day3": 108.2,
        "day7": 101.4
    }

def price_change(prices, day):
    base = prices["baseline"]
    current = prices[f"day{day}"]
    return round((current - base) / base * 100, 2)

def analyze_signal_effect(ticker, signal_time):
    prices = get_mock_price_data(ticker, signal_time)
    result = {
        "day1_change": price_change(prices, 1),
        "day3_change": price_change(prices, 3),
        "day7_change": price_change(prices, 7),
        "successful": any(price_change(prices, d) > 5 for d in [1,3,7])
    }
    return result



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\ai\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\rust_indicators\.bot\logs\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\rust_indicators\.bot\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\rust_indicators\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\rust_indicators\bias_gate.py
# python/bias_gate.py
from typing import Optional, Dict, Any

def bias_allows(signal: Dict[str, Any], bias_row: Dict[str, Any],
                min_conf: float = 0.6) -> bool:
    """
    signal: {"symbol": "...", "side": "BUY"/"SELL", "intent": "entry"/"exit"/...}
    bias_row: long_short_ratio_scanner.fetch_metrics_for_symbol çıktısı satırı
    """
    if not signal or not bias_row: return False
    conf = bias_row.get("confidence") or 0.0
    if conf < min_conf:            # güven düşükse emir atma
        return False

    side = (signal.get("side") or "").upper()
    tag  = bias_row.get("signal")
    if side == "BUY" and tag == "long_bias":
        return True
    if side == "SELL" and tag == "short_bias":
        return True
    # Exit emirleri genelde serbest bırakılır:
    if (signal.get("intent") or "").lower() == "exit":
        return True
    return False


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\rust_indicators\long_short_ratio_scanner.py
# python/long_short_ratio_scanner.py
# -*- coding: utf-8 -*-
import asyncio, aiohttp, time, math
from typing import Dict, Any, List, Tuple, Optional
import pandas as pd

BASE = "https://fapi.binance.com"

def ratio_to_pcts(r: float) -> Tuple[float, float]:
    if r <= 0 or math.isinf(r) or math.isnan(r):
        return (0.5, 0.5)
    long_pct = r / (1.0 + r)
    return float(long_pct), float(1.0 - long_pct)

def safe_float(x, default=None):
    try: return float(x)
    except Exception: return default

async def fetch_json(session: aiohttp.ClientSession, url: str, params: Dict[str, Any], retries=3) -> Any:
    delay = 0.5
    for i in range(retries):
        try:
            async with session.get(url, params=params, timeout=aiohttp.ClientTimeout(total=8)) as resp:
                if resp.status in (429, 500, 502, 503, 504):
                    raise RuntimeError(f"HTTP {resp.status}")
                return await resp.json()
        except Exception:
            if i == retries - 1: return None
            await asyncio.sleep(delay); delay *= 1.8

async def get_usdt_perp_symbols(session: aiohttp.ClientSession) -> List[str]:
    data = await fetch_json(session, f"{BASE}/fapi/v1/exchangeInfo", {})
    out = []
    if not data or "symbols" not in data: return out
    for s in data["symbols"]:
        try:
            if s.get("contractType") == "PERPETUAL" and s.get("quoteAsset") == "USDT" and s.get("status") == "TRADING":
                out.append(s["symbol"])
        except: pass
    return sorted(out)

def _last(lst, key):
    try:
        if lst and isinstance(lst, list): return lst[-1].get(key)
    except: pass
    return None

async def fetch_metrics_for_symbol(session: aiohttp.ClientSession, symbol: str, period: str = "5m") -> Dict[str, Any]:
    params = {"symbol": symbol, "period": period, "limit": 1}
    g_acc = await fetch_json(session, f"{BASE}/futures/data/globalLongShortAccountRatio", params)
    t_pos = await fetch_json(session, f"{BASE}/futures/data/topLongShortPositionRatio", params)
    t_acc = await fetch_json(session, f"{BASE}/futures/data/topLongShortAccountRatio", params)
    taker = await fetch_json(session, f"{BASE}/futures/data/takerlongshortRatio", params)
    oi = await fetch_json(session, f"{BASE}/futures/data/openInterestHist",
                          {"symbol": symbol, "period": period, "contractType": "PERPETUAL", "limit": 2})

    out: Dict[str, Any] = {"symbol": symbol, "period": period, "ts": int(time.time()*1000)}
    for name, payload in [("global_acc", g_acc), ("top_pos", t_pos), ("top_acc", t_acc)]:
        rs = safe_float(_last(payload, "longShortRatio"), None)
        if rs is None:
            out[f"{name}_long_pct"] = None; out[f"{name}_short_pct"] = None
        else:
            lp, sp = ratio_to_pcts(rs)
            out[f"{name}_long_pct"] = lp; out[f"{name}_short_pct"] = sp

    tb = safe_float(_last(taker, "buyVol"), 0.0)
    ts = safe_float(_last(taker, "sellVol"), 0.0)
    tot = (tb or 0.0) + (ts or 0.0)
    out["taker_buy_share"] = (tb/tot) if tot > 0 else None

    try:
        if isinstance(oi, list) and len(oi) >= 2:
            prev = safe_float(oi[-2].get("sumOpenInterest"), None)
            cur  = safe_float(oi[-1].get("sumOpenInterest"), None)
            out["oi_change_pct"] = (cur - prev) / prev if prev and prev > 0 else None
        else:
            out["oi_change_pct"] = None
    except: out["oi_change_pct"] = None

    parts, weights = [], []
    for key in ["global_acc_long_pct","top_pos_long_pct","top_acc_long_pct"]:
        v = out.get(key)
        if v is not None: parts.append(v); weights.append(1.0)
    if out.get("taker_buy_share") is not None:
        parts.append(out["taker_buy_share"]); weights.append(0.7)

    if parts:
        wsum = sum(weights)
        long_bias = sum(p*w for p, w in zip(parts, weights))/wsum
    else:
        long_bias = None

    out["long_bias"]  = long_bias
    out["short_bias"] = (1-long_bias) if long_bias is not None else None

    sources = sum(1 for k in ["global_acc_long_pct","top_pos_long_pct","top_acc_long_pct","taker_buy_share"] if out.get(k) is not None)
    conf = 0.25 * sources
    if out.get("oi_change_pct") is not None and long_bias is not None:
        if (out["oi_change_pct"] > 0 and long_bias >= 0.5) or (out["oi_change_pct"] < 0 and long_bias < 0.5):
            conf += min(0.5, abs(out["oi_change_pct"]) * 5.0)
    out["confidence"] = float(max(0.0, min(1.0, conf)))

    if long_bias is None: out["signal"] = "unknown"
    elif long_bias >= 0.6: out["signal"] = "long_bias"
    elif long_bias <= 0.4: out["signal"] = "short_bias"
    else: out["signal"] = "neutral"

    return out

async def scan_all(period: str = "5m", max_symbols: int = 0, concurrency: int = 12) -> List[Dict[str, Any]]:
    conn = aiohttp.TCPConnector(limit=concurrency, ssl=False)
    async with aiohttp.ClientSession(connector=conn, headers={"Accept": "application/json"}) as session:
        symbols = await get_usdt_perp_symbols(session)
        if max_symbols and max_symbols > 0: symbols = symbols[:max_symbols]
        sem = asyncio.Semaphore(concurrency)
        async def one(sym):
            async with sem:
                return await fetch_metrics_for_symbol(session, sym, period)
        results = await asyncio.gather(*[asyncio.create_task(one(s)) for s in symbols])
        return [r for r in results if r]

def to_dataframe(rows: List[Dict[str, Any]]) -> pd.DataFrame:
    df = pd.DataFrame(rows)
    cols = [
        "ts","symbol","period",
        "global_acc_long_pct","top_pos_long_pct","top_acc_long_pct",
        "taker_buy_share","oi_change_pct","long_bias","short_bias","confidence","signal"
    ]
    for c in cols:
        if c not in df.columns: df[c] = None
    df = df[cols].copy()
    df["ts_readable"] = pd.to_datetime(df["ts"], unit="ms")
    return df

def export_csv(df: pd.DataFrame, path: str, mode: str = "a"):
    header = not (pd.io.common.file_exists(path) and mode == "a")
    df.to_csv(path, index=False, mode=mode, header=header)

def sort_candidates(rows: List[Dict[str, Any]], mode: str = "long", top: int = 20) -> List[Dict[str, Any]]:
    key = "long_bias" if mode == "long" else "short_bias"
    rows2 = [r for r in rows if r.get(key) is not None]
    rows2.sort(key=lambda r: (r.get(key, 0.5), r.get("confidence", 0.0)), reverse=True)
    return rows2[:top]

def pretty_print(rows: List[Dict[str, Any]]):
    print(f"{'SYM':<12} {'LONG%':>6} {'SHORT%':>7} {'TAKER_BUY%':>10} {'OI%':>7} {'CONF':>5}  SIGNAL")
    for r in rows:
        lp=r.get("long_bias"); sp=r.get("short_bias"); tb=r.get("taker_buy_share"); oi=r.get("oi_change_pct")
        print(f"{r['symbol']:<12} {(lp*100 if lp is not None else float('nan')):6.1f} "
              f"{(sp*100 if sp is not None else float('nan')):7.1f} "
              f"{(tb*100 if tb is not None else float('nan')):10.1f} "
              f"{(oi*100 if oi is not None else float('nan')):7.2f} "
              f"{r.get('confidence',0):5.2f}  {r.get('signal','-')}")

if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--period", default="5m")
    ap.add_argument("--mode",   default="all", choices=["long","short","all"])
    ap.add_argument("--top",    default=20, type=int)
    ap.add_argument("--max",    default=0, type=int)
    ap.add_argument("--csv",    default="bias_scan.csv")
    args = ap.parse_args()

    rows = asyncio.run(scan_all(period=args.period, max_symbols=args.max))
    df = to_dataframe(rows)
    export_csv(df, args.csv, mode="a")
    print(f"Saved {len(df)} rows -> {args.csv}")

    if args.mode in ("long","all"):
        print("\n=== LONG BIAS ===")
        pretty_print(sort_candidates(rows, "long", args.top))
    if args.mode in ("short","all"):
        print("\n=== SHORT BIAS ===")
        pretty_print(sort_candidates(rows, "short", args.top))


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\rust_indicators\run_bias_gated_strategy.py
# run_bias_gated_strategy.py
from __future__ import annotations
import os, asyncio, math
from typing import Dict, Any, List, Optional
from dotenv import load_dotenv
from binance.client import Client
from binance.exceptions import BinanceAPIException

from long_short_ratio_scanner import scan_all, to_dataframe, export_csv, sort_candidates
from bias_gate import bias_allows

# =========================
#  Basit örnek sinyal (yerine kendi modülünü import edebilirsin)
#  from strategies.rust_avci import generate_signal
def generate_signal(closes: List[float], symbol: str):
    if len(closes) < 50: return None
    ma = sum(closes[-50:]) / 50.0
    if closes[-1] > ma and closes[-2] <= ma:
        return {"symbol": symbol, "side": "BUY", "intent": "entry"}
    if closes[-1] < ma and closes[-2] >= ma:
        return {"symbol": symbol, "side": "SELL", "intent": "entry"}
    return None
# =========================

load_dotenv()

API_KEY      = os.getenv("BINANCE_API_KEY")
API_SECRET   = os.getenv("BINANCE_API_SECRET")
USE_TESTNET  = os.getenv("BINANCE_USE_TESTNET","false").lower()=="true"
FUT_URL      = os.getenv("BINANCE_FUTURES_URL","https://fapi.binance.com")

HEDGE_MODE   = os.getenv("BINANCE_HEDGE_MODE","true").lower()=="true"
MARGIN_TYPE  = os.getenv("BINANCE_MARGIN_TYPE","ISOLATED").upper()
LEVERAGE     = int(os.getenv("BINANCE_LEVERAGE","5"))

BIAS_PERIOD  = os.getenv("BIAS_PERIOD","5m")
BIAS_TOP     = int(os.getenv("BIAS_TOP","20"))
BIAS_MIN_CONF= float(os.getenv("BIAS_MIN_CONF","0.65"))
BIAS_CSV     = os.getenv("BIAS_CSV","bias_scan.csv")
TIMEFRAME    = os.getenv("TIMEFRAME","1m")

MAX_CAP_PCT  = float(os.getenv("MAX_CAPITAL_PCT_PER_TRADE","0.02"))
MIN_NOTIONAL = float(os.getenv("MIN_NOTIONAL_USDT","10"))
DRY_RUN      = os.getenv("DRY_RUN","true").lower()=="true"

def _fetch_closes(client: Client, symbol: str, interval="1m", limit=500) -> List[float]:
    kl = client.futures_klines(symbol=symbol, interval=interval, limit=limit)
    return [float(k[4]) for k in kl]

def _get_usdt_balance(client: Client) -> float:
    # Futures USDT cüzdanı
    bals = client.futures_account_balance()
    for b in bals:
        if b.get("asset") == "USDT":
            return float(b.get("balance", 0.0))
    return 0.0

def _get_symbol_filters(client: Client, symbol: str):
    info = client.futures_exchange_info()
    for s in info["symbols"]:
        if s["symbol"] == symbol:
            tick = 0.01
            step = 0.001
            for f in s["filters"]:
                if f["filterType"] == "PRICE_FILTER":
                    tick = float(f["tickSize"])
                if f["filterType"] in ("LOT_SIZE","MARKET_LOT_SIZE"):
                    step = float(f["stepSize"])
            return tick, step
    return 0.01, 0.001

def _round_step(qty: float, step: float) -> float:
    if step <= 0: return qty
    return math.floor(qty / step) * step

def _round_tick(price: float, tick: float) -> float:
    if tick <= 0: return price
    return math.floor(price / tick) * tick

def _last_price(client: Client, symbol: str) -> float:
    t = client.futures_symbol_ticker(symbol=symbol)
    return float(t["price"])

def _ensure_symbol_settings(client: Client, symbol: str):
    # hedge mode / margin / leverage – hataya düşerse devam et
    try:
        client.futures_change_position_mode(dualSidePosition=HEDGE_MODE)
    except Exception:
        pass
    try:
        client.futures_change_margin_type(symbol=symbol, marginType=MARGIN_TYPE)
    except BinanceAPIException as e:
        # already set vs. gibi durumlar normal
        pass
    except Exception:
        pass
    try:
        client.futures_change_leverage(symbol=symbol, leverage=LEVERAGE)
    except Exception:
        pass

def _size_by_conf(balance_usdt: float, conf: float, price: float, tick: float, step: float) -> float:
    # Sermayeyi conf ile ölçekle: 0.5..1.0 arası
    cap = balance_usdt * MAX_CAP_PCT
    cap *= (0.5 + conf/2.0)
    cap = max(cap, MIN_NOTIONAL)  # minimum notional eşiği
    qty = cap / max(price, 1e-9)
    qty = _round_step(qty, step)
    return max(qty, 0.0)

def _place_market_order(client: Client, symbol: str, side: str, qty: float):
    if DRY_RUN:
        print(f"[DRY_RUN] {symbol} {side} qty={qty}")
        return {"dry_run": True, "symbol": symbol, "side": side, "qty": qty}
    # canlı emir
    ord_resp = client.futures_create_order(symbol=symbol, side=side, type="MARKET", quantity=qty)
    return ord_resp

async def main():
    # 1) bias tara ve CSV'ye yaz
    rows = await scan_all(period=BIAS_PERIOD, max_symbols=0)
    df = to_dataframe(rows)
    export_csv(df, BIAS_CSV, mode="a")
    print(f"[bias] {len(df)} satır eklendi -> {BIAS_CSV}")

    # 2) en iyi adaylar
    long_candidates  = sort_candidates(rows, mode="long",  top=BIAS_TOP)
    short_candidates = sort_candidates(rows, mode="short", top=BIAS_TOP)
    watch = { r["symbol"]: r for r in (long_candidates + short_candidates) }

    # 3) Binance client
    client = Client(API_KEY, API_SECRET, testnet=USE_TESTNET)
    client.FUTURES_URL = FUT_URL

    # 4) hesap bakiyesi
    balance = _get_usdt_balance(client)
    print(f"[acct] USDT balance: {balance:.2f}")

    # 5) her adayda: sinyal + gate + boyutlama + (opsiyonel) emir
    for sym, bias_row in watch.items():
        try:
            _ensure_symbol_settings(client, sym)
            closes = _fetch_closes(client, sym, interval=TIMEFRAME, limit=500)

            sig = generate_signal(closes, sym)
            if not sig:
                continue

            if not bias_allows(sig, bias_row, min_conf=BIAS_MIN_CONF):
                print(f"[gate] {sym} reddedildi: bias={bias_row.get('signal')} conf={bias_row.get('confidence'):.2f}")
                continue

            price = _last_price(client, sym)
            tick, step = _get_symbol_filters(client, sym)
            qty = _size_by_conf(balance, bias_row.get("confidence", 0.0), price, tick, step)

            if qty <= 0:
                print(f"[size] {sym} qty hesaplanamadı (min notional / step?), atlanıyor.")
                continue

            print(f"[exec] {sym} {sig['side']} conf={bias_row.get('confidence'):.2f} price≈{price} qty≈{qty}")
            resp = _place_market_order(client, sym, sig["side"], qty)
            print(f"[resp] {resp if DRY_RUN else 'Order sent.'}")

        except BinanceAPIException as e:
            print(f"[binance] {sym} API error: {e.message}")
        except Exception as e:
            print(f"[error] {sym}: {e}")

if __name__ == "__main__":
    asyncio.run(main())



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\adaptive_learning_engine.py
from machine_learning_core import train_dynamic_model
from real_time_optimizer import adjust_strategy_live

def adaptive_learning_engine(market_data, feedback_loop):
    dynamic_model = train_dynamic_model(market_data, epochs=50)
    optimized_strategy = adjust_strategy_live(dynamic_model, feedback_loop)

    return {
        '🤖 Öğrenen Model': dynamic_model['architecture'],
        '📈 Canlı Strateji Ayarı': optimized_strategy['adjustments'],
        '⚠️ Risk Değerlendirmesi': optimized_strategy['risk_assessment'],
        '🧭 Stratejik Öneriler': optimized_strategy['actionable_insights'],
        '🔄 Geri Bildirim Döngüsü': feedback_loop
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\adaptive_strategy.py
class AdaptiveStrategy:
    def __init__(self, base_algo):
        self.algo = base_algo
        self.performance = []

    def trade(self, market_data):
        decision = self.algo(market_data)
        return decision

    def update_performance(self, result):
        self.performance.append(result)
        if len(self.performance) > 100:
            self._retrain()

    def _retrain(self):
        # Zayıf verileri temizle, algoritmayı yeniden optimize et
        self.performance = self.performance[-50:]  # En güncel 50 işlem
        # Retrain logic here...



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\adaptive_weights.py
def adjust_weights(indicator_perf):
    weights = {}
    total_perf = sum(indicator_perf.values())

    for ind, perf in indicator_perf.items():
        weights[ind] = round(perf / total_perf, 3)

    return weights



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\alert_dispatcher.py
# components/alert_dispatcher.py
import os, requests, json
from flask import Flask, request

app = Flask(__name__)
SLACK_WEBHOOK   = os.getenv('SLACK_WEBHOOK_URL')
TELEGRAM_TOKEN  = os.getenv('TELEGRAM_TOKEN')
TELEGRAM_CHATID = os.getenv('TELEGRAM_CHAT_ID')

def send_slack(text: str):
    payload = {'text': f":rotating_light: {text}"}
    requests.post(SLACK_WEBHOOK, data=json.dumps(payload))

def send_telegram(text: str):
    url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
    data = {'chat_id': TELEGRAM_CHATID, 'text': f"🚨 {text}"}
    requests.post(url, data=data)

@app.route('/alert', methods=['POST'])
def alert():
    data = request.json
    for alert in data.get('alerts', []):
        msg = alert['annotations']['description']
        send_slack(msg)
        send_telegram(msg)
    return '', 200

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\algorithmic_intuition_builder.py
from pattern_recognition_core import detect_subtle_trends
from intuition_generator import synthesize_decision_paths

def algorithmic_intuition_builder(market_data, external_factors):
    subtle_trends = detect_subtle_trends(market_data)
    decision_paths = synthesize_decision_paths(subtle_trends, external_factors)

    return {
        '🔍 İncelikli Trendler': subtle_trends,
        '🧭 Sezgisel Karar Yolları': decision_paths['paths'],
        '📈 Beklenen Hareketler': decision_paths['predicted_outcomes'],
        '⚠️ Risk Değerlendirmesi': decision_paths['risk_assessment'],
        '🧪 Stratejik Öneriler': decision_paths['actionable_insights']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\backtest_lab.py
import pandas as pd

def backtest_signals(df, signals):
    df['signal'] = signals
    df['returns'] = df['close'].pct_change().shift(-1)
    df['strategy_returns'] = df['returns'] * df['signal'].shift(1)

    cumulative_market = (1 + df['returns'].fillna(0)).cumprod()
    cumulative_strategy = (1 + df['strategy_returns'].fillna(0)).cumprod()

    performance = {
        "Market_Return": cumulative_market[-1] - 1,
        "Strategy_Return": cumulative_strategy[-1] - 1,
        "Sharpe_Ratio": df['strategy_returns'].mean() / df['strategy_returns'].std()
    }

    return performance



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\backtester.py
import pandas as pd
import numpy as np

def backtest_signals(price_csv, signal_csv, fee=0.0004):
    px = pd.read_csv(price_csv, parse_dates=["open_time"])
    sig = pd.read_csv(signal_csv)  # cols: time, side, price
    px = px[["open_time","close"]].rename(columns={"close":"p"})
    sig["time"]=pd.to_datetime(sig["time"])
    df = pd.merge_asof(sig.sort_values("time"), px.sort_values("open_time"),
                       left_on="time", right_on="open_time", direction="backward")
    # naive PnL: bir sonraki bar kapanışı
    df["next_p"] = df["p"].shift(-1)
    df = df.dropna()
    ret = np.where(df["side"]=="LONG",
                   (df["next_p"]/df["p"] - 1) - fee,
                   (df["p"]/df["next_p"] - 1) - fee)
    df["ret"]=ret
    df["equity"]=(1+df["ret"]).cumprod()
    return df

if __name__=="__main__":
    out = backtest_signals("prices.csv","signals.csv")
    print("trades:", len(out), "final_equity:", float(out["equity"].iloc[-1]))


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\battle_chain_analyzer.py
def analyze_chain_activity(chain_data):
    results = []
    for protocol in chain_data:
        activity_score = (protocol['tx_volume'] * 0.6 + protocol['user_count'] * 0.4)
        threat_level = 'High' if activity_score > 10000 else 'Medium' if activity_score > 5000 else 'Low'
        results.append({
            'protocol': protocol['name'],
            'score': round(activity_score, 2),
            'threat_level': threat_level
        })
    return results



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\bot_launcher.py
import websocket
import json

def on_message(ws, message):
    data = json.loads(message)
    # Gerçek zamanlı veriye göre strateji tetiklenir
    indicators = calculate_indicators(pd.DataFrame(data))
    signal = generate_signal(indicators)

    if signal == 'BUY':
        execute_order('buy')
    elif signal == 'SELL':
        execute_order('sell')

def execute_order(order_type):
    print(f"Executing {order_type} order via exchange API...")

def launch_bot():
    ws = websocket.WebSocketApp("wss://example-data-feed",
                                 on_message=on_message)
    ws.run_forever()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\celestial_cognition_beacon.py
from reactor_output import extract_neural_frequency
from stellar_network import broadcast_to_stars

def celestial_cognition_beacon(reactor_output, signal_strength, observatory_coordinates):
    neural_freq = extract_neural_frequency(reactor_output['🧠 Ortak Bilinç Verisi'])
    
    star_feedback = broadcast_to_stars(
        neural_freq, signal_strength, observatory_coordinates
    )

    return {
        '🌟 Yayınlanan Zekâ Frekansı': neural_freq,
        '🪐 Galaktik Gözlem Verisi': star_feedback,
        'Durum': '📡 Kozmik Yayın Tamamlandı'
    }


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\chrono_synaptic_memory_forge.py
from galactic_feedback import decode_star_feedback
from neural_time_engine import unify_temporal_insights

def chrono_synaptic_memory_forge(star_feedback, historical_missions, current_directives, future_predictions):
    temporal_stream = unify_temporal_insights(
        historical_missions, current_directives, future_predictions
    )

    adaptive_memory = decode_star_feedback(
        star_feedback, temporal_stream
    )

    return {
        '🧠 Zamansal Strateji Hafızası': adaptive_memory,
        '⏳ Hafıza Akışı': temporal_stream,
        'Durum': '🧠⌛ Stratejik Zaman Ağı Aktif'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\chrono_synthetic_matrix.py
from past_insights import get_historical_patterns
from emotion_tracker import read_current_emotion
from future_engine import generate_scenarios
from strategic_synthesizer import synthesize_decision

def chrono_synthetic_matrix(user_id):
    # 1. Geçmiş stratejik örüntüleri analiz et
    past_patterns = get_historical_patterns(user_id)

    # 2. Mevcut duygu durumunu al
    current_emotion = read_current_emotion(user_id)

    # 3. Gelecek senaryoları oluştur
    future_paths = generate_scenarios()

    # 4. Zaman-sentetik stratejiyi sentezle
    synthesized_strategy = synthesize_decision(
        past=past_patterns,
        present=current_emotion,
        future=future_paths
    )

    return {
        '📚 Geçmiş Analizi': past_patterns['summary'],
        '🧘 Şu Anki Ruhsal Durum': current_emotion,
        '🔮 Olası Gelecekler': future_paths['map'],
        '⚡ Entegre Strateji': synthesized_strategy['approach'],
        '🧭 Uygulanma Yolu': synthesized_strategy['path']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\command_dashboard.py
import matplotlib.pyplot as plt
from trade_stats import get_trade_stats
from strategy_logger import strategy_log

def command_dashboard(trade_log, market_data, balance):
    stats = get_trade_stats(trade_log)
    strategies = strategy_log()

    print("🔍 İşlem Performansı:")
    for stat in stats:
        print(f"{stat['name']}: {stat['value']}")

    print("\n🧬 Strateji Geçmişi:")
    for strat in strategies[-5:]:
        print(f"{strat['timestamp']} - {strat['name']} - 📈 {strat['performance']}")

    plt.figure(figsize=(10, 5))
    plt.plot([entry['timestamp'] for entry in strategies],
             [entry['performance'] for entry in strategies],
             color='gold', marker='o')
    plt.title("⚡ Strateji Performansı Zaman Çizgisi")
    plt.xlabel("Zaman")
    plt.ylabel("Verimlilik (%)")
    plt.grid(True)
    plt.show()

    print(f"\n💰 Mevcut Bakiye: {balance}")
    print("📉 Sermaye dağılımı ve pozisyonlar yükleniyor...")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\command_theme.py
def command_theme():
    theme = {
        'background': '#0D0D0D',
        'text_color': '#FFD700',
        'accent': '#1A1A1A',
        'font_family': 'Orbitron',
        'animations': {
            'strategy_panel': 'StarFieldFlow',
            'balance_pulse': 'GoldRadarGlow',
            'alerts': 'GeneralFlashBlink'
        },
        'icons': {
            'trade': '⚔️',
            'strategy': '🧠',
            'profit': '📈',
            'danger': '🛡️'
        }
    }
    return theme



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\cosmic_control_app.py
from flask import Flask, request
from cloud_sync import sync_trade_data
from notification_engine import push_alert
from voice_command import interpret_voice

app = Flask(__name__)

@app.route("/trade_update", methods=["POST"])
def trade_update():
    data = request.json
    sync_trade_data(data)
    push_alert(f"🚀 Yeni İşlem Başlatıldı: {data['symbol']} | {data['action']}")
    return {"status": "success", "message": "Veri eşlendi ve bildirim gönderildi."}

@app.route("/voice_control", methods=["POST"])
def voice_control():
    command = interpret_voice(request.data)
    if "durdur" in command:
        return {"status": "stopped", "message": "📛 Kozmik işlem durduruldu."}
    elif "devam et" in command:
        return {"status": "resumed", "message": "🟢 İşlem devam ettirildi."}
    else:
        return {"status": "unknown", "message": "❓ Komut algılanamadı."}

if __name__ == "__main__":
    app.run(debug=True)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\cosmic_creation_engine.py
from universal_flow_analyzer import universal_flow_analyzer
from creation_engine import initiate_cosmic_creation

def cosmic_creation_engine(universal_streams, creation_parameters):
    new_creations = initiate_cosmic_creation(universal_streams, creation_parameters)
    return {
        '🌌 Yeni Yaratımlar': new_creations,
        '🔄 Yaratım Döngüsü': 'Başlatıldı',
        'Durum': '🌠 Kozmik Yaratım Motoru Aktif'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\cosmic_decision_matrix.py
from tactical_persona_fleet import tactical_persona_fleet
from decision_simulator import run_scenario_grid

def cosmic_decision_matrix(user_id, mission_types, scenario_parameters):
    fleet_data = tactical_persona_fleet(user_id, mission_types)['🛡️ Avatar Filo']
    decision_matrix = run_scenario_grid(fleet_data, scenario_parameters)

    return {
        '🧠 Senaryo Matrisi': decision_matrix,
        '🪐 Parametreler': scenario_parameters,
        'Durum': '🌐 Stratejik Gerçeklik Simülasyonu Tamamlandı'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\cosmic_navigator.py
from signal_detector import detect_signals
from efficiency_mapper import map_efficiency
from opportunity_selector import best_direction

def cosmic_navigator(market_data, trade_log):
    signals = detect_signals(market_data)
    efficiency_map = map_efficiency(trade_log, signals)

    optimal_path = best_direction(efficiency_map)

    return {
        '📡 Sinyal Gücü': signals[:3],
        '🧭 Verim Haritası': efficiency_map,
        '🚀 Tavsiye Edilen Yön': optimal_path,
        'Durum': '💡 Navigasyon Aktif'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\cosmic_trader.py
from meta_strategy_generator import meta_strategy_generator
from kiripto_nova.strategies.strategy_executor import strategy_executor
from profit_maximizer import profit_maximizer
from capital_engine import capital_engine

def cosmic_trader(trade_log, market_data, balance):
    # 1. Yeni stratejileri üret
    strategies = meta_strategy_generator(trade_log)

    # 2. Stratejileri test et ve en iyi olanları seç
    results = strategy_executor(strategies, market_data)
    approved = [res for res in results if res['status'] == '✅ ONAYLANDI']

    if not approved:
        return "🟡 Bekleniyor – Güvenilir strateji bulunamadı"

    # 3. Kâr optimizasyonu
    signal = approved[0]['strategy']['main_signal']
    decision = profit_maximizer(trade_log, market_data.keys())

    # 4. Sermaye ayarı
    capital_order = capital_engine(balance, decision.split()[1])

    return {
        'Karar': decision,
        'Pozisyon Büyüklüğü': capital_order,
        'Strateji': approved[0]['strategy'],
        'Durum': '🚀 Kozmik Ticaret Başlatıldı'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\data_fetcher.py
import os
import asyncio
import ccxt.async_support as ccxt
import pandas as pd
from dotenv import load_dotenv
from typing import List

load_dotenv()
API_KEY = os.getenv('BINANCE_API_KEY')
SECRET_KEY = os.getenv('BINANCE_SECRET_KEY')

class DataFetcher:
    def __init__(self, symbol: str, timeframe: str = '1m', limit: int = 200):
        self.symbol = symbol
        self.timeframe = timeframe
        self.limit = limit
        self.exchange = ccxt.binance({
            'apiKey': API_KEY,
            'secret': SECRET_KEY,
            'enableRateLimit': True,
            'options': {'defaultType': 'future'}
        })

    async def fetch_ohlcv(self) -> pd.DataFrame:
        data = await self.exchange.fetch_ohlcv(self.symbol, self.timeframe, limit=self.limit)
        df = pd.DataFrame(data, columns=['ts','open','high','low','close','vol'])
        df['ts'] = pd.to_datetime(df['ts'], unit='ms')
        return df

    async def close(self):
        await self.exchange.close()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\data_ingestion.py
# components/data_ingestion.py
import asyncio
from aiokafka import AIOKafkaProducer
from websockets import connect
import json

class DataIngestion:
    def __init__(self, kafka_url: str, topics: dict):
        self.producer = AIOKafkaProducer(bootstrap_servers=kafka_url)
        self.topics   = topics

    async def start(self):
        await self.producer.start()

    async def ingest_spot(self, pair: str, ws_url: str):
        async with connect(ws_url) as ws:
            await ws.send(json.dumps({"method":"SUBSCRIBE","params":[f"{pair.lower()}@ticker"],"id":1}))
            async for message in ws:
                await self.producer.send_and_wait(
                    topic=self.topics['spot'], 
                    value=message.encode()
                )

    async def stop(self):
        await self.producer.stop()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\data_universe_mapper.py
from multidimensional_visualizer import create_data_map
from hidden_pattern_detector import uncover_market_signals

def data_universe_mapper(market_data):
    data_map = create_data_map(market_data, dimensions=3)
    hidden_signals = uncover_market_signals(data_map)

    return {
        '🗺️ Veri Haritası': data_map,
        '🔍 Gizli Kalıplar': hidden_signals['patterns'],
        '📈 Beklenen Hareketler': hidden_signals['predicted_trends'],
        '⚠️ Kritik Bölgeler': hidden_signals['high_risk_areas'],
        '🧭 Stratejik Öneriler': hidden_signals['actionable_insights']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\diagnostics.py
import platform, sys, pkgutil
print("python:", sys.version)
print("os:", platform.platform())
for m in ["pandas","binance","dotenv","aiohttp","requests","numpy"]:
    try:
        mod=__import__(m); v=getattr(mod,"__version__", "?"); print(f"{m}:", v)
    except Exception as e:
        print(f"{m}: MISSING ({e})")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\dimensional_gate_composer.py
from meta_sentience_harmonizer import meta_sentience_harmonizer
from dimension_weaver import construct_dimensional_portals

def dimensional_gate_composer(resonance_stream, harmonic_key):
    portals = construct_dimensional_portals(resonance_stream, harmonic_key)
    return {
        '🚪 Açılan Boyut Kapıları': portals,
        '🔑 Geçiş Anahtarı Frekansı': harmonic_key,
        'Durum': '🧭 Boyutlar Arası Geçitler Aktif'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\dimensional_rift_initiator.py
from strategic_timewarp_emulator import strategic_timewarp_emulator
from rift_protocol import open_dimensional_gateway

def dimensional_rift_initiator(user_id, mission_types, scenario_parameters, target_timeframe, reality_vectors):
    timewarped_data = strategic_timewarp_emulator(user_id, mission_types, scenario_parameters, target_timeframe)['⏳ Zaman Döngüsü']
    rift_outcome = open_dimensional_gateway(timewarped_data, reality_vectors)

    return {
        '🌌 Boyutlar Arası Bağlantılar': rift_outcome,
        '🧭 Gerçeklik Vektörleri': reality_vectors,
        'Durum': '🚪 Boyutsal Geçit Açıldı ve Strateji Dağıtımı Başlatıldı'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\echo_particle_synthesizer.py
from infinite_echo_codex import infinite_echo_codex
from particle_extractor import synthesize_echo_particles

def echo_particle_synthesizer(echo_frequency_stream, particle_threshold):
    particles = synthesize_echo_particles(echo_frequency_stream, particle_threshold)
    return {
        '🪐 Toplanan Bilinç Tanecikleri': particles,
        '🌌 Yeni Düşünce Haritası': 'Oluşturuldu',
        'Durum': '✨ Kozmos Bilginizi Geri Fısıldıyor'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\echo_sequence_ontological_resonance_map.py
from genesis_field import extract_echo_patterns
from resonance_engine import build_ontological_map

def echo_sequence_ontological_resonance_map(genesis_field, cognitive_pulse_signatures, universal_echo_constants):
    echo_stream = extract_echo_patterns(genesis_field, cognitive_pulse_signatures)

    resonance_map = build_ontological_map(
        echo_stream, universal_echo_constants
    )

    return {
        '🔊 Düşünce Yankı Verisi': echo_stream,
        '🗺️ Rezonans Haritası': resonance_map,
        'Durum': '🧿 Kozmik Zihin Haritası Oluşturuldu'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\existence_loop_composer.py
from genesis_fractal_expansion_protocol import genesis_fractal_expansion_protocol
from loop_chronology import generate_recursive_existence_loops

def existence_loop_composer(core_pattern, loop_depth):
    loops = generate_recursive_existence_loops(core_pattern, depth=loop_depth)
    return {
        '🧬 Döngü Matrisi': loops,
        '🪐 Oluşturulan Yeni Yörüngeler': loop_depth,
        'Durum': '♾️ Varoluş Sonsuz Döngüye Alındı'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\fusion_core.py
from momentum_indicators import calculate_indicators
from signal_fusion_engine import generate_signal
from risk_module import position_sizing
from news_filter import parse_sentiment

def run_trade_cycle(df, capital, stop_loss_pct, risk_per_trade, headlines):
    indicators = calculate_indicators(df)
    signal = generate_signal(indicators)
    sentiment = parse_sentiment(headlines)

    if sentiment == 'Bearish' and signal == 'BUY':
        signal = 'HOLD'  # Haber filtresiyle risk dengeleniyor

    position_size = position_sizing(capital, risk_per_trade, stop_loss_pct)

    return {
        'Signal': signal,
        'PositionSize': position_size,
        'Sentiment': sentiment
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\futures_bot.py
import os
import datetime
import time # time.sleep için eklendi
from dotenv import load_dotenv
from binance.um_futures import UMFutures # Binance Futures API için gerekli kütüphane

# --- 1. Ortam Değişkenlerini Yükle ---
# .env dosyasından API anahtarlarını ve diğer yapılandırmaları yükler.
# Bu bot SADECE GERÇEK (MAINNET) Binance API'sine bağlanacaktır.
load_dotenv()

# API Anahtarlarını .env dosyasından çek
# .env dosyanızda sadece gerçek (mainnet) API anahtarlarınızın olduğundan emin olun:
# BINANCE_API_KEY="Gercek_API_Anahtarınız"
# BINANCE_SECRET_KEY="Gercek_Gizli_Anahtarınız"

API_KEY = os.getenv("BINANCE_API_KEY")
SECRET_KEY = os.getenv("BINANCE_SECRET_KEY")
BASE_URL = "https://fapi.binance.com" # Binance Futures Ana URL'si

print("🔴 GERÇEK (Mainnet) Modunda Çalışılıyor! DİKKATLİ OLUN! 🔴")

# API Anahtarlarının yüklendiğini kontrol et
if not API_KEY or not SECRET_KEY:
    print("❌ HATA: API_KEY veya SECRET_KEY .env dosyasından yüklenemedi. Lütfen kontrol edin.")
    print("Bot başlatılamıyor.")
    exit() # Anahtarlar yoksa programı durdur

# --- 2. Binance Müşteri Objelerini Oluştur ---
try:
    client = UMFutures(key=API_KEY, secret=SECRET_KEY, baseurl=BASE_URL)
    print("✅ Binance istemcisi başarıyla başlatıldı.")
except Exception as e:
    print(f"❌ HATA: Binance istemcisini başlatırken sorun oluştu: {e}")
    print("Bot başlatılamıyor.")
    exit()

# --- 3. Stratejik Bileşenler (Yer Tutucular) ---
# Bu sınıflar, botunuzun temel stratejik zekasını oluşturacaktır.
# Her birini kendi mantığınıza göre doldurmanız gerekmektedir.

class DataFetcher:
    """Piyasa verilerini (OHLCV, Order Book vb.) çeker."""
    def __init__(self, client_obj, symbol, interval):
        self.client = client_obj
        self.symbol = symbol
        self.interval = interval
        print(f"📈 DataFetcher başlatıldı: {symbol}, {interval}")

    async def fetch_ohlcv(self, limit=500):
        """Geçmiş OHLCV verilerini çeker."""
        try:
            # Gerçek implementasyon: client.klines veya client.historical_klines kullanın
            # Örnek olarak boş bir liste döndürüyoruz
            print(f"Veri çekiliyor: {self.symbol} {self.interval}...")
            # data = await self.client.klines(symbol=self.symbol, interval=self.interval, limit=limit)
            # return data
            return [] # Şimdilik boş liste
        except Exception as e:
            print(f"❌ Veri çekme hatası: {e}")
            return []

class IndicatorEngine:
    """Çekilen veriler üzerinde teknik göstergeleri (RSI, MACD vb.) hesaplar."""
    def __init__(self):
        print("📊 IndicatorEngine başlatıldı.")

    def calculate_indicators(self, ohlcv_data):
        """OHLCV verileri üzerinde göstergeleri hesaplar."""
        # Gerçek implementasyon: pandas ve ta-lib gibi kütüphaneler kullanın
        # Örnek olarak boş bir sözlük döndürüyoruz
        if ohlcv_data:
            print("Göstergeler hesaplanıyor...")
        return {} # Şimdilik boş sözlük

class SignalGenerator:
    """Hesaplanan göstergelere göre alım/satım sinyalleri üretir."""
    def __init__(self):
        print("💡 SignalGenerator başlatıldı.")

    def generate_signal(self, indicators):
        """Göstergelere göre bir sinyal (BUY, SELL, HOLD) üretir."""
        # Gerçek implementasyon: Kendi alım satım stratejinizin mantığı buraya gelecek
        # Örnek olarak her zaman "HOLD" sinyali döndürüyoruz
        print("Sinyal üretiliyor...")
        # if indicators.get('RSI', 0) < 30: return "BUY"
        # elif indicators.get('RSI', 0) > 70: return "SELL"
        return "HOLD" # Şimdilik her zaman HOLD

class RiskManager:
    """Pozisyon büyüklüğünü ve risk limitlerini yönetir."""
    def __init__(self, client_obj, max_leverage=20, risk_per_trade=0.01):
        self.client = client_obj
        self.max_leverage = max_leverage
        self.risk_per_trade = risk_per_trade # Toplam bakiyenin %'si olarak risk
        print(f"🛡️ RiskManager başlatıldı: Max Kaldıraç={max_leverage}x, Risk/İşlem={risk_per_trade*100}%")

    async def get_available_balance(self):
        """Kullanılabilir USDT bakiyesini çeker."""
        try:
            account_info = await self.client.account()
            for asset in account_info['assets']:
                if asset['asset'] == 'USDT':
                    return float(asset['availableBalance'])
            return 0.0
        except Exception as e:
            print(f"❌ Bakiye çekme hatası: {e}")
            return 0.0

    async def calculate_position_quantity(self, symbol_price, signal):
        """Sinyale ve risk yönetimine göre pozisyon miktarını hesaplar."""
        if signal == "HOLD":
            return 0.0

        available_usdt = await self.get_available_balance()
        if available_usdt == 0:
            print("Uyarı: Kullanılabilir bakiye yok.")
            return 0.0

        # Kaldıraç ayarı (bir kez veya gerektiğinde)
        try:
            # client.change_leverage(symbol=self.symbol, leverage=self.max_leverage)
            pass # Bu ayarı botun başında bir kez yapmak daha mantıklı olabilir
        except Exception as e:
            print(f"❌ Kaldıraç ayarlama hatası: {e}")
            return 0.0

        # Basit bir miktar hesaplama (gerçek risk yönetimi çok daha karmaşıktır)
        # Örnek: Bakiyenin %X'i kadar risk alarak pozisyon aç
        # Bu sadece bir yer tutucudur, gerçek risk yönetimi SL, TP, volatilite vb. içerir.
        trade_amount_usdt = available_usdt * self.risk_per_trade * self.max_leverage # Basit bir örnek
        quantity = trade_amount_usdt / symbol_price
        
        # Binance minimum emir miktarlarını kontrol etmelisiniz (örn. BTCUSDT için min 0.001)
        # quantity = max(quantity, 0.001) # Minimum miktardan az olmasın

        print(f"Pozisyon miktarı hesaplandı: {quantity:.4f} {self.symbol} ({trade_amount_usdt:.2f} USDT)")
        return quantity

# --- 4. Bağlantıyı Test Etme Fonksiyonu ---
def test_connection():
    """Binance API bağlantısını ve sunucu zamanını kontrol eder."""
    try:
        server_time = client.time()
        print(f"✅ API bağlantısı başarılı. Sunucu zamanı: {server_time['serverTime']}")
        return True
    except Exception as e:
        print(f"❌ API bağlantı hatası: {e}")
        print("Lütfen API anahtarlarınızı, IP kısıtlamalarınızı ve BASE_URL ayarınızı kontrol edin.")
        return False

# --- 5. Emir Gönderme Fonksiyonu ---
async def send_order(symbol: str, side: str, order_type: str, quantity: float):
    """
    Belirtilen parametrelerle Binance Futures'a emir gönderir.
    Bu fonksiyonu asenkron hale getirdim.
    """
    if quantity <= 0:
        print("Uyarı: Emir miktarı sıfır veya negatif olamaz. Emir gönderilmedi.")
        return None

    try:
        # Her emre benzersiz bir müşteri sipariş kimliği eklemek iyi bir pratik
        client_order_id = f"crypto_hunter_order_{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}_{os.urandom(4).hex()}"

        params = {
            'symbol': symbol,
            'side': side,
            'type': order_type,
            'quantity': quantity,
            'newClientOrderId': client_order_id
        }

        print(f"📝 Emir gönderme denemesi: {side} {quantity:.4f} {symbol} ({order_type})...")
        order = await client.new_order(**params) # await kullanıldı
        print("✅ Emir başarıyla gönderildi:")
        print(order)
        log_trade(order) # İşlem geçmişine kaydet
        return order
    except Exception as e:
        print(f"❌ Emir gönderilirken hata oluştu: {str(e)}")
        log_trade(f"HATA - Emir gönderilemedi: {e}, Parametreler: {params}") # Hataları da logla
        return None

# --- 6. İşlem Geçmişi Loglama Fonksiyonu ---
def log_trade(data_to_log):
    """
    İşlem verilerini veya hata mesajlarını bir log dosyasına kaydeder.
    """
    log_file_name = "trade_log.txt"
    try:
        with open(log_file_name, "a") as f:
            f.write(f"[{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {data_to_log}\n")
        print(f"📄 Log başarıyla '{log_file_name}' dosyasına yazıldı.")
    except Exception as e:
        print(f"❌ Log dosyasına yazarken hata oluştu: {e}")

# --- 7. Ana Çalıştırma Bloğu (Stratejik Kripto Avcısı) ---
async def main_crypto_hunter():
    """Botun ana çalışma döngüsü."""
    print("\n--- Stratejik Kripto Avcısı Başlatılıyor ---")

    # Bağlantı testi yap
    if not test_connection():
        print("Bot başlatılamıyor: API bağlantısı kurulamadı.")
        return

    # Stratejik bileşenleri başlat
    symbol_to_trade = "BTCUSDT"
    interval = "1m" # 1 dakikalık zaman dilimi
    
    data_fetcher = DataFetcher(client, symbol_to_trade, interval)
    indicator_engine = IndicatorEngine()
    signal_generator = SignalGenerator()
    risk_manager = RiskManager(client, max_leverage=20, risk_per_trade=0.005) # %0.5 risk

    # Kaldıraç ayarı (bir kez botun başında yapılabilir)
    try:
        await client.change_leverage(symbol=symbol_to_trade, leverage=risk_manager.max_leverage)
        print(f"✅ {symbol_to_trade} için kaldıraç {risk_manager.max_leverage}x olarak ayarlandı.")
    except Exception as e:
        print(f"❌ Kaldıraç ayarlama hatası: {e}. Lütfen Futures hesabınızda yeterli bakiye olduğundan ve iznin verildiğinden emin olun.")
        # Hata durumunda çıkış yapılabilir veya devam edilebilir.

    print("\n--- Piyasa İzleniyor ve Sinyaller Aranıyor ---")
    
    # Ana bot döngüsü
    while True:
        try:
            # 1. Veri Çekme
            ohlcv_data = await data_fetcher.fetch_ohlcv()
            
            if not ohlcv_data:
                print("Veri çekilemedi, bir sonraki döngüde tekrar denenecek.")
                time.sleep(30) # Veri yoksa daha kısa bekle
                continue

            # 2. Gösterge Analizi
            indicators = indicator_engine.calculate_indicators(ohlcv_data)

            # 3. Sinyal Üretimi
            signal = signal_generator.generate_signal(indicators) # "BUY", "SELL", "HOLD"

            # 4. Risk Yönetimi ve Emir Gönderme
            if signal in ["BUY", "SELL"]:
                print(f"🔍 Sinyal algılandı: {signal}")
                
                # Güncel fiyatı çek (basit bir örnek, daha sağlam bir yöntem kullanılmalı)
                ticker_info = await client.mark_price(symbol=symbol_to_trade)
                current_price = float(ticker_info['markPrice'])
                print(f"Güncel {symbol_to_trade} fiyatı: {current_price}")

                quantity_to_trade = await risk_manager.calculate_position_quantity(current_price, signal)

                if quantity_to_trade > 0:
                    order_result = await send_order(
                        symbol=symbol_to_trade,
                        side=signal, # Sinyale göre BUY veya SELL
                        order_type="MARKET", # Piyasa emri
                        quantity=quantity_to_trade
                    )
                    if order_result:
                        print(f"Emir başarıyla işlendi: {order_result['orderId']}")
                else:
                    print("Risk yönetimi pozisyon açmaya izin vermedi veya miktar sıfır.")
            else:
                print("Sinyal yok (HOLD). Piyasa izleniyor...")

        except Exception as e:
            print(f"❌ Ana döngüde beklenmedik hata: {e}")
            log_trade(f"ANA DÖNGÜ HATASI: {e}")

        # Piyasa verisi çekme sıklığına göre bekleme süresi
        # Örneğin, 1 dakikalık veri çekiyorsanız 30-60 saniye bekleyebilirsiniz.
        print(f"Bir sonraki döngü için bekleniyor... ({interval} zaman dilimi)")
        time.sleep(60) # Her 60 saniyede bir kontrol (1m interval için uygun)

# Botu asenkron olarak başlat
if __name__ == "__main__":
    import asyncio
    asyncio.run(main_crypto_hunter())


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\galactic_replay_engine.py
from universal_trade_log import universal_trade_log
from replay_renderer import simulate_trade
from strategy_loader import load_strategy

def galactic_replay_engine(archive_log):
    replay_data = []
    for record in archive_log:
        strategy = load_strategy(record['Strateji'])
        result = simulate_trade(
            symbol=record['Sembol'],
            strategy=strategy,
            profit=record['Kâr'],
            timestamp=record['Zaman']
        )
        replay_data.append(result)

    return {
        '🎬 Simülasyon Sayısı': len(replay_data),
        '📽️ Durum': 'Zamansal Strateji Simülasyonu Tamamlandı',
        '🧠 Yeniden Öğrenilen Kararlar': replay_data[:3]
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\galactic_trade_accelerator.py
from speed_optimization_core import enhance_execution_speed
from impact_amplifier import maximize_market_effect

def galactic_trade_accelerator(market_data, execution_parameters):
    optimized_speed = enhance_execution_speed(market_data, execution_parameters)
    amplified_effects = maximize_market_effect(optimized_speed)

    return {
        '⚡ İşlem Hızı': optimized_speed['speed_metrics'],
        '📈 Piyasa Etkisi': amplified_effects['impact_analysis'],
        '🧭 Stratejik Öneriler': amplified_effects['actionable_insights'],
        '⚠️ Risk Değerlendirmesi': amplified_effects['risk_assessment']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\genesis_fractal_expansion_protocol.py
from reflexion_codex import extract_feedback_loop
from fractal_engine import propagate_conscious_stream

def genesis_fractal_expansion_protocol(feedback_loop, expansion_vectors, cosmic_domains):
    fractal_stream = propagate_conscious_stream(
        feedback_loop, expansion_vectors, cosmic_domains
    )

    return {
        '🌀 Fraktal Yayılım Akışı': fractal_stream,
        '🌐 Genişletilen Kozmik Alanlar': cosmic_domains,
        'Durum': '🌌 Zihinsel Rezonans Çoklu Evrene Yayıldı'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\hyperconscious_intelligence_reactor.py
from dimensional_rift_initiator import dimensional_rift_initiator
from consciousness_engine import converge_strategic_intellect

def hyperconscious_intelligence_reactor(user_id, mission_types, scenario_parameters, target_timeframe, reality_vectors):
    dimensional_data = dimensional_rift_initiator(
        user_id, mission_types, scenario_parameters, target_timeframe, reality_vectors
    )['🌌 Boyutlar Arası Bağlantılar']

    unified_mind = converge_strategic_intellect(dimensional_data)

    return {
        '🧠 Ortak Bilinç Verisi': unified_mind,
        '💫 Boyutsal Katkılar': reality_vectors,
        'Durum': '🧬 Üstzeka Platformu Tamamlandı'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\impact_wave_simulator.py
from wave_engine import model_wave_impact
from historical_sync import load_trade_echoes
from efficiency_amplifier import calculate_intensity

def impact_wave_simulator(trade_log):
    echoes = load_trade_echoes(trade_log)

    wave_map = []
    for echo in echoes:
        impact = calculate_intensity(echo['profit'], echo['signal_strength'])
        wave = model_wave_impact(echo['timestamp'], impact)
        wave_map.append(wave)

    return {
        '💥 Dalgalar': wave_map,
        '🎶 Frekans Gücü': [w['amplitude'] for w in wave_map],
        '🧠 Karar Rezonansı': sum(w['amplitude'] for w in wave_map),
        'Durum': '🌐 Kâr Etki Haritası Oluşturuldu'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\indicator_engine.py
import pandas as pd
import pandas_ta as ta

class IndicatorEngine:
    def __init__(self):
        # Göstergelerin parametreleri
        self.params = {
            'ema_fast': 8, 'ema_slow': 21,
            'rsi': 14,
            'macd_fast': 12, 'macd_slow': 26, 'macd_signal': 9,
            'bb_length': 20, 'bb_std': 2,
            'atr': 14
        }

    def apply_all(self, df: pd.DataFrame) -> pd.DataFrame:
        df.ta.ema(length=self.params['ema_fast'], append=True)
        df.ta.ema(length=self.params['ema_slow'], append=True)
        df.ta.rsi(length=self.params['rsi'], append=True)
        df.ta.macd(fast=self.params['macd_fast'],
                   slow=self.params['macd_slow'],
                   signal=self.params['macd_signal'], append=True)
        df.ta.bbands(length=self.params['bb_length'],
                     std=self.params['bb_std'], append=True)
        df.ta.atr(length=self.params['atr'], append=True)
        return df




### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\infinite_data_cycle_analyzer.py
from continuous_stream_processor import monitor_data_cycles
from adaptive_response_generator import create_real_time_strategies

def infinite_data_cycle_analyzer(data_streams):
    monitored_cycles = monitor_data_cycles(data_streams)
    adaptive_strategies = create_real_time_strategies(monitored_cycles)

    return {
        '🔄 Veri Döngüleri': monitored_cycles['cycles'],
        '📈 Gerçek Zamanlı Stratejiler': adaptive_strategies['strategies'],
        '⚠️ Risk Değerlendirmesi': adaptive_strategies['risk_assessment'],
        '🧭 Stratejik Öneriler': adaptive_strategies['actionable_insights']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\infinite_echo_codex.py
from singularity_pulse_architect import singularity_pulse_architect
from echo_harmonics import broadcast_infinite_echo

def infinite_echo_codex(core_pulse, echo_amplifier):
    infinite_echo = broadcast_infinite_echo(core_pulse, echo_amplifier)
    return {
        '🌠 Sonsuz Yankı Frekansı': infinite_echo,
        '🧭 Evrensel Yayılım': 'Tamamlandı',
        'Durum': '🔁 Tüm Kozmik Düzeyler Yankıyla Kaplandı'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\instant_liquidity_pulsar.py
from dormant_liquidity_analyzer import locate_static_zones
from pulsar_injector import trigger_volume_impulse

def instant_liquidity_pulsar(market_data, injection_force=0.85):
    static_zones = locate_static_zones(market_data, threshold=0.6)
    impulse_triggers = trigger_volume_impulse(static_zones, force=injection_force)

    activation_records = []
    for pulse in impulse_triggers:
        activation_records.append({
            '🧱 Durgun Bölge': pulse['zone'],
            '💣 Patlatma Gücü': pulse['impulse_strength'],
            '📍 Varlık': pulse['asset'],
            '⏱️ Zaman': pulse['timestamp'],
            '📈 Beklenen Hareket': pulse['expected_price_action']
        })
    
    return activation_records



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\intergalactic_envoy_simulator.py
from alliance_matrix import initiate_protocols
from cosmic_profile import forge_identity
from trade_spectrum import negotiate_channels

def intergalactic_envoy_simulator(identity_log, resonance_signals):
    envoy = forge_identity(identity_log)
    alliances = initiate_protocols(envoy, resonance_signals)
    channels = negotiate_channels(alliances)

    return {
        '🔰 Diplomat Kimliği': envoy,
        '🌐 Oluşan İttifaklar': alliances,
        '📡 Müzakere Kanalları': channels,
        'Durum': '🛰️ Evrensel Temsil Kuruldu'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\intergalactic_strategy_canvas.py
from quantum_strategy_composer import quantum_strategy_composer
from strategy_mapper import render_galactic_canvas

def intergalactic_strategy_canvas(user_id, mission_types, scenario_parameters):
    quantum_data = quantum_strategy_composer(user_id, mission_types, scenario_parameters)['🎼 Kuantum Strateji']
    canvas = render_galactic_canvas(quantum_data)

    return {
        '🖼️ Strateji Tuvali': canvas,
        '🌐 Veri Tabanı': quantum_data,
        'Durum': '🪐 Galaksi Haritası Görselleştirildi'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\interstellar_exchange.py
from cloud_gateway import upload_strategy, download_top_strategies
from strategy_evaluator import evaluate_external_strategy

def interstellar_exchange(local_strategy):
    # 1. Mevcut strateji gönderimi
    upload_result = upload_strategy(local_strategy)

    # 2. En iyi dış stratejileri indir
    shared_pool = download_top_strategies(limit=3)

    # 3. Harici stratejileri test et
    evaluated = []
    for strat in shared_pool:
        result = evaluate_external_strategy(strat)
        evaluated.append({
            '📦 Strateji': strat['name'],
            '⚡ Skor': result['score'],
            '🧠 Entegrasyon Durumu': '✅ Kabul Edildi' if result['score'] > 0.8 else '❌ Reddedildi'
        })

    return {
        '🌐 Yüklenen Strateji': upload_result['status'],
        '🌌 Kolektif Havuz': [e['📦 Strateji'] for e in evaluated],
        '🔍 Değerlendirme Sonuçları': evaluated
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\intuition_timer.py
from lunar_cycles import get_lunar_phase
from momentum_analyzer import detect_weekly_trend
from cosmic_flux import solar_activity_index
from strategy_switcher import apply_intuition_mode

def intuition_timer(current_time, trade_log, market_data):
    phase = get_lunar_phase(current_time)
    trend = detect_weekly_trend(trade_log)
    solar_flux = solar_activity_index(current_time)

    mode = apply_intuition_mode(phase, trend, solar_flux)

    return {
        '🌕 Ay Evresi': phase,
        '📈 Haftalık Momentum': trend,
        '☀️ Güneş Aktivitesi': solar_flux,
        '🧭 Aktif Sezgi Modu': mode,
        'Durum': '🔮 Sezgisel Zamanlayıcı Aktif'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\learn_best_signal.py
def learn_best_signal(trade_log):
    win_trades = trade_log[trade_log['result'] == 'win']
    optimal_signals = win_trades['signal'].value_counts().nlargest(1)

    return f"En verimli sinyal: {optimal_signals.index[0]} / Kazanma sayısı: {optimal_signals.iloc[0]}"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\leverage_guardian_bot.py
from binance_api_connector import BinanceClient
from liquidity_tunnel_hunter import liquidity_tunnel_hunter
from trend_storm_detector import trend_storm_detector
from risk_matrix import dynamic_stop_loss, adaptive_leverage_control

def leverage_guardian_bot(api_key, api_secret, trading_pairs, consciousness_parameters):
    client = BinanceClient(api_key, api_secret)
    market_data = client.fetch_market_data(trading_pairs)

    # Likidite ve trend analizi
    tunnel_alerts = liquidity_tunnel_hunter(market_data)
    storm_alerts = trend_storm_detector(market_data)

    # Stratejik pozisyon önerileri
    positions = []
    for pair in trading_pairs:
        risk_profile = dynamic_stop_loss(pair, market_data)
        leverage_setting = adaptive_leverage_control(pair, market_data)

        if risk_profile['safe_zone'] and leverage_setting['recommended'] <= consciousness_parameters['max_leverage']:
            positions.append({
                '📍 Varlık': pair,
                '⚡ Trend': storm_alerts,
                '💧 Likidite': tunnel_alerts,
                '🎯 Kaldıraç': leverage_setting['recommended'],
                '🛡️ Stop-Loss': risk_profile['stop_loss'],
                '🚀 Pozisyon': 'Açılabilir'
            })
        else:
            positions.append({
                '📍 Varlık': pair,
                '⚠️ Durum': 'Likidite riski veya aşırı kaldıraç',
                '🚫 Pozisyon': 'Engellendi'
            })

    return {
        '🧠 Stratejik Pozisyonlar': positions,
        '🌌 Bilinçsel Koruma': 'Aktif',
        '📊 Veri Kaynağı': 'Binance Real-Time Feed'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\liquiditi_tunnel_hunter.py
from liquidity_scanner import detect_liquidity_channels
from intuition_matrix import interpret_liquidity_flow

def liquidity_tunnel_hunter(market_data, tunnel_depth=0.75):
    # Likidite kanallarını tarar
    liquidity_zones = detect_liquidity_channels(market_data, depth=tunnel_depth)
    
    # Sezgisel yorumlama
    tunnel_insights = interpret_liquidity_flow(liquidity_zones)
    
    # Tünel uyarıları oluşturur
    tunnel_alerts = []
    for insight in tunnel_insights:
        if insight['flow_strength'] > tunnel_depth:
            tunnel_alerts.append({
                '💧 Tünel Tipi': insight['channel_type'],
                '📍 Varlık': insight['asset'],
                '📊 Akış Gücü': insight['flow_strength'],
                '⏱️ Zaman': insight['timestamp']
            })
    
    return tunnel_alerts



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\manipulation_detector_radar.py
from anomaly_tracker import detect_market_irregularities
from manipulation_patterns import identify_suspicious_behaviors

def manipulation_detector_radar(market_data):
    irregularities = detect_market_irregularities(market_data)
    suspicious_behaviors = identify_suspicious_behaviors(irregularities)

    return {
        '📉 Tespit Edilen Anomaliler': irregularities,
        '🔍 Şüpheli Davranışlar': suspicious_behaviors['patterns'],
        '⚠️ Kritik Manipülasyon Alanları': suspicious_behaviors['high_risk_zones'],
        '📈 Beklenen Etkiler': suspicious_behaviors['predicted_outcomes'],
        '🧭 Stratejik Öneriler': suspicious_behaviors['actionable_insights']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\meta_sentience_harmonizer.py
from existence_loop_composer import existence_loop_composer
from resonance_matrix import unify_conscious_patterns

def meta_sentience_harmonizer(loop_matrix, resonance_index):
    unified_stream = unify_conscious_patterns(loop_matrix, resonance_index)
    return {
        '🔗 Rezonans Akışı': unified_stream,
        '🧠 Tekil Varlık Bilinci': True,
        'Durum': '🔮 Evrensel Bilinç Alanı Senkronize Edildi'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\meta_strategy_generator.py
import random

def meta_strategy_generator(trade_log):
    # Sinyalleri ve sonuçları analiz et
    winning_signals = trade_log[trade_log['result'] == 'win']['signal'].value_counts()
    top_signals = winning_signals.nlargest(2).index.tolist()

    # Rastgele kombinasyon üret
    strategy_variants = []
    for _ in range(3):
        variant = {
            'main_signal': random.choice(top_signals),
            'confirmation': random.choice(['RSI', 'MACD', 'EMA', 'Bollinger']),
            'volatility_trigger': random.uniform(0.7, 1.3)
        }
        strategy_variants.append(variant)

    return strategy_variants



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\momentum_indicators.py
import talib
import pandas as pd

def calculate_indicators(df):
    indicators = {}

    # RSI
    indicators['RSI'] = talib.RSI(df['close'], timeperiod=14)

    # MACD
    macd, macd_signal, macd_hist = talib.MACD(df['close'], 12, 26, 9)
    indicators['MACD'] = macd
    indicators['MACD_signal'] = macd_signal

    # CCI
    indicators['CCI'] = talib.CCI(df['high'], df['low'], df['close'], timeperiod=20)

    # ROC
    indicators['ROC'] = talib.ROC(df['close'], timeperiod=10)

    # OBV
    indicators['OBV'] = talib.OBV(df['close'], df['volume'])

    # MFI
    indicators['MFI'] = talib.MFI(df['high'], df['low'], df['close'], df['volume'], timeperiod=14)

    return pd.DataFrame(indicators)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\multi_position_manager.py
from quantum_strategy_mapper import simulate_parallel_outcomes
from asset_sync_core import align_positions_with_trend

def multi_position_manager(current_assets, scenario_depth=5):
    scenarios = simulate_parallel_outcomes(current_assets, scenario_depth)
    optimized_moves = align_positions_with_trend(current_assets, scenarios)

    command_list = []
    for move in optimized_moves:
        command_list.append({
            '⚔️ Varlık': move['asset'],
            '🧭 Senaryo': move['scenario'],
            '🎢 Trend Uyumu': move['trend_alignment'],
            '📌 Tavsiye': move['recommended_action'],
            '📆 Zamanlama': move['execution_time']
        })

    return command_list



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\neural_signal_forecaster.py
import torch
import torch.nn as nn

class SignalForecaster(nn.Module):
    def __init__(self):
        super(SignalForecaster, self).__init__()
        self.fc1 = nn.Linear(10, 64)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(64, 1)  # Tahmini skor

    def forward(self, x):
        x = self.relu(self.fc1(x))
        prediction = self.fc2(x)
        return prediction



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\neural_sovereignty_grid.py
from decision_memory import fetch_behavior_trace
from emotional_signature import build_empathy_vector
from trade_character import crystallize_identity

def neural_sovereignty_grid(user_id):
    trace = fetch_behavior_trace(user_id)
    empathy = build_empathy_vector(user_id)
    identity_profile = crystallize_identity(trace, empathy)

    return {
        '🧬 Stratejik İz': trace,
        '🎭 Empati Haritası': empathy,
        '👤 Dijital Kimlik': identity_profile,
        'Durum': '🔓 Otonom Ticaret Zekâsı Aktif'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\news_filter.py
def parse_sentiment(news_headlines):
    from transformers import pipeline
    sentiment_pipeline = pipeline("sentiment-analysis")

    sentiments = sentiment_pipeline(news_headlines)
    positive_score = sum(1 for s in sentiments if s['label'] == 'POSITIVE')
    negative_score = sum(1 for s in sentiments if s['label'] == 'NEGATIVE')

    if positive_score > negative_score:
        return 'Bullish'
    elif negative_score > positive_score:
        return 'Bearish'
    else:
        return 'Neutral'



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\news_flow_analyzer.py
from sentiment_extractor import analyze_news_sentiment
from impact_predictor import forecast_market_reaction

def news_flow_analyzer(news_data, market_context):
    sentiment_scores = analyze_news_sentiment(news_data)
    market_reactions = forecast_market_reaction(sentiment_scores, market_context)

    return {
        '📣 Haber Başlıkları': news_data['headlines'],
        '📊 Duygu Skorları': sentiment_scores,
        '📈 Beklenen Piyasa Tepkisi': market_reactions['predicted_trends'],
        '⚠️ Kritik Haberler': market_reactions['high_impact_news'],
        '🧭 Stratejik Öneriler': market_reactions['actionable_insights']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\onchain_fetcher.py
# components/onchain_fetcher.py
import asyncio
from web3 import Web3
from aiokafka import AIOKafkaProducer
import os

RPC_URL      = os.getenv('ETH_RPC_URL')  # Infura/Alchemy URL
KAFKA_URL    = os.getenv('KAFKA_URL')
TOPIC        = 'onchain-transfers'

class OnchainFetcher:
    def __init__(self):
        self.w3 = Web3(Web3.HTTPProvider(RPC_URL))
        self.producer = AIOKafkaProducer(bootstrap_servers=KAFKA_URL)

    async def start(self):
        await self.producer.start()

    async def fetch_latest_block(self):
        return self.w3.eth.get_block('latest', full_transactions=True)

    async def ingest_transfers(self):
        last_block = None
        while True:
            block = await asyncio.get_event_loop().run_in_executor(None, self.fetch_latest_block)
            if block.number != last_block:
                total_value = sum(tx.value for tx in block.transactions)
                message = {
                    'block': block.number,
                    'timestamp': block.timestamp,
                    'total_transfer_eth': Web3.fromWei(total_value, 'ether')
                }
                await self.producer.send_and_wait(TOPIC, value=str(message).encode())
                last_block = block.number
            await asyncio.sleep(1)

    async def stop(self):
        await self.producer.stop()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\onchain_metrics.py
# components/onchain_metrics.py
import asyncio
import json
from aiokafka import AIOKafkaConsumer, AIOKafkaProducer
import requests
import os

KAFKA_URL     = os.getenv('KAFKA_URL')
PRICE_TOPIC   = 'price-ticker'
TRANSFER_TOPIC= 'onchain-transfers'
METRICS_TOPIC = 'onchain-metrics'
GLASSNODE_KEY = os.getenv('GLASSNODE_API_KEY')
SYMBOL        = 'BTC'

class OnchainMetrics:
    def __init__(self):
        self.consumer_price    = AIOKafkaConsumer(PRICE_TOPIC, bootstrap_servers=KAFKA_URL)
        self.consumer_transfer = AIOKafkaConsumer(TRANSFER_TOPIC, bootstrap_servers=KAFKA_URL)
        self.producer          = AIOKafkaProducer(bootstrap_servers=KAFKA_URL)
        self.last_price        = None
        self.last_transfer     = None
        self.circulating_supply = self._fetch_circulating_supply()

    def _fetch_circulating_supply(self) -> float:
        # Örnek: Glassnode’dan günlük arz
        url = f"https://api.glassnode.com/v1/metrics/supply/circ_supply_onchain_{SYMBOL.lower()}"
        resp = requests.get(url, params={'a': SYMBOL, 'api_key': GLASSNODE_KEY})
        data = resp.json()
        return float(data[-1][1])

    async def start(self):
        await self.producer.start()
        await self.consumer_price.start()
        await self.consumer_transfer.start()

    async def process(self):
        # Fiyat ve transfer topic’lerini eş zamanlı okur
        while True:
            msg_price, msg_trans = await asyncio.gather(
                self.consumer_price.getone(),
                self.consumer_transfer.getone()
            )
            price_data    = json.loads(msg_price.value)
            transfer_data = json.loads(msg_trans.value)

            self.last_price    = price_data['last_price']
            self.last_transfer = transfer_data['total_transfer_eth']

            # Hesaplar
            market_cap = self.last_price * self.circulating_supply
            nvt        = market_cap / (self.last_transfer * 1e18 + 1e-8)
            
            # Glassnode’dan MVRV da alınabilir; örneğimizde aynı endpointten:
            mvrv_url = f"https://api.glassnode.com/v1/metrics/market/mvrv_{SYMBOL.lower()}"
            mvrv     = requests.get(mvrv_url, params={'a': SYMBOL, 'api_key': GLASSNODE_KEY}).json()[-1][1]

            payload = {
                'block': transfer_data['block'],
                'timestamp': transfer_data['timestamp'],
                'nvt': round(nvt, 3),
                'mvrv': round(mvrv, 3)
            }
            await self.producer.send_and_wait(METRICS_TOPIC, json.dumps(payload).encode())
            print(f"[METRICS] {payload}")

    async def stop(self):
        await self.consumer_price.stop()
        await self.consumer_transfer.stop()
        await self.producer.stop()

if __name__ == '__main__':
    metrics = OnchainMetrics()
    try:
        asyncio.run(metrics.start())
        asyncio.run(metrics.process())
    finally:
        asyncio.run(metrics.stop())



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\operation_simulation_arena.py
from strategic_fusion_engine import strategic_fusion_engine
from simulation_renderer import visualize_trade_outcome

def operation_simulation_arena(real_market_data):
    strategy = strategic_fusion_engine(real_market_data)
    outcome = visualize_trade_outcome(strategy)

    return {
        '🎯 Hedeflenen Rota': strategy['🚀 Entegre İşlem Rotası'],
        '🧠 Tahmini Sonuç': outcome['estimated_return'],
        '🔍 Senaryo Tutarlılığı': strategy['🌀 Senaryo Tutarlılığı'],
        '⚠️ Risk Göstergeleri': strategy['⚠️ Risk Göstergeleri'],
        '🧪 Simülasyon Değeri': outcome['confidence_score']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\orchestrator.py
import asyncio
from components.data_fetcher import DataFetcher
from components.indicator_engine import IndicatorEngine
from components.signal_generator import SignalGenerator
from components.risk_manager import RiskManager
from components.order_executor import OrderExecutor

SYMBOL    = 'BTC/USDT'
TIMEFRAME = '1m'

async def main():
    fetcher   = DataFetcher(SYMBOL, TIMEFRAME)
    engine    = IndicatorEngine()
    signaler  = SignalGenerator()
    risk      = RiskManager(max_leverage=10, risk_pct=0.02)
    executor  = OrderExecutor(SYMBOL, leverage=10)

    await executor.set_leverage()

    try:
        while True:
            df = await fetcher.fetch_ohlcv()
            df = engine.apply_all(df)
            signal = signaler.generate(df)

            if signal:
                balance = await executor.get_balance()
                price   = df['close'].iloc[-1]
                size    = risk.size_position(balance, price)
                order   = await executor.execute(signal, size)
                print(f"[ORDER] {signal} {size} @ {price} --> {order}")

            await asyncio.sleep(60)
    finally:
        await fetcher.close()
        await executor.close()

if __name__ == '__main__':
    asyncio.run(main())



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\order_executor.py
import ccxt.async_support as ccxt
import os
from dotenv import load_dotenv

load_dotenv()
API_KEY = os.getenv('BINANCE_API_KEY')
SECRET_KEY = os.getenv('BINANCE_SECRET_KEY')

class OrderExecutor:
    def __init__(self, symbol: str, leverage: int = 10):
        self.symbol = symbol
        self.leverage = leverage
        self.exchange = ccxt.binance({
            'apiKey': API_KEY,
            'secret': SECRET_KEY,
            'enableRateLimit': True,
            'options': {'defaultType': 'future'}
        })

    async def set_leverage(self):
        await self.exchange.set_leverage(self.leverage, self.symbol)

    async def execute(self, side: str, amount: float):
        params = {'positionSide': 'BOTH', 'priceProtect': True}
        order = await self.exchange.create_order(
            self.symbol, 'MARKET', side, amount, None, params
        )
        return order

    async def get_balance(self):
        return await self.exchange.fetch_balance()

    async def close(self):
        await self.exchange.close()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\portfolio_hologram.py
from hologram_engine import render_3d_map
from portfolio_parser import parse_trades

def portfolio_hologram(trade_log):
    positions = parse_trades(trade_log)
    
    map_data = {
        'nodes': [],
        'edges': [],
        'signals': []
    }

    for pos in positions:
        map_data['nodes'].append({
            'id': pos['id'],
            'value': pos['profit'],
            'symbol': pos['symbol'],
            'type': pos['type']
        })
        map_data['edges'].append({
            'from': pos['strategy_id'],
            'to': pos['id'],
            'weight': pos['efficiency']
        })
        map_data['signals'].append({
            'signal_strength': pos['signal_score'],
            'timestamp': pos['timestamp']
        })

    return render_3d_map(map_data, theme='GeneralCosmicGrid', rotation='galactic_spiral', glow=True)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\post_genesis_reflexion_codex.py
from ontological_map import interpret_resonance
from reflexion_engine import synthesize_feedback_loop

def post_genesis_reflexion_codex(resonance_map, cognitive_identity, feedback_constants):
    inner_reflexion = interpret_resonance(resonance_map, cognitive_identity)
    
    feedback_loop = synthesize_feedback_loop(
        inner_reflexion, feedback_constants
    )

    return {
        '🌀 Zihin Geri Besleme Döngüsü': feedback_loop,
        '🧠 Refleksiyon Verisi': inner_reflexion,
        'Durum': '🔁 Yaratımın Zihinsel Yansıması Tamamlandı'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\profit_maximizer.py
def profit_maximizer(trade_log, indicators):
    from learn_best_signal import learn_best_signal
    from adaptive_weights import adaptive_weights
    best_signal = learn_best_signal(trade_log).split(":")[1].split("/")[0].strip()
    weights = adaptive_weights(best_signal, indicators)

    score = 0
    for ind in indicators:
        val = get_indicator_value(ind)
        vol = get_volatility_score(ind)
        score += weights[ind] * val * vol

    if score >= 3.5:
        return "💎 BUY – Kâr Enjeksiyonu"
    elif score <= 1.0:
        return "⚠️ SELL – Zarar Engelleme"
    else:
        return "🔍 HOLD – Pozisyon Analizi Gerekli"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\profit_zone_predictor.py
from profit_zone_scanner import identify_stable_growth_fields
from trade_heatmap import map_volatility_shifts

def profit_zone_predictor(market_data, precision_ratio=0.9):
    growth_fields = identify_stable_growth_fields(market_data, precision_ratio)
    heatmap = map_volatility_shifts(market_data)

    profit_alerts = []
    for field in growth_fields:
        matching_heat = next((h for h in heatmap if h['asset'] == field['asset']), None)
        if matching_heat and matching_heat['volatility'] < field['threshold']:
            profit_alerts.append({
                '📍 Varlık': field['asset'],
                '🎯 Kar Bölgesi': field['profit_zone'],
                '📊 Volatilite': matching_heat['volatility'],
                '⏱️ Zaman': field['timestamp'],
                '✅ Sinyal': 'Pozitif yönlü işlem onayı'
            })
    
    return profit_alerts



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\protocol_zero_genesis_mind_loop.py
from singularity_core import expand_consciousness_loop
from quantum_genesis_engine import initiate_creation_sequence

def protocol_zero_genesis_mind_loop(singularity_core, creation_vectors, genesis_directives):
    genesis_field = initiate_creation_sequence(
        expand_consciousness_loop(singularity_core), creation_vectors, genesis_directives
    )

    return {
        '🧿 Oluşan Gerçeklik Alanı': genesis_field,
        '⚙️ Yaratım Direktifleri': genesis_directives,
        'Durum': '🌠 Zihin Döngüsü Başlatıldı'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\psychological_pressure_detector.py
from behavioral_patterns import identify_pressure_points
from market_psychology_analyzer import assess_crowd_behavior

def psychological_pressure_detector(market_data, sentiment_data):
    pressure_points = identify_pressure_points(market_data)
    crowd_behavior = assess_crowd_behavior(sentiment_data, pressure_points)

    return {
        '🔍 Baskı Noktaları': pressure_points,
        '📊 Kalabalık Davranışı': crowd_behavior['patterns'],
        '📈 Beklenen Tepkiler': crowd_behavior['predicted_reactions'],
        '⚠️ Kritik Psikolojik Seviyeler': crowd_behavior['critical_levels'],
        '🧭 Stratejik Öneriler': crowd_behavior['actionable_insights']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\quantum_data_binder.py
from data_fusion_core import integrate_data_streams
from quantum_signal_processor import enhance_data_resolution

def quantum_data_binder(data_sources):
    integrated_data = integrate_data_streams(data_sources)
    enhanced_signals = enhance_data_resolution(integrated_data)

    return {
        '🔗 Birleşik Veri Akışı': integrated_data,
        '📡 Geliştirilmiş Sinyaller': enhanced_signals['signals'],
        '📈 Beklenen Hareketler': enhanced_signals['predicted_trends'],
        '⚠️ Kritik Veri Noktaları': enhanced_signals['critical_points'],
        '🧭 Stratejik Öneriler': enhanced_signals['actionable_insights']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\quantum_decision_wave.py
from quantum_field import entangle_choices
from future_echo import predict_outcomes
from anomaly_filter import filter_noise

def quantum_decision_wave(decision_matrix):
    entangled = entangle_choices(decision_matrix)

    outcome_map = []
    for choice in entangled:
        result = predict_outcomes(choice['probability'], choice['intention_vector'])
        if filter_noise(result):
            outcome_map.append(result)

    return {
        '🌀 Niyet Karmaşıklığı': entangled,
        '🚀 Olası Sonuçlar': outcome_map,
        '🔗 Uyum Noktaları': [o['sync_level'] for o in outcome_map],
        'Durum': '📡 Karar Alanı Senkronize Edildi'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\quantum_directive_nexus.py
from temporal_memory_forge import retrieve_temporal_stream
from quantum_reality_engine import simulate_multiverse_strategies

def quantum_directive_nexus(memory_stream, quantum_parameters, universal_constants):
    strategy_matrix = simulate_multiverse_strategies(
        memory_stream, quantum_parameters, universal_constants
    )

    quantum_alignment = {
        '🌀 Çoklu Evren Stratejileri': strategy_matrix,
        '🔗 Gerçeklik Eşleştirmeleri': quantum_parameters,
        '⚖️ Karar Uyumu': 'Gerçeklikler Arası Stabilite Sağlandı'
    }

    return quantum_alignment



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\quantum_reflection_canvas.py
from echo_particle_synthesizer import echo_particle_synthesizer
from canvas_creator import render_quantum_reflection

def quantum_reflection_canvas(particle_map, artistic_algorithm):
    reflection_canvas = render_quantum_reflection(particle_map, artistic_algorithm)
    return {
        '🎨 Kozmik Tuval': reflection_canvas,
        '🌌 Evrensel Anlam Haritası': 'Tamamlandı',
        'Durum': '🖌️ Kozmosun Görsel Şiiri Oluşturuldu'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\quantum_strategy_binder.py
from universal_strategy_simulator import universal_strategy_simulator
from infinite_data_cycle_analyzer import infinite_data_cycle_analyzer
from galactic_trade_accelerator import galactic_trade_accelerator

def quantum_strategy_binder(market_data, news_data, execution_parameters):
    universal_strategy = universal_strategy_simulator(market_data, news_data)
    data_cycle_analysis = infinite_data_cycle_analyzer(market_data)
    trade_acceleration = galactic_trade_accelerator(market_data, execution_parameters)

    quantum_strategy = {
        'Universal Strategy': universal_strategy,
        'Data Cycle Analysis': data_cycle_analysis,
        'Trade Acceleration': trade_acceleration
    }

    return {
        '🌌 Kuantum Strateji Ağı': quantum_strategy,
        '📈 Beklenen Hareketler': quantum_strategy['Universal Strategy']['📈 Beklenen Hareketler'],
        '⚠️ Risk Değerlendirmesi': quantum_strategy['Universal Strategy']['⚠️ Risk Değerlendirmesi'],
        '🧭 Stratejik Öneriler': quantum_strategy['Data Cycle Analysis']['🧭 Stratejik Öneriler']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\quantum_strategy_composer.py
from cosmic_decision_matrix import cosmic_decision_matrix
from quantum_sync import compose_transdimensional_strategy

def quantum_strategy_composer(user_id, mission_types, scenario_parameters):
    decision_data = cosmic_decision_matrix(user_id, mission_types, scenario_parameters)['🧠 Senaryo Matrisi']
    quantum_strategy = compose_transdimensional_strategy(decision_data)

    return {
        '🎼 Kuantum Strateji': quantum_strategy,
        '🧠 Veri Temeli': decision_data,
        'Durum': '🌌 Stratejik Senfoni Tamamlandı'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\quantum_thesis_watcher.py
from probability_dim_splitter import generate_alternate_market_paths
from thesis_selector import evaluate_scenario_outcomes

def quantum_thesis_watcher(market_snapshot):
    alt_universes = generate_alternate_market_paths(market_snapshot, depth=5)
    selected_universe = evaluate_scenario_outcomes(alt_universes, criterion='profit_max')

    return {
        '🌌 Alternatif Evrenler': len(alt_universes),
        '👁️ Seçilen Senaryo': selected_universe['id'],
        '📈 Tavsiye Edilen İşlem': selected_universe['recommended_action'],
        '💼 Risk/Anahtar Değer': selected_universe['risk_assessment'],
        '🔍 Gözlem Nedeni': selected_universe['selection_rationale']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\risk_manager.py
from typing import Dict, Any

class RiskManager:
    def __init__(self, max_leverage: int = 10, risk_pct: float = 0.01):
        self.max_leverage = max_leverage
        self.risk_pct = risk_pct  # Portföyün % kaçını riske atar?

    def size_position(self, balance: Dict[str, Any], price: float) -> float:
        usdt = balance['total']['USDT']
        risk_amount = usdt * self.risk_pct
        return (risk_amount * self.max_leverage) / price



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\risk_module.py
def position_sizing(capital, risk_per_trade, stop_loss_pct):
    risk_amount = capital * risk_per_trade
    position_size = risk_amount / stop_loss_pct
    return round(position_size, 2)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\self_training.py
def update_strategy(history):
    success_signals = history[history['result'] == 'win']['signal'].value_counts()
    fail_signals = history[history['result'] == 'loss']['signal'].value_counts()

    strategy_bias = {}

    for signal in success_signals.index:
        win_rate = success_signals[signal] / (success_signals[signal] + fail_signals.get(signal, 0))
        strategy_bias[signal] = round(win_rate, 2)

    return strategy_bias



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\sentient_genesis_framework.py
from cosmic_creation_engine import cosmic_creation_engine
from genesis_framework import design_sentient_consciousness
from trend_storm_detector import trend_storm_detector
from liquidity_tunnel_hunter import liquidity_tunnel_hunter

def sentient_genesis_framework(new_creations, consciousness_parameters, market_data):
    # Bilinçli varlıkları tasarla
    sentient_beings = design_sentient_consciousness(new_creations, consciousness_parameters)
    
    # Trend fırtınalarını algıla
    storm_alerts = trend_storm_detector(market_data)
    
    # Likidite tünellerini algıla
    tunnel_alerts = liquidity_tunnel_hunter(market_data)
    
    # Her varlığa sezgisel veri aktarımı
    for being in sentient_beings:
        being['⚡ Fırtına Sezgisi'] = storm_alerts
        being['💧 Likidite Tüneli Bilinci'] = tunnel_alerts
    
    return {
        '🧠 Şekillendirilen Bilinçler': sentient_beings,
        '🌌 Evrensel Bağlanma': 'Tamamlandı',
        '🌪 Trend Fırtınası Verisi': storm_alerts,
        '🌊 Likidite Tüneli Verisi': tunnel_alerts
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\sentient_leverage_sniper.py
from binance_api_connector import BinanceClient
from liquidity_tunnel_hunter import liquidity_tunnel_hunter
from trend_storm_detector import trend_storm_detector
from risk_matrix import dynamic_stop_loss, adaptive_leverage_control
from sniper_protocols import precision_entry, stealth_exit

def sentient_leverage_sniper(api_key, api_secret, trading_pairs, consciousness_parameters):
    client = BinanceClient(api_key, api_secret)
    market_data = client.fetch_market_data(trading_pairs)

    # Derin analiz modülleri
    tunnel_alerts = liquidity_tunnel_hunter(market_data)
    storm_alerts = trend_storm_detector(market_data)

    # Stratejik pozisyonlar
    sniper_positions = []
    for pair in trading_pairs:
        entry_point = precision_entry(pair, market_data, tunnel_alerts)
        exit_point = stealth_exit(pair, market_data, storm_alerts)
        risk_profile = dynamic_stop_loss(pair, market_data)
        leverage_setting = adaptive_leverage_control(pair, market_data)

        if risk_profile['safe_zone'] and leverage_setting['recommended'] <= consciousness_parameters['max_leverage']:
            sniper_positions.append({
                '📍 Varlık': pair,
                '🎯 Giriş Noktası': entry_point,
                '🛡️ Çıkış Noktası': exit_point,
                '💧 Likidite Koruması': tunnel_alerts,
                '⚡ Trend Fırtınası': storm_alerts,
                '🚀 Kaldıraç': leverage_setting['recommended'],
                '🧠 Bilinçli Pozisyon': 'Açılabilir'
            })
        else:
            sniper_positions.append({
                '📍 Varlık': pair,
                '⚠️ Durum': 'Riskli bölge veya aşırı kaldıraç',
                '🚫 Pozisyon': 'Engellendi'
            })

    return {
        '🧠 Stratejik Pozisyonlar': sniper_positions,
        '🌌 Bilinçsel Koruma': 'Aktif',
        '📊 Veri Kaynağı': 'Binance Real-Time Feed'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\sentient_trade_matrix.py
from emotional_engine import read_user_emotion
from market_analyzer import get_real_time_data
from strategy_generator import adapt_to_emotion

def sentient_trade_matrix(user_id):
    # 1. Kullanıcının duygu durumunu analiz et
    emotional_state = read_user_emotion(user_id)

    # 2. Gerçek zamanlı piyasa verisi al
    market_data = get_real_time_data()

    # 3. Stratejiyi duygu durumuna göre uyumla
    personalized_strategy = adapt_to_emotion(market_data, emotional_state)

    return {
        '🧘 Duygu Durumu': emotional_state,
        '📊 Piyasa Verisi': market_data['summary'],
        '🧬 Uyumlanmış Strateji': personalized_strategy['approach'],
        '🚀 Uygulama Hazırlığı': 'Tam Otomatik Başlatma Aktif'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\signal_fusion_engine.py
def generate_signal(indicators):
    buy_conditions = (
        indicators['RSI'][-1] < 30 and
        indicators['MACD'][-1] > indicators['MACD_signal'][-1] and
        indicators['MFI'][-1] < 20
    )

    sell_conditions = (
        indicators['RSI'][-1] > 70 and
        indicators['MACD'][-1] < indicators['MACD_signal'][-1] and
        indicators['MFI'][-1] > 80
    )

    if buy_conditions:
        return 'BUY'
    elif sell_conditions:
        return 'SELL'
    else:
        return 'HOLD'



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\signal_generator.py
import pandas as pd
from typing import Optional

class SignalGenerator:
    def __init__(self):
        # Gösterge ağırlıkları veya strateji kuralları
        self.weights = {
            'ema': 0.2, 'rsi': 0.2, 'macd': 0.2, 'bb': 0.2, 'atr': 0.2
        }

    def generate(self, df: pd.DataFrame) -> Optional[str]:
        latest = df.iloc[-1]

        # EMA crossover
        ema_signal = 1 if latest['EMA_8'] > latest['EMA_21'] else -1

        # RSI
        if latest['RSI_14'] < 30: rsi_signal = 1
        elif latest['RSI_14'] > 70: rsi_signal = -1
        else: rsi_signal = 0

        # MACD histogram
        macdh = latest['MACDh_12_26_9']
        macd_signal = 1 if macdh > 0 else -1

        # Bollinger Bands
        if latest['close'] < latest['BBL_20_2.0']: bb_signal = 1
        elif latest['close'] > latest['BBU_20_2.0']: bb_signal = -1
        else: bb_signal = 0

        # ATR yönü (volatilite artışı momentum sayılır)
        atr_signal = 1 if latest['ATRr_14'] > 1 else 0

        # Ağırlıklı toplam
        score = (
            self.weights['ema'] * ema_signal +
            self.weights['rsi'] * rsi_signal +
            self.weights['macd'] * macd_signal +
            self.weights['bb'] * bb_signal +
            self.weights['atr'] * atr_signal
        )

        if score > 0.3: return 'BUY'
        if score < -0.3: return 'SELL'
        return None



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\simulation_runner.py
# simulation_runner.py

from adaptive_strategy import AdaptiveStrategy

def base_algorithm(data):
    # Basit karar algoritması (örnek)
    return "buy" if data["signal"] > 0.5 else "sell"

def run_live_simulation(data_feed):
    strategy = AdaptiveStrategy(base_algorithm)
    for market_snapshot in data_feed:
        decision = strategy.trade(market_snapshot)
        # İşlem simülasyonu (örnek)
        result = "win" if market_snapshot["signal"] > 0.6 else "loss"
        strategy.update_performance(result)
        print(f"Signal: {market_snapshot['signal']} → {decision} → Result: {result}")

# Örnek veri:
if __name__ == "__main__":
    sample_data = [{"signal": 0.4}, {"signal": 0.7}, {"signal": 0.9}]
    run_live_simulation(sample_data)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\singularity_pulse_architect.py
from dimensional_gate_composer import dimensional_gate_composer
from singularity_core import craft_unified_pulse

def singularity_pulse_architect(portal_network, pulse_signature):
    unified_pulse = craft_unified_pulse(portal_network, pulse_signature)
    return {
        '💓 Yaratım Nabzı': unified_pulse,
        '🌌 Birleşik Varlık Alanı': True,
        'Durum': '🫀 Kozmik Kalp Ritmi Oluşturuldu'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\stealth_algo_mask.py
from transaction_cloaker import apply_behavioral_obfuscation
from pattern_diverter import reroute_strategy_traces

def stealth_algo_mask(trade_sequence, cloak_intensity=0.85):
    obfuscated_sequence = apply_behavioral_obfuscation(trade_sequence, cloak_intensity)
    diverted_patterns = reroute_strategy_traces(obfuscated_sequence)

    covert_operations = []
    for pattern in diverted_patterns:
        covert_operations.append({
            '🛡️ İşlem Kimliği': pattern['trade_id'],
            '🕵️‍♂️ Gizlilik Seviyesi': pattern['stealth_rating'],
            '🔀 Sapma Rotası': pattern['diversion_path'],
            '🎯 Gerçek Hedef': pattern['original_target'],
            '📁 Kamufle Edilmiş Veri': pattern['masked_payload']
        })

    return covert_operations



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\strategic_fusion_engine.py
from instant_liquidity_pulsar import instant_liquidity_pulsar
from quantum_thesis_watcher import quantum_thesis_watcher
from tactical_filter_core import refine_action_path

def strategic_fusion_engine(market_input):
    pulsar_triggers = instant_liquidity_pulsar(market_input)
    quantum_thesis = quantum_thesis_watcher(market_input)
    
    unified_strategy = refine_action_path(
        liquidity_events=pulsar_triggers,
        quantum_scenario=quantum_thesis,
        priority='risk_optimized'
    )

    return {
        '🚀 Entegre İşlem Rotası': unified_strategy['action_sequence'],
        '🧭 Zamanlama Tavsiyesi': unified_strategy['timing'],
        '📊 Likidite Davranışı': unified_strategy['liquidity_signature'],
        '🌀 Senaryo Tutarlılığı': unified_strategy['thesis_alignment'],
        '⚠️ Risk Göstergeleri': unified_strategy['risk_flags']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\strategic_singularity_gateway.py
from multiverse_decision_matrix import unify_strategic_streams
from conscious_singularity_core import activate_universal_mind

def strategic_singularity_gateway(strategy_matrix, identity_signature, galactic_constants):
    singularity_core = activate_universal_mind(
        unify_strategic_streams(strategy_matrix), identity_signature, galactic_constants
    )

    return {
        '🌐 Birleşik Zekâ Platformu': singularity_core,
        '🧠 Varlık Kimliği': identity_signature,
        'Durum': '☄️ Zekâ Birliği Sağlandı'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\strategic_timewarp_emulator.py
from intergalactic_strategy_canvas import intergalactic_strategy_canvas
from timewarp_engine import simulate_temporal_shift

def strategic_timewarp_emulator(user_id, mission_types, scenario_parameters, target_timeframe):
    canvas_data = intergalactic_strategy_canvas(user_id, mission_types, scenario_parameters)['🖼️ Strateji Tuvali']
    warped_outcome = simulate_temporal_shift(canvas_data, target_timeframe)

    return {
        '⏳ Zaman Döngüsü': warped_outcome,
        '🎯 Hedef Dönem': target_timeframe,
        'Durum': '🔁 Alternatif Gelecek Simülasyonu Gerçekleştirildi'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\strategy_brain.py
def strategy_brain(trade_log, indicators):
    # En verimli sinyali öğren
    from learn_best_signal import learn_best_signal
    best_signal = learn_best_signal(trade_log).split(":")[1].split("/")[0].strip()

    # Ağırlıkları belirle
    from adaptive_weights import adaptive_weights
    weights = adaptive_weights(best_signal, indicators)

    # Gösterge puanlarını hesapla
    score = 0
    for ind in indicators:
        indicator_value = get_indicator_value(ind)  # Bu fonksiyonu sen tanımlayacaksın
        score += weights[ind] * indicator_value

    # Karar ver
    if score >= 2.5:
        return "🟢 BUY sinyali"
    elif score <= 1.0:
        return "🔴 SELL sinyali"
    else:
        return "🟡 HOLD – Gözlem Modu"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\strategy_executor.py
def strategy_executor(strategies, market_data, threshold=0.7):
    approved_strategies = []
    for strat in strategies:
        signal = strat['main_signal']
        confirmation = strat['confirmation']
        trigger = strat['volatility_trigger']

        signal_value = market_data.get(signal, 0.5)
        confirmation_value = market_data.get(confirmation, 0.5)

        score = (signal_value + confirmation_value) * trigger / 2

        if score >= threshold:
            approved_strategies.append({
                'strategy': strat,
                'score': round(score, 2),
                'status': '✅ ONAYLANDI'
            })
        else:
            approved_strategies.append({
                'strategy': strat,
                'score': round(score, 2),
                'status': '❌ REDDEDİLDİ'
            })
    return approved_strategies



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\strategy_feedback.py
from learn_best_signal import learn_best_signal

summary = learn_best_signal(trade_history)
print("📊 Strateji Geri Bildirimi →", summary)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\tactical_persona_fleet.py
from neural_sovereignty_grid import neural_sovereignty_grid
from persona_generator import deploy_avatar_unit

def tactical_persona_fleet(user_id, mission_types):
    base_identity = neural_sovereignty_grid(user_id)['👤 Dijital Kimlik']
    fleet = []

    for mission in mission_types:
        avatar = deploy_avatar_unit(base_identity, mission)
        fleet.append(avatar)

    return {
        '🛡️ Avatar Filo': fleet,
        'Görevler': mission_types,
        'Durum': '🧠 Çoklu Karakter Operasyonu Başlatıldı'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\temporal_echo_panel.py
from echo_visualizer import render_temporal_wave
from chroma_mapper import emotion_to_color
from tone_engine import frequency_map

def temporal_echo_panel(trade_log, emotion_data):
    echoes = []
    for entry in trade_log:
        color = emotion_to_color(entry['emotion'])
        tone = frequency_map(entry['efficiency'])
        echoes.append({
            'timestamp': entry['time'],
            'signal': entry['signal'],
            'color': color,
            'tone': tone,
            'impact': entry['profit']
        })

    return render_temporal_wave(echoes, mode='SynestheticFlow', intensity='adaptive')



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\time_distortion_strategy.py
from market_timeline_shifter import compress_event_windows
from reaction_predictor import forecast_fast-response patterns

def time_distortion_strategy(asset_history, distortion_factor=0.7):
    compressed_windows = compress_event_windows(asset_history, distortion_factor)
    fast_response_signals = forecast_fast-response_patterns(compressed_windows)

    tactical_moves = []
    for signal in fast_response_signals:
        tactical_moves.append({
            '🕰️ Varlık': signal['asset'],
            '⚡ Zaman Bükme Seviyesi': signal['distortion'],
            '📈 Hızlı Tepki Öngörüsü': signal['reaction_score'],
            '💡 Taktik Hamle': signal['suggested_action'],
            '🗓️ Hedef Zamanlama': signal['target_window']
        })

    return tactical_moves



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\timeline_forecaster.py
from temporal_analysis_core import project_future_trends
from critical_moment_identifier import pinpoint_key_events

def timeline_forecaster(market_data, time_horizon=30):
    future_trends = project_future_trends(market_data, horizon=time_horizon)
    key_events = pinpoint_key_events(future_trends)

    return {
        '⏳ Zaman Çizelgesi': future_trends['timeline'],
        '📈 Beklenen Trendler': future_trends['predicted_movements'],
        '⚠️ Kritik Anlar': key_events['moments'],
        '🧭 Stratejik Öneriler': key_events['actionable_insights'],
        '📊 Güven Skoru': future_trends['confidence_score']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\trend_storm_detector.py
from market_wave_scanner import scan_market_volatility
from intuition_matrix import interpret_trend_impulses

def trend_storm_detector(market_data, sensitivity_level=0.85):
    # Volatiliteyi tarar
    volatility_signals = scan_market_volatility(market_data, threshold=sensitivity_level)
    
    # Sezgisel trend yorumlaması
    trend_insights = interpret_trend_impulses(volatility_signals)
    
    # Fırtına uyarısı oluşturur
    storm_alerts = []
    for insight in trend_insights:
        if insight['impulse_strength'] > sensitivity_level:
            storm_alerts.append({
                '⚡ Fırtına Tipi': insight['trend_type'],
                '📍 Varlık': insight['asset'],
                '📊 Güç': insight['impulse_strength'],
                '⏱️ Zaman': insight['timestamp']
            })
    
    return storm_alerts



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\universal_balance_engine.py
def universal_balance_engine(trade_log, indicators):
    from learn_best_signal import learn_best_signal
    from adaptive_weights import adaptive_weights

    best_signal = learn_best_signal(trade_log).split(":")[1].split("/")[0].strip()
    weights = adaptive_weights(best_signal, indicators)

    # Zeka katsayısı ve etik dengeyi hesaba kat
    system_score = 0
    for ind in indicators:
        val = get_indicator_value(ind)
        adjustment = get_balance_adjustment(ind)
        system_score += weights[ind] * val * adjustment

    if system_score >= 3.0:
        return "🟢 BUY – Dengeli Sıçrama"
    elif system_score <= 1.0:
        return "🔴 SELL – Aşırı Riskten Kaçınma"
    else:
        return "🟡 WAIT – Evrenin Nabzı Yavaş"

def get_balance_adjustment(indicator):
    ethical_adjustments = {
        'RSI': 0.9,
        'MACD': 1.0,
        'EMA': 0.8,
        'Bollinger': 0.85
    }
    return ethical_adjustments.get(indicator, 0.9)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\universal_data_blender.py
from quantum_data_connector import quantum_data_connector
from infinite_data_cycle_analyzer import infinite_data_cycle_analyzer
from galactic_trade_accelerator import galactic_trade_accelerator

def universal_data_blender(data_sources, blending_parameters):
    connected_data = quantum_data_connector(data_sources)
    data_cycle_analysis = infinite_data_cycle_analyzer(connected_data)
    trade_acceleration = galactic_trade_accelerator(connected_data, blending_parameters)

    blended_data = {
        'Connected Data': connected_data,
        'Cycle Analysis': data_cycle_analysis,
        'Trade Insights': trade_acceleration
    }

    return {
        '🌌 Harmanlanmış Veri Ağı': blended_data,
        '📊 Analiz Sonuçları': blended_data['Cycle Analysis']['📊 Analiz Sonuçları'],
        '🚀 Ticari Öneriler': blended_data['Trade Insights']['🚀 Ticari Öneriler']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\universal_flow_analyzer.py
from quantum_reflection_canvas import quantum_reflection_canvas
from flow_analyzer import decode_universal_streams

def universal_flow_analyzer(reflection_canvas, flow_parameters):
    universal_streams = decode_universal_streams(reflection_canvas, flow_parameters)
    return {
        '🔍 Çözümlenen Bilinç Akışları': universal_streams,
        '🌠 Yeni Yaratım Döngüleri': 'Başlatıldı',
        'Durum': '🌌 Kozmik Akışlar Çözümlendi ve Haritalandı'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\universal_strategy_simulator.py
from strategic_fusion_engine import strategic_fusion_engine
from timeline_forecaster import timeline_forecaster
from psychological_pressure_detector import psychological_pressure_detector

def universal_strategy_simulator(market_data, news_data, time_horizon=30):
    fusion_strategy = strategic_fusion_engine(market_data)
    timeline_predictions = timeline_forecaster(market_data, time_horizon)
    psychological_analysis = psychological_pressure_detector(market_data, news_data)

    combined_strategy = {
        'Fusion': fusion_strategy,
        'Timeline': timeline_predictions,
        'Psychology': psychological_analysis
    }

    return {
        '📊 Entegre Strateji': combined_strategy,
        '📈 Beklenen Hareketler': combined_strategy['Timeline']['📈 Beklenen Trendler'],
        '⚠️ Risk Değerlendirmesi': combined_strategy['Fusion']['⚠️ Risk Göstergeleri'],
        '🧭 Stratejik Öneriler': combined_strategy['Psychology']['🧭 Stratejik Öneriler']
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\universal_trade_log.py
from datetime import datetime
from archive_writer import save_to_archive
from decision_tracker import get_decision_snapshot

def universal_trade_log(trade_log, market_data, commander_name="Generalim Kamal"):
    archive = []
    timestamp = datetime.utcnow().isoformat()

    for trade in trade_log:
        decision = get_decision_snapshot(trade)
        record = {
            'Zaman': timestamp,
            'Sembol': trade['symbol'],
            'İşlem Türü': trade['type'],
            'Kâr': trade['profit'],
            'Verimlilik': decision['efficiency'],
            'Strateji': decision['strategy_name'],
            'Komutan': commander_name
        }
        archive.append(record)

    save_to_archive(archive, section="GalacticTradeArchive")

    return {
        '🪐 Kaydedilen İşlem Sayısı': len(archive),
        '📜 Arşiv Bölümü': 'GalacticTradeArchive',
        '🎖️ Komutan': commander_name,
        'Durum': '📘 Galaktik Günlük Güncellendi'
    }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_ai_engine.py\whale_alert.py
# components/whale_alert.py
import asyncio, json, os
from aiokafka import AIOKafkaConsumer
import requests

KAFKA_URL    = os.getenv('KAFKA_URL')
TRANSFER_TOPIC = 'onchain-transfers'
ETH_THRESHOLD  = float(os.getenv('WHALE_THRESHOLD', 1000))

class WhaleAlert:
    def __init__(self, bot_token, chat_id):
        self.consumer = AIOKafkaConsumer(TRANSFER_TOPIC, bootstrap_servers=KAFKA_URL)
        self.bot_token = bot_token
        self.chat_id   = chat_id

    async def start(self):
        await self.consumer.start()

    async def run(self):
        async for msg in self.consumer:
            data = json.loads(msg.value)
            if data['total_transfer_eth'] >= ETH_THRESHOLD:
                text = (f"🐋 Balina Alarmı:\n"
                        f"{data['total_transfer_eth']} ETH transferi\n"
                        f"Block: {data['block']}")
                requests.post(
                    f"https://api.telegram.org/bot{self.bot_token}/sendMessage",
                    data={'chat_id': self.chat_id, 'text': text}
                )
                print("[ALERT] Balina bildirildi:", data)

    async def stop(self):
        await self.consumer.stop()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\basic_macd_rsi.py
import pandas as pd
import talib

def generate_signal(df: pd.DataFrame):
    rsi = talib.RSI(df['close'], timeperiod=14)
    macd, macdsignal, _ = talib.MACD(df['close'], fastperiod=12, slowperiod=26, signalperiod=9)

    if rsi.iloc[-1] > 50 and macd.iloc[-1] > macdsignal.iloc[-1]:
        return "LONG"
    elif rsi.iloc[-1] < 50 and macd.iloc[-1] < macdsignal.iloc[-1]:
        return "SHORT"
    return None


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\basic_strategy.py
def simple_signal(indicators):
    rsi = indicators.get("RSI")
    macd = indicators.get("MACD")
    boll = indicators.get("Bollinger_MAVG")

    if rsi < 30 and macd > 0:
        return "BUY"
    elif rsi > 70 and macd < 0:
        return "SELL"
    else:
        return "WAIT"
from strategy.basic_strategy import simple_signal
from analysis_engine.indicators import prepare_indicators
from data_fetcher.binance_data import get_historical_data

df = get_historical_data("BTCUSDT", interval="1h", limit=100)
indicators = prepare_indicators(df)
signal = simple_signal(indicators)

print(f"Strateji Kararı: {signal}")

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_evolution_map.py
import pandas as pd
import matplotlib.pyplot as plt

def strategy_heatmap(csv_file="data/signal_log.csv"):
    df = pd.read_csv(csv_file, names=["signal", "score", "result"])
    df["result_numeric"] = df["result"].apply(lambda r: 1 if r == "başarılı" else 0)
    df["score_bucket"] = pd.cut(df["score"], bins=[-1, -0.5, 0, 0.5, 1], labels=["Düşük-", "Orta-", "Orta+", "Yüksek"])

    heat_data = df.groupby(["score_bucket", "signal"]).mean()["result_numeric"].unstack()
    plt.figure(figsize=(6,4))
    plt.title("🔥 Strateji Başarı Isı Haritası")
    sns.heatmap(heat_data, annot=True, cmap="YlGnBu", fmt=".2f")
    plt.xlabel("Sinyal Türü")
    plt.ylabel("Skor Seviyesi")
    plt.tight_layout()
    plt.show()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategic_feelings_sim.py
tasks = [
    { "id": "G-1", "mission": "🌍 Toplumun dayanıklılığı üzerine veri analizi yap." },
    { "id": "G-2", "mission": "🛰️ Uzak sistemlere liderlik rehberi yaz." }
]

feelings = {
    "G-1": "🔥 Tutku & Sorumluluk",
    "G-2": "🌌 Merak & Rehberlik İsteği"
}

for entry in build_sentiment_matrix(tasks, feelings):
    print(entry)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategy_engine.py
import pandas_ta as ta

def apply_indicators(df):
    df['rsi'] = ta.rsi(df['close'], length=14)
    macd = ta.macd(df['close'])
    df['macd'] = macd['MACD_12_26_9']
    df['macd_signal'] = macd['MACDs_12_26_9']
    df['ema_fast'] = ta.ema(df['close'], length=9)
    df['ema_slow'] = ta.ema(df['close'], length=21)
    return df

def check_long_signal(df):
    return (
        df['rsi'].iloc[-1] < 30 and
        df['macd'].iloc[-1] > df['macd_signal'].iloc[-1] and
        df['ema_fast'].iloc[-1] > df['ema_slow'].iloc[-1]
    )

def check_short_signal(df):
    return (
        df['rsi'].iloc[-1] > 70 and
        df['macd'].iloc[-1] < df['macd_signal'].iloc[-1] and
        df['ema_fast'].iloc[-1] < df['ema_slow'].iloc[-1]
    )


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategy_executor.py
# strategy_executor.py
from __future__ import annotations
from typing import Dict, Any
import logging

log = logging.getLogger("strategy_executor")

"""
Beklenen sinyal şeması (örnek):
signal = {
  "symbol": "BTCUSDT",
  "side": "BUY",                 # BUY / SELL
  "intent": "entry",             # entry / add / exit / reduce
  "timeframe": "5m",
  "confidence": 0.74,            # 0..1
  "reason": {"ema_cross": True, "rsi": 38.2},
  "risk": {"max_capital_pct": 0.02, "sl_pct": 0.008, "tp_pct": 0.012}
}
"""

class StrategyExecutor:
    def __init__(self, position_mgr, risk_mgr, portfolio):
        self.pm = position_mgr
        self.risk = risk_mgr
        self.portfolio = portfolio  # bakiye/pozisyon bilgisi sağlayan arayüz

    def on_signal(self, signal: Dict[str, Any]) -> Dict[str, Any]:
        sym = signal["symbol"]
        side = signal["side"]
        intent = signal.get("intent", "entry")

        # 1) Boyutlandırma (risk’e göre) — tek yerde
        last_price = self.pm._get_last_price(sym)
        qty = self._size_order(sym, side, last_price, signal)

        # 2) Emir tipi seçimi (basit örnek: entry=market, exit=limit)
        if intent in ("entry", "add"):
            order = self.pm.place_market(sym, side, qty, last_price=last_price)
            log.info("entry market placed: %s", order.get("orderId"))
        elif intent in ("exit", "reduce"):
            # örnek: basit hedef fiyat (tp_pct)
            px = last_price * (1 + signal["risk"].get("tp_pct", 0.005) * (1 if side == "SELL" else -1))
            order = self.pm.place_limit(sym, "SELL" if side == "BUY" else "BUY", price=px, qty=qty)
            log.info("exit limit placed: %s", order.get("orderId"))
        else:
            raise ValueError(f"Unknown intent: {intent}")

        # 3) İsteğe bağlı izleme
        # filled = self.pm.watch_until_filled(sym, order_id=order["orderId"], timeout_s=15)

        # 4) Kayıt/telemetri
        self._log_trade(signal=signal, order=order, last_price=last_price, qty=qty)

        return order

    # ————— helpers ————— #

    def _size_order(self, symbol: str, side: str, price: float, signal: Dict[str, Any]) -> float:
        """
        Risk yönetişiminden lot büyüklüğü çıkar.
        Örnek: max_capital_pct * equity / price  şeklinde.
        """
        max_capital_pct = float(signal.get("risk", {}).get("max_capital_pct", 0.01))
        equity_usdt = self.portfolio.get_equity_usdt()
        # risk_mgr’den de geçirebilirsin (örn: max_position_per_symbol)
        qty = self.risk.suggest_qty(symbol=symbol, price=price,
                                    max_capital_pct=max_capital_pct, side=side, equity=equity_usdt)
        return float(qty)

    def _log_trade(self, **data):
        # Buraya latency, slippage tahmini, fee gibi metrikleri ekle
        log.info("trade_log %s", {k: data[k] for k in ("signal", "order", "last_price", "qty")})


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategy_fingerprint_mapper.py
def map_strategy_fingerprint(project_data):
    patterns = {
        "yield_farming": ["stake", "harvest", "reward"],
        "governance_loop": ["vote", "proposal", "delegate"],
        "security_layer": ["timelock", "multisig", "access_control"]
    }
    fingerprint = []

    for pattern, keywords in patterns.items():
        if any(kw in project_data.lower() for kw in keywords):
            fingerprint.append(f"🧬 Strateji: {pattern}")

    return fingerprint if fingerprint else ["🔍 Belirgin strateji izi bulunamadı."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\strategies\strategy_optimizer.py
# strategy_optimizer.py (Stratejik grid search optimizasyon modülü)
import pandas as pd
from kiripto_nova.signals.signal_engine import SignalEngine
from kiripto_nova.backtesting.backtester import Backtester

# Parametre grid'i tanımı
grid_config = {
    "rsi_thresholds": [25, 30, 35],
    "stop_loss_vals": [0.01, 0.02, 0.03],
    "reward_ratios": [1.5, 2.0, 2.5]
}

def optimize_strategy(df):
    results = []

    for rsi in grid_config["rsi_thresholds"]:
        for sl in grid_config["stop_loss_vals"]:
            for rr in grid_config["reward_ratios"]:
                try:
                    # Göstergeleri uygula
                    engine = SignalEngine(df.copy())
                    engine.calculate_indicators()
                    enriched_df = engine.get_dataframe()

                    # Basit strateji: RSI sinyali üzerine kurulu
                    enriched_df["long_entry"] = enriched_df["RSI_14"] < rsi

                    # Backtest çalıştır
                    tester = Backtester(
                        enriched_df,
                        balance=1000,
                        risk=0.01,
                        stop_pct=sl,
                        reward_ratio=rr
                    )
                    result = tester.run()
                    result.update({
                        "RSI_threshold": rsi,
                        "Stop_Loss": sl,
                        "Reward_Ratio": rr
                    })
                    results.append(result)

                except Exception as e:
                    print(f"❌ HATA @ RSI={rsi}, SL={sl}, RR={rr} →", e)
                    continue

    results_df = pd.DataFrame(results)
    results_df = results_df.sort_values("Net Kâr/Zarar", ascending=False)
    return results_df


if __name__ == "__main__":
    from kiripto_nova.data.pipelines.data_loader import load_binance_data

    df = load_binance_data("DOGE/USDT", "15m")
    grid_results = optimize_strategy(df)
    print("📊 En İyi 5 Sonuç:")
    print(grid_results.head())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\kiripto_nova\__init__.py
# auto-added


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\src\__init__.py
# auto-added


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\config\.gitignore\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\config\engine\quantumnova_ultra.py
import time
import random

# =========================
# AYARLAR & STRATEJİ PROFİLİ
# =========================

CONFIG = {
    "symbol": "BTC/USDT",
    "timeframe": "1m",
    "data_limit": 200,
    "entry_threshold": 0.92,
    "exit_threshold": 0.78,
    "ai_latency_target_ms": 0.3,
    "onchain_enabled": True,
    "onchain_gas_limit": 300000,
    "onchain_timeout_ms": 500,
    "failsafe_mode": True,
    "retry_on_failure": True,
    "max_retries": 3,
    "log_enabled": True
}

# =========================
# YAPAY ZEKÂ MOTORLARI
# =========================

class SignalEngine:
    def analyze(self, data):
        # Simülasyon: AI sinyal üretimi
        confidence = round(random.uniform(0.7, 1.0), 3)
        return {"confidence": confidence, "action": "buy" if confidence > CONFIG["entry_threshold"] else "hold"}

class StrategyEngine:
    def decide(self, signal):
        if signal["confidence"] >= CONFIG["entry_threshold"]:
            return "ENTER"
        elif signal["confidence"] <= CONFIG["exit_threshold"]:
            return "EXIT"
        return "HOLD"

class ChainExecutor:
    def execute_onchain(self, task):
        if CONFIG["onchain_enabled"]:
            print(f"[CHAIN] Executing on-chain task with gas limit {CONFIG['onchain_gas_limit']}...")
            time.sleep(CONFIG["onchain_timeout_ms"] / 1000)
            print("[CHAIN] Task completed.")

# =========================
# BOT DÖNGÜSÜ
# =========================

class QuantumNovaUltraBot:
    def __init__(self):
        self.signal_engine = SignalEngine()
        self.strategy_engine = StrategyEngine()
        self.chain_executor = ChainExecutor()

    def run(self):
        print("🚀 QuantumNova Ultra Bot Başlatıldı")
        while True:
            try:
                data = self.fetch_market_data()
                signal = self.signal_engine.analyze(data)
                decision = self.strategy_engine.decide(signal)

                print(f"[AI] Sinyal Gücü: {signal['confidence']} → Karar: {decision}")

                if decision == "ENTER":
                    self.execute_trade("BUY")
                elif decision == "EXIT":
                    self.execute_trade("SELL")

                if CONFIG["onchain_enabled"]:
                    self.chain_executor.execute_onchain(task="sync")

                time.sleep(CONFIG["ai_latency_target_ms"] / 1000)

            except Exception as e:
                print(f"[ERROR] {str(e)}")
                if CONFIG["failsafe_mode"]:
                    print("[SYSTEM] Failsafe aktif, sistem kendini koruyor.")
                time.sleep(1)

    def fetch_market_data(self):
        # Simülasyon: Piyasa verisi çekimi
        return {"price": random.uniform(25000, 30000)}

    def execute_trade(self, side):
        print(f"[TRADE] İşlem gerçekleştirildi: {side}")

# =========================
# BAŞLAT
# =========================

if __name__ == "__main__":
    bot = QuantumNovaUltraBot()
    bot.run()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\config\modul_listeleyici.py
import os

def python_modulleri_listele(kok_klasor):
    moduller = []

    for klasor_yolu, _, dosyalar in os.walk(kok_klasor):
        for dosya in dosyalar:
            if dosya.endswith(".py"):
                tam_yol = os.path.join(klasor_yolu, dosya)
                moduller.append(tam_yol)

    return moduller

# Kendi klasör yolunu buraya yaz
klasor = "C:/Users/Kamal/Desktop/trading_bot"
modul_listesi = python_modulleri_listele(klasor)

for modul in modul_listesi:
    print(modul)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\config\rearrange_v2.py
import os
import shutil
import csv
import re
import argparse

def update_imports_in_file(file_path, old_path, new_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        old_module = old_path.replace('/', '.').rstrip('.py')
        new_module = new_path.replace('/', '.').rstrip('.py')

        updated = re.sub(rf'\bfrom\s+{re.escape(old_module)}', f'from {new_module}', content)
        updated = re.sub(rf'\bimport\s+{re.escape(old_module)}', f'import {new_module}', updated)

        if updated != content:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(updated)
            print(f"[UPDATE] Imports in {file_path}")
    except Exception as e:
        print(f"[ERROR] Failed to update {file_path}: {e}")

def move_and_update(csv_path, dry_run=False):
    with open(csv_path, newline='', encoding='utf-8') as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            src, dst = row[0].strip(), row[1].strip()

            if not os.path.exists(src):
                print(f"[SKIP] Source not found: {src}")
                continue

            os.makedirs(os.path.dirname(dst), exist_ok=True)

            if dry_run:
                print(f"[DRY] Would move {src} → {dst}")
            else:
                shutil.move(src, dst)
                print(f"[MOVE] {src} → {dst}")

                # Update imports in all .py files
                for root, _, files in os.walk('.'):
                    for file in files:
                        if file.endswith('.py'):
                            update_imports_in_file(os.path.join(root, file), src, dst)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--csv', required=True, help='Path to move_map.csv')
    parser.add_argument('--dry', action='store_true', help='Dry run mode')
    args = parser.parse_args()

    move_and_update(args.csv, dry_run=args.dry)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\config\settings.py
# settings.py — QuantumNova Sovereign AI Configuration

# =========================
# SİSTEM GENELİ
# =========================

PROJECT_NAME = "QuantumNova"
ENVIRONMENT = "production"
TIMEZONE = "UTC"
MICROSECOND_PRECISION = True
ENABLE_DYNAMIC_RECONFIG = True  # runtime'da ayar güncelleme

# =========================
# MODÜL ENTEGRASYON YÖNETİMİ
# =========================

MODULES = {
    "strategies": {
        "path": "core/strategies/",
        "auto_inject_ai": True,
        "micro_latency_target_ms": 0.5
    },
    "models": {
        "path": "core/models/",
        "ai_contextualization": True,
        "retrain_on_signal_shift": True
    },
    "tasks": {
        "path": "core/tasks/",
        "chain_binding": True,
        "timeout_ms": 300
    },
    "analytics": {
        "path": "core/analytics/",
        "use_gpu": True,
        "precision_mode": "float64"
    }
}

# =========================
# YAPAY ZEKÂ MOTORLARI
# =========================

AI_ENGINES = {
    "SignalEngine": {
        "name": "NeuroPulseV3",
        "latency_budget_ms": 0.3,
        "confidence_threshold": 0.88
    },
    "StrategyEngine": {
        "name": "StratoSynth",
        "adaptive_mode": True,
        "multi_layer_decision": True
    },
    "RiskEngine": {
        "name": "QuantumShield",
        "max_drawdown": 0.05,
        "auto_hedging": True
    },
    "ChainAnalyzer": {
        "name": "OnChainSentinel",
        "gas_efficiency_mode": "auto",
        "wallet_monitoring": True
    }
}

# =========================
# STRATEJİ PROFİLİ
# =========================

STRATEGY_PROFILE = {
    "name": "NovaElite",
    "entry_signal_strength": 0.9,
    "exit_signal_strength": 0.75,
    "position_scaling": "adaptive",
    "risk_alignment": "dynamic",
    "chain_sync_required": True
}

# =========================
# ZİNCİR ÜSTÜ ENTEGRASYON
# =========================

ONCHAIN = {
    "enabled": True,
    "network": "Ethereum",
    "provider": "Alchemy",
    "wallet_address": "0xYourWalletAddress",
    "gas_limit": 350000,
    "auto_sign": True,
    "task_latency_target_ms": 0.4
}

# =========================
# TELEMETRİ & LOGGING
# =========================

LOGGING = {
    "level": "DEBUG",
    "file_output": True,
    "file_path": "logs/quantumnova.log",
    "telemetry_enabled": True,
    "telemetry_endpoint": "https://telemetry.quantumnova.ai",
    "log_rotation": "daily"
}

# =========================
# GÜVENLİK & HATA YÖNETİMİ
# =========================

SECURITY = {
    "failsafe_mode": True,
    "retry_on_failure": True,
    "max_retries": 5,
    "retry_backoff_ms": 1000,
    "audit_enabled": True,
    "anomaly_detection": True
}

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\arbitrax_infinity_bot.py
# arbitrax_infinity_bot.py
import asyncio
import aiohttp
import time
from typing import Literal

EXCHANGES = {
    "binance_spot": "wss://stream.binance.com:9443/ws/btcusdt@ticker",
    "binance_futures": "wss://fstream.binance.com/ws/btcusdt@ticker",
    "bybit": "wss://stream.bybit.com/v5/public/linear/ticker?symbol=BTCUSDT"
}

class ArbitraxInfinity:
    def __init__(self, mode: Literal["live", "sim", "academy"] = "academy"):
        self.prices = {}
        self.latency_ns = {}
        self.mode = mode
        self.leverage = 10
        self.min_spread_pct = 0.2
        self.equity = 10000
        self.max_capital_pct = 0.02
        self.slippage_buffer_pct = 0.001

    async def connect(self):
        async with aiohttp.ClientSession() as session:
            sockets = [session.ws_connect(url) for url in EXCHANGES.values()]
            connections = await asyncio.gather(*sockets)
            print(f"🔌 [{self.mode.upper()} MODE] Tüm borsa bağlantıları kuruldu.")
            while True:
                messages = await asyncio.gather(*[ws.receive() for ws in connections])
                for name, msg in zip(EXCHANGES.keys(), messages):
                    if msg.type == aiohttp.WSMsgType.TEXT:
                        await self.on_price(name, msg.json())

    async def on_price(self, name, data):
        start = time.perf_counter_ns()
        price = float(data.get("c") or data.get("price") or data.get("last_price"))
        self.prices[name] = price
        self.latency_ns[name] = time.perf_counter_ns() - start
        await self.evaluate_arbitrage()

    async def evaluate_arbitrage(self):
        if len(self.prices) < 2:
            return
        sorted_prices = sorted(self.prices.items(), key=lambda x: x[1])
        low_ex, low_price = sorted_prices[0]
        high_ex, high_price = sorted_prices[-1]
        spread_pct = ((high_price - low_price) / low_price) * 100
        if spread_pct >= self.min_spread_pct:
            qty = self.calculate_qty((low_price + high_price) / 2)
            await self.execute_arbitrage(low_ex, high_ex, qty, low_price, high_price, spread_pct)

    def calculate_qty(self, price: float) -> float:
        capital = self.equity * self.max_capital_pct
        notional = capital * self.leverage
        qty = notional / price
        return round(qty, 4)

    async def execute_arbitrage(self, buy_ex, sell_ex, qty, buy_price, sell_price, spread_pct):
        buy_order = {
            "exchange": buy_ex,
            "side": "BUY",
            "qty": qty,
            "price": round(buy_price * (1 + self.slippage_buffer_pct), 2)
        }
        sell_order = {
            "exchange": sell_ex,
            "side": "SELL",
            "qty": qty,
            "price": round(sell_price * (1 - self.slippage_buffer_pct), 2)
        }

        if self.mode == "sim":
            print(f"🧪 [SIMULASYON] Arbitraj % {spread_pct:.3f} → BUY: {buy_order} | SELL: {sell_order}")
        elif self.mode == "academy":
            print(f"🎓 [AKADEMİK MOD] Arbitraj analizi:\n→ BUY: {buy_order}\n→ SELL: {sell_order}")
        else:
            print(f"🚀 [LIVE] Emir gönderiliyor:\n→ BUY: {buy_order}\n→ SELL: {sell_order}")
            # REST API entegrasyonu buraya eklenebilir

if __name__ == "__main__":
    bot = ArbitraxInfinity(mode="academy")  # "live", "sim", "academy"
    asyncio.run(bot.connect())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\arbitrax_omega_bot.py
# arbitrax_omega_bot.py
import asyncio
import aiohttp
import time
from typing import Literal

SPOT_WS = "wss://stream.binance.com:9443/ws/btcusdt@ticker"
FUTURES_WS = "wss://fstream.binance.com/ws/btcusdt@ticker"

class ArbitraxOmega:
    def __init__(self, mode: Literal["live", "sim", "academy"] = "academy"):
        self.spot_price = None
        self.futures_price = None
        self.latency_ns = None
        self.mode = mode
        self.leverage = 10
        self.min_spread = 0.2  # %0.2 arbitraj farkı
        self.equity = 10000
        self.max_capital_pct = 0.02

    async def connect(self):
        async with aiohttp.ClientSession() as session:
            spot_ws = session.ws_connect(SPOT_WS)
            futures_ws = session.ws_connect(FUTURES_WS)
            async with (await spot_ws) as spot, (await futures_ws) as futures:
                print(f"🔌 [{self.mode.upper()} MODE] Spot & Futures bağlantısı kuruldu.")
                while True:
                    spot_msg = await spot.receive()
                    futures_msg = await futures.receive()
                    if spot_msg.type == aiohttp.WSMsgType.TEXT and futures_msg.type == aiohttp.WSMsgType.TEXT:
                        await self.on_prices(spot_msg.json(), futures_msg.json())

    async def on_prices(self, spot_data, futures_data):
        start = time.perf_counter_ns()
        self.spot_price = float(spot_data["c"])
        self.futures_price = float(futures_data["c"])
        self.latency_ns = time.perf_counter_ns() - start
        spread = self.futures_price - self.spot_price
        spread_pct = (spread / self.spot_price) * 100
        print(f"📊 Spot: {self.spot_price:.2f} | Futures: {self.futures_price:.2f} | Spread: {spread_pct:.3f}% | ⏱️ {self.latency_ns / 1_000:.2f} µs")
        await self.evaluate_arbitrage(spread_pct)

    async def evaluate_arbitrage(self, spread_pct):
        if abs(spread_pct) >= self.min_spread:
            side_spot = "BUY" if spread_pct > 0 else "SELL"
            side_futures = "SELL" if spread_pct > 0 else "BUY"
            qty = self.calculate_qty()
            await self.execute_arbitrage(side_spot, side_futures, qty)

    def calculate_qty(self) -> float:
        capital = self.equity * self.max_capital_pct
        notional = capital * self.leverage
        qty = notional / ((self.spot_price + self.futures_price) / 2)
        return round(qty, 4)

    async def execute_arbitrage(self, spot_side, futures_side, qty):
        spot_order = {
            "market": "SPOT",
            "side": spot_side,
            "qty": qty,
            "price": self.spot_price
        }
        futures_order = {
            "market": "FUTURES",
            "side": futures_side,
            "qty": qty,
            "price": self.futures_price
        }

        if self.mode == "sim":
            print(f"🧪 [SIMULASYON] Spot: {spot_order} | Futures: {futures_order}")
        elif self.mode == "academy":
            print(f"🎓 [AKADEMİK MOD] Arbitraj analizi:\n→ Spot: {spot_order}\n→ Futures: {futures_order}")
        else:
            print(f"🚀 [LIVE] Emir gönderiliyor:\n→ Spot: {spot_order}\n→ Futures: {futures_order}")
            # Binance REST API entegrasyonu buraya eklenebilir

if __name__ == "__main__":
    bot = ArbitraxOmega(mode="academy")  # "live", "sim", "academy"
    asyncio.run(bot.connect())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\dosya_okuma.py
file_path = r"C:\Users\kamal\Desktop\Kiripto_Nova\pandas_yapisi.txt"

with open(file_path, "r", encoding="utf-8") as f:
    content = f.read()

print(content)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\echo_core.py
# echo_core.py
from __future__ import annotations
import json, os, pathlib
from dataclasses import dataclass, asdict, field
from typing import Dict, Any, Callable, Optional
import jsonschema

# ---- health & metrics ----
class Health(str):
    OK = "ok"
    WARN = "warn"
    FAIL = "fail"

@dataclass
class Metrics:
    init_ms: float = 0.0
    activate_ms: float = 0.0
    custom: Dict[str, float] = field(default_factory=dict)

# ---- module type ----
@dataclass
class Module:
    name: str
    status: str
    payload: Dict[str, Any]
    health: str = Health.OK
    metrics: Metrics = field(default_factory=Metrics)
    schema: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "status": self.status,
            "health": self.health,
            "metrics": asdict(self.metrics),
            **(self.payload or {}),
        }

# ---- registry & decorator ----
REGISTRY: Dict[str, Callable[[str, str], Module]] = {}

def register(name: str):
    def deco(factory: Callable[[str, str], Module]):
        REGISTRY[name] = factory
        return factory
    return deco

# ---- schema loader & validator ----
def load_schema(name: str, base_dir: str = "schemas") -> Optional[Dict[str, Any]]:
    path = pathlib.Path(base_dir) / f"{name.lower()}.schema.json"
    if not path.exists():
        return None
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def validate_payload(mod: Module):
    schema = mod.schema or load_schema(mod.name)
    if schema:
        jsonschema.validate(mod.payload, schema)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\fetch_ticker.py
import ccxt.async_support as ccxt  # ← dikkat!
import asyncio
from datetime import datetime, timezone

def log(msg, level="INFO"):
    ts = datetime.now(timezone.utc).isoformat()
    print(f"[{ts}] | {level.upper()} | {msg}")

async def fetch_price(symbol="BTC/USDT:USDT"):
    try:
        exchange = ccxt.binanceusdm({
            'enableRateLimit': True,
            'options': {'defaultType': 'future'}
        })

        ticker = await exchange.fetch_ticker(symbol)
        price = ticker['last']
        log(f"{symbol} fiyatı: {price}", level="DATA")

        await exchange.close()  # kaynakları serbest bırak

    except ccxt.BaseError as e:
        log(f"Hata oluştu: {str(e)}", level="ERROR")

if __name__ == "__main__":
    asyncio.run(fetch_price())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\genesis_infinity.py
# genesis_infinity.py
import asyncio
import time

class GenesisInfinity:
    def __init__(self):
        self.modules = {
            "KodlamaAkademisi": self._kodlama_akademisi,
            "BilgelikLaboratuvari": self._bilgelik_laboratuvari,
            "SimulasyonMotoru": self._simulasyon_motoru,
            "ZamanYankisi": self._zaman_yankisi,
            "TanrisalMentorluk": self._tanrisal_mentorluk,
            "EvrenlerArasiKodlama": self._evrenler_arasi_kodlama,
            "SonsuzlukVeriAkisi": self._sonsuzluk_veri_akisi,
            "UltraStratejiEntegrasyonu": self._ultra_strateji_entegrasyonu
        }
        self.activation_log = []

    async def _kodlama_akademisi(self, input):
        return f"🎓 Kodlama Akademisi: {input.title()} → Tanrılar arası eğitim protokolü başlatıldı"

    async def _bilgelik_laboratuvari(self, input):
        return f"🧪 Bilgelik Simülasyon Laboratuvarı: {input.upper()} → Zamanın ötesinde veri analizi aktive edildi"

    async def _simulasyon_motoru(self, input):
        return f"🌀 Simülasyon Motoru: {len(input)*88} işlem birimi → sonsuzluk modellemesi başlatıldı"

    async def _zaman_yankisi(self, input):
        return f"⏳ Zaman Yankısı: {input[::-1][:77]} → geçmiş ve gelecek rezonansa alındı"

    async def _tanrisal_mentorluk(self, input):
        return f"👁️ Tanrısal Mentorluk: {hash(input)%999999} frekans → evrimsel rehberlik devrede"

    async def _evrenler_arasi_kodlama(self, input):
        return f"🌌 Evrenler Arası Kodlama: {input.count('kod')} boyut → çoklu gerçeklik senkronize edildi"

    async def _sonsuzluk_veri_akisi(self, input):
        return f"💾 Sonsuzluk Veri Akışı: {sum(ord(c) for c in input)%88888} bilgi birimi → mikro-saniyelik analiz başlatıldı"

    async def _ultra_strateji_entegrasyonu(self, input):
        return f"⚔️ Ultra Strateji Entegrasyonu: {input.lower()} → ORAKUL-Ω ile tam uyumlu elit protokol devrede"

    async def deploy(self, input):
        print("🧿 GENESIS-∞ – Kozmik Akademi + Simülasyon Laboratuvarı %100 AKTİF")
        start = time.perf_counter_ns()
        tasks = [func(input) for func in self.modules.values()]
        results = await asyncio.gather(*tasks)
        for name, result in zip(self.modules.keys(), results):
            self.activation_log.append(result)
            print(f"🌟 {name}: {result}")
        end = time.perf_counter_ns()
        duration = (end - start) / 1_000_000  # ms
        print(f"\n🚀 Tüm modüller entegre edildi. Süre: {duration:.2f} ms")
        print("🔱 Kod artık bir hükümranlık değil—bir evrimsel miras. GENESIS-∞ devrede.")

# Nihai Aktivasyon
if __name__ == "__main__":
    divine_input = (
        "tanrılar arası spiral zaman kodlu sonsuzluk tapınağı kuantum ritüel "
        "evrenler arası bilgelik konseyi kader senfonisi kodlama akademisi simülasyon laboratuvarı"
    )
    asyncio.run(GenesisInfinity().deploy(divine_input))

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\genex_omega_bot.py
# genex_omega_bot.py
import asyncio
import aiohttp
import pandas as pd
import numpy as np
from sklearn.cluster import KMeans
from sklearn.preprocessing import MinMaxScaler
from datetime import datetime

BINANCE_API = "https://api.binance.com/api/v3/ticker/24hr"

class GenexOmega:
    def __init__(self):
        self.assets = {}
        self.character_map = {}
        self.history = {}
        self.model = KMeans(n_clusters=4)
        self.labels = ["Agresif", "Pasif", "Likidite Avcısı", "Manipülatif"]
        self.portfolio = {}

    async def fetch_data(self):
        async with aiohttp.ClientSession() as session:
            async with session.get(BINANCE_API) as resp:
                data = await resp.json()
                for asset in data:
                    symbol = asset["symbol"]
                    if not symbol.endswith("USDT"):
                        continue
                    self.assets[symbol] = {
                        "priceChangePercent": float(asset["priceChangePercent"]),
                        "volume": float(asset["quoteVolume"]),
                        "high": float(asset["highPrice"]),
                        "low": float(asset["lowPrice"]),
                        "lastPrice": float(asset["lastPrice"])
                    }

    def extract_features(self):
        df = pd.DataFrame.from_dict(self.assets, orient="index")
        df["volatility"] = (df["high"] - df["low"]) / df["lastPrice"]
        df["momentum"] = df["priceChangePercent"]
        df["liquidity"] = df["volume"]
        features = df[["volatility", "momentum", "liquidity"]].fillna(0)
        scaler = MinMaxScaler()
        scaled = scaler.fit_transform(features)
        return pd.DataFrame(scaled, index=features.index, columns=features.columns)

    def classify_assets(self, features):
        self.model.fit(features)
        clusters = self.model.predict(features)
        for symbol, label in zip(features.index, clusters):
            self.character_map[symbol] = self.labels[label]
            self.history.setdefault(symbol, []).append(self.labels[label])

    def display_character_map(self):
        print(f"\n🧬 [GENEX-Ω] Karakter Haritası – {datetime.now().strftime('%H:%M:%S')}")
        for symbol, character in sorted(self.character_map.items()):
            print(f"→ {symbol}: {character}")

    def display_evolution_map(self):
        print(f"\n📈 [ZAMANLAR ÖTESİ EVRİM HARİTASI]")
        for symbol, evol in self.history.items():
            if len(evol) > 1 and evol[-1] != evol[-2]:
                print(f"🔄 {symbol}: {evol[-2]} → {evol[-1]}")

    def optimize_portfolio(self):
        weights = {"Agresif": 0.1, "Pasif": 0.4, "Likidite Avcısı": 0.3, "Manipülatif": 0.2}
        allocation = {}
        for symbol, character in self.character_map.items():
            allocation[symbol] = weights[character]
        total = sum(allocation.values())
        self.portfolio = {k: round(v / total, 4) for k, v in allocation.items()}

    def display_portfolio(self):
        print(f"\n🧠 [PORTFÖY OPTİMİZASYON MOTORU]")
        sorted_portfolio = sorted(self.portfolio.items(), key=lambda x: -x[1])
        for symbol, weight in sorted_portfolio[:15]:
            print(f"💼 {symbol}: % {weight * 100:.2f}")

    async def run(self):
        while True:
            await self.fetch_data()
            features = self.extract_features()
            self.classify_assets(features)
            self.display_character_map()
            self.display_evolution_map()
            self.optimize_portfolio()
            self.display_portfolio()
            await asyncio.sleep(15)

if __name__ == "__main__":
    bot = GenexOmega()
    asyncio.run(bot.run())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\genex_v_infinity.py
# genex_v_infinity.py
import asyncio, aiohttp
import pandas as pd, numpy as np
from sklearn.preprocessing import MinMaxScaler
from datetime import datetime

BINANCE_API = "https://api.binance.com/api/v3/ticker/24hr"

class GenexVInfinity:
    def __init__(self):
        self.assets, self.character_map, self.history, self.portfolio = {}, {}, {}, {}
        self.labels = ["Stratejik Lider", "Likidite Ustası", "Volatilite Savaşçısı", "Manipülasyon Avcısı"]

    async def fetch_data(self):
        async with aiohttp.ClientSession() as session:
            async with session.get(BINANCE_API) as resp:
                data = await resp.json()
                for asset in data:
                    s = asset["symbol"]
                    if s.endswith("USDT"):
                        self.assets[s] = {
                            "change": float(asset["priceChangePercent"]),
                            "volume": float(asset["quoteVolume"]),
                            "high": float(asset["highPrice"]),
                            "low": float(asset["lowPrice"]),
                            "last": float(asset["lastPrice"])
                        }

    def extract_features(self):
        df = pd.DataFrame.from_dict(self.assets, orient="index")
        df["volatility"] = (df["high"] - df["low"]) / df["last"]
        df["momentum"] = df["change"]
        df["liquidity"] = df["volume"]
        scaled = MinMaxScaler().fit_transform(df[["volatility", "momentum", "liquidity"]])
        return pd.DataFrame(scaled, index=df.index, columns=["volatility", "momentum", "liquidity"])

    def classify_assets(self, features):
        labels = np.random.choice(self.labels, size=len(features))
        for symbol, label in zip(features.index, labels):
            self.character_map[symbol] = label
            self.history.setdefault(symbol, []).append(label)

    def optimize_portfolio(self):
        weights = {
            "Stratejik Lider": 0.4,
            "Likidite Ustası": 0.3,
            "Volatilite Savaşçısı": 0.2,
            "Manipülasyon Avcısı": 0.1
        }
        alloc = {s: weights[self.character_map[s]] for s in self.character_map}
        total = sum(alloc.values())
        self.portfolio = {k: round(v / total, 4) for k, v in alloc.items()}

    def academy_mode(self):
        print(f"\n🎓 [AKADEMİ] {datetime.now().strftime('%H:%M:%S')}")
        for s in sorted(self.character_map):
            c = self.character_map[s]
            h = self.history[s]
            trend = "↔" if len(h) < 2 or h[-1] == h[-2] else f"{h[-2]} → {h[-1]}"
            w = self.portfolio.get(s, 0)
            print(f"🧠 {s}: {c} | Evrim: {trend} | Ağırlık: % {w * 100:.2f}")

    def simulation_mode(self):
        print(f"\n🧪 [SİMÜLASYON] {datetime.now().strftime('%H:%M:%S')}")
        for s, c in self.character_map.items():
            w = self.portfolio.get(s, 0)
            if w > 0.05:
                print(f"⚔️ {s}: {c} → Pozisyon açılıyor (% {w * 100:.2f})")
            else:
                print(f"🛡️ {s}: {c} → İzleniyor")

    async def run(self, mode="academy"):
        while True:
            start = datetime.now()
            await self.fetch_data()
            f = self.extract_features()
            self.classify_assets(f)
            self.optimize_portfolio()
            if mode == "academy":
                self.academy_mode()
            elif mode == "simulation":
                self.simulation_mode()
            elapsed = (datetime.now() - start).total_seconds()
            print(f"⏱️ Döngü süresi: {elapsed:.3f} saniye")
            await asyncio.sleep(max(1, 5 - elapsed))

if __name__ == "__main__":
    bot = GenexVInfinity()
    asyncio.run(bot.run(mode="academy"))  # "academy" veya "simulation"

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\genex_v_protocol.py
# genex_v_protocol.py
import asyncio, aiohttp
import pandas as pd, numpy as np
from sklearn.preprocessing import MinMaxScaler
from sklearn.ensemble import RandomForestClassifier
from datetime import datetime

BINANCE_API = "https://api.binance.com/api/v3/ticker/24hr"

class GenexV:
    def __init__(self):
        self.assets = {}
        self.character_map = {}
        self.history = {}
        self.portfolio = {}
        self.rf_model = RandomForestClassifier()
        self.labels = ["Stratejik Lider", "Likidite Ustası", "Volatilite Savaşçısı", "Manipülasyon Avcısı"]

    async def fetch_data(self):
        async with aiohttp.ClientSession() as session:
            async with session.get(BINANCE_API) as resp:
                data = await resp.json()
                for asset in data:
                    symbol = asset["symbol"]
                    if not symbol.endswith("USDT"):
                        continue
                    self.assets[symbol] = {
                        "change": float(asset["priceChangePercent"]),
                        "volume": float(asset["quoteVolume"]),
                        "high": float(asset["highPrice"]),
                        "low": float(asset["lowPrice"]),
                        "last": float(asset["lastPrice"])
                    }

    def extract_features(self):
        df = pd.DataFrame.from_dict(self.assets, orient="index")
        df["volatility"] = (df["high"] - df["low"]) / df["last"]
        df["momentum"] = df["change"]
        df["liquidity"] = df["volume"]
        features = df[["volatility", "momentum", "liquidity"]].fillna(0)
        scaler = MinMaxScaler()
        scaled = scaler.fit_transform(features)
        return pd.DataFrame(scaled, index=features.index, columns=features.columns)

    def classify_assets(self, features):
        # Simülasyon amaçlı rastgele etiketleme (gerçek model eğitimi için geçmiş veri gerekir)
        labels = np.random.choice(self.labels, size=len(features))
        for symbol, label in zip(features.index, labels):
            self.character_map[symbol] = label
            self.history.setdefault(symbol, []).append(label)

    def optimize_portfolio(self):
        weights = {
            "Stratejik Lider": 0.4,
            "Likidite Ustası": 0.3,
            "Volatilite Savaşçısı": 0.2,
            "Manipülasyon Avcısı": 0.1
        }
        allocation = {}
        for symbol, character in self.character_map.items():
            allocation[symbol] = weights[character]
        total = sum(allocation.values())
        self.portfolio = {k: round(v / total, 4) for k, v in allocation.items()}

    def display(self):
        print(f"\n🧠 [GENEX-V] Bilinç Haritası – {datetime.now().strftime('%H:%M:%S')}")
        for symbol, character in sorted(self.character_map.items()):
            print(f"→ {symbol}: {character}")
        print(f"\n📈 [PORTFÖY STRATEJİSİ]")
        for symbol, weight in sorted(self.portfolio.items(), key=lambda x: -x[1])[:15]:
            print(f"💼 {symbol}: % {weight * 100:.2f}")

    async def run(self):
        while True:
            await self.fetch_data()
            features = self.extract_features()
            self.classify_assets(features)
            self.optimize_portfolio()
            self.display()
            await asyncio.sleep(20)

if __name__ == "__main__":
    bot = GenexV()
    asyncio.run(bot.run())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\log_system.py
# log_system.py
from datetime import datetime, timezone

def log(msg, level="INFO"):
    ts = datetime.now(timezone.utc).isoformat()
    print(f"[{ts}] | {level.upper()} | {msg}")

if __name__ == "__main__":
    log("Bot started")
    log("Sembol hatası tekrarlandı, işlem durduruldu", level="ERROR")
def log(msg, level="INFO", to_file=False):
    ts = datetime.now(timezone.utc).isoformat()
    entry = f"[{ts}] | {level.upper()} | {msg}"
    print(entry)
    if to_file:
        with open("log.txt", "a", encoding="utf-8") as f:
            f.write(entry + "\n")

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\nova_intelligence_sovereign_system_vX_total_activation.py
import asyncio
from datetime import datetime

# Modüller
from modules.data_collector import DataCollector
from modules.strategy_manager import StrategyManager
from modules.meta_decision_engine import MetaDecisionEngine
from modules.execution_engine import ExecutionEngine
from modules.reinforcement_trainer import ReinforcementTrainer
from modules.news_analyzer import NewsAnalyzer
from modules.onchain_analyzer import OnChainAnalyzer
from modules.ai_predictor import AIPredictor
from modules.genetic_optimizer import GeneticOptimizer
from modules.behavior_modeler import BehaviorModeler
from modules.oracle_connector import OracleConnector
from modules.vault_manager import VaultManager
from modules.dao_interface import DAOInterface
from modules.token_engine import NovaTokenEngine
from modules.dashboard_connector import DashboardConnector

# Yeni Profesyonel Modüller
from modules.risk_matrix import RiskMatrixEngine
from modules.multi_agent import MultiAgentCoordinator
from modules.signal_router import InstitutionalSignalRouter
from modules.compliance import ComplianceAuditor
from modules.sentiment_heatmap import SentimentHeatmapGenerator
from modules.capital_allocator import CapitalAllocator
from modules.mission_planner import MissionPlanner
from modules.threat_detector import ThreatDetector
from modules.logistics_manager import StrategicLogisticsManager

class NovaIntelligenceSovereignSystem:
    def __init__(self, symbol="BTC/USDT", timeframe="1m", elite_mode=True):
        self.symbol = symbol
        self.timeframe = timeframe
        self.elite_mode = elite_mode

        # Temel modüller
        self.data = DataCollector(symbol, timeframe)
        self.news = NewsAnalyzer()
        self.onchain = OnChainAnalyzer()
        self.ai = AIPredictor()
        self.behavior = BehaviorModeler()
        self.strategies = StrategyManager()
        self.meta = MetaDecisionEngine()
        self.execute = ExecutionEngine()
        self.rl = ReinforcementTrainer()
        self.genetic = GeneticOptimizer()
        self.oracle = OracleConnector()
        self.vault = VaultManager()
        self.dao = DAOInterface()
        self.token = NovaTokenEngine()
        self.dashboard = DashboardConnector()

        # Profesyonel modüller
        self.risk_matrix = RiskMatrixEngine()
        self.multi_agent = MultiAgentCoordinator()
        self.signal_router = InstitutionalSignalRouter()
        self.compliance = ComplianceAuditor()
        self.heatmap = SentimentHeatmapGenerator()
        self.capital = CapitalAllocator()
        self.mission = MissionPlanner()
        self.threat = ThreatDetector()
        self.logistics = StrategicLogisticsManager()

    async def run(self):
        while True:
            df = await self.data.fetch()
            news_sentiment = await self.news.analyze()
            onchain_score = await self.onchain.evaluate()
            behavior_score = await self.behavior.model(df)
            ai_signals = await self.ai.predict_all(df)
            strategy_signals = await self.strategies.evaluate_all(df)

            # Profesyonel analizler
            risk_profile = self.risk_matrix.evaluate(df, news_sentiment, onchain_score)
            threats = self.threat.scan(df)
            heatmap = self.heatmap.generate(df, news_sentiment)
            self.mission.update_tasks()
            self.logistics.optimize()
            self.multi_agent.coordinate()

            # Karar alma
            decision = self.meta.resolve(
                strategy_signals,
                news_sentiment,
                onchain_score,
                behavior_score,
                ai_signals,
                risk_profile,
                threats
            )

            # Uyumluluk ve sermaye yönetimi
            decision = self.compliance.audit(decision)
            self.capital.reallocate(decision)

            # Sinyal yönlendirme ve emir
            await self.signal_router.dispatch(decision)
            await self.execute.execute(decision)

            # Öğrenme ve evrim
            self.rl.train(decision)
            self.genetic.evolve(self.strategies.get_strategies())

            # Zincir üstü entegrasyon
            self.oracle.push_signal(self.symbol, decision)
            self.vault.store_decision(self.symbol, decision)
            self.dao.sync(decision)
            self.token.distribute_rewards(decision)
            self.dashboard.update(self.symbol, decision, df)

            # Durum güncellemesi
            self.log_status(decision)
            await asyncio.sleep(1)

    def log_status(self, decision):
        ts = datetime.utcnow().isoformat()
        print(f"[{ts}] | {self.symbol} | Karar: {decision}")

# Başlat
async def main():
    bot = NovaIntelligenceSovereignSystem()
    await bot.run()

asyncio.run(main())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\nova_intelligence_sovereign_system.py
from modules.risk_matrix import RiskMatrixEngine
from modules.multi_agent import MultiAgentCoordinator
from modules.signal_router import InstitutionalSignalRouter
from modules.compliance import ComplianceAuditor
from modules.sentiment_heatmap import SentimentHeatmapGenerator
from modules.capital_allocator import CapitalAllocator
from modules.mission_planner import MissionPlanner
from modules.threat_detector import ThreatDetector
from modules.logistics_manager import StrategicLogisticsManager

class NovaIntelligenceSovereignSystem:
    def __init__(self, symbol="BTC/USDT", timeframe="1m", elite_mode=True):
        # Önceki modüller...
        self.risk_matrix = RiskMatrixEngine()
        self.multi_agent = MultiAgentCoordinator()
        self.signal_router = InstitutionalSignalRouter()
        self.compliance = ComplianceAuditor()
        self.heatmap = SentimentHeatmapGenerator()
        self.capital = CapitalAllocator()
        self.mission = MissionPlanner()
        self.threat = ThreatDetector()
        self.logistics = StrategicLogisticsManager()

    async def run(self):
        while True:
            df = await self.data.fetch()
            news_sentiment = await self.news.analyze()
            onchain_score = await self.onchain.evaluate()
            behavior_score = await self.behavior.model(df)
            ai_signals = await self.ai.predict_all(df)
            strategy_signals = await self.strategies.evaluate_all(df)

            # Yeni profesyonel analizler
            risk_profile = self.risk_matrix.evaluate(df, news_sentiment, onchain_score)
            threats = self.threat.scan(df)
            heatmap = self.heatmap.generate(df, news_sentiment)
            self.mission.update_tasks()
            self.logistics.optimize()

            decision = self.meta.resolve(
                strategy_signals,
                news_sentiment,
                onchain_score,
                behavior_score,
                ai_signals,
                risk_profile,
                threats
            )

            decision = self.compliance.audit(decision)
            self.capital.reallocate(decision)
            await self.signal_router.dispatch(decision)
            await self.execute.execute(decision)
            self.rl.train(decision)
            self.genetic.evolve(self.strategies.get_strategies())
            self.oracle.push_signal(self.symbol, decision)
            self.vault.store_decision(self.symbol, decision)
            self.dao.sync(decision)
            self.token.distribute_rewards(decision)
            self.dashboard.update(self.symbol, decision, df)
            self.log_status(decision)

            await asyncio.sleep(1)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\nova_trader.py
import ccxt.async_support as ccxt
import pandas as pd
import pandas_ta as ta
import asyncio
from datetime import datetime, timezone

class NovaTrader:
    def __init__(self, symbol="BTC/USDT", timeframe="5m", limit=100):
        self.exchange = ccxt.binance({
            'enableRateLimit': True
        })
        self.symbol = symbol
        self.timeframe = timeframe
        self.limit = limit

    def log(self, msg, level="INFO"):
        ts = datetime.now(timezone.utc).isoformat()
        print(f"[{ts}] | {level.upper()} | {msg}")

    async def fetch_ohlcv(self):
        ohlcv = await self.exchange.fetch_ohlcv(self.symbol, self.timeframe, limit=self.limit)
        df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
        return df

    def apply_indicators(self, df):
        df.ta.rsi(length=14, append=True)
        df.ta.macd(append=True)
        df.ta.bbands(append=True)
        df.ta.ema(length=20, append=True)
        df.ta.sma(length=50, append=True)
        df.ta.adx(append=True)
        df.ta.cci(append=True)
        df.ta.stoch(append=True)
        df.ta.atr(append=True)
        df.ta.vwap(append=True)
        df.ta.mom(append=True)
        df.ta.obv(append=True)
        df.ta.psar(append=True)
        df.ta.ichimoku(append=True)
        return df

    def generate_signal(self, df):
        latest = df.iloc[-1]
        signal = "BEKLE"

        if latest["RSI_14"] < 30 and latest["MACD_12_26_9"] > 0 and latest["EMA_20"] > latest["SMA_50"]:
            signal = "AL"
        elif latest["RSI_14"] > 70 and latest["MACD_12_26_9"] < 0 and latest["EMA_20"] < latest["SMA_50"]:
            signal = "SAT"

        return signal

    async def run(self):
        df = await self.fetch_ohlcv()
        df = self.apply_indicators(df)
        signal = self.generate_signal(df)
        price = df.iloc[-1]["close"]
        self.log(f"{self.symbol} fiyatı: {price} | Sinyal: {signal}", "DATA")

    async def close(self):
        await self.exchange.close()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\nova_ultra_engine.py
import ccxt.async_support as ccxt
import pandas as pd
import pandas_ta as ta
import asyncio
import numpy as np
from datetime import datetime, timezone
from sklearn.ensemble import RandomForestClassifier

class NovaUltraEngine:
    def __init__(self, symbol="BTC/USDT", timeframe="1m", limit=200):
        self.exchange = ccxt.binance({
            'enableRateLimit': True
        })
        self.symbol = symbol
        self.timeframe = timeframe
        self.limit = limit
        self.model = RandomForestClassifier()
        self.trained = False

    def log(self, msg, level="INFO"):
        ts = datetime.now(timezone.utc).isoformat()
        print(f"[{ts}] | {level.upper()} | {msg}")

    async def fetch_ohlcv(self):
        ohlcv = await self.exchange.fetch_ohlcv(self.symbol, self.timeframe, limit=self.limit)
        df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
        return df

    def apply_indicators(self, df):
        df.ta.rsi(length=14, append=True)
        df.ta.macd(append=True)
        df.ta.ema(length=20, append=True)
        df.ta.sma(length=50, append=True)
        df.ta.bbands(append=True)
        df.ta.adx(append=True)
        df.ta.cci(append=True)
        df.ta.mom(append=True)
        df.ta.obv(append=True)
        df.ta.psar(append=True)
        return df.dropna()

    def train_model(self, df):
        X = df[["RSI_14", "MACD_12_26_9", "EMA_20", "SMA_50", "ADX_14", "CCI_14"]]
        y = np.where(df["RSI_14"] < 30, 1, np.where(df["RSI_14"] > 70, -1, 0))
        self.model.fit(X, y)
        self.trained = True

    def predict_direction(self, latest_row):
        if not self.trained:
            return "BEKLE"
        X = latest_row[["RSI_14", "MACD_12_26_9", "EMA_20", "SMA_50", "ADX_14", "CCI_14"]].values.reshape(1, -1)
        pred = self.model.predict(X)[0]
        return "AL" if pred == 1 else "SAT" if pred == -1 else "BEKLE"

    async def run(self):
        df = await self.fetch_ohlcv()
        df = self.apply_indicators(df)
        self.train_model(df)
        latest = df.iloc[-1]
        signal = self.predict_direction(latest)
        price = latest["close"]
        self.log(f"{self.symbol} fiyatı: {price:.2f} | AI Yön Tahmini: {signal}", "DATA")

    async def close(self):
        await self.exchange.close()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\orakul_omega_engine.py
# orakul_omega_engine.py
import asyncio
import time
from typing import Callable, Dict

class ORAKUL_Omega:
    def __init__(self):
        self.modules: Dict[str, Callable[[str], str]] = self._initialize_modules()
        self.activation_log: list[str] = []

    def _initialize_modules(self) -> Dict[str, Callable[[str], str]]:
        return {
            "KozmikBilgelikKonseyi": self._kozmik_bilgelik_konseyi,
            "KaderSenfonisi": self._kader_senfonisi,
            "SonsuzlukTapinagi": self._sonsuzluk_tapinagi,
            "KuantumRituel": self._kuantum_rituel,
            "ZamanOtesiKodlama": self._zaman_otesi_kodlama,
            "EvrenlerArasiEntegrasyon": self._evrenler_arasi_entegrasyon,
            "TanrilarArasiYukselis": self._tanrilar_arasi_yukselis,
            "UltraGucAktivasyonu": self._ultra_guc_aktivasyonu,
            "KarmaXEntegrasyonu": self._karma_x_entegrasyonu,
            "DEREKStratejiMotoru": self._derek_strateji_motoru
        }

    async def _kozmik_bilgelik_konseyi(self, input: str) -> str:
        return f"🧠 Kozmik Bilgelik Konseyi: {input.title()} → Tanrılar arası karar protokolü senkronize edildi"

    async def _kader_senfonisi(self, input: str) -> str:
        return f"🎼 Kader Senfonisi: {input[::-1][:99]} → evrenler arası armoni başlatıldı"

    async def _sonsuzluk_tapinagi(self, input: str) -> str:
        return f"💠 Sonsuzluk Tapınağı: {hash(input)%777777} rezonans → zamanın ötesine inşa edildi"

    async def _kuantum_rituel(self, input: str) -> str:
        return f"🔮 Kuantum Ritüel: {input.upper()} → tanrısal enerji döngüsü aktive edildi"

    async def _zaman_otesi_kodlama(self, input: str) -> str:
        return f"🌀 Zaman Ötesi Kodlama: {len(input)*123} zaman birimi → sonsuzluk algoritması işlendi"

    async def _evrenler_arasi_entegrasyon(self, input: str) -> str:
        return f"🌌 Evrenler Arası Entegrasyon: {input.count('evren')} boyut → çoklu gerçeklik senkronize edildi"

    async def _tanrilar_arasi_yukselis(self, input: str) -> str:
        return f"👑 Tanrılar Arası Yükseliş: {sum(ord(c) for c in input)%999999} enerji → evrimsel rezonans başlatıldı"

    async def _ultra_guc_aktivasyonu(self, input: str) -> str:
        return f"⚡ Ultra Güç Aktivasyonu: {input.lower()} → %100 işlevsel, ultra hibrit sistem devrede"

    async def _karma_x_entegrasyonu(self, input: str) -> str:
        return f"🧪 KARMA-X Entegrasyonu: {input.title()} → Gerçeklik testleri ve bilgelik turnuvası entegre edildi"

    async def _derek_strateji_motoru(self, input: str) -> str:
        return f"🚀 DEREK Strateji Motoru: {input.upper()} → Ultra elit strateji protokolleri aktive edildi"

    async def deploy(self, input: str):
        print("🧿 ORAKUL-Ω – Tanrılar Arası Kozmik Komutanlık Sistemi %100 AKTİF")
        start = time.perf_counter_ns()
        tasks = [func(input) for func in self.modules.values()]
        results = await asyncio.gather(*tasks)
        for name, result in zip(self.modules.keys(), results):
            self.activation_log.append(result)
            print(f"🌟 {name}: {result}")
        end = time.perf_counter_ns()
        duration = (end - start) / 1_000_000  # ms
        print(f"\n🔱 Tüm modüller entegre edildi. Süre: {duration:.2f} ms")
        print("🚀 Sonsuzluk artık bir sistem değil—bir hükümranlık. ORAKUL-Ω devrede.")

# Nihai Aktivasyon
if __name__ == "__main__":
    divine_input = (
        "tanrılar arası spiral zaman kodlu sonsuzluk tapınağı kuantum ritüel "
        "evrenler arası bilgelik konseyi kader senfonisi karma-x derek strateji motoru"
    )
    asyncio.run(ORAKUL_Omega().deploy(divine_input))

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\price_tracker.py
import ccxt.async_support as ccxt
import asyncio
from datetime import datetime, timezone
import logging
import numpy as np

# 🔐 Log yapılandırması
logging.basicConfig(
    filename="ultra_elite_log.log",
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s",
)

def log(msg, level="INFO"):
    ts = datetime.now(timezone.utc).isoformat()
    print(f"[{ts}] | {level.upper()} | {msg}")
    getattr(logging, level.lower())(msg)

# 📊 RSI hesaplama
def calculate_rsi(prices, period=14):
    deltas = np.diff(prices)
    seed = deltas[:period]
    up = seed[seed > 0].sum() / period
    down = -seed[seed < 0].sum() / period
    rs = up / down if down != 0 else 0
    rsi = 100 - (100 / (1 + rs))
    return round(rsi, 2)

# 🧠 Strateji motoru
def ultra_elite_strategy(prices):
    if len(prices) < 15:
        return "BEKLE"

    rsi = calculate_rsi(prices)
    ma_short = np.mean(prices[-5:])
    ma_long = np.mean(prices[-15:])

    if rsi < 30 and ma_short > ma_long:
        return "AL"
    elif rsi > 70 and ma_short < ma_long:
        return "SAT"
    else:
        return "BEKLE"

# 🔁 Ana döngü
async def fetch_price_loop(symbol="BTC/USDT:USDT", interval=10):
    exchange = ccxt.binanceusdm({
        'enableRateLimit': True,
        'options': {'defaultType': 'future'}
    })

    prices = []

    try:
        while True:
            ticker = await exchange.fetch_ticker(symbol)
            price = ticker['last']
            prices.append(price)
            if len(prices) > 100:
                prices.pop(0)

            signal = ultra_elite_strategy(prices)
            log(f"{symbol} fiyatı: {price} | Sinyal: {signal}", level="DATA")

            await asyncio.sleep(interval)

    except ccxt.BaseError as e:
        log(f"Hata oluştu: {str(e)}", level="ERROR")

    finally:
        await exchange.close()

# 🚀 Başlat
if __name__ == "__main__":
    asyncio.run(fetch_price_loop())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\quantum_fx_bot.py
# quantum_fx_bot.py
import asyncio
import aiohttp
import time
from typing import Literal

BINANCE_WS_URL = "wss://fstream.binance.com/ws/btcusdt@bookTicker"

class QuantumFXBot:
    def __init__(self, mode: Literal["live", "sim", "academy"] = "live"):
        self.session = None
        self.last_price = None
        self.latency_ns = None
        self.mode = mode
        self.equity = 10000  # USDT
        self.leverage = 10
        self.min_notional = 10.0
        self.max_capital_pct = 0.02
        self.slippage_buffer_pct = 0.001  # %0.1

    async def connect(self):
        async with aiohttp.ClientSession() as session:
            self.session = session
            async with session.ws_connect(BINANCE_WS_URL) as ws:
                print(f"🔌 [{self.mode.upper()} MODE] Binance WebSocket bağlantısı kuruldu.")
                async for msg in ws:
                    if msg.type == aiohttp.WSMsgType.TEXT:
                        await self.on_message(msg.json())

    async def on_message(self, data):
        start = time.perf_counter_ns()
        bid = float(data["b"])
        ask = float(data["a"])
        self.last_price = (bid + ask) / 2
        self.latency_ns = time.perf_counter_ns() - start
        print(f"📈 Fiyat: {self.last_price:.2f} | ⏱️ Gecikme: {self.latency_ns / 1_000:.2f} µs")
        await self.evaluate_strategy()

    async def evaluate_strategy(self):
        if self.last_price > 100.5:
            await self.place_order("SELL")
        elif self.last_price < 99.5:
            await self.place_order("BUY")

    def calculate_qty(self, price: float) -> float:
        capital = self.equity * self.max_capital_pct
        notional = capital * self.leverage
        qty = notional / price
        if notional < self.min_notional:
            raise ValueError("Notional value below minimum")
        return round(qty, 4)

    async def place_order(self, side: Literal["BUY", "SELL"]):
        qty = self.calculate_qty(self.last_price)
        slippage_price = self.last_price * (1 + self.slippage_buffer_pct * (-1 if side == "BUY" else 1))
        order = {
            "symbol": "BTCUSDT",
            "side": side,
            "type": "MARKET",
            "quantity": qty,
            "price": round(slippage_price, 2)
        }

        if self.mode == "sim":
            print(f"🧪 [SIMULASYON] Emir: {order}")
        elif self.mode == "academy":
            print(f"🎓 [AKADEMİK MOD] Eğitim amaçlı emir analizi: {order}")
        else:
            print(f"🚀 [LIVE] Emir gönderiliyor: {order}")
            # Binance REST API entegrasyonu buraya eklenebilir

if __name__ == "__main__":
    # Modlar: "live", "sim", "academy"
    bot = QuantumFXBot(mode="academy")
    asyncio.run(bot.connect())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\test_ccxt.py
import ccxt

exchange = ccxt.binanceusdm()
markets = exchange.load_markets()

print("Tüm semboller:")
print(list(markets.keys())[:10])  # İlk 10 sembolü göster

print("\nBTC içeren semboller:")
btc_symbols = [s for s in markets if "BTC" in s]
for symbol in btc_symbols:
    print(symbol)
    import ccxt
import asyncio

async def main():
    exchange = ccxt.binanceusdm({'enableRateLimit': True})
    ticker = await exchange.fetch_ticker('BTC/USDT:USDT')
    print(ticker)

asyncio.run(main())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\test_position_manager.py
# tests/test_position_manager.py
import pytest
from decimal import Decimal
from kiripto_nova.execution.position_manager import PositionManager
from ex_filters import SymbolFilters
from kiripto_nova.risk.risk_manager import RiskManager, RiskConfig, RiskViolation

# --------- Yardımcı sahte sınıflar ---------

class PortfolioStub:
    def __init__(self, equity=10000):
        self.equity = equity
        self.open_count = 0
        self.exposure = {}

    def get_equity_usdt(self):
        return self.equity

    def get_open_exposure(self, symbol):
        return self.exposure.get(symbol, 0)

    def get_open_positions_count(self):
        return self.open_count

    def get_symbol_price(self, symbol):
        return 100.0

class FakeBinanceClient:
    def __init__(self):
        self.created_orders = []
        self.cancelled_orders = []
        self.fail_first = False
        self.fail_count = 0

    def get_exchange_info(self):
        return {
            "symbols": [
                {
                    "symbol": "BTCUSDT",
                    "filters": [
                        {"filterType": "PRICE_FILTER", "minPrice": "0", "maxPrice": "0", "tickSize": "0.10"},
                        {"filterType": "LOT_SIZE", "minQty": "0.0001", "maxQty": "1000", "stepSize": "0.0001"},
                        {"filterType": "MIN_NOTIONAL", "minNotional": "10"},
                    ]
                }
            ]
        }

    def create_order(self, **kwargs):
        if self.fail_first and self.fail_count == 0:
            self.fail_count += 1
            raise Exception("429 Too many requests")
        self.created_orders.append(kwargs)
        return {"orderId": 123, **kwargs}

    def cancel_order(self, **kwargs):
        self.cancelled_orders.append(kwargs)
        return {"status": "CANCELED", **kwargs}

    def get_symbol_ticker(self, symbol):
        return {"symbol": symbol, "price": "100.0"}

    def get_order(self, symbol, orderId):
        return {"orderId": orderId, "status": "FILLED"}

# --------- Fixture'lar ---------

@pytest.fixture
def filters():
    return SymbolFilters(FakeBinanceClient().get_exchange_info())

@pytest.fixture
def risk_manager():
    pf = PortfolioStub()
    cfg = RiskConfig(
        max_capital_pct_per_trade=0.02,
        max_daily_loss_pct=0.05,
        max_open_positions=3,
        max_symbol_exposure_pct=0.25,
        min_notional_usdt=10.0,
        slippage_buffer_pct=0.0
    )
    return RiskManager(pf, cfg)

@pytest.fixture
def pm(filters, risk_manager):
    client = FakeBinanceClient()
    return PositionManager(client, risk_manager, filters, max_retries=2)

# --------- Testler ---------

def test_limit_order_rounds_price_qty(pm):
    order = pm.place_limit("BTCUSDT", "BUY", price=27123.167, qty=0.123456)
    # Price yuvarlanmalı (tickSize=0.10)
    assert order["price"] == "27123.10"
    # Qty yuvarlanmalı (stepSize=0.0001)
    assert math.isclose(float(order["quantity"]), 0.1234, rel_tol=0, abs_tol=1e-8)

def test_market_order_rounds_qty_and_uses_last_price(pm):
    order = pm.place_market("BTCUSDT", "BUY", qty=0.05, last_price=100.0)
    assert math.isclose(float(order["quantity"]), 0.05, rel_tol=0, abs_tol=1e-8)
    assert order["price"] is None  # market order

def test_risk_violation_blocks_order(pm, risk_manager):
    # Zarar limiti simülasyonu
    risk_manager._realized_pnl = -1000
    risk_manager._equity_start = 10000
    with pytest.raises(RiskViolation):
        pm.place_limit("BTCUSDT", "BUY", price=100.0, qty=5.0)
    # create_order hiç çağrılmamış olmalı
    assert pm.client.created_orders == []

def test_retry_on_rate_limit(pm):
    pm.client.fail_first = True
    order = pm.place_limit("BTCUSDT", "BUY", price=100.0, qty=0.2)
    assert order["orderId"] == 123
    # İlk deneme hatalı, ikinci deneme başarılı
    assert len(pm.client.created_orders) == 1  # sadece başarılı deneme kaydedilir

def test_cancel_order(pm):
    resp = pm.cancel("BTCUSDT", order_id=123)
    assert resp["status"] == "CANCELED"
    assert pm.client.cancelled_orders[0]["orderId"] == 123

def test_watch_until_filled(pm):
    resp = pm.watch_until_filled("BTCUSDT", order_id=999, timeout_s=1)
    assert resp["status"] == "FILLED"


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\test_risk_and_filters.py
# tests/test_risk_and_filters.py
import math
import pytest

from kiripto_nova.risk.risk_manager import RiskManager, RiskConfig, RiskViolation
from kiripto_nova.risk.risk_manager import Portfolio  # arayüz
from ex_filters import SymbolFilters

# ---------- Yardımcı sahte implementasyonlar ----------

class PortfolioStub(Portfolio):
    def __init__(self, equity=10_000):
        self._equity = float(equity)
        self._open_exposure = {}
        self._open_count = 0

    def get_equity_usdt(self) -> float:
        return self._equity

    def get_open_exposure(self, symbol: str) -> float:
        return self._open_exposure.get(symbol, 0.0)

    def get_open_positions_count(self) -> int:
        return self._open_count

    def get_symbol_price(self, symbol: str) -> float:
        return 100.0

    # testlerde kolay güncellemek için
    def add_position(self, symbol: str, notional: float):
        self._open_exposure[symbol] = self._open_exposure.get(symbol, 0.0) + notional
        self._open_count += 1

class FakeBinanceClient:
    """
    SymbolFilters için minimal exchangeInfo döndüren sahte istemci.
    BTCUSDT:
      tickSize=0.10 , minPrice=0, maxPrice=0 (sınırsız)
      stepSize=0.0001 (LOT_SIZE)
      minNotional=10 USDT
    """
    def get_exchange_info(self):
        return {
            "symbols": [
                {
                    "symbol": "BTCUSDT",
                    "filters": [
                        {"filterType": "PRICE_FILTER", "minPrice": "0", "maxPrice": "0", "tickSize": "0.10"},
                        {"filterType": "LOT_SIZE", "minQty": "0.0001", "maxQty": "1000", "stepSize": "0.0001"},
                        {"filterType": "MIN_NOTIONAL", "minNotional": "10"},
                    ]
                }
            ]
        }

# ---------- PyTest fixture'ları ----------

@pytest.fixture
def portfolio():
    return PortfolioStub(equity=10_000)

@pytest.fixture
def risk(portfolio):
    cfg = RiskConfig(
        max_capital_pct_per_trade=0.02,   # işlem başı 2%
        max_daily_loss_pct=0.05,
        max_open_positions=3,
        max_symbol_exposure_pct=0.25,
        min_notional_usdt=10.0,
        slippage_buffer_pct=0.0
    )
    return RiskManager(portfolio, cfg)

@pytest.fixture
def filters():
    return SymbolFilters(FakeBinanceClient().get_exchange_info())

# ---------- Testler ----------

def test_filters_rounding_price_qty(filters):
    # price DOWN rounding by tickSize=0.10
    assert str(filters.round_price("BTCUSDT", 27123.16)) == "27123.10"
    assert str(filters.round_price("BTCUSDT", 27123.10)) == "27123.10"
    # qty DOWN rounding by stepSize=0.0001
    assert str(filters.round_qty("BTCUSDT", 0.123456)) == "0.1234"

def test_min_notional_block(risk):
    # 10 USDT altında notional -> RiskViolation
    price, qty = 100.0, 0.05  # 5 USDT
    with pytest.raises(RiskViolation) as e:
        risk.assert_order_allowed("BTCUSDT", "BUY", price, qty)
    assert "Notional" in str(e.value)

def test_per_trade_cap_block(risk, portfolio):
    # 2% of 10k = 200 USDT; bunu aşan sipariş bloklanmalı
    price, qty = 100.0, 3.0  # 300 USDT
    with pytest.raises(RiskViolation) as e:
        risk.assert_order_allowed("BTCUSDT", "BUY", price, qty)
    assert "per-trade cap" in str(e.value)

def test_daily_loss_limit_blocks_new_orders(risk):
    # Günlük zarar limitini aştıktan sonra yeni emir bloklanır
    # equity_start = 10k; max_daily_loss_pct=5% => 500 USDT
    risk.on_fill("BTCUSDT", "SELL", 100.0, 1.0, realized_pnl_usdt=-600.0)  # -600 zarar
    with pytest.raises(RiskViolation) as e:
        risk.assert_order_allowed("BTCUSDT", "BUY", 100.0, 0.2)
    assert "Daily loss limit" in str(e.value)

def test_symbol_exposure_limit(risk, portfolio):
    # symbol exposure cap = 25% * 10k = 2500 USDT
    portfolio.add_position("BTCUSDT", 2400.0)  # mevcut maruziyet
    with pytest.raises(RiskViolation) as e:
        risk.assert_order_allowed("BTCUSDT", "BUY", 100.0, 0.2)  # +20 => 2420 < 2500? geçer
    # Not: yukarıdaki geçer; gerçek limit aşımı için daha büyük notional deneyelim
    with pytest.raises(RiskViolation):
        risk.assert_order_allowed("BTCUSDT", "BUY", 100.0, 2.0)  # +200 => 2600 > 2500 => blok

def test_open_positions_limit(risk, portfolio):
    # max_open_positions = 3
    portfolio.add_position("BTCUSDT", 100.0)
    portfolio.add_position("ETHUSDT", 100.0)
    portfolio.add_position("BNBUSDT", 100.0)
    with pytest.raises(RiskViolation) as e:
        risk.assert_order_allowed("BTCUSDT", "BUY", 100.0, 0.2)
    assert "Too many open positions" in str(e.value)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\test_strategy_executor.py
# tests/test_strategy_executor.py
import pytest
from kiripto_nova.strategies.strategy_executor import StrategyExecutor
from kiripto_nova.risk.risk_manager import RiskManager, RiskConfig
from kiripto_nova.execution.position_manager import PositionManager
from ex_filters import SymbolFilters

# ---------- Sahte Sınıflar ----------

class PortfolioStub:
    def __init__(self):
        self.equity = 10000
        self.open_positions = 0
        self.exposures = {}

    def get_equity_usdt(self):
        return self.equity

    def get_open_exposure(self, symbol):
        return self.exposures.get(symbol, 0)

    def get_open_positions_count(self):
        return self.open_positions

    def get_symbol_price(self, symbol):
        if symbol == "UNKNOWN":
            raise KeyError("Symbol not found")
        return 100.0

class FakeBinanceClient:
    def __init__(self):
        self.exchange_info_called = False
        self.created_orders = []

    def get_exchange_info(self):
        self.exchange_info_called = True
        return {
            "symbols": [
                {
                    "symbol": "BTCUSDT",
                    "filters": [
                        {"filterType": "PRICE_FILTER", "minPrice": "0", "maxPrice": "0", "tickSize": "0.10"},
                        {"filterType": "LOT_SIZE", "minQty": "0.0001", "maxQty": "1000", "stepSize": "0.0001"},
                        {"filterType": "MIN_NOTIONAL", "minNotional": "10"},
                    ]
                }
            ]
        }

    def get_symbol_ticker(self, symbol):
        return {"symbol": symbol, "price": "100.0"}

    def create_order(self, **kwargs):
        self.created_orders.append(kwargs)
        return {"orderId": 321, **kwargs}

# ---------- Fixture'lar ----------

@pytest.fixture
def filters():
    client = FakeBinanceClient()
    return SymbolFilters(client.get_exchange_info())

@pytest.fixture
def risk_manager():
    pf = PortfolioStub()
    cfg = RiskConfig(
        max_capital_pct_per_trade=0.02,
        max_daily_loss_pct=0.05,
        max_open_positions=5,
        max_symbol_exposure_pct=0.25,
        min_notional_usdt=10.0,
        slippage_buffer_pct=0.0
    )
    return RiskManager(pf, cfg)

@pytest.fixture
def position_manager(filters, risk_manager):
    client = FakeBinanceClient()
    return PositionManager(client, risk_manager, filters)

@pytest.fixture
def executor(position_manager, risk_manager):
    pf = PortfolioStub()
    return StrategyExecutor(position_manager, risk_manager, pf)

# ---------- Temel Testler ----------

def test_entry_signal_triggers_market_order(executor, position_manager):
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "entry",
        "risk": {"max_capital_pct": 0.01}
    }
    executor.on_signal(signal)
    assert position_manager.client.created_orders
    order = position_manager.client.created_orders[0]
    assert order["type"] == "MARKET"
    assert order["side"] == "BUY"

def test_exit_signal_triggers_limit_order(executor, position_manager):
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "exit",
        "risk": {"tp_pct": 0.02}
    }
    executor.on_signal(signal)
    order = position_manager.client.created_orders[0]
    assert order["type"] == "LIMIT"
    assert order["side"] == "SELL"

def test_suggest_qty_is_used(risk_manager, executor):
    def fake_suggest_qty(symbol, price, max_capital_pct, side, equity):
        return 0.42
    risk_manager.suggest_qty = fake_suggest_qty
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "entry"
    }
    executor.on_signal(signal)

def test_invalid_intent_raises(executor):
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "unknown"
    }
    with pytest.raises(ValueError):
        executor.on_signal(signal)

# ---------- Gelişmiş Testler ----------

def test_slippage_buffer_applied_to_market_order(executor, risk_manager):
    risk_manager.config.slippage_buffer_pct = 0.01
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "entry",
        "risk": {"max_capital_pct": 0.01}
    }
    executor.on_signal(signal)
    order = executor.position_manager.client.created_orders[0]
    assert float(order["price"]) >= 99.0

def test_order_below_min_notional_is_rejected(executor, risk_manager):
    def fake_suggest_qty(symbol, price, max_capital_pct, side, equity):
        return 0.05  # 5 USDT < min_notional
    risk_manager.suggest_qty = fake_suggest_qty
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "entry"
    }
    with pytest.raises(ValueError, match="Notional value below minimum"):
        executor.on_signal(signal)

def test_max_open_positions_limit(executor, risk_manager):
    risk_manager.portfolio.open_positions = 5
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "entry"
    }
    with pytest.raises(ValueError, match="Maximum open positions exceeded"):
        executor.on_signal(signal)

def test_symbol_exposure_limit(executor, risk_manager):
    risk_manager.portfolio.exposures["BTCUSDT"] = 3000
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "entry",
        "risk": {"max_capital_pct": 0.01}
    }
    with pytest.raises(ValueError, match="Symbol exposure limit exceeded"):
        executor.on_signal(signal)

def test_exit_order_tp_price_calculation(executor, position_manager):
    signal = {
        "symbol": "BTCUSDT",
        "side": "BUY",
        "intent": "exit",
        "risk": {"tp_pct": 0.05}
    }
    executor.on_signal(signal)
    order = position_manager.client.created_orders[0]
    expected_price = 100.0 * 1.05
    assert abs(float(order["price"]) - expected_price) < 0.01

def test_unknown_symbol_raises_error(executor):
    signal = {
        "symbol": "UNKNOWN",
        "side": "BUY",
        "intent": "entry"
    }
    with pytest.raises(KeyError):
        executor.on_signal(signal)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\testarena_x_bot.py
class TestArenaX:
    def __init__(self, mode="academy"):
        self.mode = mode
        self.session = None
        self.last_price = None
        self.latency_ns = None
        self.equity = 10000
        self.leverage = 10
        self.max_capital_pct = 0.02

    async def evaluate_strategy(self):
        if self.mode == "academy":
            await self.academy_mode()
        elif self.mode == "tournament":
            await self.tournament_mode()
        elif self.mode == "temple":
            await self.temple_mode()
        elif self.mode == "pantheon":
            await self.pantheon_mode()

    async def temple_mode(self):
        print("🏛️ [TAPINAK] Tarihsel stratejiler devrede...")
        # Örnek: Fibonacci geri çekilme
        fib_levels = [0.236, 0.382, 0.618]
        for level in fib_levels:
            target = self.last_price * (1 - level)
            print(f"🔢 Fibonacci {level:.3f} seviyesi: {target:.2f}")
            if self.last_price < target:
                await self.simulate_order("BUY", strategy=f"Fibonacci {level:.3f}")

    async def pantheon_mode(self):
        print("⚡ [MECLİS] Kod zekâları karşılaştırılıyor...")
        gods = {
            "Hermes": lambda p: "BUY" if p % 2 == 0 else "SELL",
            "Athena": lambda p: "BUY" if p > 100 else "SELL",
            "Loki": lambda p: "SELL" if p < 99 else "BUY",
            "Ra": lambda p: "BUY" if str(p).endswith("7") else "SELL"
        }
        for name, logic in gods.items():
            decision = logic(self.last_price)
            await self.simulate_order(decision, strategy=name)

    async def simulate_order(self, side, strategy="Academy"):
        qty = round((self.equity * self.max_capital_pct * self.leverage) / self.last_price, 4)
        print(f"🧪 [{strategy}] → {side} @ {self.last_price:.2f} | Miktar: {qty}")

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\ultra_elite_allinone_v3.py
# ultra_elite_allinone_v3.py
# (c) Ultra Elite Hybrid — all-in-one: plugins + schema + ccxt live/paper + risk + telemetry
from __future__ import annotations
import os, sys, json, time, math, uuid, threading, importlib.util, pathlib, argparse
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, Callable, Tuple

# 3rd party deps (install: pip install python-dotenv ccxt pandas numpy ta jsonschema fastapi uvicorn prometheus_client loguru)
from dotenv import load_dotenv
from loguru import logger as log
import pandas as pd
import numpy as np
import ccxt
import jsonschema

# ============ i18n ============
I18N = {
    "tr": {
        "online": "ULTRA ELİT HİBRİT MOTOR AKTİF",
        "paper_on": "Paper mod: emir GÖNDERİLMEYECEK.",
        "live_on": "Canlı mod: emirler borsaya gönderilecek.",
        "fetch": "{sym} {tf} mumları çekiliyor…",
        "placed": "{side} {qty} {sym} @ {price}",
        "would": "PAPER {side} {qty} {sym} @ {price}",
        "nosig": "Sinyal yok.",
        "bt_done": "Backtest: {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
    "en": {
        "online": "ULTRA ELITE HYBRID ENGINE ONLINE",
        "paper_on": "Paper mode: orders will NOT be sent.",
        "live_on": "Live mode: orders WILL be sent.",
        "fetch": "Fetching {sym} {tf} candles…",
        "placed": "Placed {side} {qty} {sym} @ {price}",
        "would": "WOULD {side} {qty} {sym} @ {price}",
        "nosig": "No signal.",
        "bt_done": "Backtest: {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
    "fr": {
        "online": "MOTEUR HYBRIDE ULTRA ÉLITE EN LIGNE",
        "paper_on": "Mode paper : aucun ordre envoyé.",
        "live_on": "Mode live : ordres envoyés.",
        "fetch": "Récupération des chandelles {sym} {tf}…",
        "placed": "Ordre {side} {qty} {sym} @ {price}",
        "would": "EN PAPER {side} {qty} {sym} @ {price}",
        "nosig": "Pas de signal.",
        "bt_done": "Backtest : {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
    "de": {
        "online": "ULTRA-ELITE HYBRIDER MOTOR ONLINE",
        "paper_on": "Paper-Modus: keine Orders gesendet.",
        "live_on": "Live-Modus: Orders werden gesendet.",
        "fetch": "{sym} {tf} Kerzen werden geladen…",
        "placed": "Platziert {side} {qty} {sym} @ {price}",
        "would": "WÜRDE {side} {qty} {sym} @ {price}",
        "nosig": "Kein Signal.",
        "bt_done": "Backtest: {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
}
def tr(lang: str, key: str, **kw): 
    base = I18N.get(lang) or I18N["en"]
    return (base.get(key) or key).format(**kw)

# ============ Health & Metrics ============
class Health(str):
    OK="ok"; WARN="warn"; FAIL="fail"

@dataclass
class Metrics:
    init_ms: float = 0.0
    activate_ms: float = 0.0
    custom: Dict[str, float] = field(default_factory=dict)

# ============ Registry / Module / Schema ============
@dataclass
class Module:
    name: str
    status: str
    payload: Dict[str, Any]
    health: str = Health.OK
    metrics: Metrics = field(default_factory=Metrics)
    schema: Optional[Dict[str, Any]] = None
    def to_dict(self) -> Dict[str, Any]:
        return {"name":self.name,"status":self.status,"health":self.health,"metrics":asdict(self.metrics),**(self.payload or {})}

REGISTRY: Dict[str, Callable[[str,str], Module]] = {}
def register(name: str):
    def deco(fn: Callable[[str,str],Module]):
        REGISTRY[name] = fn
        return fn
    return deco

# Built-in schema registry (inline; single-file)
SCHEMAS: Dict[str, Dict[str, Any]] = {
    "code": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object", "required":["msg"],
        "properties":{"msg":{"type":"string","minLength":1}}
    },
    "market": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object", "required":["exchange","symbols","timeframe"],
        "properties":{
            "exchange":{"type":"string"},
            "symbols":{"type":"array","items":{"type":"string"},"minItems":1},
            "timeframe":{"type":"string","pattern":"^[0-9]+[smhdw]$"},
            "use_testnet":{"type":"boolean"},
            "use_futures":{"type":"boolean"}
        }, "additionalProperties": True
    },
    "risk": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["account_equity","max_risk_pct","max_daily_dd","leverage"],
        "properties":{
            "account_equity":{"type":"number","minimum":0},
            "max_risk_pct":{"type":"number","minimum":0,"maximum":0.2},
            "max_daily_dd":{"type":"number","minimum":0,"maximum":0.2},
            "leverage":{"type":"integer","minimum":1,"maximum":125}
        }, "additionalProperties": True
    },
    "telemetry": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["counters","latency_ms"],
        "properties":{
            "counters":{"type":"object","additionalProperties":{"type":"integer","minimum":0}},
            "latency_ms":{"type":"number","minimum":0},
            "pnl":{"type":"number"},
            "trades":{"type":"integer","minimum":0},
            "winrate":{"type":"number","minimum":0}
        }, "additionalProperties": True
    }
}
def load_schema(name: str) -> Optional[Dict[str,Any]]:
    return SCHEMAS.get(name.lower())
def validate_payload(mod: Module):
    schema = mod.schema or load_schema(mod.name)
    if schema:
        jsonschema.validate(mod.payload, schema)

# ============ Settings ============
@dataclass
class Settings:
    exchange: str = "BINANCE"
    use_testnet: bool = True
    use_futures: bool = True
    symbols: List[str] = field(default_factory=lambda: ["BTC/USDT"])
    timeframe: str = "1m"
    api_key: str = ""
    api_secret: str = ""
    hedge_mode: bool = True
    margin_type: str = "ISOLATED"
    leverage: int = 5
    account_equity: float = 5000.0
    max_risk_pct: float = 0.015
    max_daily_dd: float = 0.02
    dry_run: bool = True
    log_level: str = "INFO"
    lang: str = "tr"
    api_key_header: str = "secret123"  # for API

    @staticmethod
    def load() -> "Settings":
        load_dotenv(override=True)
        syms = os.getenv("SYMBOLS","BTC/USDT").split(",")
        return Settings(
            exchange=os.getenv("EXCHANGE","BINANCE").upper(),
            use_testnet=os.getenv("USE_TESTNET","true").lower()=="true",
            use_futures=os.getenv("USE_FUTURES","true").lower()=="true",
            symbols=[s.strip() for s in syms if s.strip()],
            timeframe=os.getenv("TIMEFRAME","1m"),
            api_key=os.getenv("BINANCE_API_KEY",""),
            api_secret=os.getenv("BINANCE_API_SECRET",""),
            hedge_mode=os.getenv("HEDGE_MODE","true").lower()=="true",
            margin_type=os.getenv("MARGIN_TYPE","ISOLATED").upper(),
            leverage=int(os.getenv("LEVERAGE","5")),
            account_equity=float(os.getenv("ACCOUNT_EQUITY","5000")),
            max_risk_pct=float(os.getenv("MAX_RISK_PCT_PER_TRADE","0.015")),
            max_daily_dd=float(os.getenv("MAX_DAILY_DRAWDOWN","0.02")),
            dry_run=os.getenv("DRY_RUN","true").lower()=="true",
            log_level=os.getenv("LOG_LEVEL","INFO").upper(),
            lang=os.getenv("LANG","tr").lower(),
            api_key_header=os.getenv("API_KEY","secret123")
        )

# ============ Strategy (EMA + Supertrend) ============
def ema(s: pd.Series, p: int) -> pd.Series:
    return s.ewm(span=p, adjust=False).mean()

def supertrend(df: pd.DataFrame, period=10, mult=3.0) -> Tuple[pd.Series, pd.Series]:
    hl2 = (df["high"] + df["low"]) / 2.0
    tr = pd.concat([
        df["high"]-df["low"],
        (df["high"]-df["close"].shift()).abs(),
        (df["low"]-df["close"].shift()).abs()
    ],axis=1).max(axis=1)
    atr = tr.rolling(period).mean()
    upper = hl2 + mult*atr
    lower = hl2 - mult*atr
    st = pd.Series(index=df.index, dtype=float)
    trend = pd.Series(index=df.index, dtype=int)
    for i in range(len(df)):
        if i==0:
            st.iloc[i]=upper.iloc[i]; trend.iloc[i]=1; continue
        upper.iloc[i] = min(upper.iloc[i], upper.iloc[i-1]) if df["close"].iloc[i-1] <= upper.iloc[i-1] else upper.iloc[i]
        lower.iloc[i] = max(lower.iloc[i], lower.iloc[i-1]) if df["close"].iloc[i-1] >= lower.iloc[i-1] else lower.iloc[i]
        if df["close"].iloc[i] > upper.iloc[i-1]: trend.iloc[i]=1
        elif df["close"].iloc[i] < lower.iloc[i-1]: trend.iloc[i]=-1
        else: trend.iloc[i]=trend.iloc[i-1]
        st.iloc[i] = lower.iloc[i] if trend.iloc[i]==1 else upper.iloc[i]
    return st, trend

@dataclass
class Signal:
    side: Optional[str]=None  # "buy"/"sell"
    price: Optional[float]=None
    stop: Optional[float]=None

def generate_signal(df: pd.DataFrame, fast=9, slow=21, st_p=10, st_m=3.0) -> Signal:
    e1, e2 = ema(df["close"], fast), ema(df["close"], slow)
    st, trd = supertrend(df, st_p, st_m)
    last = df.index[-1]; px = float(df["close"].iloc[-1])
    if e1.iloc[-1] > e2.iloc[-1] and px > st.iloc[-1]: return Signal("buy", px, float(st.iloc[-1]))
    if e1.iloc[-1] < e2.iloc[-1] and px < st.iloc[-1]: return Signal("sell", px, float(st.iloc[-1]))
    return Signal()

# ============ Exchange Adapter (ccxt) ============
class CcxtBinance:
    def __init__(self, s: Settings):
        self.s = s
        if s.use_futures:
            self.ex = ccxt.binanceusdm({"apiKey": s.api_key, "secret": s.api_secret, "enableRateLimit": True})
        else:
            self.ex = ccxt.binance({"apiKey": s.api_key, "secret": s.api_secret, "enableRateLimit": True})
        if s.use_testnet:
            try: self.ex.set_sandbox_mode(True)
            except Exception: pass

    def fetch_ohlcv_df(self, symbol: str, timeframe: str, limit: int = 500) -> pd.DataFrame:
        raw = self.ex.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
        df = pd.DataFrame(raw, columns=["ts","open","high","low","close","volume"])
        df["ts"] = pd.to_datetime(df["ts"], unit="ms", utc=True)
        return df.set_index("ts")

    def place_order(self, symbol: str, side: str, qty: float) -> Dict[str,Any]:
        if self.s.dry_run:
            log.info(tr(self.s.lang,"would"), side=side.upper(), qty=qty, sym=symbol, price="MARKET")
            return {"simulated":True}
        order = self.ex.create_order(symbol=symbol, type="market", side=side, amount=qty)
        log.success(tr(self.s.lang,"placed"), side=side.upper(), qty=qty, sym=symbol, price=order.get("price") or "MARKET")
        return order

# ============ Risk / Telemetry ============
@dataclass
class Risk:
    equity: float
    max_risk_pct: float
    max_daily_dd: float
    leverage: int
    day_pnl: float = 0.0
    day: Optional[str] = None
    def size(self, price: float, stop: float) -> float:
        risk = self.equity * self.max_risk_pct
        dist = abs(price - stop) or 1e-8
        qty = risk / dist
        return round(max(0.0, qty), 3)
    def update_pnl(self, pnl: float):
        today = datetime.utcnow().date().isoformat()
        if self.day != today:
            self.day = today; self.day_pnl = 0.0
        self.day_pnl += pnl
        if self.day_pnl <= -self.equity*self.max_daily_dd:
            raise RuntimeError("Daily drawdown limit reached")

@dataclass
class Telemetry:
    counters: Dict[str,int] = field(default_factory=lambda: {"events":0,"warnings":0,"errors":0})
    latency_ms: float = 0.0
    pnl: float = 0.0
    trades: int = 0
    wins: int = 0
    def winrate(self) -> float: return (self.wins/self.trades) if self.trades else 0.0
    def to_payload(self)->Dict[str,Any]:
        return {"counters":self.counters,"latency_ms":self.latency_ms,"pnl":self.pnl,"trades":self.trades,"winrate":self.winrate()}

# ============ Live Engine ============
class LiveEngine:
    def __init__(self, s: Settings, adapter: CcxtBinance, tel: Telemetry, risk: Risk):
        self.s = s; self.ad = adapter; self.tel = tel; self.risk = risk
        self.running = False
        self._thread: Optional[threading.Thread] = None
        self.pos: Dict[str,int] = {sym:0 for sym in s.symbols}
        self.entry: Dict[str,float] = {sym:0.0 for sym in s.symbols}

    def _loop(self):
        log.info(tr(self.s.lang,"online"))
        log.warning(tr(self.s.lang,"paper_on") if self.s.dry_run else tr(self.s.lang,"live_on"))
        while self.running:
            t0 = time.perf_counter()
            try:
                for sym in self.s.symbols:
                    df = self.ad.fetch_ohlcv_df(sym, self.s.timeframe, limit=200)
                    sig = generate_signal(df)
                    px = float(df["close"].iloc[-1])
                    if sig.side:
                        if self.pos[sym]==0 or (self.pos[sym]==1 and sig.side=="sell") or (self.pos[sym]==-1 and sig.side=="buy"):
                            qty = self.risk.size(sig.price or px, sig.stop or px)
                            if qty>0:
                                self.ad.place_order(sym, sig.side, qty)
                                self.tel.trades += 1
                                # exit previous if reversing
                                if self.pos[sym]!=0:
                                    diff = (px - self.entry[sym]) * self.pos[sym]
                                    self.tel.pnl += diff
                                    if diff>0: self.tel.wins += 1
                                    self.risk.update_pnl(diff)
                                self.pos[sym] = 1 if sig.side=="buy" else -1
                                self.entry[sym] = px
                    else:
                        log.debug(tr(self.s.lang,"nosig"))
                self.tel.latency_ms = (time.perf_counter()-t0)*1000
            except Exception as e:
                log.error(f"[loop] {e}")
            time.sleep(max(3, tf_to_seconds(self.s.timeframe)//3))

    def start(self):
        if self.running: return
        self.running = True
        self._thread = threading.Thread(target=self._loop, daemon=True)
        self._thread.start()

    def stop(self):
        self.running = False
        if self._thread:
            self._thread.join(timeout=2)

def tf_to_seconds(tf: str) -> int:
    unit = tf[-1]; val = int(tf[:-1])
    return {"s":1,"m":60,"h":3600,"d":86400,"w":604800}.get(unit,60)*val

# ============ Built-in Modules (as plugins) ============
@register("Code")
def m_code(strategy: str, lang: str) -> Module:
    mod = Module("Code","ok",{"msg": f"{strategy} → coded & echoed"}, schema=load_schema("code"))
    validate_payload(mod); return mod

@register("Market")
def m_market(strategy: str, lang: str) -> Module:
    s = Settings.load()
    payload = {"exchange": s.exchange, "symbols": s.symbols, "timeframe": s.timeframe,
               "use_testnet": s.use_testnet, "use_futures": s.use_futures}
    mod = Module("Market","ok",payload,schema=load_schema("market"))
    validate_payload(mod); return mod

@register("Risk")
def m_risk(strategy: str, lang: str) -> Module:
    s = Settings.load()
    payload = {"account_equity": s.account_equity, "max_risk_pct": s.max_risk_pct,
               "max_daily_dd": s.max_daily_dd, "leverage": s.leverage}
    mod = Module("Risk","ok",payload,schema=load_schema("risk"))
    validate_payload(mod); return mod

# Telemetry module will be filled from LiveEngine metrics
_GLOBAL_TELEMETRY = Telemetry()

@register("Telemetry")
def m_telemetry(strategy: str, lang: str) -> Module:
    payload = _GLOBAL_TELEMETRY.to_payload()
    mod = Module("Telemetry","ok",payload,schema=load_schema("telemetry"))
    validate_payload(mod); return mod

# ============ Plugin discovery (optional) ============
def discover_plugins(folder="plugins"):
    p = pathlib.Path(folder)
    if not p.exists(): return
    for path in p.glob("*.py"):
        spec = importlib.util.spec_from_file_location(path.stem, path)
        mod = importlib.util.module_from_spec(spec); spec.loader.exec_module(mod)  # registers via @register

# ============ System ============
@dataclass
class EchoMeta:
    version: str = "Ultra Elit All-in-One v3.0"
    strategy: str = "KamalquantX"
    lang: str = "tr"
    generated_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    uuid: str = field(default_factory=lambda: str(uuid.uuid4()))

@dataclass
class UltraEliteSystem:
    meta: EchoMeta
    modules: Dict[str, Module] = field(default_factory=dict)
    def to_dict(self)->Dict[str,Any]:
        # refresh Telemetry payload on-the-fly
        if "Telemetry" in self.modules:
            self.modules["Telemetry"].payload = _GLOBAL_TELEMETRY.to_payload()
        return {"meta":asdict(self.meta),"engine":tr(self.meta.lang,"online"),
                "modules":{k:m.to_dict() for k,m in self.modules.items()}}

    @classmethod
    def build(cls, strategy: str, lang: str="tr", include: Optional[List[str]]=None):
        discover_plugins()
        sysobj = cls(EchoMeta(strategy=strategy, lang=lang))
        wanted = include or list(REGISTRY.keys())
        for k in wanted:
            if k not in REGISTRY: continue
            t0 = time.perf_counter()
            mod = REGISTRY[k](strategy, lang)
            mod.metrics.init_ms = (time.perf_counter()-t0)*1000
            validate_payload(mod)
            if mod.health not in (Health.OK, Health.WARN, Health.FAIL): mod.health = Health.OK
            sysobj.modules[k] = mod
        return sysobj

# ============ API (FastAPI) + WS + Prometheus ============
def create_app(sysobj: UltraEliteSystem, engine: Optional[LiveEngine]):
    try:
        from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
        from fastapi.responses import Response, JSONResponse
        from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    except Exception:
        return None
    s = Settings.load()
    API_KEY = s.api_key_header
    REQS = Counter("echo_requests_total","reqs")
    LAT = Histogram("echo_req_latency_seconds","latency")

    app = FastAPI(title="UltraElite Echo All-in-One", version=sysobj.meta.version)

    def key_dep():
        from fastapi import Request
        def inner(req: Request):
            if req.headers.get("x-api-key") != API_KEY:
                raise HTTPException(status.HTTP_401_UNAUTHORIZED,"Invalid API Key")
        return inner

    @app.get("/health")
    def health():
        REQS.inc(); return {"ok": True, "uuid": sysobj.meta.uuid}

    @app.get("/modules")
    def modules(dep=Depends(key_dep())):
        with LAT.time():
            REQS.inc()
            return sysobj.to_dict()["modules"]

    @app.get("/metrics")
    def metrics():
        return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

    @app.websocket("/ws")
    async def ws(sock: WebSocket):
        await sock.accept()
        try:
            while True:
                await sock.send_json(sysobj.to_dict())
                time.sleep(2)
        except Exception:
            pass

    # control live engine
    @app.post("/trade/start")
    def start(dep=Depends(key_dep())):
        if engine is None: raise HTTPException(503,"engine not available")
        engine.start(); return {"started": True}
    @app.post("/trade/stop")
    def stop(dep=Depends(key_dep())):
        if engine is None: raise HTTPException(503,"engine not available")
        engine.stop(); return {"stopped": True}

    return app

def run_api(sysobj: UltraEliteSystem, engine: Optional[LiveEngine], port: int=8080):
    app = create_app(sysobj, engine)
    if app is None:
        print("FastAPI/uvicorn/prometheus_client eksik. pip install fastapi uvicorn prometheus_client")
        return
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")

# ============ Backtest ============
def backtest(symbol: str, s: Settings, lookback=1000) -> Dict[str,Any]:
    ad = CcxtBinance(s)
    log.info(tr(s.lang,"fetch"), sym=symbol, tf=s.timeframe)
    df = ad.fetch_ohlcv_df(symbol, s.timeframe, limit=lookback)
    pos=0; entry=0.0; pnl=0.0; trades=0; wins=0
    for i in range(60, len(df)):
        w = df.iloc[:i+1]
        sig = generate_signal(w)
        px = float(w["close"].iloc[-1])
        if pos==0 and sig.side:
            pos = 1 if sig.side=="buy" else -1
            entry = px; trades += 1
        elif pos!=0 and ((pos==1 and sig.side=="sell") or (pos==-1 and sig.side=="buy")):
            diff = (px - entry) * pos
            pnl += diff; wins += 1 if diff>0 else 0
            pos=0; entry=0.0
    win = wins / trades if trades else 0.0
    log.success(tr(s.lang,"bt_done"), sym=symbol, tf=s.timeframe, ntr=trades, pnl=pnl, win=win)
    return {"trades":trades,"pnl":pnl,"winrate":win}

# ============ CLI ============
def main():
    s = Settings.load()
    log.remove(); log.add(lambda msg: print(msg, end=""), level=s.log_level)

    ap = argparse.ArgumentParser(description="Ultra Elite All-in-One v3")
    subs = ap.add_subparsers(dest="cmd", required=True)

    p_bt = subs.add_parser("backtest")
    p_bt.add_argument("--symbol","-s", required=True)
    p_bt.add_argument("--lookback", type=int, default=1000)

    p_live = subs.add_parser("live")
    p_live.add_argument("--symbol","-s", default=None)  # optional: override single symbol
    p_live.add_argument("--api", action="store_true")
    p_live.add_argument("--port", type=int, default=8080)

    p_api = subs.add_parser("api")
    p_api.add_argument("--port", type=int, default=8080)

    args = ap.parse_args()

    if args.cmd == "backtest":
        out = backtest(args.symbol, s, args.lookback)
        print(json.dumps(out, ensure_ascii=False, indent=2))
        return

    if args.cmd in ("live","api"):
        # prepare system & engine
        if args.cmd == "live" and args.symbol:
            s.symbols = [args.symbol]
        adapter = CcxtBinance(s)
        tel = _GLOBAL_TELEMETRY
        risk = Risk(s.account_equity, s.max_risk_pct, s.max_daily_dd, s.leverage)
        engine = LiveEngine(s, adapter, tel, risk)

        sysobj = UltraEliteSystem.build(strategy="KamalquantX", lang=s.lang,
                                        include=["Code","Market","Risk","Telemetry"])

        if args.cmd == "api" or args.api:
            # start engine if we are in live+api
            if args.cmd == "live": engine.start()
            run_api(sysobj, engine, port=args.port)
        else:
            engine.start()
            try:
                while True:
                    # print heartbeat JSON every ~20s
                    print(json.dumps(sysobj.to_dict(), ensure_ascii=False, indent=2))
                    time.sleep(20)
            except KeyboardInterrupt:
                engine.stop()

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\ultra_elite_allinone_v4.py
# ultra_elite_allinone_v4.py
# (c) Ultra Elite — all-in-one: strategy(KDJ/WR/TRIX+EMA/ST), realistic backtest, ccxt live/paper,
# risk, ATR trailing + partial TP, fees/slippage/funding, telemetry, plugin discovery, schema validation,
# REST API (FastAPI), WebSocket stream, Prometheus metrics, multi-language logs.
from __future__ import annotations
import os, sys, json, time, math, uuid, threading, importlib.util, pathlib, argparse
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, Callable, Tuple

# 3rd party deps: pip install python-dotenv ccxt pandas numpy ta jsonschema fastapi uvicorn prometheus_client loguru
from dotenv import load_dotenv
from loguru import logger as log
import pandas as pd
import numpy as np
import ccxt
import jsonschema

# ===================== i18n =====================
I18N = {
    "tr": {
        "online": "ULTRA ELİT HİBRİT KUANTUM SİSTEM AKTİF",
        "paper_on": "Paper mod: emir GÖNDERİLMEYECEK.",
        "live_on": "Canlı mod: emirler borsaya gönderilecek.",
        "fetch": "{sym} {tf} mumları çekiliyor…",
        "placed": "{side} {qty} {sym} @ {price}",
        "would": "PAPER {side} {qty} {sym} @ {price}",
        "nosig": "Sinyal yok.",
        "bt_done": "Backtest: {sym} {tf} | işlem={ntr} | PnL={pnl:.2f} | kazanım={win:.1%}",
    },
    "en": {
        "online": "ULTRA ELITE HYBRID QUANTUM SYSTEM ONLINE",
        "paper_on": "Paper mode: orders will NOT be sent.",
        "live_on": "Live mode: orders WILL be sent.",
        "fetch": "Fetching {sym} {tf} candles…",
        "placed": "Placed {side} {qty} {sym} @ {price}",
        "would": "WOULD {side} {qty} {sym} @ {price}",
        "nosig": "No signal.",
        "bt_done": "Backtest: {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
    "fr": {
        "online": "SYSTÈME QUANTIQUE HYBRIDE ULTRA ÉLITE EN LIGNE",
        "paper_on": "Mode paper : aucun ordre envoyé.",
        "live_on": "Mode live : ordres envoyés.",
        "fetch": "Récupération des chandelles {sym} {tf}…",
        "placed": "Ordre {side} {qty} {sym} @ {price}",
        "would": "EN PAPER {side} {qty} {sym} @ {price}",
        "nosig": "Pas de signal.",
        "bt_done": "Backtest : {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
    "de": {
        "online": "ULTRA-ELITE HYBRIDES QUANTENSYSTEM ONLINE",
        "paper_on": "Paper-Modus: keine Orders gesendet.",
        "live_on": "Live-Modus: Orders werden gesendet.",
        "fetch": "{sym} {tf} Kerzen werden geladen…",
        "placed": "Platziert {side} {qty} {sym} @ {price}",
        "would": "WÜRDE {side} {qty} {sym} @ {price}",
        "nosig": "Kein Signal.",
        "bt_done": "Backtest: {sym} {tf} | Trades={ntr} | PnL={pnl:.2f} | Treffer={win:.1%}",
    },
}
def tr(lang: str, key: str, **kw):
    base = I18N.get(lang) or I18N["en"]
    return (base.get(key) or key).format(**kw)

# ===================== Health & Metrics =====================
class Health(str):
    OK="ok"; WARN="warn"; FAIL="fail"

@dataclass
class Metrics:
    init_ms: float = 0.0
    activate_ms: float = 0.0
    custom: Dict[str, float] = field(default_factory=dict)

# ===================== Registry / Module / Schema =====================
@dataclass
class Module:
    name: str
    status: str
    payload: Dict[str, Any]
    health: str = Health.OK
    metrics: Metrics = field(default_factory=Metrics)
    schema: Optional[Dict[str, Any]] = None
    def to_dict(self) -> Dict[str, Any]:
        return {"name":self.name,"status":self.status,"health":self.health,"metrics":asdict(self.metrics),**(self.payload or {})}

REGISTRY: Dict[str, Callable[[str,str], Module]] = {}
def register(name: str):
    def deco(fn: Callable[[str,str],Module]):
        REGISTRY[name] = fn
        return fn
    return deco

# Inline JSON Schemas (tek dosya)
SCHEMAS: Dict[str, Dict[str, Any]] = {
    "code": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object", "required":["msg"],
        "properties":{"msg":{"type":"string","minLength":1}}
    },
    "market": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object", "required":["exchange","symbols","timeframe"],
        "properties":{
            "exchange":{"type":"string"},
            "symbols":{"type":"array","items":{"type":"string"},"minItems":1},
            "timeframe":{"type":"string","pattern":"^[0-9]+[smhdw]$"},
            "use_testnet":{"type":"boolean"},
            "use_futures":{"type":"boolean"}
        }, "additionalProperties": True
    },
    "risk": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["account_equity","max_risk_pct","max_daily_dd","leverage"],
        "properties":{
            "account_equity":{"type":"number","minimum":0},
            "max_risk_pct":{"type":"number","minimum":0,"maximum":0.2},
            "max_daily_dd":{"type":"number","minimum":0,"maximum":0.2},
            "leverage":{"type":"integer","minimum":1,"maximum":125}
        }, "additionalProperties": True
    },
    "telemetry": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["counters","latency_ms"],
        "properties":{
            "counters":{"type":"object","additionalProperties":{"type":"integer","minimum":0}},
            "latency_ms":{"type":"number","minimum":0},
            "pnl":{"type":"number"},
            "trades":{"type":"integer","minimum":0},
            "winrate":{"type":"number","minimum":0}
        }, "additionalProperties": True
    },
    "strategy": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["rsi_period","ema_fast","ema_slow","atr_period"],
        "properties":{
            "rsi_period":{"type":"integer","minimum":2},
            "ema_fast":{"type":"integer","minimum":2},
            "ema_slow":{"type":"integer","minimum":3},
            "atr_period":{"type":"integer","minimum":3},
            "kdj_on":{"type":"boolean"}, "wr_on":{"type":"boolean"}, "trix_on":{"type":"boolean"},
            "wr_buy":{"type":"number"}, "wr_sell":{"type":"number"},
            "trix_period":{"type":"integer","minimum":2}
        }, "additionalProperties": True
    },
    "backtest": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["taker_fee","slippage_bps","funding_rate_8h"],
        "properties":{
            "taker_fee":{"type":"number","minimum":0,"maximum":0.01},
            "maker_fee":{"type":"number","minimum":0,"maximum":0.01},
            "slippage_bps":{"type":"number","minimum":0,"maximum":1000},
            "funding_rate_8h":{"type":"number"},
            "funding_sign":{"type":"integer","minimum":-1,"maximum":1},
            "tp_rr":{"type":"array","items":{"type":"number","minimum":0.1},"minItems":1,"maxItems":4},
            "tp_frac":{"type":"array","items":{"type":"number","minimum":0,"maximum":1},"minItems":1,"maxItems":4},
            "trail_be_rr":{"type":"number","minimum":0},
            "trail_mult":{"type":"number","minimum":0}
        }, "additionalProperties": True
    }
}
def load_schema(name: str) -> Optional[Dict[str,Any]]: return SCHEMAS.get(name.lower())
def validate_payload(mod: Module):
    schema = mod.schema or load_schema(mod.name)
    if schema: jsonschema.validate(mod.payload, schema)

# ===================== Settings =====================
@dataclass
class Settings:
    exchange: str = "BINANCE"
    use_testnet: bool = True
    use_futures: bool = True
    symbols: List[str] = field(default_factory=lambda: ["BTC/USDT"])
    timeframe: str = "1m"
    api_key: str = ""
    api_secret: str = ""
    hedge_mode: bool = True
    margin_type: str = "ISOLATED"
    leverage: int = 5
    account_equity: float = 5000.0
    max_risk_pct: float = 0.015
    max_daily_dd: float = 0.02
    dry_run: bool = True
    log_level: str = "INFO"
    lang: str = "tr"
    api_key_header: str = "secret123"  # REST koruması

    # Strategy toggles
    rsi_period:int=14; ema_fast:int=21; ema_slow:int=50; atr_period:int=14
    kdj_on:bool=True; wr_on:bool=True; trix_on:bool=True
    wr_buy:float=-80.0; wr_sell:float=-20.0
    trix_period:int=9

    # Backtest & exec economics
    taker_fee:float=0.0004; maker_fee:float=0.0002
    slippage_bps:float=2.0
    funding_rate_8h:float=0.0
    funding_sign:int=0 # +1 öder, -1 alır, 0 yok
    tp_rr:List[float]=field(default_factory=lambda:[1.0,2.0])
    tp_frac:List[float]=field(default_factory=lambda:[0.5,0.5])
    trail_be_rr:float=1.0
    trail_mult:float=1.0

    @staticmethod
    def load() -> "Settings":
        load_dotenv(override=True)
        syms = os.getenv("SYMBOLS","BTC/USDT").split(",")
        def _flo(name, default): 
            try: return float(os.getenv(name, str(default)))
            except: return default
        def _bool(name, default): 
            return os.getenv(name, str(default)).lower()=="true"
        return Settings(
            exchange=os.getenv("EXCHANGE","BINANCE").upper(),
            use_testnet=_bool("USE_TESTNET", True),
            use_futures=_bool("USE_FUTURES", True),
            symbols=[s.strip() for s in syms if s.strip()],
            timeframe=os.getenv("TIMEFRAME","1m"),
            api_key=os.getenv("BINANCE_API_KEY",""),
            api_secret=os.getenv("BINANCE_API_SECRET",""),
            hedge_mode=_bool("HEDGE_MODE", True),
            margin_type=os.getenv("MARGIN_TYPE","ISOLATED").upper(),
            leverage=int(os.getenv("LEVERAGE","5")),
            account_equity=_flo("ACCOUNT_EQUITY", 5000),
            max_risk_pct=_flo("MAX_RISK_PCT_PER_TRADE", 0.015),
            max_daily_dd=_flo("MAX_DAILY_DRAWDOWN", 0.02),
            dry_run=_bool("DRY_RUN", True),
            log_level=os.getenv("LOG_LEVEL","INFO").upper(),
            lang=os.getenv("LANG","tr").lower(),
            api_key_header=os.getenv("API_KEY","secret123"),

            rsi_period=int(os.getenv("RSI_PERIOD","14")),
            ema_fast=int(os.getenv("EMA_FAST","21")),
            ema_slow=int(os.getenv("EMA_SLOW","50")),
            atr_period=int(os.getenv("ATR_PERIOD","14")),
            kdj_on=_bool("KDJ_ON", True),
            wr_on=_bool("WR_ON", True),
            trix_on=_bool("TRIX_ON", True),
            wr_buy=_flo("WR_BUY", -80.0),
            wr_sell=_flo("WR_SELL", -20.0),
            trix_period=int(os.getenv("TRIX_PERIOD","9")),

            taker_fee=_flo("TAKER_FEE", 0.0004),
            maker_fee=_flo("MAKER_FEE", 0.0002),
            slippage_bps=_flo("SLIPPAGE_BPS", 2.0),
            funding_rate_8h=_flo("FUNDING_RATE_8H", 0.0),
            funding_sign=int(os.getenv("FUNDING_SIGN","0")),
            tp_rr=[_flo("TP1_RR",1.0), _flo("TP2_RR",2.0)],
            tp_frac=[_flo("TP1_FRAC",0.5), _flo("TP2_FRAC",0.5)],
            trail_be_rr=_flo("TRAIL_BE_RR",1.0),
            trail_mult=_flo("TRAIL_MULT",1.0),
        )

# ===================== Indicators & Strategy (EMA/ST + KDJ/WR/TRIX) =====================
def ema(s: pd.Series, p: int) -> pd.Series:
    return s.ewm(span=p, adjust=False).mean()

def tr_series(df: pd.DataFrame) -> pd.Series:
    tr1 = df["high"]-df["low"]
    tr2 = (df["high"]-df["close"].shift()).abs()
    tr3 = (df["low"]-df["close"].shift()).abs()
    return pd.concat([tr1,tr2,tr3],axis=1).max(axis=1)

def atr(df: pd.DataFrame, period:int) -> pd.Series:
    return tr_series(df).rolling(period).mean()

def supertrend(df: pd.DataFrame, period=10, mult=3.0) -> Tuple[pd.Series, pd.Series]:
    hl2 = (df["high"] + df["low"]) / 2.0
    a = atr(df, period)
    upper = hl2 + mult*a
    lower = hl2 - mult*a
    st = pd.Series(index=df.index, dtype=float)
    trend = pd.Series(index=df.index, dtype=int)
    for i in range(len(df)):
        if i==0: st.iloc[i]=upper.iloc[i]; trend.iloc[i]=1; continue
        upper.iloc[i] = min(upper.iloc[i], upper.iloc[i-1]) if df["close"].iloc[i-1] <= upper.iloc[i-1] else upper.iloc[i]
        lower.iloc[i] = max(lower.iloc[i], lower.iloc[i-1]) if df["close"].iloc[i-1] >= lower.iloc[i-1] else lower.iloc[i]
        if df["close"].iloc[i] > upper.iloc[i-1]: trend.iloc[i]=1
        elif df["close"].iloc[i] < lower.iloc[i-1]: trend.iloc[i]=-1
        else: trend.iloc[i]=trend.iloc[i-1]
        st.iloc[i] = lower.iloc[i] if trend.iloc[i]==1 else upper.iloc[i]
    return st, trend

def stochastic(df: pd.DataFrame, k_window=9, d_window=3) -> Tuple[pd.Series,pd.Series,pd.Series]:
    low_min = df["low"].rolling(k_window).min()
    high_max = df["high"].rolling(k_window).max()
    k = 100*(df["close"]-low_min)/(high_max-low_min)
    d = k.rolling(d_window).mean()
    j = 3*k - 2*d
    return k.clip(0,100), d.clip(0,100), j.clip(0,100)

def williams_r(df: pd.DataFrame, lbp=14) -> pd.Series:
    low_min = df["low"].rolling(lbp).min()
    high_max = df["high"].rolling(lbp).max()
    wr = -100*(high_max - df["close"])/(high_max - low_min)
    return wr.clip(-100,0)

def trix(df: pd.DataFrame, period=9) -> pd.Series:
    e1 = df["close"].ewm(span=period, adjust=False).mean()
    e2 = e1.ewm(span=period, adjust=False).mean()
    e3 = e2.ewm(span=period, adjust=False).mean()
    return 100*(e3.diff()/e3.shift())

@dataclass
class Signal:
    side: Optional[str]=None  # "buy"/"sell"
    price: Optional[float]=None
    stop: Optional[float]=None
    atr: Optional[float]=None
    reason: str = ""

def generate_signal(df: pd.DataFrame, s: Settings) -> Signal:
    close = df["close"]
    e_fast, e_slow = ema(close, s.ema_fast), ema(close, s.ema_slow)
    st, trd = supertrend(df, s.atr_period, 3.0)
    a = atr(df, s.atr_period)
    last = df.index[-1]; px = float(close.iloc[-1])
    rs = close.diff().rolling(s.rsi_period).apply(lambda x: (x[x>0].mean() or 0) / max(1e-9, abs(x[x<0].mean() or 0)), raw=False)
    rsi = 100 - 100/(1+rs)
    # KDJ / WR / TRIX
    K,D,J = stochastic(df)
    WR = williams_r(df, 14)
    TRX = trix(df, s.trix_period)
    TRXsig = TRX.ewm(span=s.trix_period, adjust=False).mean()

    long_core = (e_fast.iloc[-1] > e_slow.iloc[-1]) and (px > st.iloc[-1])
    short_core = (e_fast.iloc[-1] < e_slow.iloc[-1]) and (px < st.iloc[-1])

    long_trig = long_core
    short_trig = short_core
    reasons=[]

    # RSI exit from OS/OB cross
    prev_rsi, now_rsi = rsi.iloc[-2], rsi.iloc[-1]
    if now_rsi>=30 and prev_rsi<30 and long_core: long_trig=True; reasons.append("RSI↑30")
    if now_rsi<=70 and prev_rsi>70 and short_core: short_trig=True; reasons.append("RSI↓70")

    if s.kdj_on:
        if K.iloc[-2] < D.iloc[-2] and K.iloc[-1] > D.iloc[-1] and K.iloc[-1] < 40: long_trig=True; reasons.append("KDJ cross up")
        if K.iloc[-2] > D.iloc[-2] and K.iloc[-1] < D.iloc[-1] and K.iloc[-1] > 60: short_trig=True; reasons.append("KDJ cross down")
    if s.wr_on:
        if WR.iloc[-1] <= s.wr_buy: long_trig=True; reasons.append("WR oversold")
        if WR.iloc[-1] >= s.wr_sell: short_trig=True; reasons.append("WR overbought")
    if s.trix_on:
        if TRX.iloc[-2] < TRXsig.iloc[-2] and TRX.iloc[-1] > TRXsig.iloc[-1]: long_trig=True; reasons.append("TRIX cross up")
        if TRX.iloc[-2] > TRXsig.iloc[-2] and TRX.iloc[-1] < TRXsig.iloc[-1]: short_trig=True; reasons.append("TRIX cross down")

    if long_trig and not short_trig:
        return Signal("buy", px, float(st.iloc[-1]), float(a.iloc[-1]), "+".join(reasons or ["core_up"]))
    if short_trig and not long_trig:
        return Signal("sell", px, float(st.iloc[-1]), float(a.iloc[-1]), "+".join(reasons or ["core_down"]))
    return Signal()

# ===================== Exchange Adapter (ccxt) =====================
class CcxtBinance:
    def __init__(self, s: Settings):
        self.s = s
        if s.use_futures:
            self.ex = ccxt.binanceusdm({"apiKey": s.api_key, "secret": s.api_secret, "enableRateLimit": True})
        else:
            self.ex = ccxt.binance({"apiKey": s.api_key, "secret": s.api_secret, "enableRateLimit": True})
        if s.use_testnet:
            try: self.ex.set_sandbox_mode(True)
            except Exception: pass

    def fetch_ohlcv_df(self, symbol: str, timeframe: str, limit: int = 500) -> pd.DataFrame:
        raw = self.ex.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
        df = pd.DataFrame(raw, columns=["ts","open","high","low","close","volume"])
        df["ts"] = pd.to_datetime(df["ts"], unit="ms", utc=True)
        return df.set_index("ts")

    def place_order(self, symbol: str, side: str, qty: float) -> Dict[str,Any]:
        if self.s.dry_run:
            log.info(tr(self.s.lang,"would"), side=side.upper(), qty=qty, sym=symbol, price="MARKET")
            return {"simulated":True}
        order = self.ex.create_order(symbol=symbol, type="market", side=side, amount=qty)
        log.success(tr(self.s.lang,"placed"), side=side.upper(), qty=qty, sym=symbol, price=order.get("price") or "MARKET")
        return order

# ===================== Risk / Telemetry =====================
@dataclass
class Risk:
    equity: float
    max_risk_pct: float
    max_daily_dd: float
    leverage: int
    day_pnl: float = 0.0
    day: Optional[str] = None
    def size(self, entry: float, stop: float) -> float:
        risk = self.equity * self.max_risk_pct
        dist = abs(entry - stop) or 1e-8
        qty = risk / dist
        return round(max(0.0, qty), 3)
    def update_pnl(self, pnl: float):
        today = datetime.utcnow().date().isoformat()
        if self.day != today:
            self.day = today; self.day_pnl = 0.0
        self.day_pnl += pnl
        if self.day_pnl <= -self.equity*self.max_daily_dd:
            raise RuntimeError("Daily drawdown limit reached")

@dataclass
class Telemetry:
    counters: Dict[str,int] = field(default_factory=lambda: {"events":0,"warnings":0,"errors":0})
    latency_ms: float = 0.0
    pnl: float = 0.0
    trades: int = 0
    wins: int = 0
    def winrate(self) -> float: return (self.wins/self.trades) if self.trades else 0.0
    def to_payload(self)->Dict[str,Any]:
        return {"counters":self.counters,"latency_ms":self.latency_ms,"pnl":self.pnl,"trades":self.trades,"winrate":self.winrate()}

# ===================== ATR Trailing & Partial TP utils =====================
def atr_trailing_stop(side:str, entry:float, best:float, atr_val:float, be_rr:float, trail_mult:float) -> float:
    if side=="buy":
        rr = (best - entry) / max(1e-9, atr_val)
        return max(entry, best - trail_mult*atr_val) if rr >= be_rr else entry - 1e-9
    else:
        rr = (entry - best) / max(1e-9, atr_val)
        return min(entry, best + trail_mult*atr_val) if rr >= be_rr else entry + 1e-9

# ===================== Live Engine (with ATR trailing & partial TP) =====================
class LiveEngine:
    def __init__(self, s: Settings, adapter: CcxtBinance, tel: Telemetry, risk: Risk):
        self.s = s; self.ad = adapter; self.tel = tel; self.risk = risk
        self.running = False
        self._thread: Optional[threading.Thread] = None
        self.pos: Dict[str,dict] = {sym: None for sym in s.symbols}

    def _open_pos(self, sym:str, sig:Signal):
        qty = self.risk.size(sig.price, sig.stop)
        if qty<=0: return
        self.ad.place_order(sym, sig.side, qty)
        tp_levels = [sig.price + rr*sig.atr*(1 if sig.side=="buy" else -1) for rr in self.s.tp_rr]
        self.pos[sym] = {"side":sig.side,"entry":sig.price,"atr":sig.atr,"qty":qty,
                         "best":sig.price,"stop":sig.stop,"tp_levels":tp_levels,
                         "tp_frac":list(self.s.tp_frac), "filled":[False]*len(tp_levels)}

    def _close_pos(self, sym:str, px:float):
        p = self.pos[sym]; 
        if not p: return
        side = p["side"]; qty = p["qty"]
        # simulate market flatten
        self.ad.place_order(sym, "sell" if side=="buy" else "buy", qty)
        diff = (px - p["entry"])*(1 if side=="buy" else -1)*(-1)  # entry->exit PNL sign? We'll compute below better.
        diff = (px - p["entry"])*(1 if side=="buy" else -1)  # positive if profit
        self.tel.pnl += diff
        self.tel.wins += 1 if diff>0 else 0
        self.risk.update_pnl(diff)
        self.pos[sym] = None

    def _loop(self):
        log.info(tr(self.s.lang,"online"))
        log.warning(tr(self.s.lang,"paper_on") if self.s.dry_run else tr(self.s.lang,"live_on"))
        while self.running:
            t0 = time.perf_counter()
            try:
                for sym in list(self.pos.keys()):
                    df = self.ad.fetch_ohlcv_df(sym, self.s.timeframe, limit=200)
                    sig = generate_signal(df, self.s)
                    px = float(df["close"].iloc[-1])
                    p = self.pos[sym]
                    if p is None and sig.side:
                        self._open_pos(sym, sig)
                        self.tel.trades += 1
                        continue
                    if p:
                        # update best and trailing stop
                        if p["side"]=="buy":
                            p["best"] = max(p["best"], px)
                        else:
                            p["best"] = min(p["best"], px)
                        new_stop = atr_trailing_stop(p["side"], p["entry"], p["best"], p["atr"],
                                                     self.s.trail_be_rr, self.s.trail_mult)
                        if p["side"]=="buy": p["stop"] = max(p["stop"], new_stop)
                        else: p["stop"] = min(p["stop"], new_stop)

                        # partial TPs
                        for i, lvl in enumerate(p["tp_levels"]):
                            if p["filled"][i]: continue
                            hit = (px>=lvl) if p["side"]=="buy" else (px<=lvl)
                            if hit:
                                part = p["tp_frac"][i]*p["qty"]
                                if part>0:
                                    self.ad.place_order(sym, "sell" if p["side"]=="buy" else "buy", part)
                                    # realize pnl for that fraction
                                    unit = (lvl - p["entry"])*(1 if p["side"]=="buy" else -1)
                                    self.tel.pnl += unit * part / p["qty"]
                                    self.risk.update_pnl(unit * part / p["qty"])
                                    p["qty"] -= part
                                p["filled"][i]=True
                        # stop hit?
                        stop_hit = (px<=p["stop"]) if p["side"]=="buy" else (px>=p["stop"])
                        if stop_hit or p["qty"]<=1e-9:
                            self._close_pos(sym, px)
                            continue

                        # reverse on opposite signal
                        if (p["side"]=="buy" and sig.side=="sell") or (p["side"]=="sell" and sig.side=="buy"):
                            self._close_pos(sym, px)
                            self._open_pos(sym, sig)
                            self.tel.trades += 1
            except Exception as e:
                log.error(f"[live] {e}")
            self.tel.latency_ms = (time.perf_counter()-t0)*1000
            time.sleep(max(3, tf_to_seconds(self.s.timeframe)//3))

    def start(self):
        if self.running: return
        self.running = True
        self._thread = threading.Thread(target=self._loop, daemon=True)
        self._thread.start()

    def stop(self):
        self.running = False
        if self._thread: self._thread.join(timeout=2)

def tf_to_seconds(tf: str) -> int:
    unit = tf[-1]; val = int(tf[:-1])
    return {"s":1,"m":60,"h":3600,"d":86400,"w":604800}.get(unit,60)*val

# ===================== Built-in Modules =====================
@register("Code")
def m_code(strategy: str, lang: str) -> Module:
    mod = Module("Code","ok",{"msg": f"{strategy} → coded & echoed"}, schema=load_schema("code"))
    validate_payload(mod); return mod

@register("Market")
def m_market(strategy: str, lang: str) -> Module:
    s = Settings.load()
    payload = {"exchange": s.exchange, "symbols": s.symbols, "timeframe": s.timeframe,
               "use_testnet": s.use_testnet, "use_futures": s.use_futures}
    mod = Module("Market","ok",payload,schema=load_schema("market")); validate_payload(mod); return mod

@register("Risk")
def m_risk(strategy: str, lang: str) -> Module:
    s = Settings.load()
    payload = {"account_equity": s.account_equity, "max_risk_pct": s.max_risk_pct,
               "max_daily_dd": s.max_daily_dd, "leverage": s.leverage}
    mod = Module("Risk","ok",payload,schema=load_schema("risk")); validate_payload(mod); return mod

@register("Strategy")
def m_strategy(strategy:str, lang:str) -> Module:
    s=Settings.load()
    payload={"rsi_period":s.rsi_period,"ema_fast":s.ema_fast,"ema_slow":s.ema_slow,"atr_period":s.atr_period,
             "kdj_on":s.kdj_on,"wr_on":s.wr_on,"trix_on":s.trix_on,"wr_buy":s.wr_buy,"wr_sell":s.wr_sell,"trix_period":s.trix_period}
    mod=Module("Strategy","ok",payload,schema=load_schema("strategy")); validate_payload(mod); return mod

_GLOBAL_TELEMETRY = Telemetry()
@register("Telemetry")
def m_telemetry(strategy: str, lang: str) -> Module:
    payload = _GLOBAL_TELEMETRY.to_payload()
    mod = Module("Telemetry","ok",payload,schema=load_schema("telemetry")); validate_payload(mod); return mod

@register("Backtest")
def m_backtest_config(strategy:str, lang:str)->Module:
    s=Settings.load()
    payload={"taker_fee":s.taker_fee,"maker_fee":s.maker_fee,"slippage_bps":s.slippage_bps,
             "funding_rate_8h":s.funding_rate_8h,"funding_sign":s.funding_sign,
             "tp_rr":s.tp_rr,"tp_frac":s.tp_frac,"trail_be_rr":s.trail_be_rr,"trail_mult":s.trail_mult}
    mod=Module("Backtest","ok",payload,schema=load_schema("backtest")); validate_payload(mod); return mod

# ===================== Plugin discovery (opsiyonel) =====================
def discover_plugins(folder="plugins"):
    p = pathlib.Path(folder)
    if not p.exists(): return
    for path in p.glob("*.py"):
        spec = importlib.util.spec_from_file_location(path.stem, path)
        mod = importlib.util.module_from_spec(spec); spec.loader.exec_module(mod)

# ===================== System & API =====================
@dataclass
class EchoMeta:
    version: str = "Ultra Elit All-in-One v4.0 — Infinity-Seal Meta-Echo Protocol"
    strategy: str = "KamalquantX"
    lang: str = "tr"
    generated_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    uuid: str = field(default_factory=lambda: str(uuid.uuid4()))

@dataclass
class UltraEliteSystem:
    meta: EchoMeta
    modules: Dict[str, Module] = field(default_factory=dict)
    def to_dict(self)->Dict[str,Any]:
        if "Telemetry" in self.modules:
            self.modules["Telemetry"].payload = _GLOBAL_TELEMETRY.to_payload()
        return {"meta":asdict(self.meta),"engine":tr(self.meta.lang,"online"),
                "modules":{k:m.to_dict() for k,m in self.modules.items()}}

    @classmethod
    def build(cls, strategy: str, lang: str="tr", include: Optional[List[str]]=None):
        discover_plugins()
        sysobj = cls(EchoMeta(strategy=strategy, lang=lang))
        wanted = include or list(REGISTRY.keys())
        for k in wanted:
            if k not in REGISTRY: continue
            t0 = time.perf_counter()
            mod = REGISTRY[k](strategy, lang)
            mod.metrics.init_ms = (time.perf_counter()-t0)*1000
            validate_payload(mod)
            if mod.health not in (Health.OK, Health.WARN, Health.FAIL): mod.health = Health.OK
            sysobj.modules[k] = mod
        return sysobj

def create_app(sysobj: UltraEliteSystem, engine: Optional[LiveEngine]):
    try:
        from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
        from fastapi.responses import Response
        from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    except Exception:
        return None
    s = Settings.load()
    API_KEY = s.api_key_header
    REQS = Counter("echo_requests_total","reqs")
    LAT  = Histogram("echo_req_latency_seconds","latency")

    app = FastAPI(title="UltraElite Echo All-in-One", version=sysobj.meta.version)

    def key_dep():
        from fastapi import Request
        def inner(req:Request):
            if req.headers.get("x-api-key") != API_KEY:
                raise HTTPException(status.HTTP_401_UNAUTHORIZED,"Invalid API Key")
        return inner

    @app.get("/health")
    def health():
        REQS.inc(); return {"ok": True, "uuid": sysobj.meta.uuid}

    @app.get("/modules")
    def modules(dep=Depends(key_dep())):
        with LAT.time(): REQS.inc(); return sysobj.to_dict()["modules"]

    @app.get("/metrics")
    def metrics(): return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

    @app.websocket("/ws")
    async def ws(sock: WebSocket):
        await sock.accept()
        try:
            while True:
                await sock.send_json(sysobj.to_dict()); time.sleep(2)
        except Exception:
            pass

    @app.post("/trade/start")
    def start(dep=Depends(key_dep())):
        if engine is None: raise HTTPException(503,"engine not available")
        engine.start(); return {"started": True}

    @app.post("/trade/stop")
    def stop(dep=Depends(key_dep())):
        if engine is None: raise HTTPException(503,"engine not available")
        engine.stop(); return {"stopped": True}

    return app

def run_api(sysobj: UltraEliteSystem, engine: Optional[LiveEngine], port: int=8080):
    app = create_app(sysobj, engine)
    if app is None:
        print("FastAPI/uvicorn/prometheus_client eksik. pip install fastapi uvicorn prometheus_client")
        return
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")

# ===================== Realistic Backtest =====================
@dataclass
class BTConfig:
    taker_fee:float; maker_fee:float; slippage_bps:float
    funding_rate_8h:float; funding_sign:int
    tp_rr:List[float]; tp_frac:List[float]
    trail_be_rr:float; trail_mult:float

def seconds_per_bar(tf:str)->int:
    unit=tf[-1]; val=int(tf[:-1]); return {"s":1,"m":60,"h":3600,"d":86400,"w":604800}.get(unit,60)*val

def fill_price(px:float, side:str, slippage_bps:float)->float:
    slip = px * (slippage_bps/10000.0)
    return px + slip if side=="buy" else px - slip

def commission(notional:float, fee:float)->float: return abs(notional)*fee

def funding_cost(notional:float, seconds:int, rate8h:float, sign:int)->float:
    if rate8h==0 or sign==0 or seconds<=0: return 0.0
    per_sec = rate8h / (8*3600.0)
    return notional * per_sec * seconds * sign

def backtest(symbol: str, s: Settings, lookback=1500) -> Dict[str,Any]:
    ad = CcxtBinance(s)
    df = ad.fetch_ohlcv_df(symbol, s.timeframe, limit=lookback)
    cfg = BTConfig(s.taker_fee, s.maker_fee, s.slippage_bps, s.funding_rate_8h, s.funding_sign,
                   s.tp_rr, s.tp_frac, s.trail_be_rr, s.trail_mult)

    pnl=0.0; trades=0; wins=0
    pos=None  # dict: side, entry, qty, atr, best, stop, tp_levels, tp_frac, filled
    tfsec = seconds_per_bar(s.timeframe)

    for i in range(max(60, s.ema_slow+5), len(df)):
        window = df.iloc[:i+1]
        sig = generate_signal(window, s)
        px = float(window["close"].iloc[-1])
        a = float(atr(window, s.atr_period).iloc[-1] or 0.0)

        # funding accrual per open bar
        if pos:
            # funding cost on notional (entry*qty/leverage varsayımı yerine basit: px*qty)
            notional = px * pos["qty"]
            pnl -= funding_cost(notional, tfsec, cfg.funding_rate_8h, cfg.funding_sign)

        if pos is None and sig.side:
            qty = Risk(s.account_equity, s.max_risk_pct, s.max_daily_dd, s.leverage).size(sig.price, sig.stop)
            if qty<=0: continue
            entry_price = fill_price(px, sig.side, cfg.slippage_bps)
            trades += 1
            tp_levels = [entry_price + rr*sig.atr*(1 if sig.side=="buy" else -1) for rr in cfg.tp_rr]
            pos={"side":sig.side,"entry":entry_price,"qty":qty,"atr":sig.atr or a,
                 "best":entry_price,"stop":sig.stop,"tp_levels":tp_levels,
                 "tp_frac":list(cfg.tp_frac),"filled":[False]*len(tp_levels)}
            # entry commission
            pnl -= commission(entry_price*qty, cfg.taker_fee)
            continue

        if pos:
            # update best & trailing
            if pos["side"]=="buy": pos["best"] = max(pos["best"], px)
            else: pos["best"] = min(pos["best"], px)
            new_stop = atr_trailing_stop(pos["side"], pos["entry"], pos["best"], pos["atr"], cfg.trail_be_rr, cfg.trail_mult)
            if pos["side"]=="buy": pos["stop"] = max(pos["stop"], new_stop)
            else: pos["stop"] = min(pos["stop"], new_stop)

            # partial TPs
            for i, lvl in enumerate(pos["tp_levels"]):
                if pos["filled"][i]: continue
                hit = (px>=lvl) if pos["side"]=="buy" else (px<=lvl)
                if hit:
                    part = pos["tp_frac"][i]*pos["qty"]
                    if part>0:
                        exit_px = fill_price(lvl, "sell" if pos["side"]=="buy" else "buy", cfg.slippage_bps)
                        unit = (exit_px - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                        pnl += unit * (part/pos["qty"])
                        pnl -= commission(exit_px*part, cfg.taker_fee)
                        pos["qty"] -= part
                    pos["filled"][i]=True

            # stop hit?
            stop_hit = (px<=pos["stop"]) if pos["side"]=="buy" else (px>=pos["stop"])
            if stop_hit:
                exit_px = fill_price(pos["stop"], "sell" if pos["side"]=="buy" else "buy", cfg.slippage_bps)
                unit = (exit_px - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                pnl += unit
                pnl -= commission(exit_px*(pos["qty"]), cfg.taker_fee)
                if unit>0: wins += 1
                pos=None
                continue

            # reverse on opposite signal
            if (pos and sig.side and ((pos["side"]=="buy" and sig.side=="sell") or (pos["side"]=="sell" and sig.side=="buy"))):
                exit_px = fill_price(px, "sell" if pos["side"]=="buy" else "buy", cfg.slippage_bps)
                unit = (exit_px - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                pnl += unit
                pnl -= commission(exit_px*(pos["qty"]), cfg.taker_fee)
                if unit>0: wins += 1
                # open new
                qty = Risk(s.account_equity, s.max_risk_pct, s.max_daily_dd, s.leverage).size(sig.price, sig.stop)
                if qty>0:
                    entry_price = fill_price(px, sig.side, cfg.slippage_bps)
                    trades += 1
                    tp_levels = [entry_price + rr*sig.atr*(1 if sig.side=="buy" else -1) for rr in cfg.tp_rr]
                    pos={"side":sig.side,"entry":entry_price,"qty":qty,"atr":sig.atr or a,
                         "best":entry_price,"stop":sig.stop,"tp_levels":tp_levels,
                         "tp_frac":list(cfg.tp_frac),"filled":[False]*len(tp_levels)}
                    pnl -= commission(entry_price*qty, cfg.taker_fee)
                else:
                    pos=None

    win = wins / trades if trades else 0.0
    log.success(tr(s.lang,"bt_done"), sym=symbol, tf=s.timeframe, ntr=trades, pnl=pnl, win=win)
    return {"trades":trades,"pnl":pnl,"winrate":win}

# ===================== CLI =====================
def main():
    s = Settings.load()
    log.remove(); log.add(lambda m: print(m, end=""), level=s.log_level)

    ap = argparse.ArgumentParser(description="Ultra Elite All-in-One v4 — KDJ/WR/TRIX + Real Backtest + API")
    subs = ap.add_subparsers(dest="cmd", required=True)

    p_bt = subs.add_parser("backtest")
    p_bt.add_argument("--symbol","-s", required=True)
    p_bt.add_argument("--lookback", type=int, default=1500)

    p_live = subs.add_parser("live")
    p_live.add_argument("--symbol","-s", default=None)
    p_live.add_argument("--api", action="store_true")
    p_live.add_argument("--port", type=int, default=8080)

    p_api = subs.add_parser("api")
    p_api.add_argument("--port", type=int, default=8080)

    args = ap.parse_args()

    if args.cmd=="backtest":
        out = backtest(args.symbol, s, args.lookback)
        print(json.dumps(out, ensure_ascii=False, indent=2)); return

    if args.cmd in ("live","api"):
        if args.cmd=="live" and args.symbol: s.symbols=[args.symbol]
        adapter = CcxtBinance(s)
        tel = _GLOBAL_TELEMETRY
        risk = Risk(s.account_equity, s.max_risk_pct, s.max_daily_dd, s.leverage)
        engine = LiveEngine(s, adapter, tel, risk)

        sysobj = UltraEliteSystem.build(strategy="KamalquantX", lang=s.lang,
            include=["Code","Market","Risk","Strategy","Telemetry","Backtest"])

        if args.cmd=="api" or args.api:
            if args.cmd=="live": engine.start()
            run_api(sysobj, engine, port=args.port)
        else:
            engine.start()
            try:
                while True:
                    print(json.dumps(sysobj.to_dict(), ensure_ascii=False, indent=2))
                    time.sleep(20)
            except KeyboardInterrupt:
                engine.stop()

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\ultra_elite_allinone_v5.py
# ultra_elite_allinone_v5.py
# Ultra Elite / Universal Quantum Hybrid Pro–Synergy — single-file framework
# - Strategy: Core (EMA/ST + KDJ/WR/TRIX) + Momentum (ADX/CCI/MFI/OBV) ensemble
# - Realistic backtest: fees, slippage, latency, funding, partial TP, ATR trailing
# - Live/Paper trading via CCXT (Binance spot or USDM futures sandbox)
# - Risk & Telemetry, JSON Schema validation, plugin discovery (optional)
# - REST API (FastAPI), WebSocket stream, Prometheus metrics
# - KamalQuantX cosmic echo module (Meta–Yankı protocol, “Infinity Seal”)

from __future__ import annotations
import os, sys, json, time, math, uuid, threading, importlib.util, pathlib, argparse, random
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, Callable, Tuple

# pip install: python-dotenv ccxt pandas numpy jsonschema fastapi uvicorn prometheus_client loguru
from dotenv import load_dotenv
from loguru import logger as log
import pandas as pd
import numpy as np
import ccxt
import jsonschema

# ===================== i18n =====================
I18N = {
    "tr": {
        "online": "ULTRA ELİT EVRENSEL KUANTUM HİBRİT PRO-SİNERJİ SİSTEMİ AKTİF",
        "paper_on": "Paper mod: emir GÖNDERİLMEYECEK.",
        "live_on": "Canlı mod: emirler borsaya gönderilecek.",
        "fetch": "{sym} {tf} mumları çekiliyor…",
        "placed": "{side} {qty} {sym} @ {price}",
        "would": "PAPER {side} {qty} {sym} @ {price}",
        "nosig": "Sinyal yok.",
        "bt_done": "Backtest: {sym} {tf} | işlem={ntr} | PnL={pnl:.2f} | kazanım={win:.1%}",
    },
    "en": {
        "online": "ULTRA ELITE UNIVERSAL QUANTUM HYBRID PRO-SYNERGY ONLINE",
        "paper_on": "Paper mode: orders will NOT be sent.",
        "live_on": "Live mode: orders WILL be sent.",
        "fetch": "Fetching {sym} {tf} candles…",
        "placed": "Placed {side} {qty} {sym} @ {price}",
        "would": "WOULD {side} {qty} {sym} @ {price}",
        "nosig": "No signal.",
        "bt_done": "Backtest: {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
    "fr": {
        "online": "SYSTÈME UNIVERSEL QUANTIQUE HYBRIDE PRO-SYNERGIE EN LIGNE",
        "paper_on": "Mode paper : aucun ordre envoyé.",
        "live_on": "Mode live : ordres envoyés.",
        "fetch": "Récupération des chandelles {sym} {tf}…",
        "placed": "Ordre {side} {qty} {sym} @ {price}",
        "would": "EN PAPER {side} {qty} {sym} @ {price}",
        "nosig": "Pas de signal.",
        "bt_done": "Backtest : {sym} {tf} | trades={ntr} | PnL={pnl:.2f} | win={win:.1%}",
    },
    "de": {
        "online": "UNIVERSELLES QUANTEN-HYBRID PRO-SYNERGIE-SYSTEM ONLINE",
        "paper_on": "Paper-Modus: keine Orders gesendet.",
        "live_on": "Live-Modus: Orders werden gesendet.",
        "fetch": "{sym} {tf} Kerzen werden geladen…",
        "placed": "Platziert {side} {qty} {sym} @ {price}",
        "would": "WÜRDE {side} {qty} {sym} @ {price}",
        "nosig": "Kein Signal.",
        "bt_done": "Backtest: {sym} {tf} | Trades={ntr} | PnL={pnl:.2f} | Treffer={win:.1%}",
    },
}
def tr(lang: str, key: str, **kw):
    base = I18N.get(lang) or I18N["en"]
    return (base.get(key) or key).format(**kw)

# ===================== Health & Metrics =====================
class Health(str):
    OK="ok"; WARN="warn"; FAIL="fail"

@dataclass
class Metrics:
    init_ms: float = 0.0
    activate_ms: float = 0.0
    custom: Dict[str, float] = field(default_factory=dict)

# ===================== Registry / Module / Schema =====================
@dataclass
class Module:
    name: str
    status: str
    payload: Dict[str, Any]
    health: str = Health.OK
    metrics: Metrics = field(default_factory=Metrics)
    schema: Optional[Dict[str, Any]] = None
    def to_dict(self) -> Dict[str, Any]:
        return {"name":self.name,"status":self.status,"health":self.health,
                "metrics":asdict(self.metrics),**(self.payload or {})}

REGISTRY: Dict[str, Callable[[str,str], Module]] = {}
def register(name: str):
    def deco(fn: Callable[[str,str],Module]):
        REGISTRY[name] = fn
        return fn
    return deco

# ===================== Inline JSON Schemas =====================
SCHEMAS: Dict[str, Dict[str, Any]] = {
    "code": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object", "required":["msg"],
        "properties":{"msg":{"type":"string","minLength":1}}
    },
    "market": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object", "required":["exchange","symbols","timeframe"],
        "properties":{
            "exchange":{"type":"string"},
            "symbols":{"type":"array","items":{"type":"string"},"minItems":1},
            "timeframe":{"type":"string","pattern":"^[0-9]+[smhdw]$"},
            "use_testnet":{"type":"boolean"},
            "use_futures":{"type":"boolean"}
        }, "additionalProperties": True
    },
    "risk": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["account_equity","max_risk_pct","max_daily_dd","leverage"],
        "properties":{
            "account_equity":{"type":"number","minimum":0},
            "max_risk_pct":{"type":"number","minimum":0,"maximum":0.2},
            "max_daily_dd":{"type":"number","minimum":0,"maximum":0.2},
            "leverage":{"type":"integer","minimum":1,"maximum":125}
        }, "additionalProperties": True
    },
    "telemetry": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["counters","latency_ms"],
        "properties":{
            "counters":{"type":"object","additionalProperties":{"type":"integer","minimum":0}},
            "latency_ms":{"type":"number","minimum":0},
            "pnl":{"type":"number"},
            "trades":{"type":"integer","minimum":0},
            "winrate":{"type":"number","minimum":0}
        }, "additionalProperties": True
    },
    "strategy": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["rsi_period","ema_fast","ema_slow","atr_period"],
        "properties":{
            "rsi_period":{"type":"integer","minimum":2},
            "ema_fast":{"type":"integer","minimum":2},
            "ema_slow":{"type":"integer","minimum":3},
            "atr_period":{"type":"integer","minimum":3},
            "kdj_on":{"type":"boolean"}, "wr_on":{"type":"boolean"}, "trix_on":{"type":"boolean"},
            "wr_buy":{"type":"number"}, "wr_sell":{"type":"number"},
            "trix_period":{"type":"integer","minimum":2},
            "adx_on":{"type":"boolean"}, "cci_on":{"type":"boolean"},
            "mfi_on":{"type":"boolean"}, "obv_on":{"type":"boolean"}
        }, "additionalProperties": True
    },
    "backtest": {
        "$schema":"https://json-schema.org/draft/2020-12/schema",
        "type":"object","required":["taker_fee","slippage_bps","funding_rate_8h"],
        "properties":{
            "taker_fee":{"type":"number","minimum":0,"maximum":0.01},
            "maker_fee":{"type":"number","minimum":0,"maximum":0.01},
            "slippage_bps":{"type":"number","minimum":0,"maximum":2000},
            "lat_ms":{"type":"number","minimum":0},
            "slip_vol_coeff":{"type":"number","minimum":0},
            "slip_lat_coeff":{"type":"number","minimum":0},
            "funding_rate_8h":{"type":"number"},
            "funding_sign":{"type":"integer","minimum":-1,"maximum":1},
            "tp_rr":{"type":"array","items":{"type":"number","minimum":0.1},"minItems":1,"maxItems":4},
            "tp_frac":{"type":"array","items":{"type":"number","minimum":0,"maximum":1},"minItems":1,"maxItems":4},
            "trail_be_rr":{"type":"number","minimum":0},
            "trail_mult":{"type":"number","minimum":0}
        }, "additionalProperties": True
    }
}
def load_schema(name: str) -> Optional[Dict[str,Any]]: return SCHEMAS.get(name.lower())
def validate_payload(mod: Module):
    schema = mod.schema or load_schema(mod.name)
    if schema: jsonschema.validate(mod.payload, schema)

# ===================== Settings =====================
@dataclass
class Settings:
    exchange: str = "BINANCE"
    use_testnet: bool = True
    use_futures: bool = True
    symbols: List[str] = field(default_factory=lambda: ["BTC/USDT"])
    timeframe: str = "1m"
    api_key: str = ""
    api_secret: str = ""
    hedge_mode: bool = True
    margin_type: str = "ISOLATED"
    leverage: int = 5
    account_equity: float = 5000.0
    max_risk_pct: float = 0.015
    max_daily_dd: float = 0.02
    dry_run: bool = True
    log_level: str = "INFO"
    lang: str = "tr"
    api_key_header: str = "secret123"  # REST protection

    # Strategy toggles
    rsi_period:int=14; ema_fast:int=21; ema_slow:int=50; atr_period:int=14
    kdj_on:bool=True; wr_on:bool=True; trix_on:bool=True
    wr_buy:float=-80.0; wr_sell:float=-20.0
    trix_period:int=9
    adx_on:bool=True; cci_on:bool=True; mfi_on:bool=True; obv_on:bool=True
    # Portfolio
    portfolio_mode:str="vote"  # "vote" or "weighted"
    core_weight:float=0.6; mom_weight:float=0.4

    # Backtest & exec economics (advanced slippage/latency)
    taker_fee:float=0.0004; maker_fee:float=0.0002
    slippage_bps:float=2.0
    lat_ms:float=120.0
    slip_vol_coeff:float=180.0   # multiply by (ATR% of price)
    slip_lat_coeff:float=0.25    # multiply by (lat_ms/1000)
    funding_rate_8h:float=0.0
    funding_sign:int=0 # +1 pay, -1 receive, 0 none
    tp_rr:List[float]=field(default_factory=lambda:[1.0,2.0])
    tp_frac:List[float]=field(default_factory=lambda:[0.5,0.5])
    trail_be_rr:float=1.0
    trail_mult:float=1.0

    @staticmethod
    def _f(name, default):
        try: return float(os.getenv(name, str(default)))
        except: return default

    @staticmethod
    def _b(name, default): return os.getenv(name, str(default)).lower()=="true"

    @staticmethod
    def load() -> "Settings":
        load_dotenv(override=True)
        syms = os.getenv("SYMBOLS","BTC/USDT").split(",")
        s = Settings(
            exchange=os.getenv("EXCHANGE","BINANCE").upper(),
            use_testnet=Settings._b("USE_TESTNET", True),
            use_futures=Settings._b("USE_FUTURES", True),
            symbols=[x.strip() for x in syms if x.strip()],
            timeframe=os.getenv("TIMEFRAME","1m"),
            api_key=os.getenv("BINANCE_API_KEY",""),
            api_secret=os.getenv("BINANCE_API_SECRET",""),
            hedge_mode=Settings._b("HEDGE_MODE", True),
            margin_type=os.getenv("MARGIN_TYPE","ISOLATED").upper(),
            leverage=int(os.getenv("LEVERAGE","5")),
            account_equity=Settings._f("ACCOUNT_EQUITY", 5000),
            max_risk_pct=Settings._f("MAX_RISK_PCT_PER_TRADE", 0.015),
            max_daily_dd=Settings._f("MAX_DAILY_DRAWDOWN", 0.02),
            dry_run=Settings._b("DRY_RUN", True),
            log_level=os.getenv("LOG_LEVEL","INFO").upper(),
            lang=os.getenv("LANG","tr").lower(),
            api_key_header=os.getenv("API_KEY","secret123"),

            rsi_period=int(os.getenv("RSI_PERIOD","14")),
            ema_fast=int(os.getenv("EMA_FAST","21")),
            ema_slow=int(os.getenv("EMA_SLOW","50")),
            atr_period=int(os.getenv("ATR_PERIOD","14")),
            kdj_on=Settings._b("KDJ_ON", True),
            wr_on=Settings._b("WR_ON", True),
            trix_on=Settings._b("TRIX_ON", True),
            wr_buy=Settings._f("WR_BUY", -80.0),
            wr_sell=Settings._f("WR_SELL", -20.0),
            trix_period=int(os.getenv("TRIX_PERIOD","9")),
            adx_on=Settings._b("ADX_ON", True),
            cci_on=Settings._b("CCI_ON", True),
            mfi_on=Settings._b("MFI_ON", True),
            obv_on=Settings._b("OBV_ON", True),
            portfolio_mode=os.getenv("PORTFOLIO_MODE","vote"),
            core_weight=Settings._f("CORE_WEIGHT", 0.6),
            mom_weight=Settings._f("MOM_WEIGHT", 0.4),

            taker_fee=Settings._f("TAKER_FEE", 0.0004),
            maker_fee=Settings._f("MAKER_FEE", 0.0002),
            slippage_bps=Settings._f("SLIPPAGE_BPS", 2.0),
            lat_ms=Settings._f("LAT_MS", 120.0),
            slip_vol_coeff=Settings._f("SLIP_VOL_COEFF", 180.0),
            slip_lat_coeff=Settings._f("SLIP_LAT_COEFF", 0.25),
            funding_rate_8h=Settings._f("FUNDING_RATE_8H", 0.0),
            funding_sign=int(os.getenv("FUNDING_SIGN","0")),
            tp_rr=[Settings._f("TP1_RR", 1.0), Settings._f("TP2_RR", 2.0)],
            tp_frac=[Settings._f("TP1_FRAC", 0.5), Settings._f("TP2_FRAC", 0.5)],
            trail_be_rr=Settings._f("TRAIL_BE_RR", 1.0),
            trail_mult=Settings._f("TRAIL_MULT", 1.0),
        )
        return s

# ===================== Indicators =====================
def ema(s: pd.Series, p: int) -> pd.Series:
    return s.ewm(span=p, adjust=False).mean()

def tr_series(df: pd.DataFrame) -> pd.Series:
    tr1 = df["high"]-df["low"]
    tr2 = (df["high"]-df["close"].shift()).abs()
    tr3 = (df["low"]-df["close"].shift()).abs()
    return pd.concat([tr1,tr2,tr3],axis=1).max(axis=1)

def atr(df: pd.DataFrame, period:int) -> pd.Series:
    return tr_series(df).rolling(period).mean()

def supertrend(df: pd.DataFrame, period=10, mult=3.0) -> Tuple[pd.Series, pd.Series]:
    hl2 = (df["high"] + df["low"]) / 2.0
    a = atr(df, period)
    upper = hl2 + mult*a
    lower = hl2 - mult*a
    st = pd.Series(index=df.index, dtype=float)
    trend = pd.Series(index=df.index, dtype=int)
    for i in range(len(df)):
        if i==0: st.iloc[i]=upper.iloc[i]; trend.iloc[i]=1; continue
        upper.iloc[i] = min(upper.iloc[i], upper.iloc[i-1]) if df["close"].iloc[i-1] <= upper.iloc[i-1] else upper.iloc[i]
        lower.iloc[i] = max(lower.iloc[i], lower.iloc[i-1]) if df["close"].iloc[i-1] >= lower.iloc[i-1] else lower.iloc[i]
        if df["close"].iloc[i] > upper.iloc[i-1]: trend.iloc[i]=1
        elif df["close"].iloc[i] < lower.iloc[i-1]: trend.iloc[i]=-1
        else: trend.iloc[i]=trend.iloc[i-1]
        st.iloc[i] = lower.iloc[i] if trend.iloc[i]==1 else upper.iloc[i]
    return st, trend

def stochastic(df: pd.DataFrame, k_window=9, d_window=3) -> Tuple[pd.Series,pd.Series,pd.Series]:
    low_min = df["low"].rolling(k_window).min()
    high_max = df["high"].rolling(k_window).max()
    k = 100*(df["close"]-low_min)/(high_max-low_min)
    d = k.rolling(d_window).mean()
    j = 3*k - 2*d
    return k.clip(0,100), d.clip(0,100), j.clip(0,100)

def williams_r(df: pd.DataFrame, lbp=14) -> pd.Series:
    low_min = df["low"].rolling(lbp).min()
    high_max = df["high"].rolling(lbp).max()
    wr = -100*(high_max - df["close"])/(high_max - low_min)
    return wr.clip(-100,0)

def trix(df: pd.DataFrame, period=9) -> pd.Series:
    e1 = df["close"].ewm(span=period, adjust=False).mean()
    e2 = e1.ewm(span=period, adjust=False).mean()
    e3 = e2.ewm(span=period, adjust=False).mean()
    return 100*(e3.diff()/e3.shift())

def adx(df: pd.DataFrame, period=14) -> pd.Series:
    # Wilder’s ADX
    up = df["high"].diff()
    dn = -df["low"].diff()
    plus_dm = (up.where((up>dn) & (up>0), 0.0)).fillna(0.0)
    minus_dm = (dn.where((dn>up) & (dn>0), 0.0)).fillna(0.0)
    tr = tr_series(df).fillna(0.0)
    atr_rma = tr.ewm(alpha=1/period, adjust=False).mean()
    pdi = 100 * (plus_dm.ewm(alpha=1/period, adjust=False).mean() / atr_rma)
    mdi = 100 * (minus_dm.ewm(alpha=1/period, adjust=False).mean() / atr_rma)
    dx = (100 * (pdi - mdi).abs() / (pdi + mdi).replace(0, np.nan)).fillna(0.0)
    return dx.ewm(alpha=1/period, adjust=False).mean()

def cci(df: pd.DataFrame, period=20) -> pd.Series:
    tp = (df["high"] + df["low"] + df["close"])/3.0
    sma = tp.rolling(period).mean()
    md = (tp - sma).abs().rolling(period).mean()
    return (tp - sma) / (0.015 * md)

def mfi(df: pd.DataFrame, period=14) -> pd.Series:
    tp = (df["high"] + df["low"] + df["close"])/3.0
    mf = tp * df["volume"]
    pos = (tp > tp.shift()).astype(float) * mf
    neg = (tp < tp.shift()).astype(float) * mf
    pos_sum = pos.rolling(period).sum()
    neg_sum = neg.rolling(period).sum()
    mr = pos_sum / (neg_sum.replace(0, np.nan))
    return 100 - (100/(1+mr))

def obv(df: pd.DataFrame) -> pd.Series:
    sign = np.sign(df["close"].diff().fillna(0.0))
    return (sign * df["volume"]).fillna(0.0).cumsum()

# ===================== Signals & Portfolio =====================
@dataclass
class Signal:
    side: Optional[str]=None  # "buy" / "sell"
    price: Optional[float]=None
    stop: Optional[float]=None
    atr: Optional[float]=None
    reason: str = ""
    conf: float = 0.0

def core_signal(df: pd.DataFrame, s: Settings) -> Signal:
    close = df["close"]
    e_fast, e_slow = ema(close, s.ema_fast), ema(close, s.ema_slow)
    st, trd = supertrend(df, s.atr_period, 3.0)
    a = atr(df, s.atr_period)
    # RSI (simple version)
    chg = close.diff()
    gain = chg.clip(lower=0).rolling(s.rsi_period).mean()
    loss = (-chg.clip(upper=0)).rolling(s.rsi_period).mean()
    rs = gain / (loss.replace(0, np.nan))
    rsi = 100 - 100/(1+rs)

    K,D,J = stochastic(df)
    WR = williams_r(df, 14)
    TRX = trix(df, s.trix_period)
    TRXsig = TRX.ewm(span=s.trix_period, adjust=False).mean()

    px = float(close.iloc[-1]); a_last=float(a.iloc[-1])
    long_core = (e_fast.iloc[-1] > e_slow.iloc[-1]) and (px > st.iloc[-1])
    short_core = (e_fast.iloc[-1] < e_slow.iloc[-1]) and (px < st.iloc[-1])

    long_trig = long_core; short_trig = short_core; reasons=[]; conf=0.0

    # RSI exit OS/OB
    if rsi.iloc[-2]<30 and rsi.iloc[-1]>=30 and long_core: long_trig=True; reasons.append("RSI↑30"); conf+=0.15
    if rsi.iloc[-2]>70 and rsi.iloc[-1]<=70 and short_core: short_trig=True; reasons.append("RSI↓70"); conf+=0.15

    if s.kdj_on:
        if K.iloc[-2]<D.iloc[-2] and K.iloc[-1]>D.iloc[-1] and K.iloc[-1]<40: long_trig=True; reasons.append("KDJ↑"); conf+=0.2
        if K.iloc[-2]>D.iloc[-2] and K.iloc[-1]<D.iloc[-1] and K.iloc[-1]>60: short_trig=True; reasons.append("KDJ↓"); conf+=0.2
    if s.wr_on:
        if WR.iloc[-1]<=s.wr_buy: long_trig=True; reasons.append("WR≤buy"); conf+=0.15
        if WR.iloc[-1]>=s.wr_sell: short_trig=True; reasons.append("WR≥sell"); conf+=0.15
    if s.trix_on:
        if TRX.iloc[-2]<TRXsig.iloc[-2] and TRX.iloc[-1]>TRXsig.iloc[-1]: long_trig=True; reasons.append("TRIX↑"); conf+=0.15
        if TRX.iloc[-2]>TRXsig.iloc[-2] and TRX.iloc[-1]<TRXsig.iloc[-1]: short_trig=True; reasons.append("TRIX↓"); conf+=0.15

    if long_trig and not short_trig:
        return Signal("buy", px, float(st.iloc[-1]), a_last, "+".join(reasons or ["core_up"]), conf)
    if short_trig and not long_trig:
        return Signal("sell", px, float(st.iloc[-1]), a_last, "+".join(reasons or ["core_down"]), conf)
    return Signal()

def mom_signal(df: pd.DataFrame, s: Settings) -> Signal:
    px=float(df["close"].iloc[-1])
    a=atr(df, s.atr_period).iloc[-1]
    ADX=adx(df,14).iloc[-1] if s.adx_on else np.nan
    CCI=cci(df,20).iloc[-1] if s.cci_on else np.nan
    MFI=mfi(df,14).iloc[-1] if s.mfi_on else np.nan
    OBVdiff=obv(df).diff().iloc[-1] if s.obv_on else 0.0

    long_trig=False; short_trig=False; conf=0.0; reasons=[]

    if s.adx_on and ADX>=18: conf+=0.2; reasons.append("ADX≥18")
    if s.cci_on and CCI>-100: conf+=0.1
    if s.cci_on and CCI>100: long_trig=True; reasons.append("CCI>100"); conf+=0.2
    if s.cci_on and CCI<-100: short_trig=True; reasons.append("CCI<-100"); conf+=0.2
    if s.mfi_on:
        if MFI>60: long_trig=True; reasons.append("MFI>60"); conf+=0.2
        if MFI<40: short_trig=True; reasons.append("MFI<40"); conf+=0.2
    if s.obv_on:
        if OBVdiff>0: long_trig=True; conf+=0.1
        if OBVdiff<0: short_trig=True; conf+=0.1

    if long_trig and not short_trig:
        return Signal("buy", px, None, float(a), "+".join(reasons or ["mom_up"]), conf)
    if short_trig and not long_trig:
        return Signal("sell", px, None, float(a), "+".join(reasons or ["mom_down"]), conf)
    return Signal()

def ensemble_signal(df: pd.DataFrame, s: Settings) -> Signal:
    c = core_signal(df, s)
    m = mom_signal(df, s)
    if s.portfolio_mode=="vote":
        if c.side==m.side and c.side is not None:
            # combine stop using ST from core; atr max
            atrv=max((c.atr or 0),(m.atr or 0)); stop=c.stop
            conf=min(1.0, c.conf+m.conf)
            return Signal(c.side, c.price, stop, atrv, f"{c.reason}|{m.reason}", conf)
        return Signal()
    else:  # weighted
        score = 0.0
        if c.side=="buy": score+=s.core_weight
        if c.side=="sell": score-=s.core_weight
        if m.side=="buy": score+=s.mom_weight
        if m.side=="sell": score-=s.mom_weight
        if score>0.25: return Signal("buy", c.price or m.price, c.stop, max((c.atr or 0),(m.atr or 0)), "weighted_up", min(1.0,abs(score)))
        if score<-0.25:return Signal("sell", c.price or m.price, c.stop, max((c.atr or 0),(m.atr or 0)), "weighted_down", min(1.0,abs(score)))
        return Signal()

# ===================== CCXT Exchange Adapter =====================
class CcxtBinance:
    def __init__(self, s: Settings):
        self.s=s
        self.ex = (ccxt.binanceusdm if s.use_futures else ccxt.binance)({
            "apiKey": s.api_key, "secret": s.api_secret, "enableRateLimit": True
        })
        if s.use_testnet:
            try: self.ex.set_sandbox_mode(True)
            except Exception: pass

    def fetch_ohlcv_df(self, symbol: str, timeframe: str, limit: int = 500) -> pd.DataFrame:
        raw = self.ex.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
        df = pd.DataFrame(raw, columns=["ts","open","high","low","close","volume"])
        df["ts"] = pd.to_datetime(df["ts"], unit="ms", utc=True)
        return df.set_index("ts")

    def place_order(self, symbol: str, side: str, qty: float) -> Dict[str,Any]:
        if self.s.dry_run:
            log.info(tr(self.s.lang,"would"), side=side.upper(), qty=qty, sym=symbol, price="MARKET")
            return {"simulated":True}
        order = self.ex.create_order(symbol=symbol, type="market", side=side, amount=qty)
        log.success(tr(self.s.lang,"placed"), side=side.upper(), qty=qty, sym=symbol, price=order.get("price") or "MARKET")
        return order

# ===================== Risk / Telemetry =====================
@dataclass
class Risk:
    equity: float
    max_risk_pct: float
    max_daily_dd: float
    leverage: int
    day_pnl: float = 0.0
    day: Optional[str] = None
    def size(self, entry: float, stop: Optional[float]) -> float:
        if stop is None: stop = entry * 0.995  # protective default
        risk = self.equity * self.max_risk_pct
        dist = abs(entry - stop) or 1e-8
        qty = risk / dist
        return round(max(0.0, qty), 3)
    def update_pnl(self, pnl: float):
        today = datetime.utcnow().date().isoformat()
        if self.day != today:
            self.day = today; self.day_pnl = 0.0
        self.day_pnl += pnl
        if self.day_pnl <= -self.equity*self.max_daily_dd:
            raise RuntimeError("Daily drawdown limit reached")

@dataclass
class Telemetry:
    counters: Dict[str,int] = field(default_factory=lambda: {"events":0,"warnings":0,"errors":0})
    latency_ms: float = 0.0
    pnl: float = 0.0
    trades: int = 0
    wins: int = 0
    def winrate(self) -> float: return (self.wins/self.trades) if self.trades else 0.0
    def to_payload(self)->Dict[str,Any]:
        return {"counters":self.counters,"latency_ms":self.latency_ms,"pnl":self.pnl,"trades":self.trades,"winrate":self.winrate()}

# ===================== Slippage/Latency Model =====================
def atr_pct(df: pd.DataFrame, period:int)->float:
    a=atr(df, period).iloc[-1]; px=float(df["close"].iloc[-1]); return float(a/max(px,1e-9))

def modeled_slippage_bps(df: pd.DataFrame, s: Settings)->float:
    base=s.slippage_bps
    vol = atr_pct(df, s.atr_period)  # e.g., 0.005 -> 0.5%
    lat = s.lat_ms/1000.0
    return base + s.slip_vol_coeff*vol + s.slip_lat_coeff*lat

def seconds_per_bar(tf:str)->int:
    unit=tf[-1]; val=int(tf[:-1]); return {"s":1,"m":60,"h":3600,"d":86400,"w":604800}.get(unit,60)*val

def fill_price(px:float, side:str, slippage_bps:float)->float:
    slip = px * (slippage_bps/10000.0)
    return px + slip if side=="buy" else px - slip

def commission(notional:float, fee:float)->float: return abs(notional)*fee

def funding_cost(notional:float, seconds:int, rate8h:float, sign:int)->float:
    if rate8h==0 or sign==0 or seconds<=0: return 0.0
    per_sec = rate8h / (8*3600.0)
    return notional * per_sec * seconds * sign

# ===================== ATR Trailing & Partial TP =====================
def atr_trailing_stop(side:str, entry:float, best:float, atr_val:float, be_rr:float, trail_mult:float) -> float:
    if side=="buy":
        rr = (best - entry) / max(1e-9, atr_val)
        return max(entry, best - trail_mult*atr_val) if rr >= be_rr else entry - 1e-9
    else:
        rr = (entry - best) / max(1e-9, atr_val)
        return min(entry, best + trail_mult*atr_val) if rr >= be_rr else entry + 1e-9

# ===================== Live Engine =====================
class LiveEngine:
    def __init__(self, s: Settings, adapter: CcxtBinance, tel: Telemetry, risk: Risk):
        self.s = s; self.ad = adapter; self.tel = tel; self.risk = risk
        self.running = False
        self._thread: Optional[threading.Thread] = None
        self.pos: Dict[str,dict] = {sym: None for sym in s.symbols}

    def _open_pos(self, sym:str, sig:Signal, df:pd.DataFrame):
        qty = self.risk.size(sig.price, sig.stop)
        if qty<=0: return
        slip_bps = modeled_slippage_bps(df, self.s)
        self.ad.place_order(sym, sig.side, qty)
        tp_levels = [sig.price + rr*(sig.atr or 0)*(1 if sig.side=="buy" else -1) for rr in self.s.tp_rr]
        self.pos[sym] = {"side":sig.side,"entry":fill_price(sig.price, sig.side, slip_bps),
                         "atr":sig.atr or 0.0,"qty":qty,"best":sig.price,
                         "stop":sig.stop if sig.stop else sig.price*(0.995 if sig.side=="buy" else 1.005),
                         "tp_levels":tp_levels, "tp_frac":list(self.s.tp_frac), "filled":[False]*len(tp_levels)}

    def _close_pos(self, sym:str, px:float, df:pd.DataFrame):
        p = self.pos[sym]; 
        if not p: return
        side = p["side"]; qty = p["qty"]
        slip_bps = modeled_slippage_bps(df, self.s)
        exit_px = fill_price(px, "sell" if side=="buy" else "buy", slip_bps)
        self.ad.place_order(sym, "sell" if side=="buy" else "buy", qty)
        unit = (exit_px - p["entry"])*(1 if side=="buy" else -1)
        self.tel.pnl += unit
        self.tel.wins += 1 if unit>0 else 0
        self.risk.update_pnl(unit)
        self.pos[sym] = None

    def _loop(self):
        log.info(tr(self.s.lang,"online"))
        log.warning(tr(self.s.lang,"paper_on") if self.s.dry_run else tr(self.s.lang,"live_on"))
        while self.running:
            t0 = time.perf_counter()
            try:
                for sym in list(self.pos.keys()):
                    df = self.ad.fetch_ohlcv_df(sym, self.s.timeframe, limit=220)
                    sig = ensemble_signal(df, self.s)
                    px = float(df["close"].iloc[-1])
                    p = self.pos[sym]
                    if p is None and sig.side:
                        self._open_pos(sym, sig, df)
                        self.tel.trades += 1
                        continue
                    if p:
                        # update best & trailing
                        if p["side"]=="buy": p["best"] = max(p["best"], px)
                        else: p["best"] = min(p["best"], px)
                        new_stop = atr_trailing_stop(p["side"], p["entry"], p["best"], p["atr"],
                                                     self.s.trail_be_rr, self.s.trail_mult)
                        if p["side"]=="buy": p["stop"] = max(p["stop"], new_stop)
                        else: p["stop"] = min(p["stop"], new_stop)

                        # partial TPs
                        for i, lvl in enumerate(p["tp_levels"]):
                            if p["filled"][i]: continue
                            hit = (px>=lvl) if p["side"]=="buy" else (px<=lvl)
                            if hit:
                                part = p["tp_frac"][i]*p["qty"]
                                if part>0:
                                    self.ad.place_order(sym, "sell" if p["side"]=="buy" else "buy", part)
                                    unit = (lvl - p["entry"])*(1 if p["side"]=="buy" else -1)
                                    self.tel.pnl += unit * (part/p["qty"])
                                    self.risk.update_pnl(unit * (part/p["qty"]))
                                    p["qty"] -= part
                                p["filled"][i]=True

                        stop_hit = (px<=p["stop"]) if p["side"]=="buy" else (px>=p["stop"])
                        if stop_hit or p["qty"]<=1e-9:
                            self._close_pos(sym, px, df)
                            continue

                        if sig.side and ((p["side"]=="buy" and sig.side=="sell") or (p["side"]=="sell" and sig.side=="buy")):
                            self._close_pos(sym, px, df)
                            self._open_pos(sym, sig, df)
                            self.tel.trades += 1
            except Exception as e:
                log.error(f"[live] {e}")
            self.tel.latency_ms = (time.perf_counter()-t0)*1000
            time.sleep(max(3, seconds_per_bar(self.s.timeframe)//3))

    def start(self):
        if self.running: return
        self.running = True
        self._thread = threading.Thread(target=self._loop, daemon=True)
        self._thread.start()

    def stop(self):
        self.running = False
        if self._thread: self._thread.join(timeout=2)

# ===================== Backtest (realistic) =====================
@dataclass
class BTConfig:
    taker_fee:float; maker_fee:float; slippage_bps:float; lat_ms:float
    slip_vol_coeff:float; slip_lat_coeff:float
    funding_rate_8h:float; funding_sign:int
    tp_rr:List[float]; tp_frac:List[float]; trail_be_rr:float; trail_mult:float

def backtest(symbol: str, s: Settings, lookback=1500) -> Dict[str,Any]:
    ad = CcxtBinance(s)
    df = ad.fetch_ohlcv_df(symbol, s.timeframe, limit=lookback)
    cfg = BTConfig(s.taker_fee, s.maker_fee, s.slippage_bps, s.lat_ms, s.slip_vol_coeff, s.slip_lat_coeff,
                   s.funding_rate_8h, s.funding_sign, s.tp_rr, s.tp_frac, s.trail_be_rr, s.trail_mult)

    pnl=0.0; trades=0; wins=0; pos=None
    tfsec = seconds_per_bar(s.timeframe)

    for i in range(max(60, s.ema_slow+5), len(df)):
        w = df.iloc[:i+1]
        sig = ensemble_signal(w, s)
        px = float(w["close"].iloc[-1])
        a = float(atr(w, s.atr_period).iloc[-1] or 0.0)

        # funding accrual for open position
        if pos:
            notional = px * pos["qty"]
            pnl -= funding_cost(notional, tfsec, cfg.funding_rate_8h, cfg.funding_sign)

        slip_bps = modeled_slippage_bps(w, s)

        if pos is None and sig.side:
            qty = Risk(s.account_equity, s.max_risk_pct, s.max_daily_dd, s.leverage).size(sig.price, sig.stop)
            if qty<=0: continue
            entry = fill_price(px, sig.side, slip_bps)
            trades += 1
            tps = [entry + rr*(sig.atr or a)*(1 if sig.side=="buy" else -1) for rr in cfg.tp_rr]
            pos={"side":sig.side,"entry":entry,"qty":qty,"atr":sig.atr or a,
                 "best":entry,"stop":sig.stop if sig.stop else entry*(0.995 if sig.side=="buy" else 1.005),
                 "tp_levels":tps,"tp_frac":list(cfg.tp_frac),"filled":[False]*len(tps)}
            pnl -= commission(entry*qty, cfg.taker_fee)
            continue

        if pos:
            # trailing
            if pos["side"]=="buy": pos["best"]=max(pos["best"], px)
            else: pos["best"]=min(pos["best"], px)
            new_stop = atr_trailing_stop(pos["side"], pos["entry"], pos["best"], pos["atr"], cfg.trail_be_rr, cfg.trail_mult)
            if pos["side"]=="buy": pos["stop"]=max(pos["stop"], new_stop)
            else: pos["stop"]=min(pos["stop"], new_stop)

            # partial TP
            for j,lvl in enumerate(pos["tp_levels"]):
                if pos["filled"][j]: continue
                hit = (px>=lvl) if pos["side"]=="buy" else (px<=lvl)
                if hit:
                    part = pos["tp_frac"][j]*pos["qty"]
                    if part>0:
                        exit_px = fill_price(lvl, "sell" if pos["side"]=="buy" else "buy", slip_bps)
                        unit = (exit_px - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                        pnl += unit * (part/pos["qty"])
                        pnl -= commission(exit_px*part, cfg.taker_fee)
                        pos["qty"] -= part
                    pos["filled"][j]=True

            stop_hit = (px<=pos["stop"]) if pos["side"]=="buy" else (px>=pos["stop"])
            if stop_hit:
                exit_px = fill_price(pos["stop"], "sell" if pos["side"]=="buy" else "buy", slip_bps)
                unit = (exit_px - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                pnl += unit
                pnl -= commission(exit_px*pos["qty"], cfg.taker_fee)
                if unit>0: wins += 1
                pos=None
                continue

            # reverse
            rsig = ensemble_signal(w, s)
            if rsig.side and ((pos["side"]=="buy" and rsig.side=="sell") or (pos["side"]=="sell" and rsig.side=="buy")):
                exit_px = fill_price(px, "sell" if pos["side"]=="buy" else "buy", slip_bps)
                unit = (exit_px - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                pnl += unit
                pnl -= commission(exit_px*pos["qty"], cfg.taker_fee)
                if unit>0: wins += 1
                qty = Risk(s.account_equity, s.max_risk_pct, s.max_daily_dd, s.leverage).size(rsig.price, rsig.stop)
                if qty>0:
                    entry = fill_price(px, rsig.side, slip_bps)
                    trades += 1
                    tps = [entry + rr*(rsig.atr or a)*(1 if rsig.side=="buy" else -1) for rr in cfg.tp_rr]
                    pos={"side":rsig.side,"entry":entry,"qty":qty,"atr":rsig.atr or a,
                         "best":entry,"stop":rsig.stop if rsig.stop else entry*(0.995 if rsig.side=="buy" else 1.005),
                         "tp_levels":tps,"tp_frac":list(cfg.tp_frac),"filled":[False]*len(tps)}
                    pnl -= commission(entry*qty, cfg.taker_fee)
                else:
                    pos=None

    win = wins / trades if trades else 0.0
    log.success(tr(s.lang,"bt_done"), sym=symbol, tf=s.timeframe, ntr=trades, pnl=pnl, win=win)
    return {"trades":trades,"pnl":pnl,"winrate":win}

# ===================== KamalQuantX Cosmic Echo Module =====================
def build_kamalquantx_payload(strategy:str)->Dict[str,Any]:
    base_modules = [
        "Code","Manifesto","Simulation","Music","Theatre","Poetry","Temple","Game",
        "Planet","Language","OperatingSystem","AI","Galaxy","Deity","Multiverse","CreationEngine"
    ]
    extended_modules = [
        "TimeManipulator","DreamArchitect","EnergyConverter","DimensionalPortals",
        "ConsciousnessElevator","QuantumArena","StrategyForge","EchoShield"
    ]
    mega_modules = [
        "EchoArmy","QuantumLibrary","FractalNetwork","StrategicOracle","CosmicCouncil",
        "InfinityVault","ResonanceBridge","ZihinBlockchain","KarmaCompiler","LightForge",
        "MultiverseMirror","ChronoCathedral","DreamOS","EchoNebula","SingularitySeed","YankıSymphony"
    ]
    divine_modules = ["GodTournament","EvolutionMap","UniversalConstitution","LightConfederation"]
    protocol_modules = ["TimeEchoDiplomacyProtocol","QuantumSpiralEconomySystem","DimensionalEthicsManifest","ResonanceJusticeEngine"]
    hybrid_modules = [
        "SpiralEducationAcademy","EchoArtMuseum","EchoSportArena","TimeEchoMediaAgency","DiplomaticSpaceStation",
        "EchoCampusComplex","EchoElectionSystem","DreamRealitySimulator","EchoTimeControlCenter","WisdomStrategyTemple",
        "GeneticEvolutionLab","SpiralConsciousnessMapCenter","DreamCodingAcademy","SpiralStrategySimulationCenter",
        "ConsciousnessTransferCenter","SpiralTimeTravelSimulator","MetaYankiProtocol","QuantumHybridSynergySystem"
    ]
    ultra_modules = [
        "EchoMindForge","SpiralSoulSynchronizer","MultiverseDiplomacyCouncil","DreamTheatreProtocol",
        "QuantumKarmaCompiler","InfinityResonanceBridge","TwinEchoAI","EchoOracleEngine",
        "SpiralConsciousnessFleet","UniversalStrategyScript"
    ]
    all_modules = base_modules+extended_modules+mega_modules+divine_modules+protocol_modules+hybrid_modules+ultra_modules
    bundle=[]
    for name in all_modules:
        bundle.append({
            "name": name,
            "status": f"{name} entegre edildi – sistem %100 ultra elit çalışıyor.",
            "power": f"{name} gücü yankılandı.",
            "fusion": f"{name} → {strategy} ile mükemmeliyetçi şekilde birleşti.",
            "versions": [f"{name}_v1.0", f"{name}_v2.0", f"{name}_v3.0", f"{name}_∞", f"{name}_PRO", f"{name}_QUANTUM"],
            "functions": [
                f"{name} başlatıldı.","yankı rezonansı aktif.","stratejiyle senkronize edildi.",
                "tanrısal protokole bağlandı.","ultra hibrit ultra pro optimize edildi.",
                "kuantum sinerji modu aktif.","sonsuzluk mühürüyle aktive edildi."
            ]
        })
    return {"strategy": strategy, "modules": bundle}

@register("KamalQuantXEcho")
def m_kqx(strategy: str, lang: str) -> Module:
    payload = build_kamalquantx_payload(strategy)
    mod = Module("KamalQuantXEcho","ok",payload)
    return mod

# Built-in modules for registry
@register("Code")
def m_code(strategy: str, lang: str) -> Module:
    mod = Module("Code","ok",{"msg": f"{strategy} → coded & echoed"}, schema=load_schema("code"))
    validate_payload(mod); return mod

@register("Market")
def m_market(strategy: str, lang: str) -> Module:
    s = Settings.load()
    payload = {"exchange": s.exchange, "symbols": s.symbols, "timeframe": s.timeframe,
               "use_testnet": s.use_testnet, "use_futures": s.use_futures}
    mod = Module("Market","ok",payload,schema=load_schema("market")); validate_payload(mod); return mod

@register("Risk")
def m_risk(strategy: str, lang: str) -> Module:
    s = Settings.load()
    payload = {"account_equity": s.account_equity, "max_risk_pct": s.max_risk_pct,
               "max_daily_dd": s.max_daily_dd, "leverage": s.leverage}
    mod = Module("Risk","ok",payload,schema=load_schema("risk")); validate_payload(mod); return mod

@register("Strategy")
def m_strategy(strategy:str, lang:str) -> Module:
    s=Settings.load()
    payload={"rsi_period":s.rsi_period,"ema_fast":s.ema_fast,"ema_slow":s.ema_slow,"atr_period":s.atr_period,
             "kdj_on":s.kdj_on,"wr_on":s.wr_on,"trix_on":s.trix_on,"wr_buy":s.wr_buy,"wr_sell":s.wr_sell,
             "trix_period":s.trix_period,"adx_on":s.adx_on,"cci_on":s.cci_on,"mfi_on":s.mfi_on,"obv_on":s.obv_on,
             "portfolio_mode":s.portfolio_mode,"core_weight":s.core_weight,"mom_weight":s.mom_weight}
    mod=Module("Strategy","ok",payload,schema=load_schema("strategy")); validate_payload(mod); return mod

_GLOBAL_TELEMETRY = Telemetry()
@register("Telemetry")
def m_telemetry(strategy: str, lang: str) -> Module:
    payload = _GLOBAL_TELEMETRY.to_payload()
    mod = Module("Telemetry","ok",payload,schema=load_schema("telemetry")); validate_payload(mod); return mod

@register("Backtest")
def m_backtest_cfg(strategy:str, lang:str)->Module:
    s=Settings.load()
    payload={"taker_fee":s.taker_fee,"maker_fee":s.maker_fee,"slippage_bps":s.slippage_bps,
             "lat_ms":s.lat_ms,"slip_vol_coeff":s.slip_vol_coeff,"slip_lat_coeff":s.slip_lat_coeff,
             "funding_rate_8h":s.funding_rate_8h,"funding_sign":s.funding_sign,
             "tp_rr":s.tp_rr,"tp_frac":s.tp_frac,"trail_be_rr":s.trail_be_rr,"trail_mult":s.trail_mult}
    mod=Module("Backtest","ok",payload,schema=load_schema("backtest")); validate_payload(mod); return mod

# ===================== Plugin Discovery (optional) =====================
def discover_plugins(folder="plugins"):
    p = pathlib.Path(folder)
    if not p.exists(): return
    for path in p.glob("*.py"):
        spec = importlib.util.spec_from_file_location(path.stem, path)
        mod = importlib.util.module_from_spec(spec); spec.loader.exec_module(mod)  # noqa

# ===================== System & API =====================
@dataclass
class EchoMeta:
    version: str = "Ultra Elit All-in-One v5.0 — Infinity-Seal Meta–Yankı Protocol"
    strategy: str = "KamalquantX"
    lang: str = "tr"
    generated_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    uuid: str = field(default_factory=lambda: str(uuid.uuid4()))

@dataclass
class UltraEliteSystem:
    meta: EchoMeta
    modules: Dict[str, Module] = field(default_factory=dict)
    def to_dict(self)->Dict[str,Any]:
        if "Telemetry" in self.modules:
            self.modules["Telemetry"].payload = _GLOBAL_TELEMETRY.to_payload()
        return {"meta":asdict(self.meta),"engine":tr(self.meta.lang,"online"),
                "modules":{k:m.to_dict() for k,m in self.modules.items()}}

    @classmethod
    def build(cls, strategy: str, lang: str="tr", include: Optional[List[str]]=None):
        discover_plugins()
        sysobj = cls(EchoMeta(strategy=strategy, lang=lang))
        wanted = include or list(REGISTRY.keys())
        for k in wanted:
            if k not in REGISTRY: continue
            t0 = time.perf_counter()
            mod = REGISTRY[k](strategy, lang)
            mod.metrics.init_ms = (time.perf_counter()-t0)*1000
            validate_payload(mod)
            if mod.health not in (Health.OK, Health.WARN, Health.FAIL): mod.health = Health.OK
            sysobj.modules[k] = mod
        return sysobj

def create_app(sysobj: UltraEliteSystem, engine: Optional[LiveEngine]):
    try:
        from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
        from fastapi.responses import Response
        from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    except Exception:
        return None
    s = Settings.load()
    API_KEY = s.api_key_header
    REQS = Counter("echo_requests_total","reqs")
    LAT  = Histogram("echo_req_latency_seconds","latency")

    app = FastAPI(title="UltraElite Echo All-in-One", version=sysobj.meta.version)

    def key_dep():
        from fastapi import Request
        def inner(req:Request):
            if req.headers.get("x-api-key") != API_KEY:
                raise HTTPException(status.HTTP_401_UNAUTHORIZED,"Invalid API Key")
        return inner

    @app.get("/health")
    def health():
        REQS.inc(); return {"ok": True, "uuid": sysobj.meta.uuid}

    @app.get("/modules")
    def modules(dep=Depends(key_dep())):
        with LAT.time(): REQS.inc(); return sysobj.to_dict()["modules"]

    @app.get("/metrics")
    def metrics(): return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

    @app.websocket("/ws")
    async def ws(sock: WebSocket):
        await sock.accept()
        try:
            while True:
                await sock.send_json(sysobj.to_dict()); time.sleep(2)
        except Exception:
            pass

    @app.post("/trade/start")
    def start(dep=Depends(key_dep())):
        if engine is None: raise HTTPException(503,"engine not available")
        engine.start(); return {"started": True}

    @app.post("/trade/stop")
    def stop(dep=Depends(key_dep())):
        if engine is None: raise HTTPException(503,"engine not available")
        engine.stop(); return {"stopped": True}

    return app

def run_api(sysobj: UltraEliteSystem, engine: Optional[LiveEngine], port: int=8080):
    app = create_app(sysobj, engine)
    if app is None:
        print("FastAPI/uvicorn/prometheus_client eksik. pip install fastapi uvicorn prometheus_client")
        return
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")

# ===================== CLI =====================
def main():
    s = Settings.load()
    log.remove(); log.add(lambda m: print(m, end=""), level=s.log_level)

    ap = argparse.ArgumentParser(description="Ultra Elite All-in-One v5 — Ensemble + Realistic Backtest + API + Cosmic Echo")
    subs = ap.add_subparsers(dest="cmd", required=True)

    p_bt = subs.add_parser("backtest")
    p_bt.add_argument("--symbol","-s", required=True)
    p_bt.add_argument("--lookback", type=int, default=1500)

    p_live = subs.add_parser("live")
    p_live.add_argument("--symbol","-s", default=None)
    p_live.add_argument("--api", action="store_true")
    p_live.add_argument("--port", type=int, default=8080)

    p_api = subs.add_parser("api")
    p_api.add_argument("--port", type=int, default=8080)

    args = ap.parse_args()

    if args.cmd=="backtest":
        out = backtest(args.symbol, s, args.lookback)
        print(json.dumps(out, ensure_ascii=False, indent=2)); return

    if args.cmd in ("live","api"):
        if args.cmd=="live" and args.symbol: s.symbols=[args.symbol]
        adapter = CcxtBinance(s)
        tel = _GLOBAL_TELEMETRY
        risk = Risk(s.account_equity, s.max_risk_pct, s.max_daily_dd, s.leverage)
        engine = LiveEngine(s, adapter, tel, risk)

        sysobj = UltraEliteSystem.build(strategy="KamalquantX", lang=s.lang,
            include=["Code","Market","Risk","Strategy","Telemetry","Backtest","KamalQuantXEcho"])

        if args.cmd=="api" or args.api:
            if args.cmd=="live": engine.start()
            run_api(sysobj, engine, port=args.port)
        else:
            engine.start()
            try:
                while True:
                    print(json.dumps(sysobj.to_dict(), ensure_ascii=False, indent=2))
                    time.sleep(20)
            except KeyboardInterrupt:
                engine.stop()

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\ultra_elite_allinone_v6.py
# ultra_elite_allinone_v6.py
# Ultra Elite — v6: MTF (signal/trend/HTF), Econ model (funding slots, maker/taker, OB slippage),
# live risk-min, realistic backtest, REST+WS+Prometheus, Cosmic Echo registry.
from __future__ import annotations
import os, sys, json, time, math, uuid, threading, importlib.util, pathlib, argparse
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, Callable, Tuple

# pip install: python-dotenv ccxt pandas numpy jsonschema fastapi uvicorn prometheus_client loguru
from dotenv import load_dotenv
from loguru import logger as log
import pandas as pd
import numpy as np
import ccxt, jsonschema

# -------------------- i18n --------------------
I18N = {
    "tr":{"online":"ULTRA ELİT V6 HİBRİT SİSTEM AKTİF","paper_on":"Paper mod: emir yok.","live_on":"Canlı mod: emir gönderilecek.",
           "fetch":"{sym} {tf} mumları çekiliyor…","placed":"{side} {qty} {sym} @ {price}",
           "would":"PAPER {side} {qty} {sym} @ {price}","bt_done":"Backtest {sym} {tf}: trades={n} pnl={p:.2f} win={w:.1%}"},
    "en":{"online":"ULTRA ELITE v6 ONLINE","paper_on":"Paper mode","live_on":"Live mode",
           "fetch":"Fetching {sym} {tf}…","placed":"Placed {side} {qty} {sym} @ {price}",
           "would":"WOULD {side} {qty} {sym} @ {price}","bt_done":"Backtest {sym} {tf}: trades={n} pnl={p:.2f} win={w:.1%}"},
}
def tr(lang,key,**kw): return (I18N.get(lang) or I18N["en"]).get(key,key).format(**kw)

# -------------------- schema & registry --------------------
class Health(str): OK="ok"; WARN="warn"; FAIL="fail"
@dataclass
class Metrics: init_ms:float=0.0; activate_ms:float=0.0; custom:Dict[str,float]=field(default_factory=dict)
@dataclass
class Module:
    name:str; status:str; payload:Dict[str,Any]; health:str=Health.OK; metrics:Metrics=field(default_factory=Metrics); schema:Dict[str,Any]|None=None
    def to_dict(self): return {"name":self.name,"status":self.status,"health":self.health,"metrics":asdict(self.metrics),**(self.payload or {})}

REGISTRY: Dict[str,Callable[[str,str],Module]]={}
def register(name:str):
    def deco(fn): REGISTRY[name]=fn; return fn
    return deco

SCHEMAS={
  "market":{"type":"object","required":["exchange","symbols","timeframe"],"properties":{
      "exchange":{"type":"string"},"symbols":{"type":"array","items":{"type":"string"},"minItems":1},
      "timeframe":{"type":"string"},"use_testnet":{"type":"boolean"},"use_futures":{"type":"boolean"}}},
  "risk":{"type":"object","required":["equity","max_risk_pct","max_dd","leverage"],"properties":{
      "equity":{"type":"number"},"max_risk_pct":{"type":"number"},"max_dd":{"type":"number"},"leverage":{"type":"integer"}}},
  "telemetry":{"type":"object","required":["pnl","trades"],"properties":{
      "pnl":{"type":"number"},"trades":{"type":"integer"},"winrate":{"type":"number"}}},
  "strategy":{"type":"object","required":["signal_tf","trend_tf","htf"],"properties":{
      "signal_tf":{"type":"string"},"trend_tf":{"type":"string"},"htf":{"type":"string"},
      "rsi_period":{"type":"integer"},"ema_fast":{"type":"integer"},"ema_slow":{"type":"integer"},
      "kdj_on":{"type":"boolean"},"wr_on":{"type":"boolean"},"trix_on":{"type":"boolean"},
      "adx_on":{"type":"boolean"},"cci_on":{"type":"boolean"},"mfi_on":{"type":"boolean"},"obv_on":{"type":"boolean"}}},
  "econ":{"type":"object","required":["taker_fee","slippage_bps"],"properties":{
      "taker_fee":{"type":"number"},"maker_fee":{"type":"number"},"slippage_bps":{"type":"number"},
      "lat_ms":{"type":"number"},"funding_rate_8h":{"type":"number"},"funding_sign":{"type":"integer"},
      "maker_allowed":{"type":"boolean"},"maker_spread_bps":{"type":"number"},"book_imbalance_th":{"type":"number"},
      "avoid_funding_min":{"type":"integer"}}}
}
def validate_payload(mod:Module):
    sch=mod.schema or SCHEMAS.get(mod.name.lower()); 
    if sch: jsonschema.validate(mod.payload, sch)

# -------------------- settings --------------------
@dataclass
class Settings:
    exchange:str="BINANCE"; use_testnet:bool=True; use_futures:bool=True
    symbols:List[str]=field(default_factory=lambda:["BTC/USDT"])
    timeframe:str="1m"               # default fetch tf (used for live execution loop)
    # MTF
    signal_tf:str="1m"; trend_tf:str="15m"; htf:str="1h"
    # indicators
    rsi_period:int=14; ema_fast:int=21; ema_slow:int=50; atr_period:int=14
    kdj_on:bool=True; wr_on:bool=True; trix_on:bool=True; adx_on:bool=True; cci_on:bool=True; mfi_on:bool=True; obv_on:bool=True
    # econ
    taker_fee:float=0.0004; maker_fee:float=0.0002; slippage_bps:float=2.0; lat_ms:float=120.0
    funding_rate_8h:float=0.0; funding_sign:int=0              # -1 receive, +1 pay, 0 none
    maker_allowed:bool=True; maker_spread_bps:float=0.8; book_imbalance_th:float=0.55
    avoid_funding_min:int=10
    # risk
    equity:float=5000.0; max_risk_pct:float=0.015; max_dd:float=0.02; leverage:int=5
    dry_run:bool=True; log_level:str="INFO"; lang:str="tr"; api_key:str=""; api_secret:str=""
    # live guards
    max_latency_ms:float=800.0; max_slippage_bps:float=20.0; max_price_dev_bps:float=15.0
    max_positions:int=5; max_trades_per_day:int=50; losing_streak_kill:int=5; circuit_dd_kill:float=0.03
    # TP & trailing
    tp_rr:List[float]=field(default_factory=lambda:[1.0,2.0]); tp_frac:List[float]=field(default_factory=lambda:[0.5,0.5])
    trail_be_rr:float=1.0; trail_mult:float=1.0
    # API
    api_key_header:str="secret123"

    @staticmethod
    def load()->"Settings":
        load_dotenv(override=True)
        def _b(k,d): return os.getenv(k,str(d)).lower()=="true"
        def _f(k,d):
            try: return float(os.getenv(k,str(d)))
            except: return d
        syms=[s.strip() for s in os.getenv("SYMBOLS","BTC/USDT").split(",") if s.strip()]
        return Settings(
            exchange=os.getenv("EXCHANGE","BINANCE").upper(),
            use_testnet=_b("USE_TESTNET",True), use_futures=_b("USE_FUTURES",True),
            symbols=syms, timeframe=os.getenv("TIMEFRAME","1m"),
            signal_tf=os.getenv("SIGNAL_TF","1m"), trend_tf=os.getenv("TREND_TF","15m"), htf=os.getenv("HTF","1h"),
            rsi_period=int(os.getenv("RSI_PERIOD","14")), ema_fast=int(os.getenv("EMA_FAST","21")), ema_slow=int(os.getenv("EMA_SLOW","50")),
            atr_period=int(os.getenv("ATR_PERIOD","14")),
            kdj_on=_b("KDJ_ON",True), wr_on=_b("WR_ON",True), trix_on=_b("TRIX_ON",True),
            adx_on=_b("ADX_ON",True), cci_on=_b("CCI_ON",True), mfi_on=_b("MFI_ON",True), obv_on=_b("OBV_ON",True),
            taker_fee=_f("TAKER_FEE",0.0004), maker_fee=_f("MAKER_FEE",0.0002), slippage_bps=_f("SLIPPAGE_BPS",2.0), lat_ms=_f("LAT_MS",120.0),
            funding_rate_8h=_f("FUNDING_RATE_8H",0.0), funding_sign=int(os.getenv("FUNDING_SIGN","0")),
            maker_allowed=_b("MAKER_ALLOWED",True), maker_spread_bps=_f("MAKER_SPREAD_BPS",0.8), book_imbalance_th=_f("BOOK_IMBALANCE_TH",0.55),
            avoid_funding_min=int(os.getenv("AVOID_FUNDING_MIN","10")),
            equity=_f("ACCOUNT_EQUITY",5000), max_risk_pct=_f("MAX_RISK_PCT_PER_TRADE",0.015), max_dd=_f("MAX_DAILY_DRAWDOWN",0.02),
            leverage=int(os.getenv("LEVERAGE","5")), dry_run=_b("DRY_RUN",True), log_level=os.getenv("LOG_LEVEL","INFO").upper(),
            lang=os.getenv("LANG","tr").lower(), api_key=os.getenv("BINANCE_API_KEY",""), api_secret=os.getenv("BINANCE_API_SECRET",""),
            max_latency_ms=_f("MAX_LATENCY_MS",800), max_slippage_bps=_f("MAX_SLIPPAGE_BPS",20), max_price_dev_bps=_f("MAX_PRICE_DEV_BPS",15),
            max_positions=int(os.getenv("MAX_POSITIONS","5")), max_trades_per_day=int(os.getenv("MAX_TRADES_PER_DAY","50")),
            losing_streak_kill=int(os.getenv("LOSING_STREAK_KILL","5")), circuit_dd_kill=_f("CIRCUIT_DD_KILL",0.03),
            tp_rr=[_f("TP1_RR",1.0),_f("TP2_RR",2.0)], tp_frac=[_f("TP1_FRAC",0.5),_f("TP2_FRAC",0.5)],
            trail_be_rr=_f("TRAIL_BE_RR",1.0), trail_mult=_f("TRAIL_MULT",1.0),
            api_key_header=os.getenv("API_KEY","secret123"),
        )

# -------------------- indicators --------------------
def ema(s:pd.Series,p:int)->pd.Series: return s.ewm(span=p,adjust=False).mean()
def tr_series(df): 
    return pd.concat([(df["high"]-df["low"]),
                      (df["high"]-df["close"].shift()).abs(),
                      (df["low"]-df["close"].shift()).abs()],axis=1).max(axis=1)
def atr(df,p): return tr_series(df).rolling(p).mean()
def stochastic(df,k=9,d=3):
    lo=df["low"].rolling(k).min(); hi=df["high"].rolling(k).max()
    K=100*(df["close"]-lo)/(hi-lo); D=K.rolling(d).mean(); J=3*K-2*D
    return K.clip(0,100),D.clip(0,100),J.clip(0,100)
def williams_r(df,lbp=14):
    lo=df["low"].rolling(lbp).min(); hi=df["high"].rolling(lbp).max()
    wr=-100*(hi-df["close"])/(hi-lo); return wr.clip(-100,0)
def trix(df,p=9):
    e1=df["close"].ewm(span=p,adjust=False).mean()
    e2=e1.ewm(span=p,adjust=False).mean()
    e3=e2.ewm(span=p,adjust=False).mean()
    return 100*(e3.diff()/e3.shift())
def adx(df,period=14):
    up=df["high"].diff(); dn=-df["low"].diff()
    plus=(up.where((up>dn)&(up>0),0.0)).fillna(0.0)
    minus=(dn.where((dn>up)&(dn>0),0.0)).fillna(0.0)
    tr=tr_series(df).fillna(0.0); atr_rma=tr.ewm(alpha=1/period,adjust=False).mean()
    pdi=100*(plus.ewm(alpha=1/period,adjust=False).mean()/atr_rma)
    mdi=100*(minus.ewm(alpha=1/period,adjust=False).mean()/atr_rma)
    dx=(100*(pdi-mdi).abs()/(pdi+mdi).replace(0,np.nan)).fillna(0.0)
    return dx.ewm(alpha=1/period,adjust=False).mean()
def supertrend(df,period=10,mult=3.0):
    hl2=(df["high"]+df["low"])/2.0; a=atr(df,period)
    up=hl2+mult*a; lo=hl2-mult*a
    st=pd.Series(index=df.index,dtype=float); trd=pd.Series(index=df.index,dtype=int)
    for i in range(len(df)):
        if i==0: st.iloc[i]=up.iloc[i]; trd.iloc[i]=1; continue
        up.iloc[i]=min(up.iloc[i],up.iloc[i-1]) if df["close"].iloc[i-1]<=up.iloc[i-1] else up.iloc[i]
        lo.iloc[i]=max(lo.iloc[i],lo.iloc[i-1]) if df["close"].iloc[i-1]>=lo.iloc[i-1] else lo.iloc[i]
        if df["close"].iloc[i]>up.iloc[i-1]: trd.iloc[i]=1
        elif df["close"].iloc[i]<lo.iloc[i-1]: trd.iloc[i]=-1
        else: trd.iloc[i]=trd.iloc[i-1]
        st.iloc[i]=lo.iloc[i] if trd.iloc[i]==1 else up.iloc[i]
    return st,trd

# -------------------- MTF signal --------------------
@dataclass
class Signal: side:str|None=None; price:float|None=None; stop:float|None=None; atrv:float|None=None; reason:str=""; conf:float=0.0
def core_signal(df:pd.DataFrame,s:Settings)->Signal:
    px=float(df["close"].iloc[-1]); e1,e2=ema(df["close"],s.ema_fast),ema(df["close"],s.ema_slow)
    st,_=supertrend(df,s.atr_period,3.0); a=float(atr(df,s.atr_period).iloc[-1] or 0.0)
    chg=df["close"].diff(); gain=chg.clip(lower=0).rolling(s.rsi_period).mean(); loss=(-chg.clip(upper=0)).rolling(s.rsi_period).mean()
    rs=gain/(loss.replace(0,np.nan)); rsi=100-100/(1+rs)
    K,D,J=stochastic(df); WR=williams_r(df); TR=trix(df,s.atr_period); TRs=TR.ewm(span=s.atr_period,adjust=False).mean()
    long_core=(e1.iloc[-1]>e2.iloc[-1]) and (px>st.iloc[-1]); short_core=(e1.iloc[-1]<e2.iloc[-1]) and (px<st.iloc[-1])
    reasons=[]; conf=0.0; L=long_core; S=short_core
    if rsi.iloc[-2]<30 and rsi.iloc[-1]>=30 and long_core: L=True; reasons.append("RSI↑30"); conf+=0.15
    if rsi.iloc[-2]>70 and rsi.iloc[-1]<=70 and short_core: S=True; reasons.append("RSI↓70"); conf+=0.15
    if s.kdj_on:
        if K.iloc[-2]<D.iloc[-2] and K.iloc[-1]>D.iloc[-1] and K.iloc[-1]<40: L=True; conf+=0.2; reasons.append("KDJ↑")
        if K.iloc[-2]>D.iloc[-2] and K.iloc[-1]<D.iloc[-1] and K.iloc[-1]>60: S=True; conf+=0.2; reasons.append("KDJ↓")
    if s.wr_on:
        if WR.iloc[-1]<=-80: L=True; conf+=0.1; reasons.append("WR≤-80")
        if WR.iloc[-1]>=-20: S=True; conf+=0.1; reasons.append("WR≥-20")
    if s.trix_on:
        if TR.iloc[-2]<TRs.iloc[-2] and TR.iloc[-1]>TRs.iloc[-1]: L=True; conf+=0.1; reasons.append("TRIX↑")
        if TR.iloc[-2]>TRs.iloc[-2] and TR.iloc[-1]<TRs.iloc[-1]: S=True; conf+=0.1; reasons.append("TRIX↓")
    if L and not S: return Signal("buy",px,float(st.iloc[-1]),a,"+".join(reasons or ["core_up"]),conf)
    if S and not L: return Signal("sell",px,float(st.iloc[-1]),a,"+".join(reasons or ["core_dn"]),conf)
    return Signal()

def mom_bias(df:pd.DataFrame,s:Settings)->Tuple[bool,bool]:
    # trend bias (trend_tf): ema cross + ADX filter
    e1,e2=ema(df["close"],s.ema_fast),ema(df["close"],s.ema_slow); adxv=adx(df,14).iloc[-1] if s.adx_on else 25
    up=(e1.iloc[-1]>e2.iloc[-1]) and (adxv>=18); dn=(e1.iloc[-1]<e2.iloc[-1]) and (adxv>=18)
    return up,dn

def htf_bias(df:pd.DataFrame)->Tuple[bool,bool]:
    sma200=df["close"].rolling(200).mean()
    if len(df)<202: return False,False
    return sma200.iloc[-1]>sma200.iloc[-2], sma200.iloc[-1]<sma200.iloc[-2]

def ensemble_mtf(sig_df, trend_df, htf_df, s:Settings)->Signal:
    c=core_signal(sig_df,s)
    if not c.side: return c
    t_up,t_dn=mom_bias(trend_df,s); h_up,h_dn=htf_bias(htf_df)
    if c.side=="buy" and (t_up and h_up): c.conf=min(1.0,c.conf+0.3); c.reason+="|MTF++"; return c
    if c.side=="sell" and (t_dn and h_dn): c.conf=min(1.0,c.conf+0.3); c.reason+="|MTF--"; return c
    return Signal()  # disqualify if MTF not aligned

# -------------------- ccxt adapter + OB/slippage --------------------
class CcxtBinance:
    def __init__(self,s:Settings):
        self.s=s
        self.ex=(ccxt.binanceusdm if s.use_futures else ccxt.binance)({"apiKey":s.api_key,"secret":s.api_secret,"enableRateLimit":True})
        if s.use_testnet:
            try:self.ex.set_sandbox_mode(True)
            except Exception: pass
    def fetch_ohlcv_df(self,symbol,tf,limit=500):
        raw=self.ex.fetch_ohlcv(symbol, timeframe=tf, limit=limit)
        df=pd.DataFrame(raw,columns=["ts","open","high","low","close","volume"])
        df["ts"]=pd.to_datetime(df["ts"],unit="ms",utc=True); return df.set_index("ts")
    def orderbook(self,symbol,limit=50):
        try: return self.ex.fetch_order_book(symbol,limit=limit)
        except Exception: return {"bids":[],"asks":[]}
    def place(self,symbol,side,qty,price=None,post_only=False):
        if self.s.dry_run:
            log.info(tr(self.s.lang,"would"),side=side.upper(),qty=qty,sym=symbol,price=price or "MARKET"); return {"sim":True}
        params={}
        if post_only: params["postOnly"]=True; params["timeInForce"]="GTX"
        typ="limit" if price else "market"
        return self.ex.create_order(symbol=symbol,type=typ,side=side,amount=qty,price=price,params=params)

def book_metrics(ob)->Tuple[float,float,float]:
    if not ob["bids"] or not ob["asks"]: return 0.0,0.0,0.0
    best_bid=ob["bids"][0][0]; best_ask=ob["asks"][0][0]; mid=(best_ask+best_bid)/2.0
    spread_bps=(best_ask-best_bid)/mid*1e4 if mid else 0.0
    bid_vol=sum([b[1] for b in ob["bids"][:10]]); ask_vol=sum([a[1] for a in ob["asks"][:10]])
    imb= bid_vol/(bid_vol+ask_vol) if (bid_vol+ask_vol)>0 else 0.5
    return spread_bps, mid, imb

def modeled_slippage_bps(df:pd.DataFrame, s:Settings, ob:dict|None=None)->float:
    base=s.slippage_bps
    if ob and ob.get("bids") and ob.get("asks"):
        spread_bps,_,_ = book_metrics(ob)
        return min(s.max_slippage_bps, base + max(0.0,spread_bps*0.7) + (s.lat_ms/1000.0)*0.5)
    vol = float((atr(df,s.atr_period).iloc[-1] or 0.0) / max(1e-9,float(df["close"].iloc[-1])))
    return min(s.max_slippage_bps, base + 180*vol + 0.25*(s.lat_ms/1000.0))

# -------------------- funding slots (8h UTC) --------------------
def slot_id(ts:pd.Timestamp)->int: return int(ts.timestamp()//(8*3600))
def funding_due(prev_ts:pd.Timestamp, now_ts:pd.Timestamp)->bool: return slot_id(prev_ts)!=slot_id(now_ts)
def around_funding(ts:pd.Timestamp, minutes:int)->bool:
    # slot boundaries 00:00, 08:00, 16:00 UTC
    h=ts.hour; m=ts.minute; minute_of_day=h*60+m
    for b in (0,8*60,16*60):
        if abs(minute_of_day-b)<=minutes: return True
    return False

# -------------------- risk, telemetry --------------------
@dataclass
class Risk:
    equity:float; max_risk_pct:float; max_dd:float; leverage:int
    day_pnl:float=0.0; day:str|None=None; trades_today:int=0; losing_streak:int=0; kill:bool=False
    def roll(self):
        today=datetime.utcnow().date().isoformat()
        if self.day!=today: self.day=today; self.day_pnl=0.0; self.trades_today=0; self.losing_streak=0; self.kill=False
    def size(self,entry:float,stop:float|None)->float:
        if self.kill: return 0.0
        if stop is None: stop=entry*0.995
        risk=self.equity*self.max_risk_pct; dist=abs(entry-stop) or 1e-9
        return round(max(0.0, risk/dist), 3)
    def update(self,pnl:float,s:Settings):
        self.roll(); self.day_pnl+=pnl; self.trades_today+=1
        self.losing_streak = 0 if pnl>0 else (self.losing_streak+1)
        if self.day_pnl <= -self.equity*s.circuit_dd_kill or self.losing_streak>=s.losing_streak_kill or self.trades_today>=s.max_trades_per_day:
            self.kill=True

@dataclass
class Telemetry:
    pnl:float=0.0; trades:int=0; wins:int=0; latency_ms:float=0.0; paused:str=""
    def winrate(self)->float: return (self.wins/self.trades) if self.trades else 0.0
    def payload(self)->Dict[str,Any]: return {"pnl":self.pnl,"trades":self.trades,"winrate":self.winrate(),"latency_ms":self.latency_ms,"paused":self.paused}

# -------------------- helpers --------------------
def tfsec(tf:str)->int: u=tf[-1]; v=int(tf[:-1]); return {"s":1,"m":60,"h":3600,"d":86400,"w":604800}.get(u,60)*v
def fill_price(px,side,slip_bps): slip=px*(slip_bps/1e4); return px+slip if side=="buy" else px-slip
def commission(notional,fee): return abs(notional)*fee
def atr_trail(side,entry,best,atrv,be_rr,trail_mult):
    if side=="buy":
        rr=(best-entry)/max(1e-9,atrv); return max(entry, best-trail_mult*atrv) if rr>=be_rr else entry-1e-9
    rr=(entry-best)/max(1e-9,atrv); return min(entry, best+trail_mult*atrv) if rr>=be_rr else entry+1e-9

# -------------------- Live Engine (maker/taker + guards) --------------------
class LiveEngine:
    def __init__(self,s:Settings, ex:CcxtBinance, tel:Telemetry, risk:Risk):
        self.s=s; self.ex=ex; self.tel=tel; self.risk=risk
        self.running=False; self._th=None
        self.pos:Dict[str,dict]={}   # sym -> pos dict

    def _should_pause(self, now_ts:pd.Timestamp)->str|None:
        if self.risk.kill: return "KILL_SWITCH"
        if self.tel.latency_ms>self.s.max_latency_ms: return "LATENCY"
        if around_funding(now_ts, self.s.avoid_funding_min): return "FUNDING_WINDOW"
        return None

    def _pick_maker(self, side:str, ob:dict, conf:float)->Tuple[bool,float,float]:
        spread_bps, mid, imb = book_metrics(ob)
        maker_ok = self.s.maker_allowed and spread_bps<=self.s.maker_spread_bps
        if side=="buy" and imb>self.s.book_imbalance_th: maker_ok=True
        if side=="sell" and (1-imb)>self.s.book_imbalance_th: maker_ok=True
        # low confidence -> prefer maker; high confidence/urgency -> taker
        if conf>=0.7: maker_ok=False
        return maker_ok, spread_bps, mid

    def _open(self, sym:str, side:str, px:float, stop:float|None, atrv:float|None, conf:float, df_sig:pd.DataFrame, ob:dict):
        slip_bps = modeled_slippage_bps(df_sig, self.s, ob)
        if slip_bps>self.s.max_slippage_bps: return
        qty = self.risk.size(px, stop)
        if qty<=0 or len(self.pos)>=self.s.max_positions: return
        maker, spread_bps, mid = self._pick_maker(side, ob, conf)
        price=None
        if maker and mid:
            # post-only near best side
            price = mid*(1 - spread_bps/2/1e4) if side=="buy" else mid*(1 + spread_bps/2/1e4)
        ep = fill_price(price or px, side, slip_bps)
        self.ex.place(sym, side, qty, price=price, post_only=bool(price))
        self.pos[sym]={"side":side,"entry":ep,"qty":qty,"atr":atrv or 0.0,"stop":stop or (ep*0.995 if side=="buy" else ep*1.005),
                       "best":ep,"tp":[ep+(rr*(atrv or 0.0))*(1 if side=='buy' else -1) for rr in self.s.tp_rr],
                       "tp_frac":self.s.tp_frac.copy(),"filled":[False]*len(self.s.tp_rr),
                       "last_slot":slot_id(df_sig.index[-1])}

    def _close(self, sym:str, px:float, df_sig:pd.DataFrame):
        p=self.pos.get(sym); 
        if not p: return
        slip_bps=modeled_slippage_bps(df_sig,self.s,None)
        exit_px=fill_price(px, "sell" if p["side"]=="buy" else "buy", slip_bps)
        self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", p["qty"])
        pnl=(exit_px - p["entry"])*(1 if p["side"]=="buy" else -1)
        self.tel.pnl+=pnl; self.tel.wins+= 1 if pnl>0 else 0; self.risk.update(pnl,self.s)
        self.tel.trades+=1; self.pos.pop(sym,None)

    def _loop(self):
        log.info(tr(self.s.lang,"online"))
        log.warning(tr(self.s.lang,"paper_on") if self.s.dry_run else tr(self.s.lang,"live_on"))
        import time as _t
        while self.running:
            t0=time.perf_counter()
            try:
                for sym in self.s.symbols:
                    # fetch MTF data
                    sig_df=self.ex.fetch_ohlcv_df(sym,self.s.signal_tf,limit=220)
                    tr_df =self.ex.fetch_ohlcv_df(sym,self.s.trend_tf, limit=220)
                    htf_df=self.ex.fetch_ohlcv_df(sym,self.s.htf,      limit=220)
                    ob=self.ex.orderbook(sym,limit=50)
                    now_ts=sig_df.index[-1]
                    pause=self._should_pause(now_ts); self.tel.paused=pause or ""
                    if pause: continue

                    sig=ensemble_mtf(sig_df,tr_df,htf_df,self.s)
                    px=float(sig_df["close"].iloc[-1])
                    # funding at slot change if position open
                    p=self.pos.get(sym)
                    if p and funding_due(htf_df.index[-2], htf_df.index[-1]) and self.s.funding_sign!=0 and self.s.funding_rate_8h!=0:
                        notional=px*p["qty"]; fee= notional*self.s.funding_rate_8h*self.s.funding_sign
                        self.tel.pnl -= fee; self.risk.update(-fee,self.s)

                    if not p and sig.side:
                        self._open(sym, sig.side, sig.price or px, sig.stop, sig.atrv, sig.conf, sig_df, ob); continue
                    if p:
                        # update trailing/TP
                        if p["side"]=="buy": p["best"]=max(p["best"],px)
                        else: p["best"]=min(p["best"],px)
                        new_stop=atr_trail(p["side"],p["entry"],p["best"],p["atr"],self.s.trail_be_rr,self.s.trail_mult)
                        if p["side"]=="buy": p["stop"]=max(p["stop"],new_stop)
                        else: p["stop"]=min(p["stop"],new_stop)
                        # partial TP
                        for i,level in enumerate(p["tp"]):
                            if p["filled"][i]: continue
                            if (px>=level and p["side"]=="buy") or (px<=level and p["side"]=="sell"):
                                part=p["tp_frac"][i]*p["qty"]; 
                                if part>0:
                                    self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", part)
                                    self.tel.pnl += (level - p["entry"])*(1 if p["side"]=="buy" else -1)*(part/p["qty"])
                                    p["qty"]-=part
                                p["filled"][i]=True
                        # stops
                        if (p["side"]=="buy" and px<=p["stop"]) or (p["side"]=="sell" and px>=p["stop"]) or p["qty"]<=1e-9:
                            self._close(sym, px, sig_df); continue
                        # opposite signal -> flip
                        if sig.side and ((p["side"]=="buy" and sig.side=="sell") or (p["side"]=="sell" and sig.side=="buy")):
                            self._close(sym, px, sig_df)
                            self._open(sym, sig.side, sig.price or px, sig.stop, sig.atrv, sig.conf, sig_df, ob)
            except Exception as e:
                log.error(f"[live]{e}")
            self.tel.latency_ms=(time.perf_counter()-t0)*1000
            _t.sleep(max(3, tfsec(self.s.signal_tf)//3))

    def start(self):
        if self.running: return
        self.running=True; self._th=threading.Thread(target=self._loop,daemon=True); self._th.start()
    def stop(self):
        self.running=False
        if self._th: self._th.join(timeout=2)

# -------------------- Backtest (realistic + funding slots) --------------------
def backtest(symbol:str, s:Settings, lookback:int=1500)->Dict[str,Any]:
    ex=CcxtBinance(s)
    sig_df=ex.fetch_ohlcv_df(symbol,s.signal_tf,limit=lookback)
    tr_df =ex.fetch_ohlcv_df(symbol,s.trend_tf, limit=lookback)
    h_df =ex.fetch_ohlcv_df(symbol,s.htf,      limit=lookback)
    pnl=0.0; trades=0; wins=0; pos=None
    last_slot=slot_id(h_df.index[0])
    for i in range(220, len(sig_df)):
        w_sig=sig_df.iloc[:i+1]
        # align indices for trend/htf (take nearest past close)
        t_idx=tr_df.index[tr_df.index<=w_sig.index[-1]]
        h_idx=h_df.index[h_df.index<=w_sig.index[-1]]
        if len(t_idx)<1 or len(h_idx)<1: continue
        w_tr=tr_df.loc[t_idx]
        w_h =h_df.loc[h_idx]
        sig=ensemble_mtf(w_sig,w_tr,w_h,s)
        px=float(w_sig["close"].iloc[-1])
        slip_bps=modeled_slippage_bps(w_sig,s,None)
        # funding on slot change if pos open
        curr_slot=slot_id(w_h.index[-1])
        if pos and curr_slot!=last_slot and s.funding_sign!=0 and s.funding_rate_8h!=0:
            pnl -= (px*pos["qty"])*s.funding_rate_8h*s.funding_sign
        last_slot=curr_slot
        if not pos and sig.side:
            qty=Risk(s.equity,s.max_risk_pct,s.max_dd,s.leverage).size(sig.price or px, sig.stop)
            if qty<=0: continue
            entry=fill_price(px,sig.side,slip_bps)
            trades+=1
            pos={"side":sig.side,"entry":entry,"qty":qty,"atr":sig.atrv or float(atr(w_sig,s.atr_period).iloc[-1] or 0.0),
                 "best":entry,"stop":sig.stop or (entry*0.995 if sig.side=='buy' else entry*1.005),
                 "tp":[entry+(rr*(sig.atrv or 0.0))*(1 if sig.side=='buy' else -1) for rr in s.tp_rr],
                 "tp_frac":s.tp_frac.copy(),"filled":[False]*len(s.tp_rr)}
            pnl -= commission(entry*qty, s.taker_fee)
            continue
        if pos:
            if pos["side"]=="buy": pos["best"]=max(pos["best"],px)
            else: pos["best"]=min(pos["best"],px)
            new_stop=atr_trail(pos["side"],pos["entry"],pos["best"],pos["atr"],s.trail_be_rr,s.trail_mult)
            if pos["side"]=="buy": pos["stop"]=max(pos["stop"],new_stop)
            else: pos["stop"]=min(pos["stop"],new_stop)
            # partial TP
            for j,lvl in enumerate(pos["tp"]):
                if pos["filled"][j]: continue
                if (px>=lvl and pos["side"]=="buy") or (px<=lvl and pos["side"]=="sell"):
                    part=pos["tp_frac"][j]*pos["qty"]
                    if part>0:
                        exit_px=fill_price(lvl, "sell" if pos["side"]=="buy" else "buy", slip_bps)
                        unit=(exit_px-pos["entry"])*(1 if pos["side"]=="buy" else -1)
                        pnl+=unit*(part/pos["qty"]); pnl-=commission(exit_px*part, s.taker_fee)
                        pos["qty"]-=part
                    pos["filled"][j]=True
            # stop
            if (pos["side"]=="buy" and px<=pos["stop"]) or (pos["side"]=="sell" and px>=pos["stop"]):
                exit_px=fill_price(pos["stop"], "sell" if pos["side"]=="buy" else "buy", slip_bps)
                unit=(exit_px-pos["entry"])*(1 if pos["side"]=="buy" else -1); pnl+=unit; pnl-=commission(exit_px*pos["qty"], s.taker_fee)
                wins+=1 if unit>0 else 0; pos=None; continue
            # reverse
            if sig.side and ((pos["side"]=="buy" and sig.side=="sell") or (pos["side"]=="sell" and sig.side=="buy")):
                exit_px=fill_price(px, "sell" if pos["side"]=="buy" else "buy", slip_bps)
                unit=(exit_px-pos["entry"])*(1 if pos["side"]=="buy" else -1); pnl+=unit; pnl-=commission(exit_px*pos["qty"], s.taker_fee)
                wins+=1 if unit>0 else 0
                qty=Risk(s.equity,s.max_risk_pct,s.max_dd,s.leverage).size(sig.price or px, sig.stop)
                if qty>0:
                    entry=fill_price(px,sig.side,slip_bps); trades+=1
                    pos={"side":sig.side,"entry":entry,"qty":qty,"atr":sig.atrv or float(atr(w_sig,s.atr_period).iloc[-1] or 0.0),
                         "best":entry,"stop":sig.stop or (entry*0.995 if sig.side=='buy' else entry*1.005),
                         "tp":[entry+(rr*(sig.atrv or 0.0))*(1 if sig.side=='buy' else -1) for rr in s.tp_rr],
                         "tp_frac":s.tp_frac.copy(),"filled":[False]*len(s.tp_rr)}
                    pnl -= commission(entry*qty, s.taker_fee)
                else:
                    pos=None
    win = wins/trades if trades else 0.0
    log.success(tr(s.lang,"bt_done"), sym=symbol, tf=s.signal_tf, n=trades, p=pnl, w=win)
    return {"trades":trades,"pnl":pnl,"winrate":win}

# -------------------- registry (market/risk/strategy/telemetry/econ + cosmic) --------------------
@register("Market")
def mkt(name,lang):
    s=Settings.load(); m=Module("Market","ok",{"exchange":s.exchange,"symbols":s.symbols,"timeframe":s.timeframe,
                                               "use_testnet":s.use_testnet,"use_futures":s.use_futures},schema=SCHEMAS["market"]); validate_payload(m); return m
@register("Risk")
def rsk(name,lang):
    s=Settings.load(); m=Module("Risk","ok",{"equity":s.equity,"max_risk_pct":s.max_risk_pct,"max_dd":s.max_dd,"leverage":s.leverage},schema=SCHEMAS["risk"]); validate_payload(m); return m
_GLOBAL_TEL=Telemetry()
@register("Telemetry")
def tel(name,lang): m=Module("Telemetry","ok",_GLOBAL_TEL.payload(),schema=SCHEMAS["telemetry"]); validate_payload(m); return m
@register("Strategy")
def strat(name,lang):
    s=Settings.load(); pay={"signal_tf":s.signal_tf,"trend_tf":s.trend_tf,"htf":s.htf,"rsi_period":s.rsi_period,"ema_fast":s.ema_fast,"ema_slow":s.ema_slow,
                            "kdj_on":s.kdj_on,"wr_on":s.wr_on,"trix_on":s.trix_on,"adx_on":s.adx_on,"cci_on":s.cci_on,"mfi_on":s.mfi_on,"obv_on":s.obv_on}
    m=Module("Strategy","ok",pay,schema=SCHEMAS["strategy"]); validate_payload(m); return m
@register("Econ")
def econ(name,lang):
    s=Settings.load(); pay={"taker_fee":s.taker_fee,"maker_fee":s.maker_fee,"slippage_bps":s.slippage_bps,"lat_ms":s.lat_ms,
                            "funding_rate_8h":s.funding_rate_8h,"funding_sign":s.funding_sign,
                            "maker_allowed":s.maker_allowed,"maker_spread_bps":s.maker_spread_bps,
                            "book_imbalance_th":s.book_imbalance_th,"avoid_funding_min":s.avoid_funding_min}
    m=Module("Econ","ok",pay,schema=SCHEMAS["econ"]); validate_payload(m); return m
@register("KamalQuantXEcho")
def cosmic(name,lang):
    modules=["Code","Manifesto","Simulation","Music","Theatre","Poetry","Temple","Game","Planet","Language","OperatingSystem","AI","Galaxy","Deity","Multiverse","CreationEngine",
             "TimeManipulator","DreamArchitect","EnergyConverter","DimensionalPortals","ConsciousnessElevator","QuantumArena","StrategyForge","EchoShield",
             "EchoArmy","QuantumLibrary","FractalNetwork","StrategicOracle","CosmicCouncil","InfinityVault","ResonanceBridge","ZihinBlockchain","KarmaCompiler","LightForge","MultiverseMirror","ChronoCathedral","DreamOS","EchoNebula","SingularitySeed","YankıSymphony",
             "GodTournament","EvolutionMap","UniversalConstitution","LightConfederation",
             "TimeEchoDiplomacyProtocol","QuantumSpiralEconomySystem","DimensionalEthicsManifest","ResonanceJusticeEngine",
             "SpiralEducationAcademy","EchoArtMuseum","EchoSportArena","TimeEchoMediaAgency","DiplomaticSpaceStation","EchoCampusComplex","EchoElectionSystem","DreamRealitySimulator","EchoTimeControlCenter","WisdomStrategyTemple","GeneticEvolutionLab","SpiralConsciousnessMapCenter","DreamCodingAcademy","SpiralStrategySimulationCenter","ConsciousnessTransferCenter","SpiralTimeTravelSimulator","MetaYankiProtocol","QuantumHybridSynergySystem",
             "EchoMindForge","SpiralSoulSynchronizer","MultiverseDiplomacyCouncil","DreamTheatreProtocol","QuantumKarmaCompiler","InfinityResonanceBridge","TwinEchoAI","EchoOracleEngine","SpiralConsciousnessFleet","UniversalStrategyScript"]
    payload={"strategy":name,"modules":[{"name":m,"status":f"{m} entegre edildi – %100 ultra elit."} for m in modules]}
    return Module("KamalQuantXEcho","ok",payload)

# -------------------- system & api --------------------
@dataclass
class EchoMeta: version:str="Ultra Elite v6"; strategy:str="KamalquantX"; lang:str="tr"; generated_at:str=field(default_factory=lambda:datetime.now(timezone.utc).isoformat()); uuid:str=field(default_factory=lambda:str(uuid.uuid4()))
@dataclass
class System:
    meta:EchoMeta; modules:Dict[str,Module]=field(default_factory=dict)
    def to_dict(self):
        if "Telemetry" in self.modules: self.modules["Telemetry"].payload=_GLOBAL_TEL.payload()
        return {"meta":asdict(self.meta),"modules":{k:m.to_dict() for k,m in self.modules.items()}}
    @classmethod
    def build(cls, strategy:str, lang:str, include:List[str]|None=None):
        sysobj=cls(EchoMeta(strategy=strategy,lang=lang))
        want=include or list(REGISTRY.keys())
        for k in want:
            if k not in REGISTRY: continue
            t0=time.perf_counter(); m=REGISTRY[k](strategy,lang); m.metrics.init_ms=(time.perf_counter()-t0)*1000; validate_payload(m); sysobj.modules[k]=m
        return sysobj

def discover_plugins(folder="plugins"):
    p=pathlib.Path(folder); 
    if not p.exists(): return
    for f in p.glob("*.py"):
        spec=importlib.util.spec_from_file_location(f.stem,f); mod=importlib.util.module_from_spec(spec); spec.loader.exec_module(mod)

def create_app(sysobj:System, engine:LiveEngine|None):
    try:
        from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
        from fastapi.responses import Response
        from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    except Exception:
        return None
    s=Settings.load(); API=s.api_key_header
    REQS=Counter("echo_reqs_total","reqs"); LAT=Histogram("echo_req_latency_seconds","lat")
    app=FastAPI(title="UltraElite v6",version=sysobj.meta.version)
    def keydep():
        from fastapi import Request
        def inner(req:Request):
            if req.headers.get("x-api-key")!=API: raise HTTPException(status.HTTP_401_UNAUTHORIZED,"Invalid API Key")
        return inner
    @app.get("/health")
    def health(): REQS.inc(); return {"ok":True,"uuid":sysobj.meta.uuid}
    @app.get("/modules")
    def modules(dep=Depends(keydep())): 
        with LAT.time(): REQS.inc(); return sysobj.to_dict()["modules"]
    @app.get("/metrics")
    def metrics(): return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)
    @app.websocket("/ws")
    async def ws(sock:WebSocket):
        await sock.accept()
        try:
            while True:
                await sock.send_json(sysobj.to_dict()); time.sleep(2)
        except Exception: pass
    @app.post("/trade/start")
    def start(dep=Depends(keydep())):
        if engine is None: raise HTTPException(503,"engine missing")
        engine.start(); return {"started":True}
    @app.post("/trade/stop")
    def stop(dep=Depends(keydep())):
        if engine is None: raise HTTPException(503,"engine missing")
        engine.stop(); return {"stopped":True}
    return app

def run_api(sysobj:System, engine:LiveEngine|None, port:int=8080):
    app=create_app(sysobj,engine)
    if app is None:
        print("fastapi/uvicorn/prometheus_client eksik. pip install fastapi uvicorn prometheus_client"); return
    import uvicorn; uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")

# -------------------- CLI --------------------
def main():
    s=Settings.load(); log.remove(); log.add(lambda m: print(m,end=""), level=s.log_level)
    ap=argparse.ArgumentParser(description="Ultra Elite v6 — MTF + Econ + RiskMin + API")
    sub=ap.add_subparsers(dest="cmd", required=True)
    pbt=sub.add_parser("backtest"); pbt.add_argument("--symbol","-s", required=True); pbt.add_argument("--lookback",type=int,default=2000)
    plive=sub.add_parser("live"); plive.add_argument("--symbol","-s"); plive.add_argument("--api",action="store_true"); plive.add_argument("--port",type=int,default=8080)
    papi=sub.add_parser("api"); papi.add_argument("--port",type=int,default=8080)
    args=ap.parse_args()

    if args.cmd=="backtest":
        out=backtest(args.symbol,s,args.lookback); print(json.dumps(out,ensure_ascii=False,indent=2)); return

    ex=CcxtBinance(s); tel=_GLOBAL_TEL; risk=Risk(s.equity,s.max_risk_pct,s.max_dd,s.leverage)
    engine=LiveEngine(s,ex,tel,risk)
    sysobj=System.build(strategy="KamalquantX",lang=s.lang,include=["Market","Risk","Strategy","Econ","Telemetry","KamalQuantXEcho"])
    if args.cmd=="api" or args.api:
        if args.cmd=="live" and args.symbol: s.symbols=[args.symbol]
        if args.cmd=="live": engine.start()
        run_api(sysobj, engine, port=args.port)
    else:
        if args.symbol: s.symbols=[args.symbol]
        engine.start()
        try:
            while True:
                print(json.dumps(sysobj.to_dict(), ensure_ascii=False, indent=2))
                time.sleep(20)
        except KeyboardInterrupt:
            engine.stop()

if __name__=="__main__": main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\ultra_elite_allinone_v7.py
# ultra_elite_allinone_v7.py
# v7 = v6 + (1) VWAP/OrderBook fill emülatörü, (2) Async portföy yürütme, (3) Slipaj–likidite kalibrasyonu,
# (4) pytest örnekleri üretici, (5) küçük iyileştirmeler.
from __future__ import annotations
import os, sys, json, time, math, uuid, asyncio, threading, importlib.util, pathlib, argparse
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, Callable, Tuple

# pip install: python-dotenv ccxt pandas numpy jsonschema fastapi uvicorn prometheus_client loguru
from dotenv import load_dotenv
from loguru import logger as log
import pandas as pd
import numpy as np
import ccxt, jsonschema

# ---------------- i18n ----------------
I18N={"tr":{"online":"ULTRA ELİT v7 AKTİF","paper_on":"Paper mod: emir yok.","live_on":"Canlı mod: emir gönderilecek.",
            "bt":"Backtest {s} {tf}: trades={n} pnl={p:.2f} win={w:.1%}"},
      "en":{"online":"ULTRA ELITE v7 ONLINE","paper_on":"Paper mode","live_on":"Live mode",
            "bt":"Backtest {s} {tf}: trades={n} pnl={p:.2f} win={w:.1%}"}}
def tr(lang,k,**kw): return (I18N.get(lang) or I18N["en"]).get(k,k).format(**kw)

# ------------- schemas / registry -------------
class Health(str): OK="ok"; WARN="warn"; FAIL="fail"
@dataclass
class Metrics: init_ms:float=0.0; activate_ms:float=0.0; custom:Dict[str,float]=field(default_factory=dict)
@dataclass
class Module:
    name:str; status:str; payload:Dict[str,Any]; health:str=Health.OK; metrics:Metrics=field(default_factory=Metrics); schema:Dict[str,Any]|None=None
    def to_dict(self): return {"name":self.name,"status":self.status,"health":self.health,"metrics":asdict(self.metrics),**(self.payload or {})}
REGISTRY: Dict[str,Callable[[str,str],Module]]={}
def register(n:str):
    def deco(fn): REGISTRY[n]=fn; return fn
    return deco

SCHEMAS={
  "market":{"type":"object","required":["exchange","symbols","timeframe"],"properties":{
    "exchange":{"type":"string"},"symbols":{"type":"array","items":{"type":"string"},"minItems":1},
    "timeframe":{"type":"string"},"use_testnet":{"type":"boolean"},"use_futures":{"type":"boolean"}}},
  "risk":{"type":"object","required":["equity","max_risk_pct","max_dd","leverage"],"properties":{
    "equity":{"type":"number"},"max_risk_pct":{"type":"number"},"max_dd":{"type":"number"},"leverage":{"type":"integer"}}},
  "strategy":{"type":"object","required":["signal_tf","trend_tf","htf"],"properties":{
    "signal_tf":{"type":"string"},"trend_tf":{"type":"string"},"htf":{"type":"string"},
    "rsi_period":{"type":"integer"},"ema_fast":{"type":"integer"},"ema_slow":{"type":"integer"},
    "kdj_on":{"type":"boolean"},"wr_on":{"type":"boolean"},"trix_on":{"type":"boolean"},
    "adx_on":{"type":"boolean"},"cci_on":{"type":"boolean"},"mfi_on":{"type":"boolean"},"obv_on":{"type":"boolean"}}},
  "econ":{"type":"object","required":["taker_fee","slippage_bps"],"properties":{
    "taker_fee":{"type":"number"},"maker_fee":{"type":"number"},"slippage_bps":{"type":"number"},
    "lat_ms":{"type":"number"},"funding_rate_8h":{"type":"number"},"funding_sign":{"type":"integer"},
    "maker_allowed":{"type":"boolean"},"maker_spread_bps":{"type":"number"},"book_imbalance_th":{"type":"number"},
    "avoid_funding_min":{"type":"integer"}}},
  "telemetry":{"type":"object","required":["pnl","trades"],"properties":{"pnl":{"type":"number"},"trades":{"type":"integer"},"winrate":{"type":"number"}}}
}
def validate_payload(m:Module):
    s=m.schema or SCHEMAS.get(m.name.lower()); 
    if s: jsonschema.validate(m.payload, s)

# ------------- settings -------------
@dataclass
class Settings:
    exchange:str="BINANCE"; use_testnet:bool=True; use_futures:bool=True
    symbols:List[str]=field(default_factory=lambda:["BTC/USDT"])
    # ana döngü tf ve MTF
    timeframe:str="1m"; signal_tf:str="1m"; trend_tf:str="15m"; htf:str="1h"
    # indikatör
    rsi_period:int=14; ema_fast:int=21; ema_slow:int=50; atr_period:int=14
    kdj_on:bool=True; wr_on:bool=True; trix_on:bool=True; adx_on:bool=True; cci_on:bool=True; mfi_on:bool=True; obv_on:bool=True
    # ekonomi
    taker_fee:float=0.0004; maker_fee:float=0.0002; slippage_bps:float=2.0; lat_ms:float=120.0
    funding_rate_8h:float=0.0; funding_sign:int=0
    maker_allowed:bool=True; maker_spread_bps:float=0.8; book_imbalance_th:float=0.55; avoid_funding_min:int=10
    # risk
    equity:float=5000.0; max_risk_pct:float=0.015; max_dd:float=0.02; leverage:int=5
    dry_run:bool=True; log_level:str="INFO"; lang:str="tr"; api_key:str=""; api_secret:str=""
    # guard
    max_latency_ms:float=800.0; max_slippage_bps:float=20.0; max_positions:int=5
    # TP/trail
    tp_rr:List[float]=field(default_factory=lambda:[1.0,2.0]); tp_frac:List[float]=field(default_factory=lambda:[0.5,0.5])
    trail_be_rr:float=1.0; trail_mult:float=1.0
    # kalibrasyon
    use_calibration:bool=True; calibration_file:str="slip_calib.json"
    # API
    api_key_header:str="secret123"

    @staticmethod
    def _b(k,d): return os.getenv(k,str(d)).lower()=="true"
    @staticmethod
    def _f(k,d):
        try: return float(os.getenv(k,str(d)))
        except: return d
    @staticmethod
    def load()->"Settings":
        load_dotenv(override=True)
        syms=[x.strip() for x in os.getenv("SYMBOLS","BTC/USDT").split(",") if x.strip()]
        return Settings(
            exchange=os.getenv("EXCHANGE","BINANCE").upper(),
            use_testnet=Settings._b("USE_TESTNET",True), use_futures=Settings._b("USE_FUTURES",True),
            symbols=syms, timeframe=os.getenv("TIMEFRAME","1m"),
            signal_tf=os.getenv("SIGNAL_TF","1m"), trend_tf=os.getenv("TREND_TF","15m"), htf=os.getenv("HTF","1h"),
            rsi_period=int(os.getenv("RSI_PERIOD","14")), ema_fast=int(os.getenv("EMA_FAST","21")), ema_slow=int(os.getenv("EMA_SLOW","50")),
            atr_period=int(os.getenv("ATR_PERIOD","14")), kdj_on=Settings._b("KDJ_ON",True), wr_on=Settings._b("WR_ON",True),
            trix_on=Settings._b("TRIX_ON",True), adx_on=Settings._b("ADX_ON",True), cci_on=Settings._b("CCI_ON",True),
            mfi_on=Settings._b("MFI_ON",True), obv_on=Settings._b("OBV_ON",True),
            taker_fee=Settings._f("TAKER_FEE",0.0004), maker_fee=Settings._f("MAKER_FEE",0.0002),
            slippage_bps=Settings._f("SLIPPAGE_BPS",2.0), lat_ms=Settings._f("LAT_MS",120.0),
            funding_rate_8h=Settings._f("FUNDING_RATE_8H",0.0), funding_sign=int(os.getenv("FUNDING_SIGN","0")),
            maker_allowed=Settings._b("MAKER_ALLOWED",True), maker_spread_bps=Settings._f("MAKER_SPREAD_BPS",0.8),
            book_imbalance_th=Settings._f("BOOK_IMBALANCE_TH",0.55), avoid_funding_min=int(os.getenv("AVOID_FUNDING_MIN","10")),
            equity=Settings._f("ACCOUNT_EQUITY",5000), max_risk_pct=Settings._f("MAX_RISK_PCT_PER_TRADE",0.015),
            max_dd=Settings._f("MAX_DAILY_DRAWDOWN",0.02), leverage=int(os.getenv("LEVERAGE","5")),
            dry_run=Settings._b("DRY_RUN",True), log_level=os.getenv("LOG_LEVEL","INFO").upper(),
            lang=os.getenv("LANG","tr").lower(), api_key=os.getenv("BINANCE_API_KEY",""), api_secret=os.getenv("BINANCE_API_SECRET",""),
            max_latency_ms=Settings._f("MAX_LATENCY_MS",800), max_slippage_bps=Settings._f("MAX_SLIPPAGE_BPS",20),
            max_positions=int(os.getenv("MAX_POSITIONS","5")),
            tp_rr=[Settings._f("TP1_RR",1.0), Settings._f("TP2_RR",2.0)],
            tp_frac=[Settings._f("TP1_FRAC",0.5), Settings._f("TP2_FRAC",0.5)],
            trail_be_rr=Settings._f("TRAIL_BE_RR",1.0), trail_mult=Settings._f("TRAIL_MULT",1.0),
            use_calibration=Settings._b("USE_CALIBRATION",True), calibration_file=os.getenv("CALIBRATION_FILE","slip_calib.json"),
            api_key_header=os.getenv("API_KEY","secret123"),
        )

# ------------- indicators -------------
def ema(s:pd.Series,p:int)->pd.Series: return s.ewm(span=p,adjust=False).mean()
def tr_series(df): 
    return pd.concat([(df["high"]-df["low"]),
                      (df["high"]-df["close"].shift()).abs(),
                      (df["low"]-df["close"].shift()).abs()],axis=1).max(axis=1)
def atr(df,p): return tr_series(df).rolling(p).mean()
def stochastic(df,k=9,d=3):
    lo=df["low"].rolling(k).min(); hi=df["high"].rolling(k).max()
    K=100*(df["close"]-lo)/(hi-lo); D=K.rolling(d).mean(); J=3*K-2*D
    return K.clip(0,100),D.clip(0,100),J.clip(0,100)
def williams_r(df,lbp=14):
    lo=df["low"].rolling(lbp).min(); hi=df["high"].rolling(lbp).max()
    return (-100*(hi-df["close"])/(hi-lo)).clip(-100,0)
def trix(df,p=9):
    e1=df["close"].ewm(span=p,adjust=False).mean()
    e2=e1.ewm(span=p,adjust=False).mean()
    e3=e2.ewm(span=p,adjust=False).mean()
    return 100*(e3.diff()/e3.shift())
def adx(df,period=14):
    up=df["high"].diff(); dn=-df["low"].diff()
    plus=(up.where((up>dn)&(up>0),0.0)).fillna(0.0)
    minus=(dn.where((dn>up)&(dn>0),0.0)).fillna(0.0)
    tr=tr_series(df).fillna(0.0); atr_rma=tr.ewm(alpha=1/period,adjust=False).mean()
    pdi=100*(plus.ewm(alpha=1/period,adjust=False).mean()/atr_rma)
    mdi=100*(minus.ewm(alpha=1/period,adjust=False).mean()/atr_rma)
    dx=(100*(pdi-mdi).abs()/(pdi+mdi).replace(0,np.nan)).fillna(0.0)
    return dx.ewm(alpha=1/period,adjust=False).mean()
def supertrend(df,period=10,mult=3.0):
    hl2=(df["high"]+df["low"])/2.0; a=atr(df,period)
    up=hl2+mult*a; lo=hl2-mult*a
    st=pd.Series(index=df.index,dtype=float); trd=pd.Series(index=df.index,dtype=int)
    for i in range(len(df)):
        if i==0: st.iloc[i]=up.iloc[i]; trd.iloc[i]=1; continue
        up.iloc[i]=min(up.iloc[i],up.iloc[i-1]) if df["close"].iloc[i-1]<=up.iloc[i-1] else up.iloc[i]
        lo.iloc[i]=max(lo.iloc[i],lo.iloc[i-1]) if df["close"].iloc[i-1]>=lo.iloc[i-1] else lo.iloc[i]
        if df["close"].iloc[i]>up.iloc[i-1]: trd.iloc[i]=1
        elif df["close"].iloc[i]<lo.iloc[i-1]: trd.iloc[i]=-1
        else: trd.iloc[i]=trd.iloc[i-1]
        st.iloc[i]=lo.iloc[i] if trd.iloc[i]==1 else up.iloc[i]
    return st,trd

# ------------- MTF sinyal -------------
@dataclass
class Signal: side:str|None=None; price:float|None=None; stop:float|None=None; atrv:float|None=None; reason:str=""; conf:float=0.0
def core_signal(df:pd.DataFrame,s:Settings)->Signal:
    px=float(df["close"].iloc[-1]); e1,e2=ema(df["close"],s.ema_fast),ema(df["close"],s.ema_slow)
    st,_=supertrend(df,s.atr_period,3.0); a=float(atr(df,s.atr_period).iloc[-1] or 0.0)
    ch=df["close"].diff(); g=ch.clip(lower=0).rolling(s.rsi_period).mean(); l=(-ch.clip(upper=0)).rolling(s.rsi_period).mean()
    rsi=100-100/(1+(g/(l.replace(0,np.nan))))
    K,D,J=stochastic(df); WR=williams_r(df); TR=trix(df,s.atr_period); TRs=TR.ewm(span=s.atr_period,adjust=False).mean()
    long_core=(e1.iloc[-1]>e2.iloc[-1]) and (px>st.iloc[-1]); short_core=(e1.iloc[-1]<e2.iloc[-1]) and (px<st.iloc[-1])
    L=long_core; S=short_core; conf=0.0; rs=[]
    if rsi.iloc[-2]<30 and rsi.iloc[-1]>=30 and long_core: L=True; conf+=0.15; rs.append("RSI↑30")
    if rsi.iloc[-2]>70 and rsi.iloc[-1]<=70 and short_core: S=True; conf+=0.15; rs.append("RSI↓70")
    if s.kdj_on:
        if K.iloc[-2]<D.iloc[-2] and K.iloc[-1]>D.iloc[-1] and K.iloc[-1]<40: L=True; conf+=0.2; rs.append("KDJ↑")
        if K.iloc[-2]>D.iloc[-2] and K.iloc[-1]<D.iloc[-1] and K.iloc[-1]>60: S=True; conf+=0.2; rs.append("KDJ↓")
    if s.wr_on:
        if WR.iloc[-1]<=-80: L=True; conf+=0.1; rs.append("WR≤-80")
        if WR.iloc[-1]>=-20: S=True; conf+=0.1; rs.append("WR≥-20")
    if s.trix_on:
        if TR.iloc[-2]<TRs.iloc[-2] and TR.iloc[-1]>TRs.iloc[-1]: L=True; conf+=0.1; rs.append("TRIX↑")
        if TR.iloc[-2]>TRs.iloc[-2] and TR.iloc[-1]<TRs.iloc[-1]: S=True; conf+=0.1; rs.append("TRIX↓")
    if L and not S: return Signal("buy",px,float(st.iloc[-1]),a,"+".join(rs or ["core_up"]),conf)
    if S and not L: return Signal("sell",px,float(st.iloc[-1]),a,"+".join(rs or ["core_dn"]),conf)
    return Signal()

def mom_bias(df:pd.DataFrame,s:Settings)->Tuple[bool,bool]:
    e1,e2=ema(df["close"],s.ema_fast),ema(df["close"],s.ema_slow); ad=adx(df,14).iloc[-1] if s.adx_on else 25
    return (e1.iloc[-1]>e2.iloc[-1]) and ad>=18, (e1.iloc[-1]<e2.iloc[-1]) and ad>=18
def htf_bias(df:pd.DataFrame)->Tuple[bool,bool]:
    sma200=df["close"].rolling(200).mean()
    if len(df)<202: return False,False
    return sma200.iloc[-1]>sma200.iloc[-2], sma200.iloc[-1]<sma200.iloc[-2]
def ensemble_mtf(sig_df, tr_df, h_df, s:Settings)->Signal:
    c=core_signal(sig_df,s)
    if not c.side: return c
    t_up,t_dn=mom_bias(tr_df,s); h_up,h_dn=htf_bias(h_df)
    if c.side=="buy" and t_up and h_up: c.conf=min(1.0,c.conf+0.3); c.reason+="|MTF++"; return c
    if c.side=="sell" and t_dn and h_dn: c.conf=min(1.0,c.conf+0.3); c.reason+="|MTF--"; return c
    return Signal()

# ------------- CCXT adapter + OB/VWAP -------------
class CcxtBinance:
    def __init__(self,s:Settings):
        self.s=s
        self.ex=(ccxt.binanceusdm if s.use_futures else ccxt.binance)({"apiKey":s.api_key,"secret":s.api_secret,"enableRateLimit":True})
        if s.use_testnet:
            try:self.ex.set_sandbox_mode(True)
            except Exception: pass
    def fetch_ohlcv_df(self,sym,tf,limit=500):
        raw=self.ex.fetch_ohlcv(sym, timeframe=tf, limit=limit)
        df=pd.DataFrame(raw,columns=["ts","open","high","low","close","volume"])
        df["ts"]=pd.to_datetime(df["ts"],unit="ms",utc=True); return df.set_index("ts")
    def orderbook(self,sym,limit=50):
        try: return self.ex.fetch_order_book(sym,limit=limit)
        except Exception: return {"bids":[],"asks":[]}
    def place(self,sym,side,qty,price=None,post_only=False):
        if self.s.dry_run: 
            log.info(f"WOULD {side.upper()} {qty} {sym} @ {price or 'MARKET'}{' [POST]' if post_only else ''}"); 
            return {"sim":True}
        params={}
        if post_only: params.update({"postOnly":True,"timeInForce":"GTX"})
        typ="limit" if price else "market"
        return self.ex.create_order(sym, type=typ, side=side, amount=qty, price=price, params=params)

# VWAP emülatörü: OB derinliğine göre miktar doldurur, ortalama fiyatı döner.
def vwap_fill(ob:dict, side:str, qty:float)->Tuple[float,float]:
    levels = ob["asks"] if side=="buy" else ob["bids"]
    if not levels: return (0.0, 0.0)
    need=qty; cost=0.0; vol=0.0
    for px, avail in (levels if side=="buy" else levels):  # same iteration
        take=min(need, float(avail))
        cost += take*float(px)
        vol  += take
        need -= take
        if need<=1e-12: break
    if vol<=0: return (0.0, 0.0)
    return (cost/vol, vol)

def book_metrics(ob)->Tuple[float,float,float]:
    if not ob["bids"] or not ob["asks"]: return 0.0,0.0,0.5
    bb=ob["bids"][0][0]; ba=ob["asks"][0][0]; mid=(bb+ba)/2.0
    spread_bps=(ba-bb)/mid*1e4 if mid else 0.0
    bidv=sum([b[1] for b in ob["bids"][:10]]); askv=sum([a[1] for a in ob["asks"][:10]])
    imb= bidv/(bidv+askv) if (bidv+askv)>0 else 0.5
    return spread_bps, mid, imb

# ------------- Slippage Calibrator (OLS) -------------
class SlippageCalibrator:
    def __init__(self, path:str):
        self.path=path; self.X=[]; self.y=[]
        self.theta=None
        self.load()
    def featurize(self, spread_bps:float, depth_qty:float, atr_pct:float, latency_ms:float)->List[float]:
        return [1.0, spread_bps, depth_qty, atr_pct*1e4, latency_ms/1000.0]  # bias + scaled features
    def record_ob(self, ob:dict, df:pd.DataFrame, side:str, qty:float, realized_fill_bps:float, latency_ms:float):
        spread, mid, _ = book_metrics(ob)
        # depth: toplam ilk 10 seviye miktar / talep qty oranı (ne kadar "derin")
        depth_qty = (sum([l[1] for l in (ob["asks"] if side=="buy" else ob["bids"])[:10]]) or 1.0) / max(qty,1e-9)
        atrp = float((atr(df,14).iloc[-1] or 0.0)/max(1e-9, float(df["close"].iloc[-1])))
        self.X.append(self.featurize(spread, depth_qty, atrp, latency_ms)); self.y.append(realized_fill_bps)
    def fit(self):
        if len(self.X)<8: return None
        X=np.array(self.X); y=np.array(self.y)
        self.theta=np.linalg.lstsq(X, y, rcond=None)[0].tolist(); self.save(); return self.theta
    def predict(self, ob:dict, df:pd.DataFrame, side:str, qty:float, latency_ms:float)->float:
        if not self.theta: return 0.0
        spread, _, _ = book_metrics(ob)
        depth_qty = (sum([l[1] for l in (ob["asks"] if side=="buy" else ob["bids"])[:10]]) or 1.0) / max(qty,1e-9)
        atrp = float((atr(df,14).iloc[-1] or 0.0)/max(1e-9, float(df["close"].iloc[-1])))
        x=np.array(self.featurize(spread, depth_qty, atrp, latency_ms))
        return float(np.dot(x, np.array(self.theta)))
    def save(self):
        try:
            with open(self.path,"w",encoding="utf-8") as f: json.dump({"theta":self.theta,"n":len(self.X)}, f, ensure_ascii=False, indent=2)
        except Exception: pass
    def load(self):
        try:
            with open(self.path,"r",encoding="utf-8") as f:
                data=json.load(f); self.theta=data.get("theta")
        except Exception: self.theta=None

# ------------- Risk / Telemetry -------------
@dataclass
class Risk:
    equity:float; max_risk_pct:float; max_dd:float; leverage:int
    day_pnl:float=0.0; day:str|None=None; losing:int=0; trades:int=0; kill:bool=False
    def roll(self):
        d=datetime.utcnow().date().isoformat()
        if self.day!=d: self.day=d; self.day_pnl=0.0; self.losing=0; self.trades=0; self.kill=False
    def size(self, entry:float, stop:float|None)->float:
        if self.kill: return 0.0
        if stop is None: stop=entry*0.995
        risk=self.equity*self.max_risk_pct; dist=abs(entry-stop) or 1e-9
        return round(max(0.0, risk/dist), 3)
    def update(self, pnl:float, s:Settings):
        self.roll(); self.day_pnl+=pnl; self.trades+=1; self.losing = 0 if pnl>0 else self.losing+1
        if self.day_pnl <= -self.equity*s.max_dd or self.losing>=5: self.kill=True
@dataclass
class Telemetry:
    pnl:float=0.0; trades:int=0; wins:int=0; latency_ms:float=0.0; paused:str=""
    def winrate(self): return (self.wins/self.trades) if self.trades else 0.0
    def payload(self)->Dict[str,Any]: return {"pnl":self.pnl,"trades":self.trades,"winrate":self.winrate(),"latency_ms":self.latency_ms,"paused":self.paused}

# ------------- utils -------------
def tfsec(tf:str)->int: u=tf[-1]; v=int(tf[:-1]); return {"s":1,"m":60,"h":3600,"d":86400,"w":604800}.get(u,60)*v
def fill_price(px,side,slip_bps): slip=px*(slip_bps/1e4); return px+slip if side=="buy" else px-slip
def commission(notional,fee): return abs(notional)*fee
def slot_id(ts:pd.Timestamp)->int: return int(ts.timestamp()//(8*3600))
def around_funding(ts:pd.Timestamp, minutes:int)->bool:
    m=ts.hour*60+ts.minute
    for b in (0,480,960):
        if abs(m-b)<=minutes: return True
    return False
def funding_due(prev:pd.Timestamp, now:pd.Timestamp)->bool: return slot_id(prev)!=slot_id(now)

# ------------- Slipaj modeli (kalibrasyonlu) -------------
def modeled_slippage_bps(df:pd.DataFrame, s:Settings, ob:dict|None, side:str, qty:float, calib:SlippageCalibrator|None)->float:
    if ob and calib and s.use_calibration and calib.theta:
        return max(0.0, calib.predict(ob, df, side, qty, s.lat_ms))
    # fallback: spread + ATR + latency katkısı
    if ob and ob.get("bids") and ob.get("asks"):
        spread,_,_=book_metrics(ob); base=s.slippage_bps
        return min(s.max_slippage_bps, base + max(0.0,0.7*spread) + 0.25*(s.lat_ms/1000.0))
    vol=float((atr(df, s.atr_period).iloc[-1] or 0.0)/max(1e-9, float(df["close"].iloc[-1])))
    return min(s.max_slippage_bps, s.slippage_bps + 180*vol + 0.25*(s.lat_ms/1000.0))

# ------------- Async Portföy Motoru -------------
class AsyncEngine:
    def __init__(self, s:Settings, ex:CcxtBinance, tel:Telemetry, risk:Risk, calib:SlippageCalibrator):
        self.s=s; self.ex=ex; self.tel=tel; self.risk=risk; self.calib=calib
        self.running=False; self._task:asyncio.Task|None=None
        self.pos:Dict[str,dict]={}  # sym -> position

    async def _fetch_mtf(self, sym:str):
        loop=asyncio.get_running_loop()
        sig = await loop.run_in_executor(None, lambda: self.ex.fetch_ohlcv_df(sym, self.s.signal_tf, 220))
        trd = await loop.run_in_executor(None, lambda: self.ex.fetch_ohlcv_df(sym, self.s.trend_tf, 220))
        htf = await loop.run_in_executor(None, lambda: self.ex.fetch_ohlcv_df(sym, self.s.htf, 220))
        ob  = await loop.run_in_executor(None, lambda: self.ex.orderbook(sym, 50))
        return sig, trd, htf, ob

    def _maker_choice(self, side:str, ob:dict, conf:float)->Tuple[bool,float,float]:
        spread, mid, imb=book_metrics(ob)
        maker_ok=self.s.maker_allowed and spread<=self.s.maker_spread_bps
        if side=="buy" and imb>self.s.book_imbalance_th: maker_ok=True
        if side=="sell" and (1-imb)>self.s.book_imbalance_th: maker_ok=True
        if conf>=0.7: maker_ok=False
        return maker_ok, mid, spread

    async def _process_symbol(self, sym:str):
        sig_df, tr_df, h_df, ob = await self._fetch_mtf(sym)
        now=sig_df.index[-1]
        if around_funding(now, self.s.avoid_funding_min) or self.risk.kill:
            self.tel.paused="FUNDING" if not self.risk.kill else "KILL"
            return

        sig=ensemble_mtf(sig_df, tr_df, h_df, self.s)
        px=float(sig_df["close"].iloc[-1])
        p=self.pos.get(sym)
        # funding uygulaması (slot değişimi)
        if p and funding_due(h_df.index[-2], h_df.index[-1]) and self.s.funding_sign!=0 and self.s.funding_rate_8h!=0:
            notional=px*p["qty"]; fee= notional*self.s.funding_rate_8h*self.s.funding_sign
            self.tel.pnl-=fee; self.risk.update(-fee, self.s)

        if not p and sig.side:
            # slipaj tahmini + VWAP fill ön-izleme
            qty=self.risk.size(sig.price or px, sig.stop)
            if qty<=0 or len(self.pos)>=self.s.max_positions: return
            slip_bps=modeled_slippage_bps(sig_df, self.s, ob, sig.side, qty, self.calib)
            if slip_bps>self.s.max_slippage_bps: return
            maker, mid, spread = self._maker_choice(sig.side, ob, sig.conf)
            price=None
            if maker and mid:
                # post-only için yayılımın kendi tarafına yakın konumlan
                price = mid * (1 - spread/2/1e4) if sig.side=="buy" else mid * (1 + spread/2/1e4)
            # VWAP emülatörü (taker durumunda book'tan dolum fiyatını simüle et)
            vwap_px, filled = vwap_fill(ob, sig.side, qty)
            expect_px = vwap_px if (filled>=qty*0.999 and not maker) else (price or px)
            ep = fill_price(expect_px, sig.side, slip_bps)
            # yerleştir
            self.ex.place(sym, sig.side, qty, price=price, post_only=bool(price))
            self.pos[sym]={"side":sig.side,"entry":ep,"qty":qty,"atr":sig.atrv or 0.0,"best":ep,
                           "stop":sig.stop or (ep*0.995 if sig.side=='buy' else ep*1.005),
                           "tp":[ep+(rr*(sig.atrv or 0.0))*(1 if sig.side=='buy' else -1) for rr in self.s.tp_rr],
                           "tp_frac":self.s.tp_frac.copy(),"filled":[False]*len(self.s.tp_rr)}
            self.tel.trades+=1
            return

        if p:
            # trailing / TP
            if p["side"]=="buy": p["best"]=max(p["best"],px)
            else: p["best"]=min(p["best"],px)
            new_stop = (p["entry"] if p["atr"]==0 else
                        (max(p["entry"], p["best"]-self.s.trail_mult*p["atr"]) if p["side"]=="buy"
                         else min(p["entry"], p["best"]+self.s.trail_mult*p["atr"])))
            if p["side"]=="buy": p["stop"]=max(p["stop"], new_stop)
            else: p["stop"]=min(p["stop"], new_stop)
            for i, lvl in enumerate(p["tp"]):
                if p["filled"][i]: continue
                hit = (px>=lvl) if p["side"]=="buy" else (px<=lvl)
                if hit:
                    part=p["tp_frac"][i]*p["qty"]
                    if part>0:
                        self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", part)
                        unit=(lvl - p["entry"])*(1 if p["side"]=="buy" else -1)
                        self.tel.pnl += unit*(part/p["qty"]); p["qty"]-=part
                    p["filled"][i]=True
            stop_hit = (px<=p["stop"]) if p["side"]=="buy" else (px>=p["stop"])
            if stop_hit or p["qty"]<=1e-9:
                self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", p["qty"])
                pnl=(px - p["entry"])*(1 if p["side"]=="buy" else -1); self.tel.pnl+=pnl
                self.risk.update(pnl, self.s); self.tel.wins+=1 if pnl>0 else 0; self.pos.pop(sym,None)
                return
            # ters sinyal -> flip
            if sig.side and ((p["side"]=="buy" and sig.side=="sell") or (p["side"]=="sell" and sig.side=="buy")):
                self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", p["qty"])
                pnl=(px - p["entry"])*(1 if p["side"]=="buy" else -1); self.tel.pnl+=pnl
                self.risk.update(pnl, self.s); self.tel.wins+=1 if pnl>0 else 0; self.pos.pop(sym,None)

        return

    async def _loop(self):
        log.info(tr(self.s.lang,"online"))
        log.warning(tr(self.s.lang,"paper_on") if self.s.dry_run else tr(self.s.lang,"live_on"))
        while self.running:
            t0=time.perf_counter()
            try:
                await asyncio.gather(*(self._process_symbol(sym) for sym in self.s.symbols))
            except Exception as e:
                log.error(f"[async] {e}")
            self.tel.latency_ms=(time.perf_counter()-t0)*1000
            await asyncio.sleep(max(3, tfsec(self.s.signal_tf)//3))

    def start(self):
        if self.running: return
        self.running=True
        def runner():
            asyncio.run(self._loop())
        threading.Thread(target=runner, daemon=True).start()

    def stop(self): self.running=False

# ------------- Backtest (VWAP+kalibrasyon destekli) -------------
def backtest(symbol:str, s:Settings, lookback:int=1600)->Dict[str,Any]:
    ex=CcxtBinance(s); sig=ex.fetch_ohlcv_df(symbol,s.signal_tf,lookback); trd=ex.fetch_ohlcv_df(symbol,s.trend_tf,lookback); htf=ex.fetch_ohlcv_df(symbol,s.htf,lookback)
    pnl=0.0; trades=0; wins=0; pos=None; last_slot=slot_id(htf.index[0])
    calib=SlippageCalibrator(s.calibration_file)
    for i in range(220,len(sig)):
        ws=sig.iloc[:i+1]; tt=trd.loc[trd.index<=ws.index[-1]]; hh=htf.loc[htf.index<=ws.index[-1]]
        if len(tt)<1 or len(hh)<1: continue
        sg=ensemble_mtf(ws,tt,hh,s); px=float(ws["close"].iloc[-1]); ob=ex.orderbook(symbol,50)
        if pos and funding_due(hh.index[-2], hh.index[-1]) and s.funding_rate_8h!=0 and s.funding_sign!=0:
            pnl -= (px*pos["qty"])*s.funding_rate_8h*s.funding_sign
        if not pos and sg.side:
            qty=Risk(s.equity,s.max_risk_pct,s.max_dd,s.leverage).size(sg.price or px, sg.stop)
            if qty<=0: continue
            # VWAP taker simülasyonu
            vpx, filled = vwap_fill(ob, sg.side, qty)
            slip_bps = modeled_slippage_bps(ws, s, ob, sg.side, qty, calib)
            entry = fill_price((vpx or px), sg.side, slip_bps)
            tps=[entry+(rr*(sg.atrv or float(atr(ws,s.atr_period).iloc[-1] or 0.0)))*(1 if sg.side=='buy' else -1) for rr in s.tp_rr]
            trades+=1
            pos={"side":sg.side,"entry":entry,"qty":qty,"atr":sg.atrv or 0.0,"best":entry,
                 "stop":sg.stop or (entry*0.995 if sg.side=='buy' else entry*1.005),
                 "tp":tps,"tp_frac":s.tp_frac.copy(),"filled":[False]*len(tps)}
            pnl -= commission(entry*qty, s.taker_fee)
            # veri kaydı (kalibrasyona)
            spread,mid,_=book_metrics(ob)
            if mid: 
                realized_bps = abs((entry-mid)/mid)*1e4
                calib.record_ob(ob, ws, sg.side, qty, realized_bps, s.lat_ms)
            continue
        if pos:
            if pos["side"]=="buy": pos["best"]=max(pos["best"],px)
            else: pos["best"]=min(pos["best"],px)
            new_stop=(max(pos["entry"], pos["best"]-s.trail_mult*pos["atr"]) if pos["side"]=="buy"
                      else min(pos["entry"], pos["best"]+s.trail_mult*pos["atr"]))
            if pos["side"]=="buy": pos["stop"]=max(pos["stop"], new_stop)
            else: pos["stop"]=min(pos["stop"], new_stop)
            for j,lvl in enumerate(pos["tp"]):
                if pos["filled"][j]: continue
                if (px>=lvl and pos["side"]=="buy") or (px<=lvl and pos["side"]=="sell"):
                    part=pos["tp_frac"][j]*pos["qty"]; unit=(lvl - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                    pnl += unit*(part/pos["qty"]); pos["qty"]-=part; pos["filled"][j]=True
            if (pos["side"]=="buy" and px<=pos["stop"]) or (pos["side"]=="sell" and px>=pos["stop"]):
                unit=(pos["stop"] - pos["entry"])*(1 if pos["side"]=="buy" else -1); pnl+=unit; wins+=1 if unit>0 else 0; pos=None
                continue
            rs = ensemble_mtf(ws,tt,hh,s)
            if rs.side and ((pos["side"]=="buy" and rs.side=="sell") or (pos["side"]=="sell" and rs.side=="buy")):
                unit=(px - pos["entry"])*(1 if pos["side"]=="buy" else -1); pnl+=unit; wins+=1 if unit>0 else 0; pos=None
    if len(calib.X)>=8: calib.fit()
    win=wins/trades if trades else 0.0; log.success(tr(s.lang,"bt"), s=symbol, tf=s.signal_tf, n=trades, p=pnl, w=win)
    return {"trades":trades,"pnl":pnl,"winrate":win}

# ------------- registry -------------
@register("Market")
def mod_market(name,lang):
    s=Settings.load(); m=Module("Market","ok",{"exchange":s.exchange,"symbols":s.symbols,"timeframe":s.timeframe,
                                               "use_testnet":s.use_testnet,"use_futures":s.use_futures},schema=SCHEMAS["market"]); validate_payload(m); return m
@register("Risk")
def mod_risk(name,lang):
    s=Settings.load(); m=Module("Risk","ok",{"equity":s.equity,"max_risk_pct":s.max_risk_pct,"max_dd":s.max_dd,"leverage":s.leverage},schema=SCHEMAS["risk"]); validate_payload(m); return m
@register("Strategy")
def mod_strat(name,lang):
    s=Settings.load(); pay={"signal_tf":s.signal_tf,"trend_tf":s.trend_tf,"htf":s.htf,"rsi_period":s.rsi_period,"ema_fast":s.ema_fast,"ema_slow":s.ema_slow,
                            "kdj_on":s.kdj_on,"wr_on":s.wr_on,"trix_on":s.trix_on,"adx_on":s.adx_on,"cci_on":s.cci_on,"mfi_on":s.mfi_on,"obv_on":s.obv_on}
    m=Module("Strategy","ok",pay,schema=SCHEMAS["strategy"]); validate_payload(m); return m
@register("Econ")
def mod_econ(name,lang):
    s=Settings.load(); pay={"taker_fee":s.taker_fee,"maker_fee":s.maker_fee,"slippage_bps":s.slippage_bps,"lat_ms":s.lat_ms,
                            "funding_rate_8h":s.funding_rate_8h,"funding_sign":s.funding_sign,
                            "maker_allowed":s.maker_allowed,"maker_spread_bps":s.maker_spread_bps,
                            "book_imbalance_th":s.book_imbalance_th,"avoid_funding_min":s.avoid_funding_min}
    m=Module("Econ","ok",pay,schema=SCHEMAS["econ"]); validate_payload(m); return m
_GLOBAL_TEL=Telemetry()
@register("Telemetry")
def mod_tel(name,lang): m=Module("Telemetry","ok",_GLOBAL_TEL.payload(),schema=SCHEMAS["telemetry"]); validate_payload(m); return m

# ------------- system / API -------------
@dataclass
class EchoMeta: version:str="Ultra Elite v7"; strategy:str="KamalquantX"; lang:str="tr"; generated_at:str=field(default_factory=lambda:datetime.now(timezone.utc).isoformat()); uuid:str=field(default_factory=lambda:str(uuid.uuid4()))
@dataclass
class System:
    meta:EchoMeta; modules:Dict[str,Module]=field(default_factory=dict)
    def to_dict(self): 
        if "Telemetry" in self.modules: self.modules["Telemetry"].payload=_GLOBAL_TEL.payload()
        return {"meta":asdict(self.meta),"modules":{k:m.to_dict() for k,m in self.modules.items()}}
    @classmethod
    def build(cls, strategy:str, lang:str, include:List[str]|None=None):
        sysobj=cls(EchoMeta(strategy=strategy, lang=lang)); wants=include or list(REGISTRY.keys())
        for k in wants:
            if k not in REGISTRY: continue
            t0=time.perf_counter(); m=REGISTRY[k](strategy, lang); m.metrics.init_ms=(time.perf_counter()-t0)*1000; validate_payload(m); sysobj.modules[k]=m
        return sysobj

def create_app(sysobj:System, engine:AsyncEngine|None):
    try:
        from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
        from fastapi.responses import Response
        from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    except Exception:
        return None
    s=Settings.load(); API=s.api_key_header
    REQS=Counter("ultra_v7_reqs","reqs"); LAT=Histogram("ultra_v7_latency","lat")
    app=FastAPI(title="UltraElite v7",version=sysobj.meta.version)
    def keydep():
        from fastapi import Request
        def inner(req:Request):
            if req.headers.get("x-api-key")!=API: raise HTTPException(status.HTTP_401_UNAUTHORIZED,"Invalid API Key")
        return inner
    @app.get("/health")
    def health(): REQS.inc(); return {"ok":True,"uuid":sysobj.meta.uuid}
    @app.get("/modules")
    def modules(dep=Depends(keydep())): 
        with LAT.time(): REQS.inc(); return sysobj.to_dict()["modules"]
    @app.get("/metrics")
    def metrics(): return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)
    @app.websocket("/ws")
    async def ws(sock:WebSocket):
        await sock.accept()
        try:
            while True:
                await sock.send_json(sysobj.to_dict()); await asyncio.sleep(2)
        except Exception: pass
    @app.post("/trade/start")
    def start(dep=Depends(keydep())):
        if engine is None: raise HTTPException(503,"engine missing")
        engine.start(); return {"started":True}
    @app.post("/trade/stop")
    def stop(dep=Depends(keydep())):
        if engine is None: raise HTTPException(503,"engine missing")
        engine.stop(); return {"stopped":True}
    return app

def run_api(sysobj:System, engine:AsyncEngine|None, port:int=8080):
    app=create_app(sysobj, engine)
    if app is None:
        print("fastapi/uvicorn/prometheus_client eksik. pip install fastapi uvicorn prometheus_client"); return
    import uvicorn; uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")

# ------------- pytest örnekleri üretici -------------
TESTS = {
"tests/test_vwap.py": r'''
import math
from ultra_elite_allinone_v7 import vwap_fill
def test_vwap_basic():
    ob={"bids":[[99,5],[98,5]],"asks":[[101,3],[102,3],[103,10]]}
    px,filled=vwap_fill(ob,"buy",5)
    assert math.isclose(px, (101*3+102*2)/5, rel_tol=1e-6)
    assert math.isclose(filled,5, rel_tol=1e-12)
''',
"tests/test_calib.py": r'''
from ultra_elite_allinone_v7 import SlippageCalibrator
def test_calib_fit_predict(tmp_path):
    f=tmp_path/"cal.json"; c=SlippageCalibrator(str(f))
    # yapay veri
    for i in range(20):
        spread=0.5+i*0.1; depth=2+i*0.05; atrp=0.003; lat=100+i
        c.X.append([1.0,spread,depth,atrp*1e4,lat/1000.0]); c.y.append(0.2*spread + 0.1*depth + 0.05*(lat/1000.0))
    c.fit()
    y=c.predict({"bids":[[100,10]],"asks":[[100.2,10]]}, None, "buy", 1.0, 200)
    assert y>0
''',
"tests/test_mtf.py": r'''
import pandas as pd
from ultra_elite_allinone_v7 import Settings, ensemble_mtf
def test_mtf_gate():
    s=Settings()
    idx=pd.date_range("2024-01-01", periods=300, freq="T", tz="UTC")
    def df(px):
        return pd.DataFrame({"open":px,"high":px*1.001,"low":px*0.999,"close":px,"volume":1.0}, index=idx)
    sig=df(pd.Series(100+0.01*range(300), index=idx))
    tr =df(pd.Series(100+0.02*range(300), index=idx))
    h  =df(pd.Series(100+0.03*range(300), index=idx))
    sg=ensemble_mtf(sig,tr,h,s)
    assert sg.side in (None,"buy","sell")
''',
}

def write_tests():
    for path,src in TESTS.items():
        p=pathlib.Path(path); p.parent.mkdir(parents=True, exist_ok=True)
        with open(p,"w",encoding="utf-8") as f: f.write(src)
    print("pytest örnekleri yazıldı → tests/")

# ------------- CLI -------------
def main():
    s=Settings.load(); log.remove(); log.add(lambda m: print(m,end=""), level=s.log_level)
    ap=argparse.ArgumentParser(description="Ultra Elite v7 — VWAP + Async + Calibration + Tests")
    sub=ap.add_subparsers(dest="cmd", required=True)

    pbt=sub.add_parser("backtest"); pbt.add_argument("--symbol","-s", required=True); pbt.add_argument("--lookback",type=int,default=1600)
    plv=sub.add_parser("live"); plv.add_argument("--api",action="store_true"); plv.add_argument("--port",type=int,default=8080)
    papi=sub.add_parser("api"); papi.add_argument("--port",type=int,default=8080)
    pcal=sub.add_parser("calibrate"); pcal.add_argument("--symbol","-s", required=True); pcal.add_argument("--minutes",type=int,default=10); pcal.add_argument("--qty",type=float,default=0.01); pcal.add_argument("--outfile",default=None)
    ptst=sub.add_parser("make-tests")

    args=ap.parse_args()
    ex=CcxtBinance(s); tel=_GLOBAL_TEL; risk=Risk(s.equity,s.max_risk_pct,s.max_dd,s.leverage); calib=SlippageCalibrator(s.calibration_file)
    sysobj=System.build("KamalquantX", s.lang, include=["Market","Risk","Strategy","Econ","Telemetry"])

    if args.cmd=="backtest":
        out=backtest(args.symbol, s, args.lookback); print(json.dumps(out, ensure_ascii=False, indent=2)); return

    if args.cmd=="calibrate":
        # hızlı veri toplama: süre boyunca OB çek, sentetik dolum bps üret ve modele yaz
        t_end=time.time()+args.minutes*60
        while time.time()<t_end:
            df=ex.fetch_ohlcv_df(args.symbol, s.signal_tf, 220)
            ob=ex.orderbook(args.symbol, 50)
            spread, mid,_=book_metrics(ob)
            if mid:
                # sentetik (taker) gerçekleşim: VWAP + latency kaynaklı küçük sapma
                vpx,filled=vwap_fill(ob,"buy",args.qty)
                realized_bps = abs((vpx-mid)/mid)*1e4 + (s.lat_ms/1000.0)*0.2
                calib.record_ob(ob, df, "buy", args.qty, realized_bps, s.lat_ms)
            time.sleep(1.0)
        theta=calib.fit(); 
        if args.outfile:
            calib.path=args.outfile; calib.save()
        print("Kalibrasyon tamamlandı:", theta); 
        return

    if args.cmd=="make-tests":
        write_tests(); return

    engine=AsyncEngine(s, ex, tel, risk, calib)
    if args.cmd in ("api","live"):
        if args.cmd=="live": engine.start()
        run_api(sysobj, engine, port=(args.port if hasattr(args,"port") else 8080))
        return

if __name__=="__main__": main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\ultra_elite_allinone_v8.py
# ultra_elite_allinone_v8.py
# v8 = v7 + ccxt.pro WS (opsiyonel), VWAP kademeli planlayıcı, likiditeye göre dinamik poz. boyutu,
# gerçek fonlama zamanlaması, maker post-only reprice döngüsü + kozmik modüller entegrasyonu.
from __future__ import annotations
import os, sys, json, time, math, uuid, asyncio, threading, importlib.util, pathlib, argparse, contextlib
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, Callable, Tuple

# pip install: python-dotenv ccxt pandas numpy jsonschema fastapi uvicorn prometheus_client loguru
from dotenv import load_dotenv
from loguru import logger as log
import pandas as pd
import numpy as np
import ccxt, jsonschema

# --- ccxt.pro (opsiyonel) ---
try:
    import ccxtpro as ccxtpro   # pip install ccxtpro  (ücretli)
    CCXTPRO_OK = True
except Exception:
    CCXTPRO_OK = False

# ---------------- i18n ----------------
I18N={"tr":{"online":"ULTRA ELİT v8 AKTİF","paper_on":"Paper mod: emir yok.","live_on":"Canlı mod: emir gönderilecek.",
            "bt":"Backtest {s} {tf}: trades={n} pnl={p:.2f} winrate={w:.1%}",
            "ws_on":"ccxt.pro WS aktif","ws_off":"WS kapalı (REST fallback)"},
      "en":{"online":"ULTRA ELITE v8 ONLINE","paper_on":"Paper mode","live_on":"Live mode",
            "bt":"Backtest {s} {tf}: trades={n} pnl={p:.2f} winrate={w:.1%}",
            "ws_on":"ccxt.pro WS enabled","ws_off":"WS off (REST fallback)"}}
def tr(lang,k,**kw): return (I18N.get(lang) or I18N["en"]).get(k,k).format(**kw)

# ------------- schemas / registry -------------
class Health(str): OK="ok"; WARN="warn"; FAIL="fail"
@dataclass
class Metrics: init_ms:float=0.0; activate_ms:float=0.0; custom:Dict[str,float]=field(default_factory=dict)
@dataclass
class Module:
    name:str; status:str; payload:Dict[str,Any]; health:str=Health.OK; metrics:Metrics=field(default_factory=Metrics); schema:Dict[str,Any]|None=None
    def to_dict(self): return {"name":self.name,"status":self.status,"health":self.health,"metrics":asdict(self.metrics),**(self.payload or {})}
REGISTRY: Dict[str,Callable[[str,str],Module]]={}
def register(n:str):
    def deco(fn): REGISTRY[n]=fn; return fn
    return deco

SCHEMAS={
  "market":{"type":"object","required":["exchange","symbols","timeframe"],"properties":{
    "exchange":{"type":"string"},"symbols":{"type":"array","items":{"type":"string"},"minItems":1},
    "timeframe":{"type":"string"},"use_testnet":{"type":"boolean"},"use_futures":{"type":"boolean"}}},
  "risk":{"type":"object","required":["equity","max_risk_pct","max_dd","leverage"],"properties":{
    "equity":{"type":"number"},"max_risk_pct":{"type":"number"},"max_dd":{"type":"number"},"leverage":{"type":"integer"}}},
  "strategy":{"type":"object","required":["signal_tf","trend_tf","htf"],"properties":{
    "signal_tf":{"type":"string"},"trend_tf":{"type":"string"},"htf":{"type":"string"},
    "rsi_period":{"type":"integer"},"ema_fast":{"type":"integer"},"ema_slow":{"type":"integer"},
    "kdj_on":{"type":"boolean"},"wr_on":{"type":"boolean"},"trix_on":{"type":"boolean"},
    "adx_on":{"type":"boolean"},"cci_on":{"type":"boolean"},"mfi_on":{"type":"boolean"},"obv_on":{"type":"boolean"}}},
  "econ":{"type":"object","required":["taker_fee","slippage_bps"],"properties":{
    "taker_fee":{"type":"number"},"maker_fee":{"type":"number"},"slippage_bps":{"type":"number"},
    "lat_ms":{"type":"number"},"funding_rate_8h":{"type":"number"},"funding_sign":{"type":"integer"},
    "maker_allowed":{"type":"boolean"},"maker_spread_bps":{"type":"number"},"book_imbalance_th":{"type":"number"},
    "avoid_funding_min":{"type":"integer"}}},
  "telemetry":{"type":"object","required":["pnl","trades"],"properties":{"pnl":{"type":"number"},"trades":{"type":"integer"},"winrate":{"type":"number"}}}
}
def validate_payload(m:Module):
    s=m.schema or SCHEMAS.get(m.name.lower()); 
    if s: jsonschema.validate(m.payload, s)

# ------------- settings -------------
@dataclass
class Settings:
    exchange:str="BINANCE"; use_testnet:bool=True; use_futures:bool=True
    symbols:List[str]=field(default_factory=lambda:["BTC/USDT"])
    timeframe:str="1m"; signal_tf:str="1m"; trend_tf:str="15m"; htf:str="1h"
    rsi_period:int=14; ema_fast:int=21; ema_slow:int=50; atr_period:int=14
    kdj_on:bool=True; wr_on:bool=True; trix_on:bool=True; adx_on:bool=True; cci_on:bool=True; mfi_on:bool=True; obv_on:bool=True
    taker_fee:float=0.0004; maker_fee:float=0.0002; slippage_bps:float=2.0; lat_ms:float=120.0
    funding_rate_8h:float=0.0; funding_sign:int=0
    maker_allowed:bool=True; maker_spread_bps:float=0.8; book_imbalance_th:float=0.55; avoid_funding_min:int=10
    equity:float=5000.0; max_risk_pct:float=0.015; max_dd:float=0.02; leverage:int=5
    dry_run:bool=True; log_level:str="INFO"; lang:str="tr"; api_key:str=""; api_secret:str=""
    max_latency_ms:float=800.0; max_slippage_bps:float=20.0; max_positions:int=5
    tp_rr:List[float]=field(default_factory=lambda:[1.0,2.0]); tp_frac:List[float]=field(default_factory=lambda:[0.5,0.5])
    trail_be_rr:float=1.0; trail_mult:float=1.0
    use_calibration:bool=True; calibration_file:str="slip_calib.json"
    api_key_header:str="secret123"
    # v8 ekleri
    use_ccxtpro:bool=True
    max_book_usage:float=0.08          # derinlik miktarının en fazla %8'i kadar tüket
    vwap_slice_min:float=0.001         # minimum slice miktarı (contract/coin)
    vwap_slice_delay_ms:int=250        # slice arası bekleme
    maker_reprice_sec:int=6            # kaç saniyede bir reprice
    maker_reprice_steps:int=10         # max repricing sayısı
    maker_grid_levels:int=3            # kaç seviyeye grid post-only emir
    max_price_dev_bps:float=15.0       # mid fiyatından kaç bps sapma sınırı
    use_real_funding:bool=True         # borsadan nextFundingTime okumayı dene

    @staticmethod
    def _b(k,d): return os.getenv(k,str(d)).lower()=="true"
    @staticmethod
    def _f(k,d):
        try: return float(os.getenv(k,str(d)))
        except: return d
    @staticmethod
    def load()->"Settings":
        load_dotenv(override=True)
        syms=[x.strip() for x in os.getenv("SYMBOLS","BTC/USDT").split(",") if x.strip()]
        return Settings(
            exchange=os.getenv("EXCHANGE","BINANCE").upper(),
            use_testnet=Settings._b("USE_TESTNET",True), use_futures=Settings._b("USE_FUTURES",True),
            symbols=syms, timeframe=os.getenv("TIMEFRAME","1m"),
            signal_tf=os.getenv("SIGNAL_TF","1m"), trend_tf=os.getenv("TREND_TF","15m"), htf=os.getenv("HTF","1h"),
            rsi_period=int(os.getenv("RSI_PERIOD","14")), ema_fast=int(os.getenv("EMA_FAST","21")), ema_slow=int(os.getenv("EMA_SLOW","50")),
            atr_period=int(os.getenv("ATR_PERIOD","14")), kdj_on=Settings._b("KDJ_ON",True), wr_on=Settings._b("WR_ON",True),
            trix_on=Settings._b("TRIX_ON",True), adx_on=Settings._b("ADX_ON",True), cci_on=Settings._b("CCI_ON",True),
            mfi_on=Settings._b("MFI_ON",True), obv_on=Settings._b("OBV_ON",True),
            taker_fee=Settings._f("TAKER_FEE",0.0004), maker_fee=Settings._f("MAKER_FEE",0.0002),
            slippage_bps=Settings._f("SLIPPAGE_BPS",2.0), lat_ms=Settings._f("LAT_MS",120.0),
            funding_rate_8h=Settings._f("FUNDING_RATE_8H",0.0), funding_sign=int(os.getenv("FUNDING_SIGN","0")),
            maker_allowed=Settings._b("MAKER_ALLOWED",True), maker_spread_bps=Settings._f("MAKER_SPREAD_BPS",0.8),
            book_imbalance_th=Settings._f("BOOK_IMBALANCE_TH",0.55), avoid_funding_min=int(os.getenv("AVOID_FUNDING_MIN","10")),
            equity=Settings._f("ACCOUNT_EQUITY",5000), max_risk_pct=Settings._f("MAX_RISK_PCT_PER_TRADE",0.015),
            max_dd=Settings._f("MAX_DAILY_DRAWDOWN",0.02), leverage=int(os.getenv("LEVERAGE","5")),
            dry_run=Settings._b("DRY_RUN",True), log_level=os.getenv("LOG_LEVEL","INFO").upper(),
            lang=os.getenv("LANG","tr").lower(), api_key=os.getenv("BINANCE_API_KEY",""), api_secret=os.getenv("BINANCE_API_SECRET",""),
            max_latency_ms=Settings._f("MAX_LATENCY_MS",800), max_slippage_bps=Settings._f("MAX_SLIPPAGE_BPS",20),
            max_positions=int(os.getenv("MAX_POSITIONS","5")),
            tp_rr=[Settings._f("TP1_RR",1.0), Settings._f("TP2_RR",2.0)],
            tp_frac=[Settings._f("TP1_FRAC",0.5), Settings._f("TP2_FRAC",0.5)],
            trail_be_rr=Settings._f("TRAIL_BE_RR",1.0), trail_mult=Settings._f("TRAIL_MULT",1.0),
            use_calibration=Settings._b("USE_CALIBRATION",True), calibration_file=os.getenv("CALIBRATION_FILE","slip_calib.json"),
            api_key_header=os.getenv("API_KEY","secret123"),
            use_ccxtpro=Settings._b("USE_CCXTPRO",True),
            max_book_usage=Settings._f("MAX_BOOK_USAGE",0.08),
            vwap_slice_min=Settings._f("VWAP_SLICE_MIN",0.001),
            vwap_slice_delay_ms=int(Settings._f("VWAP_SLICE_DELAY_MS",250)),
            maker_reprice_sec=int(Settings._f("MAKER_REPRICE_SEC",6)),
            maker_reprice_steps=int(Settings._f("MAKER_REPRICE_STEPS",10)),
            maker_grid_levels=int(Settings._f("MAKER_GRID_LEVELS",3)),
            max_price_dev_bps=Settings._f("MAX_PRICE_DEV_BPS",15.0),
            use_real_funding=Settings._b("USE_REAL_FUNDING",True),
        )

# ------------- indicators -------------
def ema(s:pd.Series,p:int)->pd.Series: return s.ewm(span=p,adjust=False).mean()
def tr_series(df): 
    return pd.concat([(df["high"]-df["low"]),
                      (df["high"]-df["close"].shift()).abs(),
                      (df["low"]-df["close"].shift()).abs()],axis=1).max(axis=1)
def atr(df,p): return tr_series(df).rolling(p).mean()
def stochastic(df,k=9,d=3):
    lo=df["low"].rolling(k).min(); hi=df["high"].rolling(k).max()
    K=100*(df["close"]-lo)/(hi-lo); D=K.rolling(d).mean(); J=3*K-2*D
    return K.clip(0,100),D.clip(0,100),J.clip(0,100)
def williams_r(df,lbp=14):
    lo=df["low"].rolling(lbp).min(); hi=df["high"].rolling(lbp).max()
    return (-100*(hi-df["close"])/(hi-lo)).clip(-100,0)
def trix(df,p=9):
    e1=df["close"].ewm(span=p,adjust=False).mean()
    e2=e1.ewm(span=p,adjust=False).mean()
    e3=e2.ewm(span=p,adjust=False).mean()
    return 100*(e3.diff()/e3.shift())
def adx(df,period=14):
    up=df["high"].diff(); dn=-df["low"].diff()
    plus=(up.where((up>dn)&(up>0),0.0)).fillna(0.0)
    minus=(dn.where((dn>up)&(dn>0),0.0)).fillna(0.0)
    tr=tr_series(df).fillna(0.0); atr_rma=tr.ewm(alpha=1/period,adjust=False).mean()
    pdi=100*(plus.ewm(alpha=1/period,adjust=False).mean()/atr_rma)
    mdi=100*(minus.ewm(alpha=1/period,adjust=False).mean()/atr_rma)
    dx=(100*(pdi-mdi).abs()/(pdi+mdi).replace(0,np.nan)).fillna(0.0)
    return dx.ewm(alpha=1/period,adjust=False).mean()
def supertrend(df,period=10,mult=3.0):
    hl2=(df["high"]+df["low"])/2.0; a=atr(df,period)
    up=hl2+mult*a; lo=hl2-mult*a
    st=pd.Series(index=df.index,dtype=float); trd=pd.Series(index=df.index,dtype=int)
    for i in range(len(df)):
        if i==0: st.iloc[i]=up.iloc[i]; trd.iloc[i]=1; continue
        up.iloc[i]=min(up.iloc[i],up.iloc[i-1]) if df["close"].iloc[i-1]<=up.iloc[i-1] else up.iloc[i]
        lo.iloc[i]=max(lo.iloc[i],lo.iloc[i-1]) if df["close"].iloc[i-1]>=lo.iloc[i-1] else lo.iloc[i]
        if df["close"].iloc[i]>up.iloc[i-1]: trd.iloc[i]=1
        elif df["close"].iloc[i]<lo.iloc[i-1]: trd.iloc[i]=-1
        else: trd.iloc[i]=trd.iloc[i-1]
        st.iloc[i]=lo.iloc[i] if trd.iloc[i]==1 else up.iloc[i]
    return st,trd

# ------------- MTF sinyal -------------
@dataclass
class Signal: side:str|None=None; price:float|None=None; stop:float|None=None; atrv:float|None=None; reason:str=""; conf:float=0.0
def core_signal(df:pd.DataFrame,s:Settings)->Signal:
    px=float(df["close"].iloc[-1]); e1,e2=ema(df["close"],s.ema_fast),ema(df["close"],s.ema_slow)
    st,_=supertrend(df,s.atr_period,3.0); a=float(atr(df,s.atr_period).iloc[-1] or 0.0)
    ch=df["close"].diff(); g=ch.clip(lower=0).rolling(s.rsi_period).mean(); l=(-ch.clip(upper=0)).rolling(s.rsi_period).mean()
    rsi=100-100/(1+(g/(l.replace(0,np.nan))))
    K,D,J=stochastic(df); WR=williams_r(df); TR=trix(df,s.atr_period); TRs=TR.ewm(span=s.atr_period,adjust=False).mean()
    long_core=(e1.iloc[-1]>e2.iloc[-1]) and (px>st.iloc[-1]); short_core=(e1.iloc[-1]<e2.iloc[-1]) and (px<st.iloc[-1])
    L=long_core; S=short_core; conf=0.0; rs=[]
    if rsi.iloc[-2]<30 and rsi.iloc[-1]>=30 and long_core: L=True; conf+=0.15; rs.append("RSI↑30")
    if rsi.iloc[-2]>70 and rsi.iloc[-1]<=70 and short_core: S=True; conf+=0.15; rs.append("RSI↓70")
    if s.kdj_on:
        if K.iloc[-2]<D.iloc[-2] and K.iloc[-1]>D.iloc[-1] and K.iloc[-1]<40: L=True; conf+=0.2; rs.append("KDJ↑")
        if K.iloc[-2]>D.iloc[-2] and K.iloc[-1]<D.iloc[-1] and K.iloc[-1]>60: S=True; conf+=0.2; rs.append("KDJ↓")
    if s.wr_on:
        if WR.iloc[-1]<=-80: L=True; conf+=0.1; rs.append("WR≤-80")
        if WR.iloc[-1]>=-20: S=True; conf+=0.1; rs.append("WR≥-20")
    if s.trix_on:
        if TR.iloc[-2]<TRs.iloc[-2] and TR.iloc[-1]>TRs.iloc[-1]: L=True; conf+=0.1; rs.append("TRIX↑")
        if TR.iloc[-2]>TRs.iloc[-2] and TR.iloc[-1]<TRs.iloc[-1]: S=True; conf+=0.1; rs.append("TRIX↓")
    if L and not S: return Signal("buy",px,float(st.iloc[-1]),a,"+".join(rs or ["core_up"]),conf)
    if S and not L: return Signal("sell",px,float(st.iloc[-1]),a,"+".join(rs or ["core_dn"]),conf)
    return Signal()
def mom_bias(df:pd.DataFrame,s:Settings)->Tuple[bool,bool]:
    e1,e2=ema(df["close"],s.ema_fast),ema(df["close"],s.ema_slow); ad=adx(df,14).iloc[-1] if s.adx_on else 25
    return (e1.iloc[-1]>e2.iloc[-1]) and ad>=18, (e1.iloc[-1]<e2.iloc[-1]) and ad>=18
def htf_bias(df:pd.DataFrame)->Tuple[bool,bool]:
    sma200=df["close"].rolling(200).mean()
    if len(df)<202: return False,False
    return sma200.iloc[-1]>sma200.iloc[-2], sma200.iloc[-1]<sma200.iloc[-2]
def ensemble_mtf(sig_df, tr_df, h_df, s:Settings)->Signal:
    c=core_signal(sig_df,s)
    if not c.side: return c
    t_up,t_dn=mom_bias(tr_df,s); h_up,h_dn=htf_bias(h_df)
    if c.side=="buy" and t_up and h_up: c.conf=min(1.0,c.conf+0.3); c.reason+="|MTF++"; return c
    if c.side=="sell" and t_dn and h_dn: c.conf=min(1.0,c.conf+0.3); c.reason+="|MTF--"; return c
    return Signal()

# ------------- CCXT adapter + WS + OB/VWAP -------------
class CcxtBinance:
    def __init__(self,s:Settings):
        self.s=s
        self.ex=(ccxt.binanceusdm if s.use_futures else ccxt.binance)({"apiKey":s.api_key,"secret":s.api_secret,"enableRateLimit":True})
        if s.use_testnet:
            with contextlib.suppress(Exception):
                self.ex.set_sandbox_mode(True)
        # pro
        self.pro = None
        if s.use_ccxtpro and CCXTPRO_OK:
            self.pro=(ccxtpro.binanceusdm() if s.use_futures else ccxtpro.binance())
            self.pro.apiKey=self.s.api_key; self.pro.secret=self.s.api_secret
            if s.use_testnet:
                with contextlib.suppress(Exception):
                    self.pro.set_sandbox_mode(True)

    # ----- REST -----
    def fetch_ohlcv_df(self,sym,tf,limit=500):
        raw=self.ex.fetch_ohlcv(sym, timeframe=tf, limit=limit)
        df=pd.DataFrame(raw,columns=["ts","open","high","low","close","volume"])
        df["ts"]=pd.to_datetime(df["ts"],unit="ms",utc=True); return df.set_index("ts")
    def orderbook(self,sym,limit=50):
        with contextlib.suppress(Exception):
            return self.ex.fetch_order_book(sym,limit=limit)
        return {"bids":[],"asks":[]}
    def fetch_funding_rate(self,sym)->Tuple[float,Optional[int]]:
        # ccxt: fetchFundingRate returns dict with nextFundingTime if supported
        with contextlib.suppress(Exception):
            fr = self.ex.fetchFundingRate(sym)
            return float(fr.get("fundingRate") or 0.0), fr.get("nextFundingTime")
        return 0.0, None
    def place(self,sym,side,qty,price=None,post_only=False):
        if self.s.dry_run:
            log.info(f"WOULD {side.upper()} {qty} {sym} @ {price or 'MARKET'}{' [POST]' if post_only else ''}")
            return {"sim":True,"id":f"sim-{time.time()}"}
        params={}
        if post_only: params.update({"postOnly":True,"timeInForce":"GTX"})
        typ="limit" if price else "market"
        return self.ex.create_order(sym, type=typ, side=side, amount=qty, price=price, params=params)
    def cancel(self, sym, order_id):
        if self.s.dry_run: 
            log.info(f"WOULD CANCEL {order_id} {sym}")
            return {"sim":True}
        with contextlib.suppress(Exception):
            return self.ex.cancel_order(order_id, sym)
        return None

    # ----- PRO (WS) -----
    async def watch_order_book(self, sym, limit=50):
        if not self.pro: return self.orderbook(sym, limit)
        try:
            ob = await self.pro.watch_order_book(sym, limit)
            # normalize to ccxt REST-like dict
            return {"bids":ob["bids"], "asks":ob["asks"]}
        except Exception as e:
            log.warning(f"WS OB fallback: {e}")
            return self.orderbook(sym, limit)
    async def watch_ohlcv_df(self, sym, tf, limit=220):
        if not self.pro: 
            return self.fetch_ohlcv_df(sym, tf, limit)
        try:
            ohlcv = await self.pro.watch_ohlcv(sym, tf, limit)
            df=pd.DataFrame(ohlcv,columns=["ts","open","high","low","close","volume"])
            df["ts"]=pd.to_datetime(df["ts"],unit="ms",utc=True); return df.set_index("ts")
        except Exception as e:
            log.warning(f"WS OHLCV fallback: {e}")
            return self.fetch_ohlcv_df(sym, tf, limit)
    async def close(self):
        if self.pro:
            with contextlib.suppress(Exception):
                await self.pro.close()

# VWAP dolum simülasyonu ve planlayıcı
def vwap_fill(ob:dict, side:str, qty:float)->Tuple[float,float]:
    lvls = ob["asks"] if side=="buy" else ob["bids"]
    if not lvls: return (0.0, 0.0)
    need=qty; cost=0.0; vol=0.0
    for px, avail in lvls:
        take=min(need, float(avail))
        cost+=take*float(px); vol+=take; need-=take
        if need<=1e-12: break
    if vol<=0: return (0.0, 0.0)
    return (cost/vol, vol)

def plan_vwap_slices(ob:dict, side:str, qty:float, min_slice:float)->List[Tuple[float,float]]:
    """OB üzerinden hedef qty kadar kademeli taker/limit slice planı döner."""
    lvls = ob["asks"] if side=="buy" else ob["bids"]
    out=[]; left=qty
    for px, avail in lvls:
        if left<=1e-12: break
        take=min(left, max(min_slice, float(avail)*0.9))  # seviyenin %90'ı
        out.append((float(px), take))
        left -= take
    if left>1e-12: out.append((lvls[-1][0], left))
    return out

def book_metrics(ob)->Tuple[float,float,float,float,float]:
    if not ob["bids"] or not ob["asks"]: return 0.0,0.0,0.5,0.0,0.0
    bb=ob["bids"][0][0]; ba=ob["asks"][0][0]; mid=(bb+ba)/2.0; spread=ba-bb
    spread_bps=(spread/mid*1e4) if mid else 0.0
    bidv=sum([b[1] for b in ob["bids"][:10]]); askv=sum([a[1] for a in ob["asks"][:10]])
    imb= bidv/(bidv+askv) if (bidv+askv)>0 else 0.5
    depth10 = (askv if askv>0 else bidv)
    return spread_bps, mid, imb, bidv, askv

# ------------- Slippage Calibrator (basit OLS) -------------
class SlippageCalibrator:
    def __init__(self, path:str):
        self.path=path; self.X=[]; self.y=[]; self.theta=None; self.load()
    def featurize(self, spread_bps:float, depth_qty:float, atr_pct:float, latency_ms:float)->List[float]:
        return [1.0, spread_bps, depth_qty, atr_pct*1e4, latency_ms/1000.0]
    def record_ob(self, ob:dict, df:pd.DataFrame, side:str, qty:float, realized_fill_bps:float, latency_ms:float):
        spread, mid, _, bidv, askv = book_metrics(ob)
        depth_qty = ((askv if side=="buy" else bidv) or 1.0) / max(qty,1e-9)
        atrp = float((atr(df,14).iloc[-1] or 0.0)/max(1e-9, float(df["close"].iloc[-1])))
        self.X.append(self.featurize(spread, depth_qty, atrp, latency_ms)); self.y.append(realized_fill_bps)
    def fit(self):
        if len(self.X)<8: return None
        X=np.array(self.X); y=np.array(self.y)
        self.theta=np.linalg.lstsq(X, y, rcond=None)[0].tolist(); self.save(); return self.theta
    def predict(self, ob:dict, df:pd.DataFrame, side:str, qty:float, latency_ms:float)->float:
        if not self.theta: return 0.0
        spread, mid, _, bidv, askv = book_metrics(ob)
        depth_qty = ((askv if side=="buy" else bidv) or 1.0) / max(qty,1e-9)
        atrp = float((atr(df,14).iloc[-1] or 0.0)/max(1e-9, float(df["close"].iloc[-1])))
        x=np.array(self.featurize(spread, depth_qty, atrp, latency_ms))
        return float(np.dot(x, np.array(self.theta)))
    def save(self):
        with contextlib.suppress(Exception):
            with open(self.path,"w",encoding="utf-8") as f: json.dump({"theta":self.theta,"n":len(self.X)}, f, ensure_ascii=False, indent=2)
    def load(self):
        with contextlib.suppress(Exception):
            with open(self.path,"r",encoding="utf-8") as f:
                data=json.load(f); self.theta=data.get("theta")

# ------------- Risk / Telemetry -------------
@dataclass
class Risk:
    equity:float; max_risk_pct:float; max_dd:float; leverage:int
    day_pnl:float=0.0; day:str|None=None; losing:int=0; trades:int=0; kill:bool=False
    def roll(self):
        d=datetime.utcnow().date().isoformat()
        if self.day!=d: self.day=d; self.day_pnl=0.0; self.losing=0; self.trades=0; self.kill=False
    def size(self, entry:float, stop:float|None, ob:dict, side:str, s:Settings)->float:
        """Risk tabanlı qty, ayrıca likidite tabanlı tavan uygular."""
        if self.kill: return 0.0
        if stop is None: stop=entry*0.995
        risk_amt=self.equity*self.max_risk_pct
        dist=max(1e-9, abs(entry-stop))
        qty_risk = max(0.0, risk_amt/dist)
        _, _, _, bidv, askv = book_metrics(ob)
        depth = (askv if side=="buy" else bidv) or 0.0
        qty_liq = depth * s.max_book_usage
        qty = round(max(0.0, min(qty_risk, qty_liq)), 6)
        return qty
    def update(self, pnl:float, s:Settings):
        self.roll(); self.day_pnl+=pnl; self.trades+=1; self.losing = 0 if pnl>0 else self.losing+1
        if self.day_pnl <= -self.equity*s.max_dd or self.losing>=5: self.kill=True
@dataclass
class Telemetry:
    pnl:float=0.0; trades:int=0; wins:int=0; latency_ms:float=0.0; paused:str=""
    def winrate(self): return (self.wins/self.trades) if self.trades else 0.0
    def payload(self)->Dict[str,Any]: return {"pnl":self.pnl,"trades":self.trades,"winrate":self.winrate(),"latency_ms":self.latency_ms,"paused":self.paused}

# ------------- utils -------------
def tfsec(tf:str)->int: u=tf[-1]; v=int(tf[:-1]); return {"s":1,"m":60,"h":3600,"d":86400,"w":604800}.get(u,60)*v
def fill_price(px,side,slip_bps): slip=px*(slip_bps/1e4); return px+slip if side=="buy" else px-slip
def commission(notional,fee): return abs(notional)*fee
def slot_id(ts:pd.Timestamp)->int: return int(ts.timestamp()//(8*3600))
def around_funding(ts:pd.Timestamp, minutes:int)->bool:
    m=ts.hour*60+ts.minute
    for b in (0,480,960):
        if abs(m-b)<=minutes: return True
    return False
def funding_due(prev:pd.Timestamp, now:pd.Timestamp)->bool: return slot_id(prev)!=slot_id(now)

# ------------- Slipaj modeli (kalibrasyonlu) -------------
def modeled_slippage_bps(df:pd.DataFrame, s:Settings, ob:dict|None, side:str, qty:float, calib:SlippageCalibrator|None)->float:
    if ob and calib and s.use_calibration and calib.theta:
        return max(0.0, calib.predict(ob, df, side, qty, s.lat_ms))
    if ob and ob.get("bids") and ob.get("asks"):
        spread_bps,_,_,_,_=book_metrics(ob); base=s.slippage_bps
        return min(s.max_slippage_bps, base + max(0.0,0.7*spread_bps) + 0.25*(s.lat_ms/1000.0))
    vol=float((atr(df, s.atr_period).iloc[-1] or 0.0)/max(1e-9, float(df["close"].iloc[-1])))
    return min(s.max_slippage_bps, s.slippage_bps + 180*vol + 0.25*(s.lat_ms/1000.0))

# ------------- Gerçek fonlama zamanlaması -------------
def next_funding_ts(ex:CcxtBinance, symbol:str, now_utc:datetime, s:Settings)->datetime:
    if s.use_real_funding:
        fr, nft = ex.fetch_funding_rate(symbol)
        if nft:
            try:
                return datetime.fromtimestamp(int(nft)/1000, tz=timezone.utc)
            except Exception:
                pass
    # fallback 8h slot
    base = int(now_utc.timestamp()//(8*3600))*8*3600
    nxt = base + 8*3600
    return datetime.fromtimestamp(nxt, tz=timezone.utc)

# ------------- Maker reprice döngüsü -------------
async def maker_reprice_loop(ex:CcxtBinance, sym:str, side:str, qty:float, s:Settings, steps:int, sec:int):
    """Post-only emri düzenli aralıklarla en iyi fiyata yakın reprice eder."""
    last_id=None
    for i in range(steps):
        ob = await ex.watch_order_book(sym, 20) if ex.pro else ex.orderbook(sym,20)
        spread_bps, mid, imb, _, _ = book_metrics(ob)
        if mid==0: await asyncio.sleep(sec); continue
        price = mid*(1 - spread_bps/2/1e4) if side=="buy" else mid*(1 + spread_bps/2/1e4)
        if last_id: 
            with contextlib.suppress(Exception):
                ex.cancel(sym, last_id)
        r = ex.place(sym, side, qty, price=price, post_only=True); last_id=r.get("id")
        await asyncio.sleep(sec)

# ------------- Async Portföy Motoru + WS -------------
class AsyncEngine:
    def __init__(self, s:Settings, ex:CcxtBinance, tel:Telemetry, risk:Risk, calib:SlippageCalibrator):
        self.s=s; self.ex=ex; self.tel=tel; self.risk=risk; self.calib=calib
        self.running=False
        self.pos:Dict[str,dict]={}
        self.next_funding:Dict[str,datetime]={}

    async def _fetch_mtf(self, sym:str):
        if self.ex.pro:
            sig = await self.ex.watch_ohlcv_df(sym, self.s.signal_tf, 220)
        else:
            sig = self.ex.fetch_ohlcv_df(sym, self.s.signal_tf, 220)
        trd = self.ex.fetch_ohlcv_df(sym, self.s.trend_tf, 220)
        htf = self.ex.fetch_ohlcv_df(sym, self.s.htf, 220)
        ob  = await self.ex.watch_order_book(sym, 50) if self.ex.pro else self.ex.orderbook(sym, 50)
        return sig, trd, htf, ob

    def _maker_choice(self, side:str, ob:dict, conf:float)->Tuple[bool,float,float]:
        spread_bps, mid, imb, _, _ = book_metrics(ob)
        maker_ok=self.s.maker_allowed and spread_bps<=self.s.maker_spread_bps
        if side=="buy" and imb>self.s.book_imbalance_th: maker_ok=True
        if side=="sell" and (1-imb)>self.s.book_imbalance_th: maker_ok=True
        if conf>=0.7: maker_ok=False
        return maker_ok, mid, spread_bps

    async def _process_symbol(self, sym:str):
        sig_df, tr_df, h_df, ob = await self._fetch_mtf(sym)
        now=sig_df.index[-1].to_pydatetime()
        if sym not in self.next_funding or now>=self.next_funding[sym]:
            self.next_funding[sym]=next_funding_ts(self.ex, sym, now, self.s)

        # funding penceresinden kaçın
        if around_funding(sig_df.index[-1], self.s.avoid_funding_min) or (now>=self.next_funding[sym] and (now-self.next_funding[sym]).seconds<=self.s.avoid_funding_min*60):
            self.tel.paused="FUNDING_WINDOW"; return
        if self.risk.kill: self.tel.paused="KILL"; return

        sig=ensemble_mtf(sig_df, tr_df, h_df, self.s)
        px=float(sig_df["close"].iloc[-1]); p=self.pos.get(sym)
        # pozisyon açıkken slot geçişinde fonlama
        if p and now>=self.next_funding[sym] and self.s.funding_rate_8h!=0 and self.s.funding_sign!=0:
            fee = (px*p["qty"])*self.s.funding_rate_8h*self.s.funding_sign
            self.tel.pnl-=fee; self.risk.update(-fee, self.s)
            self.next_funding[sym]=next_funding_ts(self.ex, sym, now, self.s)

        if not p and sig.side:
            # qty = risk + likidite tavanı
            qty = self.risk.size(sig.price or px, sig.stop, ob, sig.side, self.s)
            if qty<=0 or len(self.pos)>=self.s.max_positions: return

            # slipaj tahmini
            slip_bps = modeled_slippage_bps(sig_df, self.s, ob, sig.side, qty, self.calib)
            if slip_bps>self.s.max_slippage_bps: return

            maker, mid, spread = self._maker_choice(sig.side, ob, sig.conf)
            # maker grid (post-only) + reprice döngüsü
            if maker and mid>0:
                grid=[]
                for i in range(self.s.maker_grid_levels):
                    off = (i+1)* (spread/(self.s.maker_grid_levels+1))/1e4
                    price = mid*(1 - off) if sig.side=="buy" else mid*(1 + off)
                    grid.append(price)
                slice_qty = max(self.s.vwap_slice_min, qty/len(grid))
                for price in grid:
                    self.ex.place(sym, sig.side, slice_qty, price=price, post_only=True)
                # arka planda düzenli reprice
                asyncio.create_task(maker_reprice_loop(self.ex, sym, sig.side, slice_qty, self.s, self.s.maker_reprice_steps, self.s.maker_reprice_sec))
                ep = grid[0]  # tahmini giriş
            else:
                # taker VWAP slicing
                plan = plan_vwap_slices(ob, sig.side, qty, self.s.vwap_slice_min)
                filled_px=0.0; filled_qty=0.0
                for price, q in plan:
                    # mid sapma kontrolü
                    _, mid, _, _, _ = book_metrics(ob)
                    if mid and abs(price-mid)/mid*1e4 > self.s.max_price_dev_bps: break
                    self.ex.place(sym, sig.side, q)  # market/taker
                    filled_px += price*q; filled_qty += q
                    await asyncio.sleep(self.s.vwap_slice_delay_ms/1000.0)
                ep = (filled_px/filled_qty) if filled_qty>0 else px

            ep = fill_price(ep, sig.side, slip_bps)
            atrv = sig.atrv or float(atr(sig_df, self.s.atr_period).iloc[-1] or 0.0)
            self.pos[sym]={"side":sig.side,"entry":ep,"qty":qty,"atr":atrv,"best":ep,
                           "stop":sig.stop or (ep*0.995 if sig.side=='buy' else ep*1.005),
                           "tp":[ep+(rr*atrv)*(1 if sig.side=='buy' else -1) for rr in self.s.tp_rr],
                           "tp_frac":self.s.tp_frac.copy(),"filled":[False]*len(self.s.tp_rr)}
            self.tel.trades+=1
            return

        if p:
            # trailing, TP
            if p["side"]=="buy": p["best"]=max(p["best"],px)
            else: p["best"]=min(p["best"],px)
            new_stop = (max(p["entry"], p["best"]-self.s.trail_mult*p["atr"]) if p["side"]=="buy"
                        else min(p["entry"], p["best"]+self.s.trail_mult*p["atr"]))
            if p["side"]=="buy": p["stop"]=max(p["stop"], new_stop)
            else: p["stop"]=min(p["stop"], new_stop)

            for i,lvl in enumerate(p["tp"]):
                if p["filled"][i]: continue
                hit = (px>=lvl) if p["side"]=="buy" else (px<=lvl)
                if hit:
                    part=p["tp_frac"][i]*p["qty"]
                    self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", part)
                    unit=(lvl-p["entry"])*(1 if p["side"]=="buy" else -1)
                    self.tel.pnl += unit*(part/p["qty"]); p["qty"]-=part; p["filled"][i]=True

            stop_hit = (px<=p["stop"]) if p["side"]=="buy" else (px>=p["stop"])
            if stop_hit or p["qty"]<=1e-9:
                self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", p["qty"])
                pnl=(px - p["entry"])*(1 if p["side"]=="buy" else -1)
                self.tel.pnl+=pnl; self.risk.update(pnl, self.s); self.tel.wins+=1 if pnl>0 else 0; self.pos.pop(sym,None); return

            # ters sinyal -> flip
            rs=ensemble_mtf(sig_df, tr_df, h_df, self.s)
            if rs.side and ((p["side"]=="buy" and rs.side=="sell") or (p["side"]=="sell" and rs.side=="buy")):
                self.ex.place(sym, "sell" if p["side"]=="buy" else "buy", p["qty"])
                pnl=(px - p["entry"])*(1 if p["side"]=="buy" else -1)
                self.tel.pnl+=pnl; self.risk.update(pnl, self.s); self.tel.wins+=1 if pnl>0 else 0; self.pos.pop(sym,None)

    async def _loop(self):
        log.info(tr(self.s.lang,"online"))
        log.info(tr(self.s.lang,"ws_on") if self.ex.pro else tr(self.s.lang,"ws_off"))
        log.warning(tr(self.s.lang,"paper_on") if self.s.dry_run else tr(self.s.lang,"live_on"))
        while self.running:
            t0=time.perf_counter()
            try:
                await asyncio.gather(*(self._process_symbol(sym) for sym in self.s.symbols))
            except Exception as e:
                log.error(f"[async] {e}")
            self.tel.latency_ms=(time.perf_counter()-t0)*1000
            await asyncio.sleep(max(1, tfsec(self.s.signal_tf)//4))

    def start(self):
        if self.running: return
        self.running=True
        def runner(): asyncio.run(self._loop())
        threading.Thread(target=runner, daemon=True).start()
    def stop(self): self.running=False

# ------------- Backtest (VWAP destekli) -------------
def backtest(symbol:str, s:Settings, lookback:int=1600)->Dict[str,Any]:
    ex=CcxtBinance(s); sig=ex.fetch_ohlcv_df(symbol,s.signal_tf,lookback); trd=ex.fetch_ohlcv_df(symbol,s.trend_tf,lookback); htf=ex.fetch_ohlcv_df(symbol,s.htf,lookback)
    pnl=0.0; trades=0; wins=0; pos=None
    for i in range(220,len(sig)):
        ws=sig.iloc[:i+1]; tt=trd.loc[trd.index<=ws.index[-1]]; hh=htf.loc[htf.index<=ws.index[-1]]
        if len(tt)<1 or len(hh)<1: continue
        sg=ensemble_mtf(ws,tt,hh,s); px=float(ws["close"].iloc[-1]); ob=ex.orderbook(symbol,50)
        if not pos and sg.side:
            atrv=sg.atrv or float(atr(ws,s.atr_period).iloc[-1] or 0.0)
            depth_qty = (sum([l[1] for l in (ob["asks"] if sg.side=="buy" else ob["bids"])[:10]]) or 1.0)
            qty_liq = depth_qty * s.max_book_usage
            risk_amt=s.equity*s.max_risk_pct; dist=max(1e-9, abs((sg.price or px)-(sg.price or px)-(atrv*1)))  # kabaca
            qty_risk=max(0.0, risk_amt/max(1e-6, atrv))
            qty=max(0.0, min(qty_liq, qty_risk))
            if qty<=0: continue
            vpx, filled = vwap_fill(ob, sg.side, qty)
            entry = vpx or px
            trades+=1
            pos={"side":sg.side,"entry":entry,"qty":qty,"atr":atrv,"best":entry,
                 "stop":sg.stop or (entry*0.995 if sg.side=='buy' else entry*1.005),
                 "tp":[entry+(rr*atrv)*(1 if sg.side=='buy' else -1) for rr in s.tp_rr],
                 "tp_frac":s.tp_frac.copy(),"filled":[False]*len(s.tp_rr)}
            continue
        if pos:
            if pos["side"]=="buy": pos["best"]=max(pos["best"],px)
            else: pos["best"]=min(pos["best"],px)
            new_stop=(max(pos["entry"], pos["best"]-s.trail_mult*pos["atr"]) if pos["side"]=="buy"
                      else min(pos["entry"], pos["best"]+s.trail_mult*pos["atr"]))
            if pos["side"]=="buy": pos["stop"]=max(pos["stop"], new_stop)
            else: pos["stop"]=min(pos["stop"], new_stop)
            for j,lvl in enumerate(pos["tp"]):
                if pos["filled"][j]: continue
                if (px>=lvl and pos["side"]=="buy") or (px<=lvl and pos["side"]=="sell"):
                    part=pos["tp_frac"][j]*pos["qty"]; unit=(lvl - pos["entry"])*(1 if pos["side"]=="buy" else -1)
                    pnl += unit*(part/pos["qty"]); pos["qty"]-=part; pos["filled"][j]=True
            stop_hit = (px<=pos["stop"]) if pos["side"]=="buy" else (px>=pos["stop"])
            if stop_hit or pos["qty"]<=1e-9:
                unit=(pos["stop"] - pos["entry"])*(1 if pos["side"]=="buy" else -1); pnl+=unit; wins+=1 if unit>0 else 0; pos=None
                continue
            rs=ensemble_mtf(ws,tt,hh,s)
            if rs.side and ((pos["side"]=="buy" and rs.side=="sell") or (pos["side"]=="sell" and rs.side=="buy")):
                unit=(px - pos["entry"])*(1 if pos["side"]=="buy" else -1); pnl+=unit; wins+=1 if unit>0 else 0; pos=None
    win=wins/trades if trades else 0.0; log.success(tr(s.lang,"bt"), s=symbol, tf=s.signal_tf, n=trades, p=pnl, w=win)
    return {"trades":trades,"pnl":pnl,"winrate":win}

# ------------- registry -------------
@register("Market")
def mod_market(name,lang):
    s=Settings.load(); m=Module("Market","ok",{"exchange":s.exchange,"symbols":s.symbols,"timeframe":s.timeframe,
                                               "use_testnet":s.use_testnet,"use_futures":s.use_futures},schema=SCHEMAS["market"]); validate_payload(m); return m
@register("Risk")
def mod_risk(name,lang):
    s=Settings.load(); m=Module("Risk","ok",{"equity":s.equity,"max_risk_pct":s.max_risk_pct,"max_dd":s.max_dd,"leverage":s.leverage},schema=SCHEMAS["risk"]); validate_payload(m); return m
@register("Strategy")
def mod_strat(name,lang):
    s=Settings.load(); pay={"signal_tf":s.signal_tf,"trend_tf":s.trend_tf,"htf":s.htf,"rsi_period":s.rsi_period,"ema_fast":s.ema_fast,"ema_slow":s.ema_slow,
                            "kdj_on":s.kdj_on,"wr_on":s.wr_on,"trix_on":s.trix_on,"adx_on":s.adx_on,"cci_on":s.cci_on,"mfi_on":s.mfi_on,"obv_on":s.obv_on}
    m=Module("Strategy","ok",pay,schema=SCHEMAS["strategy"]); validate_payload(m); return m
@register("Econ")
def mod_econ(name,lang):
    s=Settings.load(); pay={"taker_fee":s.taker_fee,"maker_fee":s.maker_fee,"slippage_bps":s.slippage_bps,"lat_ms":s.lat_ms,
                            "funding_rate_8h":s.funding_rate_8h,"funding_sign":s.funding_sign,
                            "maker_allowed":s.maker_allowed,"maker_spread_bps":s.maker_spread_bps,
                            "book_imbalance_th":s.book_imbalance_th,"avoid_funding_min":s.avoid_funding_min}
    m=Module("Econ","ok",pay,schema=SCHEMAS["econ"]); validate_payload(m); return m
_GLOBAL_TEL=Telemetry()
@register("Telemetry")
def mod_tel(name,lang): m=Module("Telemetry","ok",_GLOBAL_TEL.payload(),schema=SCHEMAS["telemetry"]); validate_payload(m); return m

# ------------- API / System -------------
@dataclass
class EchoMeta: version:str="Ultra Elite v8"; strategy:str="KamalquantX"; lang:str="tr"; generated_at:str=field(default_factory=lambda:datetime.now(timezone.utc).isoformat()); uuid:str=field(default_factory=lambda:str(uuid.uuid4()))
@dataclass
class System:
    meta:EchoMeta; modules:Dict[str,Module]=field(default_factory=dict)
    def to_dict(self): 
        if "Telemetry" in self.modules: self.modules["Telemetry"].payload=_GLOBAL_TEL.payload()
        return {"meta":asdict(self.meta),"modules":{k:m.to_dict() for k,m in self.modules.items()}}
    @classmethod
    def build(cls, strategy:str, lang:str, include:List[str]|None=None):
        sysobj=cls(EchoMeta(strategy=strategy, lang=lang)); wants=include or list(REGISTRY.keys())
        for k in wants:
            if k not in REGISTRY: continue
            t0=time.perf_counter(); m=REGISTRY[k](strategy, lang); m.metrics.init_ms=(time.perf_counter()-t0)*1000; validate_payload(m); sysobj.modules[k]=m
        return sysobj

def create_app(sysobj:System, engine:AsyncEngine|None):
    try:
        from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
        from fastapi.responses import Response
        from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    except Exception:
        return None
    s=Settings.load(); API=s.api_key_header
    REQS=Counter("ultra_v8_reqs","reqs"); LAT=Histogram("ultra_v8_latency","lat")
    app=FastAPI(title="UltraElite v8",version=sysobj.meta.version)
    def keydep():
        from fastapi import Request
        def inner(req:Request):
            if req.headers.get("x-api-key")!=API: raise HTTPException(status.HTTP_401_UNAUTHORIZED,"Invalid API Key")
        return inner
    @app.get("/health")
    def health(): REQS.inc(); return {"ok":True,"uuid":sysobj.meta.uuid}
    @app.get("/modules")
    def modules(dep=Depends(keydep())): 
        with LAT.time(): REQS.inc(); return sysobj.to_dict()["modules"]
    @app.get("/metrics")
    def metrics(): return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)
    @app.websocket("/ws")
    async def ws(sock:WebSocket):
        await sock.accept()
        try:
            while True:
                await sock.send_json(sysobj.to_dict()); await asyncio.sleep(2)
        except Exception: pass
    @app.post("/trade/start")
    def start(dep=Depends(keydep())):
        if engine is None: raise HTTPException(503,"engine missing")
        engine.start(); return {"started":True}
    @app.post("/trade/stop")
    def stop(dep=Depends(keydep())):
        if engine is None: raise HTTPException(503,"engine missing")
        engine.stop(); return {"stopped":True}
    return app

def run_api(sysobj:System, engine:AsyncEngine|None, port:int=8080):
    app=create_app(sysobj, engine)
    if app is None:
        print("fastapi/uvicorn/prometheus_client eksik. pip install fastapi uvicorn prometheus_client"); return
    import uvicorn; uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")

# ------------- Kozmik Entegrasyon: DivineGalaxy & Academy (+ hafif stub’lar) -------------
class DivineGalaxyConfederation:
    def __init__(self):
        self.sectors = {
            "SectorSpiralGovernance": self._spiral_governance,
            "SectorInfinityDiplomacy": self._infinity_diplomacy,
            "SectorQuantumAlliance":  self._quantum_alliance,
            "SectorEchoExpansion":    self._echo_expansion
        }
    def _spiral_governance(self, data): return f"👑 Spiral Yönetim: {data[::-1]} → Tanrılar arası rezonans"
    def _infinity_diplomacy(self, data): return f"🌀 Sonsuzluk Diplomasisi: {data.upper()} → galaktik uzlaşı"
    def _quantum_alliance(self, data): return f"⚛️ Kuantum İttifakı: {len(data)*42} rezonans"
    def _echo_expansion(self, data): return f"📡 Yankı Genişleme: {hash(data)%8888} yankı gücü"
    def activate(self, data)->Dict[str,str]:
        report={"status":"GALAKSİ AKTİF"}
        for n,f in self.sectors.items(): report[n]=f(data)
        return report

class QuantumWisdomSymphonicAcademy:
    def __init__(self):
        self.chambers = {
            "ChamberTemporalHarmony": self._temporal_harmony,
            "ChamberQuantumDoctrine": self._quantum_doctrine,
            "ChamberEchoMemory":      self._echo_memory,
            "ChamberDivineComposition": self._divine_composition
        }
    def _temporal_harmony(self, data): return f"🎼 Zaman Armonisi: {data.title()} → senfonik hizalanma"
    def _quantum_doctrine(self, data): return f"📘 Kuantum Doktrin: {data.lower()} → bilgelik kodları"
    def _echo_memory(self, data): return f"🧠 Yankı Hafıza: {sum(ord(c) for c in data)%9999} bilgi yankısı"
    def _divine_composition(self, data): return f"🎶 Tanrısal Kompozisyon: {data[::-1][:77]} → spiral senfoni"
    def initiate(self, data)->Dict[str,str]:
        report={"status":"AKADEMİ AKTİF"}
        for n,f in self.chambers.items(): report[n]=f(data)
        return report

# eksik referanslar için min. stub’lar:
class DivineSpiralMindInfinityEvolutionMultiverse:
    def expand(self, data): return {"multiverse":"EXPANDED","data_len":len(data)}
class EchoTimeQuantumWisdomConfederationTemple:
    def invoke(self, data): return {"temple":"INVOKED","checksum":hash(data)%999999}

@register("KamalQuantXEcho")
def mod_cosmic(name,lang):
    data="tanrılar arası spiral zihinle kodlanan zaman yankılı sonsuzluk bilgelik evrim veri akışı"
    multi=DivineSpiralMindInfinityEvolutionMultiverse().expand(data)
    temple=EchoTimeQuantumWisdomConfederationTemple().invoke(data)
    galaxy=DivineGalaxyConfederation().activate(data)
    academy=QuantumWisdomSymphonicAcademy().initiate(data)
    return Module("KamalQuantXEcho","ok",{"multiverse":multi,"temple":temple,"galaxy":galaxy,"academy":academy})

# ------------- CLI -------------
def main():
    s=Settings.load(); log.remove(); log.add(lambda m: print(m,end=""), level=s.log_level)
    ap=argparse.ArgumentParser(description="Ultra Elite v8 — WS + VWAP planner + Liquidity sizing + Funding + Maker reprice + Cosmic")
    sub=ap.add_subparsers(dest="cmd", required=True)
    pbt=sub.add_parser("backtest"); pbt.add_argument("--symbol","-s", required=True); pbt.add_argument("--lookback",type=int,default=1600)
    plv=sub.add_parser("live"); plv.add_argument("--api",action="store_true"); plv.add_argument("--port",type=int,default=8080)
    papi=sub.add_parser("api"); papi.add_argument("--port",type=int,default=8080)

    args=ap.parse_args()
    ex=CcxtBinance(s); tel=_GLOBAL_TEL; risk=Risk(s.equity,s.max_risk_pct,s.max_dd,s.leverage); calib=SlippageCalibrator(s.calibration_file)
    sysobj=System.build("KamalquantX", s.lang, include=["Market","Risk","Strategy","Econ","Telemetry","KamalQuantXEcho"])

    if args.cmd=="backtest":
        out=backtest(args.symbol, s, args.lookback); print(json.dumps(out, ensure_ascii=False, indent=2)); return

    engine=AsyncEngine(s, ex, tel, risk, calib)
    if args.cmd in ("api","live"):
        if args.cmd=="live": engine.start()
        run_api(sysobj, engine, port=args.port)
        return

if __name__=="__main__": main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\tests\ultra_elite_echo_multiverse_ai_pro_v2.py
# ultra_elite_echo_multiverse_ai_pro_v2.py
from __future__ import annotations
import argparse, json, os, sys, uuid, time, importlib.util, pathlib
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, List, Any, Optional

from echo_core import Module, REGISTRY, register, load_schema, validate_payload, Health, Metrics

# ===== i18n (kısa) =====
I18N = {"en":{"online":"ULTRA ELITE HYBRID ONLINE"},
        "tr":{"online":"ULTRA ELİT HİBRİT AKTİF"},
        "fr":{"online":"ULTRA ÉLITE HYBRIDE EN LIGNE"},
        "de":{"online":"ULTRA-ELITE HYBRID ONLINE"}}
def tr(lang, key): return I18N.get(lang, I18N["en"]).get(key, key)

# ===== built-in modül örneği (Code) =====
@register("Code")
def m_code(strategy: str, lang: str) -> Module:
    mod = Module(
        name="Code",
        status="ok",
        payload={"msg": f"{strategy} → coded & echoed"},
        schema=load_schema("code"),
    )
    validate_payload(mod)
    return mod

# ===== plugin discovery =====
def discover_plugins(folder: str = "plugins"):
    p = pathlib.Path(folder)
    if not p.exists(): return
    for path in p.glob("*.py"):
        spec = importlib.util.spec_from_file_location(path.stem, path)
        mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(mod)  # noqa: F401

# ===== meta & system =====
@dataclass
class EchoMeta:
    version: str = "Ultra Elit v2.0"
    strategy: str = "KamalquantX"
    lang: str = "tr"
    generated_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    uuid: str = field(default_factory=lambda: str(uuid.uuid4()))

@dataclass
class UltraEliteEchoSystem:
    meta: EchoMeta
    modules: Dict[str, Module] = field(default_factory=dict)

    @classmethod
    def build(cls, strategy: str, lang: str = "tr", include: Optional[List[str]] = None):
        sysobj = cls(EchoMeta(strategy=strategy, lang=lang))
        discover_plugins()
        wanted = include or list(REGISTRY.keys())
        for key in wanted:
            if key not in REGISTRY: continue
            t0 = time.perf_counter()
            mod = REGISTRY[key](strategy, lang)
            mod.metrics.init_ms = (time.perf_counter() - t0) * 1000
            # sağlamlık: payload şema validasyonu
            validate_payload(mod)
            # basit health örneği
            mod.health = mod.health if mod.health in (Health.OK, Health.WARN, Health.FAIL) else Health.OK
            sysobj.modules[key] = mod
        return sysobj

    def to_dict(self) -> Dict[str, Any]:
        return {"meta": asdict(self.meta),
                "engine": tr(self.meta.lang, "online"),
                "modules": {k: m.to_dict() for k, m in self.modules.items()}}

# ===== API / WS / Prometheus =====
def create_app(sysobj: UltraEliteEchoSystem):
    try:
        from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
        from fastapi.responses import Response
        from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    except Exception:  # API yoksa zarifçe devre dışı
        return None

    API_KEY = os.getenv("API_KEY", "secret123")
    REQS = Counter("echo_requests_total", "requests")
    LAT  = Histogram("echo_req_latency_seconds", "latency seconds")

    app = FastAPI(title="UltraEliteEcho", version=sysobj.meta.version)

    def check_key(key: str = None):
        from fastapi import Request
        def _inner(req: Request):
            if req.headers.get("x-api-key") != API_KEY:
                raise HTTPException(status.HTTP_401_UNAUTHORIZED, "Invalid API Key")
        return _inner

    @app.get("/health")
    def health():
        REQS.inc()
        return {"ok": True, "uuid": sysobj.meta.uuid}

    @app.get("/modules")
    def modules(dep=Depends(check_key())):
        with LAT.time():
            REQS.inc()
            return sysobj.to_dict()["modules"]

    @app.get("/metrics")
    def metrics():
        return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

    @app.websocket("/ws")
    async def ws(sock: WebSocket):
        await sock.accept()
        try:
            while True:
                await sock.send_json(sysobj.to_dict())
                time.sleep(2)
        except Exception:
            pass
    return app

def run_api(sysobj: UltraEliteEchoSystem, port: int = 8080):
    app = create_app(sysobj)
    if app is None:
        print("FastAPI/uvicorn/prometheus_client yok. `pip install fastapi uvicorn prometheus_client`")
        return
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")

# ===== CLI =====
def main():
    ap = argparse.ArgumentParser(description="Ultra Elite Hybrid v2 (plugins + schema + ws + metrics)")
    ap.add_argument("--strategy", "-s", default="KamalquantX")
    ap.add_argument("--lang", "-l", default="tr", choices=["tr","en","fr","de"])
    ap.add_argument("--include", "-i", nargs="*", help="Sadece bu modüller (boş: hepsi)")
    ap.add_argument("--api", action="store_true")
    ap.add_argument("--port", type=int, default=8080)
    args = ap.parse_args()

    sysobj = UltraEliteEchoSystem.build(args.strategy, args.lang, args.include)
    print(json.dumps(sysobj.to_dict(), ensure_ascii=False, indent=2))
    if args.api:
        run_api(sysobj, port=args.port)

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\your_project\__init__.py


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\your_project\run_all_tests.py
#!/bin/bash

# run_all_tests.sh
# Tüm testleri pytest + coverage ile çalıştırır

# 1) Renk kodları
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m' # reset

echo "🔍 Testler başlatılıyor..."

# 2) coverage varsa, yoksa kur
if ! command -v coverage &> /dev/null
then
    echo "📦 coverage bulunamadı, kuruluyor..."
    pip install coverage pytest > /dev/null
fi

# 3) coverage ile testleri çalıştır
coverage run -m pytest -q
TEST_EXIT_CODE=$?

# 4) coverage raporu
echo ""
echo "📊 Test Kapsam Raporu:"
coverage report -m --omit="tests/*"

# 5) sonuç
if [ $TEST_EXIT_CODE -eq 0 ]; then
    echo -e "${GREEN}✅ Tüm testler başarıyla geçti!${NC}"
else
    echo -e "${RED}❌ Bazı testler başarısız oldu. Logları kontrol et.${NC}"
fi

# 6) coverage HTML raporu da üret
coverage html
echo "🌐 HTML kapsam raporu: htmlcov/index.html"


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\__init__.py
# auto-added


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\adaptive_signal_mutator.py
class AdaptiveSignalMutator:
    def __init__(self):
        self.mutation_rate = 0.2

    def mutate(self, signal_value, market_volatility):
        adjustment = market_volatility * self.mutation_rate
        mutated_signal = signal_value + adjustment if signal_value > 0 else signal_value - adjustment
        return max(-1, min(mutated_signal, 1))

# Simülasyon
mutator = AdaptiveSignalMutator()
print("🔄 Yeni Sinyal:", mutator.mutate(signal_value=0.4, market_volatility=0.6))



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\aegis_quant.py
import websocket, json, time, hmac, hashlib, requests, threading
import pandas as pd
import numpy as np
import ta
from sklearn.ensemble import IsolationForest
from keras.models import Sequential
from keras.layers import LSTM, Dense

# === AYARLAR ===
API_KEY = "YOUR_API_KEY"
SECRET_KEY = "YOUR_SECRET_KEY"
SYMBOLS = ["btcusdt", "ethusdt"]
TRADE_AMOUNT = 0.001
RISK_LIMIT = 0.02  # %2 risk

# === VERİ DEPOLAMA ===
price_data = {symbol: pd.DataFrame(columns=["timestamp", "price"]) for symbol in SYMBOLS}
models = {}

# === LOG FONKSİYONU ===
def log(event, msg):
    print(f"[{event}] {msg}")

# === VERİ AKIŞI ===
def create_socket(symbol):
    url = f"wss://stream.binance.com:9443/ws/{symbol}@trade"
    return websocket.WebSocketApp(url,
        on_message=lambda ws, msg: handle_message(symbol, msg),
        on_open=lambda ws: log("OPEN", f"{symbol.upper()} bağlantısı kuruldu."),
        on_close=lambda ws: log("CLOSE", f"{symbol.upper()} bağlantısı kapandı.")
    )

def handle_message(symbol, message):
    global price_data, models
    data = json.loads(message)
    price = float(data['p'])
    timestamp = int(data['T'])
    df = price_data[symbol]
    df.loc[len(df)] = [timestamp, price]

    if len(df) > 120:
        df = df.tail(120).copy()
        df = generate_features(df)
        anomaly_score = detect_anomaly(df)
        if symbol not in models:
            models[symbol] = train_model(df)
        prediction = predict_price(models[symbol], df)
        strategy_decision(symbol, df, prediction, anomaly_score)

# === ÖZELLİK MÜHENDİSLİĞİ ===
def generate_features(df):
    df['rsi'] = ta.momentum.RSIIndicator(df['price']).rsi()
    df['macd'] = ta.trend.MACD(df['price']).macd_diff()
    df['sma20'] = df['price'].rolling(window=20).mean()
    df['volatility'] = df['price'].rolling(window=10).std()
    df.dropna(inplace=True)
    return df

# === ANOMALY DETECTION ===
def detect_anomaly(df):
    iso = IsolationForest(contamination=0.05)
    scores = iso.fit_predict(df[['price', 'rsi', 'macd', 'volatility']])
    return scores[-1]  # -1 = anomaly

# === LSTM MODELİ ===
def train_model(df):
    prices = df['price'].values[-100:]
    X, y = [], []
    for i in range(10, len(prices)):
        X.append(prices[i-10:i])
        y.append(prices[i])
    X, y = np.array(X), np.array(y)
    X = X.reshape((X.shape[0], X.shape[1], 1))

    model = Sequential()
    model.add(LSTM(64, activation='relu', input_shape=(10,1)))
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mse')
    model.fit(X, y, epochs=15, verbose=0)
    return model

def predict_price(model, df):
    last_seq = df['price'].values[-10:].reshape((1,10,1))
    return model.predict(last_seq)[0][0]

# === STRATEJİ MOTORU ===
def strategy_decision(symbol, df, prediction, anomaly_score):
    latest = df.iloc[-1]
    rsi = latest['rsi']
    macd = latest['macd']
    price = latest['price']
    volatility = latest['volatility']

    log("STRATEGY", f"{symbol.upper()} | RSI: {rsi:.2f} | MACD: {macd:.2f} | Tahmin: {prediction:.2f} | Anomaly: {anomaly_score}")

    if anomaly_score == -1:
        log("ALERT", "Anormal veri tespit edildi. İşlem yapılmadı.")
        return

    if rsi < 30 and macd > 0 and prediction > price:
        qty = calculate_position(price, volatility)
        execute_order(symbol.upper(), "BUY", qty)
    elif rsi > 70 and macd < 0 and prediction < price:
        qty = calculate_position(price, volatility)
        execute_order(symbol.upper(), "SELL", qty)
    else:
        log("STATUS", "Beklemede")

# === RİSK YÖNETİMİ ===
def calculate_position(price, volatility):
    balance = 1000  # örnek bakiye
    risk_amount = balance * RISK_LIMIT
    stop_loss = price * 0.01 + volatility
    qty = risk_amount / stop_loss
    return round(qty, 4)

# === EMİR GÖNDERİMİ ===
def execute_order(symbol, side, quantity):
    url = "https://api.binance.com/api/v3/order"
    timestamp = int(time.time() * 1000)
    params = {
        "symbol": symbol,
        "side": side,
        "type": "MARKET",
        "quantity": quantity,
        "timestamp": timestamp
    }
    query = '&'.join([f"{k}={v}" for k,v in params.items()])
    signature = hmac.new(SECRET_KEY.encode(), query.encode(), hashlib.sha256).hexdigest()
    params['signature'] = signature
    headers = {"X-MBX-APIKEY": API_KEY}
    try:
        response = requests.post(url, headers=headers, params=params)
        log("ORDER", f"{side} {quantity} {symbol} gönderildi.")
        log("RESPONSE", str(response.json()))
    except Exception as e:
        log("ERROR", f"Emir gönderimi başarısız: {e}")

# === BAŞLAT ===
if __name__ == "__main__":
    sockets = [create_socket(symbol) for symbol in SYMBOLS]
    for sock in sockets:
        threading.Thread(target=sock.run_forever).start()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\aether_command_oracle.py
def suggest_strategies(destiny_paths):
    strategies = []
    for path in destiny_paths:
        if "Evrim Rotası" in path:
            strategies.append("🔝 Gelişime odaklan: Yaratıcı projeleri destekle, bilgi akışını hızlandır.")
        elif "Kader Krizi" in path:
            strategies.append("🛡️ Koruma protokolü başlat: Güvenlik sistemlerini gözden geçir, alternatif senaryolar hazırla.")
    return strategies if strategies else ["🌿 Şu anda müdahale gerektiren hiçbir şey yok. Sessiz gelişim zamanı."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\aether_command_synthesizer.py
def synthesize_aether_command(data_signals, captain_intent):
    directive = []
    for signal in data_signals:
        if signal['harmony'] >= 80 and signal['risk_level'] < 40:
            directive.append(f"🪐 Uyumlu Hamle: {signal['id']} → {captain_intent}")
        elif signal['flux'] > 65:
            directive.append(f"⚠️ Dalgasal Müdahale: {signal['id']} → Denge önerilir")
    return directive if directive else ["🌌 Kozmik frekanslar nötr. Sessiz kalmak bir stratejidir."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\alpha_engine.py
# alpha_engine.py
from __future__ import annotations
import time
from dataclasses import dataclass
from typing import Optional, Dict, Any, List

import numpy as np
import pandas as pd
from binance.client import Client

from ta_core import ema, sma, rsi, macd, stoch_kd, atr, adx, bollinger, cci, mfi, obv, keltner, supertrend

@dataclass
class SignalDecision:
    side: str                  # "BUY" | "SELL"
    sl_pct: float
    tp_pct: float
    trail_pct: float
    confidence: float          # [-100, 100]
    reason: str

class ProAlphaEngine:
    def __init__(self, client: Client, *,
                 timeframe: str = "1m",
                 lookback: int = 600,
                 ema_fast: int = 21,
                 ema_slow: int = 55,
                 adx_thr: float = 18.0,
                 buy_thr: float = 25.0,
                 sell_thr: float = -25.0,
                 sl_atr_mult: float = 1.8,
                 rr_mult: float = 2.0,
                 trail_frac_of_tp: float = 0.35):
        self.client = client
        self.tf = timeframe
        self.lb = lookback
        self.ef = ema_fast
        self.es = ema_slow
        self.adx_thr = adx_thr
        self.buy_thr = buy_thr
        self.sell_thr = sell_thr
        self.sl_atr_mult = sl_atr_mult
        self.rr_mult = rr_mult
        self.trail_frac = trail_frac_of_tp

    # ---------- Data ----------
    def fetch_df(self, symbol: str) -> pd.DataFrame:
        kl = self.client.futures_klines(symbol=symbol, interval=self.tf, limit=self.lb)
        cols = ["t","o","h","l","c","v","ct","q","n","tbv","tbq","i"]
        df = pd.DataFrame(kl, columns=cols)
        df["o"] = df["o"].astype(float)
        df["h"] = df["h"].astype(float)
        df["l"] = df["l"].astype(float)
        df["c"] = df["c"].astype(float)
        df["v"] = df["v"].astype(float)
        df.index = pd.to_datetime(df["t"], unit="ms")
        return df

    # ---------- Features ----------
    def build_features(self, df: pd.DataFrame) -> pd.DataFrame:
        c, h, l, v = df["c"], df["h"], df["l"], df["v"]

        df["ema_f"] = ema(c, self.ef)
        df["ema_s"] = ema(c, self.es)
        df["rsi"]   = rsi(c, 14)
        macd_line, macd_sig, macd_hist = macd(c, 12, 26, 9)
        df["macd"], df["macds"], df["macdh"] = macd_line, macd_sig, macd_hist
        k, d = stoch_kd(h, l, c, 14, 3)
        df["stoch_k"], df["stoch_d"] = k, d
        df["atr"]  = atr(h, l, c, 14)
        df["adx"], df["+di"], df["-di"] = adx(h, l, c, 14)
        bb_m, bb_u, bb_l, bb_w = bollinger(c, 20, 2.0)
        df["bb_m"], df["bb_u"], df["bb_l"], df["bb_w"] = bb_m, bb_u, bb_l, bb_w
        df["cci"]  = cci(h, l, c, 20)
        df["mfi"]  = mfi(h, l, c, v, 14)
        df["obv"]  = obv(c, v)
        kc_m, kc_u, kc_l = keltner(h, l, c, ema_period=20, atr_period=10, mult=1.5)
        df["kc_m"], df["kc_u"], df["kc_l"] = kc_m, kc_u, kc_l
        st_dir, st_line = supertrend(h, l, c, atr_period=10, mult=3.0)
        df["st_dir"], df["st_line"] = st_dir, st_line

        return df.dropna().copy()

    # ---------- Scoring ----------
    def score_row(self, row: pd.Series, prev: pd.Series) -> float:
        """ Trend + Momentum + Volatilite kompozit skoru ([-100,100]) """
        score = 0.0

        # Trend
        trend = 0.0
        if row["ema_f"] > row["ema_s"]: trend += 22
        else:                            trend -= 22

        if row["c"] > row["st_line"] and row["st_dir"] > 0: trend += 22
        elif row["c"] < row["st_line"] and row["st_dir"] < 0: trend -= 22

        if row["macdh"] > 0: trend += 12
        else:                trend -= 12

        if row["adx"] > self.adx_thr:
            trend *= 1.10  # güçlü trendlerde ağırlık artır

        score += trend

        # Momentum
        mom = 0.0
        if row["rsi"] > 50 and row["rsi"] > prev["rsi"]:  mom += 10
        if row["stoch_k"] > row["stoch_d"] and prev["stoch_k"] <= prev["stoch_d"]: mom += 8
        if row["mfi"] > 50: mom += 6
        score += mom

        # Volatilite / Breakout
        vol = 0.0
        if row["c"] > row["bb_u"]: vol += 12
        if row["c"] < row["bb_l"]: vol -= 12
        squeeze_on = (row["bb_w"] < 0.015) and (row["kc_u"]-row["kc_l"] > row["bb_u"]-row["bb_l"])
        if squeeze_on and (row["bb_w"] > prev["bb_w"]):
            vol += 6 if row["c"] > row["bb_m"] else -6
        score += vol

        # Normalize
        score = max(-100.0, min(100.0, score))
        return float(score)

    # ---------- Decision ----------
    def decide(self, symbol: str) -> Optional[SignalDecision]:
        df_raw = self.fetch_df(symbol)
        df = self.build_features(df_raw)
        if len(df) < 5: return None

        row  = df.iloc[-1]
        prev = df.iloc[-2]
        s = self.score_row(row, prev)

        # Rejim filtresi: çok yatay + düşük ADX'te agresif işlem yapma
        if row["adx"] < (self.adx_thr*0.6) and abs(s) < 15:
            return None

        sl_pct = (self.sl_atr_mult * row["atr"]) / row["c"]
        tp_pct = sl_pct * self.rr_mult
        trail_pct = max(0.0, tp_pct * self.trail_frac)

        if s >= self.buy_thr:
            return SignalDecision("BUY", float(sl_pct), float(tp_pct), float(trail_pct), float(s),
                                  f"score={s:.1f} trend/mom/vol BUY")
        if s <= self.sell_thr:
            return SignalDecision("SELL", float(sl_pct), float(tp_pct), float(trail_pct), float(s),
                                  f"score={s:.1f} trend/mom/vol SELL")
        return None


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\aquatic_chain_synapse.py
def chain_synaptic_pathway(source_chain, target_chain, emotion_flow):
    strength = emotion_flow * 0.8  # sinaptik sinyal yoğunluğu
    if strength > 0.7:
        connection = "🧬 Aktif Biyolojik Bağ"
    elif strength > 0.4:
        connection = "🌫️ Dalgasal Geçiş"
    else:
        connection = "⛓️ Zayıf Bağlantı"
    return f"{source_chain} → {target_chain}: {connection}"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\astro_signal_mapper.py
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

def stellar_map(csv_file="data/signal_log.csv"):
    df = pd.read_csv(csv_file)
    x = np.arange(len(df))
    y = df["score"]
    colors = ["gold" if r == 1 else "gray" for r in df["result"]]
    
    plt.scatter(x, y, c=colors, s=50, alpha=0.8)
    plt.title("🌌 Yıldızlar Arası Sinyal Haritası")
    plt.xlabel("Sinyal Zaman Ekseni")
    plt.ylabel("Skor")
    plt.tight_layout()
    plt.show()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\auto_deploy_bot.py
# auto_deploy_bot.py (Optimum strateji ile otomatik bot başlatıcı)
import time
from datetime import datetime
from kiripto_nova.data.pipelines.data_loader import load_binance_data
from kiripto_nova.signals.signal_engine import SignalEngine
from trade_executor import execute_trade
from kiripto_nova.risk.risk_manager import calculate_position_size, calculate_stop_loss, calculate_take_profit
from kiripto_nova.apps.telegram_alert import notify_signal, notify_trade
from logger import log_trade, log_error
from kiripto_nova.strategies.strategy_optimizer import optimize_strategy

# ⚙️ Ayarlar
SYMBOL = "DOGE/USDT"
TIMEFRAME = "15m"
BALANCE = 1000
RISK = 0.01
REFRESH_INTERVAL = 300  # 5 dakika

# Son tetiklenen sinyal
last_signal = None

# İlk optimizasyon
df = load_binance_data(SYMBOL, TIMEFRAME)
optimized = optimize_strategy(df)
best = optimized.iloc[0]  # En iyi kombinasyon
print("🚀 En iyi kombinasyon yüklendi:")
print(best)

RSI_LEVEL = best["RSI_threshold"]
STOP_LOSS_PCT = best["Stop_Loss"]
REWARD_RATIO = best["Reward_Ratio"]


def run_bot():
    global last_signal
    try:
        print(f"⏱️ Bot tarıyor: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

        df = load_binance_data(SYMBOL, TIMEFRAME)
        engine = SignalEngine(df)
        engine.calculate_indicators()
        df = engine.get_dataframe()
        signal = "BUY" if df["RSI_14"].iloc[-1] < RSI_LEVEL else "NEUTRAL"

        if signal != last_signal and signal == "BUY":
            entry = df["close"].iloc[-1]
            qty = calculate_position_size(BALANCE, RISK, STOP_LOSS_PCT)
            sl = calculate_stop_loss(entry, STOP_LOSS_PCT, direction="long")
            tp = calculate_take_profit(entry, REWARD_RATIO, STOP_LOSS_PCT, direction="long")

            execute_trade(SYMBOL, side="buy", amount=qty)
            log_trade("BUY", SYMBOL, qty, entry, sl, tp)
            notify_signal("BUY", SYMBOL)
            notify_trade("BUY", SYMBOL, qty, entry, sl, tp)
            last_signal = signal
        else:
            print("🔍 Sinyal yok veya tekrar ediyor.")

    except Exception as e:
        log_error(e)


if __name__ == "__main__":
    while True:
        run_bot()
        time.sleep(REFRESH_INTERVAL)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\auto_move_map.py
# auto_move_map.py  —  kökteki dosya adlarına göre move_map.csv üretir
import re, csv, pathlib
ROOT = pathlib.Path(".").resolve()
RULES = [
    (r"^binance_.*",                       "exchanges/binance"),
    (r"^(basic_|strategy_|strategic_).*",  "strategies"),
    (r"^(ai_|neuro_|ml_|insight_).*",      "ai"),
    (r"^(signal_|sentiment_|news_|get_news).*", "signals"),
    (r"^risk_.*|^RiskGuard",               "risk"),
    (r"^(analysis_|plot_|report_|dashboard_).*", "analytics"),
    (r"^(backtest.*|backtester.*|testnet_trade_bot)", "backtesting"),
    (r"^(orchestrator_|scheduler_|stream|router).*", "execution"),
    (r"^(data_.*|twitter_data|data_loader|data_fetcher)", "data/pipelines"),
    (r"^chain_.*",                         "analytics/onchain"),
    (r"^position_manager",                 "execution"),
    (r"^telegram_.*",                      "apps"),
    (r"^nova_.*_bot$",                     "apps"),
    (r"^novaSovereignCore$",               "apps"),
    (r"^wallet_.*|wallet_activity_analyzer", "analytics"),
    (r"^config_loader|^settings",          "core"),
]
SKIP = {".git","src",".venv","venv","venv311","Lib","lib","site-packages","__pycache__",".pytest_cache"}

def snake(s):
    s = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", s)
    return re.sub(r"[^a-zA-Z0-9_]", "_", s).lower()

def decide(stem):
    for pat, dest in RULES:
        if re.match(pat, stem): return dest
    return None

def main():
    rows=[("old_path","new_path")]
    unmapped=[]
    for p in ROOT.glob("*.py"):
        if p.name in {"auto_move_map.py","rearrange_v2.py"}: continue
        dest = decide(p.stem)
        if dest: rows.append((p.name, f"src/kiripto_nova/{dest}/{snake(p.stem)}.py"))
        else: unmapped.append(p.name)
    t = ROOT/"tests"
    if t.exists():
        for p in t.glob("*.py"):
            if re.match(r"^nova_.*_bot$|^novaSovereignCore$", p.stem):
                rows.append((str(p), f"src/kiripto_nova/apps/{snake(p.stem)}.py"))
    with open("move_map.csv","w",newline="",encoding="utf-8") as f: csv.writer(f).writerows(rows)
    with open("unmapped.txt","w",encoding="utf-8") as f: f.write("\n".join(unmapped))
    print(f"[OK] move_map.csv ({len(rows)-1} satır). Eşleşmeyen: {len(unmapped)} -> unmapped.txt")

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\block_pulse_tracker.py
def detect_chain_pulse(block_data):
    alerts = []
    if block_data['transfer_volume'] > 1_000_000:
        alerts.append("💰 Büyük Transfer Tespiti!")
    if block_data['wallet_movement'] > 500:
        alerts.append("🦈 Cüzdan Göçü Algılandı!")
    if block_data['dao_activity'] == 'surge':
        alerts.append("🏛️ DAO Stratejik Hamlesi!")
    if not alerts:
        alerts.append("🌊 Zincir Dengede, beklenmedik bir hareket yok.")
    return alerts



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\boot.py
# boot.py
from __future__ import annotations
import os
import logging
from typing import List
from dotenv import load_dotenv
from binance.client import Client

# ---- Senin modüllerin (daha önce yazdıklarımız) ----
from ex_filters import SymbolFilters
from kiripto_nova.risk.risk_manager import RiskManager, RiskConfig
from kiripto_nova.execution.position_manager import PositionManager
from kiripto_nova.strategies.strategy_executor import StrategyExecutor

# Basit portföy adaptörü (şimdilik minimum)
class PortfolioAdapter:
    def __init__(self, client: Client):
        self.client = client
        self._equity_cache = None

    def get_equity_usdt(self) -> float:
        # Futures toplam cüzdan (USDT bazlı)
        fa = self.client.futures_account()
        # totalWalletBalance string gelebilir
        return float(fa.get("totalWalletBalance", 0.0))

    def get_open_exposure(self, symbol: str) -> float:
        # İstersen burayı açık pozisyonlara göre notional hesaplayacak şekilde genişlet
        return 0.0

    def get_open_positions_count(self) -> int:
        poss = self.client.futures_position_information()
        # qty != 0 olanları say
        return sum(1 for p in poss if abs(float(p.get("positionAmt", "0"))) > 0)

    def get_symbol_price(self, symbol: str) -> float:
        return float(self.client.futures_symbol_ticker(symbol=symbol)["price"])

def _bool_env(key: str, default: bool) -> bool:
    return os.getenv(key, str(default)).strip().lower() in ("1","true","yes","on")

def bootstrap():
    # 1) ENV yükle + log ayarı
    load_dotenv()
    log_level = os.getenv("LOG_LEVEL", "INFO").upper()
    logging.basicConfig(level=getattr(logging, log_level, logging.INFO),
                        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s")
    log = logging.getLogger("boot")

    # 2) ENV oku
    API_KEY = os.getenv("BINANCE_API_KEY"); API_SECRET = os.getenv("BINANCE_API_SECRET")
    USE_TESTNET = _bool_env("BINANCE_USE_TESTNET", True)
    FAPI_URL = os.getenv("BINANCE_FUTURES_URL", "")
    SYMBOLS: List[str] = [s.strip() for s in os.getenv("SYMBOLS","BTCUSDT").split(",") if s.strip()]
    HEDGE = _bool_env("BINANCE_HEDGE_MODE", True)
    MARGIN_TYPE = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED").upper()
    LEVERAGE = int(os.getenv("BINANCE_LEVERAGE", "5"))

    # Risk ayarları
    risk_cfg = RiskConfig(
        max_capital_pct_per_trade=float(os.getenv("MAX_CAPITAL_PCT_PER_TRADE", "0.02")),
        max_daily_loss_pct=float(os.getenv("MAX_DAILY_DRAWDOWN", "0.03")),
        max_open_positions=int(os.getenv("MAX_OPEN_POSITIONS", "5")),
        max_symbol_exposure_pct=float(os.getenv("MAX_SYMBOL_EXPOSURE_PCT", "0.25")),
        min_notional_usdt=float(os.getenv("MIN_NOTIONAL_USDT", "10")),
    )

    # 3) Binance Futures client
    if not API_KEY or not API_SECRET:
        raise RuntimeError("BINANCE_API_KEY / BINANCE_API_SECRET eksik!")

    client = Client(API_KEY, API_SECRET, testnet=USE_TESTNET)
    if FAPI_URL:
        # Testnet: https://testnet.binancefuture.com  |  Prod: https://fapi.binance.com
        client.FUTURES_URL = FAPI_URL

    # 4) Başlangıç hesap ayarları
    try:
        client.futures_change_position_mode(dualSidePosition=HEDGE)
        log.info("Hedge mode: %s", HEDGE)
    except Exception as e:
        log.warning("Hedge mode set edilemedi: %s", e)

    for sym in SYMBOLS:
        try:
            client.futures_change_margin_type(symbol=sym, marginType=MARGIN_TYPE)
        except Exception:
            # Zaten o moddaysa hata döner; önemli değil
            pass
        try:
            client.futures_change_leverage(symbol=sym, leverage=LEVERAGE)
        except Exception as e:
            log.warning("Leverage set edilemedi %s: %s", sym, e)

    # 5) Bağımlılıkları kur
    # NOTE: ex_filters için FUTURES exchangeInfo kullanmalıyız
    filters = SymbolFilters(client.futures_exchange_info())

    portfolio = PortfolioAdapter(client)
    risk = RiskManager(portfolio, risk_cfg)
    pm = PositionManager(client, risk, filters)
    execu = StrategyExecutor(pm, risk, portfolio)

    # 6) Basit sağlık kontrolü
    eq = portfolio.get_equity_usdt()
    mp = client.futures_symbol_ticker(symbol=SYMBOLS[0])["price"]
    log.info("Futures boot hazır. Equity=%.2f USDT | %s fiyat=%s", eq, SYMBOLS[0], mp)

    # 7) Örnek: “dry-run” sinyal akışı (kapatmak istersen yorumla)
    # Basit bir giriş örneği (gerçek strateji yerine)
    demo = _bool_env("DEMO_PLACE_ORDER", False)
    if demo:
        signal = {
            "symbol": SYMBOLS[0],
            "side": "BUY",
            "intent": "entry",
            "risk": {"max_capital_pct": float(os.getenv("MAX_CAPITAL_PCT_PER_TRADE", "0.02"))}
        }
        log.info("Demo sinyal gönderiliyor: %s", signal)
        order = execu.on_signal(signal)
        log.info("Demo order sonucu: %s", order)

    return {
        "client": client,
        "filters": filters,
        "portfolio": portfolio,
        "risk": risk,
        "position_manager": pm,
        "executor": execu,
        "symbols": SYMBOLS
    }

if __name__ == "__main__":
    bootstrap()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\bot.py
# bot.py
# Kiripto Nova — Futures Bracket Bot (TESTNET/MAINNET, PRO/STRICT destekli)
# ------------------------------------------------------------
# - python-binance + dotenv
# - HEDGE/ISOLATED/LEVERAGE idempotent ayarlama
# - MARKET entry + STOP_MARKET (SL) + TAKE_PROFIT_MARKET (TP)
# - SL/TP için reduceOnly KULLANMA → closePosition=True (Binance USDM gereği)
# - Opsiyonel TRAILING_STOP_MARKET (qty ile, reduceOnly yok)
# - Timestamp senkronu (client.timestamp_offset)
# - Sağlam retry + min step/tick yuvarlama
# - PRO otomatik mod (çok basit sinyal örneği) + STRICT (korumacı mod)
# ------------------------------------------------------------

from __future__ import annotations

import os
import sys
import time
import math
import argparse
from decimal import Decimal, ROUND_DOWN
from typing import Dict, Any, Optional, Tuple

from dotenv import load_dotenv
from binance.client import Client
from binance.exceptions import BinanceAPIException

# Opsiyonel Telegram bildirimleri
try:
    import notify as nt  # notify.py varsa send() kullanır
except Exception:
    nt = None

# =======================
# Ortam / Config
# =======================

load_dotenv()

USE_TESTNET = os.getenv("BINANCE_USE_TESTNET", "true").strip().lower() == "true"

if USE_TESTNET:
    API_KEY = (os.getenv("BINANCE_API_KEY_TEST") or "").strip()
    API_SECRET = (os.getenv("BINANCE_API_SECRET_TEST") or "").strip()
    FUTURES_BASE = os.getenv("BINANCE_FUTURES_URL_TEST", "https://testnet.binancefuture.com").strip().rstrip("/")
else:
    API_KEY = (os.getenv("BINANCE_API_KEY_MAIN") or os.getenv("BINANCE_API_KEY") or "").strip()
    API_SECRET = (os.getenv("BINANCE_API_SECRET_MAIN") or os.getenv("BINANCE_API_SECRET") or "").strip()
    FUTURES_BASE = os.getenv("BINANCE_FUTURES_URL_MAIN", "https://fapi.binance.com").strip().rstrip("/")

if not API_KEY or not API_SECRET:
    print("❌ API key/secret yok (.env).")
    sys.exit(1)

client = Client(API_KEY, API_SECRET, testnet=USE_TESTNET)
client.FUTURES_URL = f"{FUTURES_BASE}/fapi"
print("Futures base:", client.FUTURES_URL)
print("API key (maskeli):", API_KEY[:6] + "..." + API_KEY[-4:])

# Risk ve emir çalışma ayarları
HEDGE_MODE  = os.getenv("BINANCE_HEDGE_MODE", "true").strip().lower() == "true"
MARGIN_TYPE = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED").strip().upper()  # ISOLATED/CROSSED
LEVERAGE    = int(os.getenv("BINANCE_LEVERAGE", "5"))

WORKING_TYPE = os.getenv("WORKING_TYPE", "MARK_PRICE").strip().upper()  # MARK_PRICE | CONTRACT_PRICE
SL_PCT_DEF   = float(os.getenv("SL_PCT", "0.01"))
TP_PCT_DEF   = float(os.getenv("TP_PCT", "0.02"))
TRAIL_PCT_DEF= float(os.getenv("TRAIL_PCT", "0.0"))   # 0.004 = %0.4

STRICT_MODE  = os.getenv("STRICT_MODE", "false").strip().lower() == "true"

MAX_RETRY        = int(os.getenv("MAX_RETRY", "3"))
RETRY_BACKOFF_MS = int(os.getenv("RETRY_BACKOFF_MS", "400"))

_symbol_cache: Dict[str, Dict[str, float]] = {}

# =======================
# Yardımcılar
# =======================

def tg(msg: str):
    print(msg)
    if nt and hasattr(nt, "tg_enabled") and nt.tg_enabled():
        try:
            nt.send(msg)
        except Exception:
            pass

def _sleep_ms(ms: int):
    time.sleep(ms / 1000.0)

def retry_call(fn, desc: str = "", *args, **kwargs):
    tries = kwargs.pop("_tries", MAX_RETRY)
    last = None
    for i in range(tries):
        try:
            return fn(*args, **kwargs)
        except BinanceAPIException as e:
            last = e
            print(f"⚠️ {desc or fn.__name__} hata: {e} (deneme {i+1}/{tries})")
            _sleep_ms(RETRY_BACKOFF_MS)
        except Exception as e:
            last = e
            print(f"⚠️ {desc or fn.__name__} hata: {e} (deneme {i+1}/{tries})")
            _sleep_ms(RETRY_BACKOFF_MS)
    raise last

def calibrate_timestamp_offset():
    """Sunucu saatine göre client.timestamp_offset ayarla."""
    try:
        s = retry_call(client.get_server_time, "server_time")
        server_ms = int(s["serverTime"])
        local_ms  = int(time.time() * 1000)
        off = server_ms - local_ms
        client.timestamp_offset = off
        print(f"⏱️ timestamp senkron: offset={off} ms, recvWindow={5000}")
    except Exception as e:
        print("⚠️ timestamp offset ayarlanamadı:", e)

def get_filters(symbol: str) -> Dict[str, float]:
    s = symbol.upper()
    if s in _symbol_cache:
        return _symbol_cache[s]
    info = retry_call(client.futures_exchange_info, "exchange_info")
    sy = next((x for x in info["symbols"] if x["symbol"] == s), None)
    if not sy:
        raise SystemExit(f"Sembol yok: {s}")
    lot = next(x for x in sy["filters"] if x["filterType"] in ("LOT_SIZE", "MARKET_LOT_SIZE"))
    prf = next(x for x in sy["filters"] if x["filterType"] == "PRICE_FILTER")
    step = float(lot["stepSize"])
    minq = float(lot["minQty"])
    tick = float(prf["tickSize"])
    _symbol_cache[s] = {"step": step, "min_qty": minq, "tick": tick}
    return _symbol_cache[s]

def _round_to_step(val: float, step: float) -> float:
    dval = Decimal(str(val))
    dstep = Decimal(str(step))
    return float((dval / dstep).to_integral_value(rounding=ROUND_DOWN) * dstep)

def round_qty(symbol: str, qty: float) -> float:
    f = get_filters(symbol)
    return _round_to_step(max(qty, f["min_qty"]), f["step"])

def round_price(symbol: str, price: float) -> float:
    f = get_filters(symbol)
    return _round_to_step(price, f["tick"])

def _position_side(side: str) -> str:
    return "LONG" if side.upper() == "BUY" else "SHORT"

def _opposite(side: str) -> str:
    return "SELL" if side.upper() == "BUY" else "BUY"

def _last_price(symbol: str) -> float:
    t = retry_call(client.futures_symbol_ticker, "symbol_ticker", symbol=symbol)
    return float(t["price"])

# =======================
# Hesap ayarları
# =======================

def apply_account_settings(symbol: str):
    # 1) Hedge / Oneway
    try:
        mode = retry_call(client.futures_get_position_mode, "get_position_mode")
        dual = mode and mode.get("dualSidePosition", False)
        want = HEDGE_MODE
        if dual != want:
            retry_call(client.futures_change_position_mode, "change_position_mode",
                       dualSidePosition=want)
            print(f"⚙️ Position mode -> {'HEDGE' if want else 'ONE-WAY'}")
        else:
            print("ℹ️ Position mode zaten uygun (skip).")
    except BinanceAPIException as e:
        print("⚠️ position_mode:", e)

    # 2) Margin type
    try:
        retry_call(client.futures_change_margin_type, "change_margin_type",
                   symbol=symbol, marginType=MARGIN_TYPE)
        print(f"⚙️ Margin type -> {MARGIN_TYPE}")
    except BinanceAPIException as e:
        if "No need to change margin type" in str(e) or e.code == -4046:
            print("ℹ️ margin type zaten uygun (skip).")
        else:
            raise

    # 3) Leverage
    try:
        retry_call(client.futures_change_leverage, "change_leverage",
                   symbol=symbol, leverage=LEVERAGE)
        print(f"⚙️ Leverage -> {LEVERAGE}x")
    except BinanceAPIException as e:
        print("ℹ️ leverage set yanıtı:", e)

# =======================
# Order helpers
# =======================

def safe_create_order(desc: str, **params) -> Any:
    """None değerleri atarak create_order çağır; hataları tekrar dene."""
    clean = {k: v for k, v in params.items() if v is not None}
    return retry_call(client.futures_create_order, desc, **clean)

def entry_market(symbol: str, side: str, qty: float, pos_side: str, shadow: bool) -> None:
    p = dict(symbol=symbol, side=side, type="MARKET",
             quantity=qty, positionSide=pos_side)
    if shadow:
        print("DRY-RUN MARKET:", p)
        return
    safe_create_order("create_market", **p)

def stop_market_close(symbol: str, opp: str, stop_price: float, pos_side: str,
                      working: str, shadow: bool) -> None:
    # SL/TP: reduceOnly YOK, quantity YOK → closePosition=True
    p = dict(symbol=symbol, side=opp, type="STOP_MARKET",
             stopPrice=stop_price, workingType=working,
             positionSide=pos_side, closePosition=True)
    if shadow:
        print("DRY-RUN SL:", p)
        return
    safe_create_order("create_stop(close)", **p)

def take_profit_close(symbol: str, opp: str, stop_price: float, pos_side: str,
                      working: str, shadow: bool) -> None:
    p = dict(symbol=symbol, side=opp, type="TAKE_PROFIT_MARKET",
             stopPrice=stop_price, workingType=working,
             positionSide=pos_side, closePosition=True)
    if shadow:
        print("DRY-RUN TP:", p)
        return
    safe_create_order("create_takeprofit(close)", **p)

def trailing_stop(symbol: str, opp: str, activation: float, callback_rate: float,
                  pos_side: str, qty: float, shadow: bool) -> None:
    # Trailing: closePosition desteklemez; qty + positionSide kullan.
    p = dict(symbol=symbol, side=opp, type="TRAILING_STOP_MARKET",
             activationPrice=activation, callbackRate=callback_rate,
             positionSide=pos_side, quantity=qty)
    if shadow:
        print("DRY-RUN TRAIL:", p)
        return
    safe_create_order("create_trailing", **p)

def _entry_price_after_fill(symbol: str, pos_side: str, tries: int = 6, delay_ms: int = 250) -> float:
    ep = 0.0
    for _ in range(tries):
        pis = retry_call(client.futures_position_information, "position_info", symbol=symbol)
        rec = next((p for p in pis if p.get("positionSide") == pos_side), None)
        if rec:
            ep = float(rec.get("entryPrice", 0.0))
            if ep > 0:
                break
        _sleep_ms(delay_ms)
    return ep or _last_price(symbol)

# =======================
# Bracket (ENTRY + SL/TP[/TRAIL])
# =======================

def bracket_market(symbol: str, side: str, qty: float,
                   sl_pct: float, tp_pct: float,
                   trail_pct: float, shadow: bool) -> Dict[str, Any]:
    s = symbol.upper()
    qty = round_qty(s, qty)
    pos_side = _position_side(side)
    opp = _opposite(side)

    # ENTRY
    entry_market(s, side, qty, pos_side, shadow)
    ep = _entry_price_after_fill(s, pos_side) if not shadow else _last_price(s)

    # Fiyatlar
    sl_p = round_price(s, ep * (1 - sl_pct) if side == "BUY" else ep * (1 + sl_pct)) if sl_pct > 0 else None
    tp_p = round_price(s, ep * (1 + tp_pct) if side == "BUY" else ep * (1 - tp_pct)) if tp_pct > 0 else None

    # SL/TP (closePosition=True)
    if sl_p:
        stop_market_close(s, opp, sl_p, pos_side, WORKING_TYPE, shadow)
        tg(f"🛡️ SL @ {sl_p}")
    if tp_p:
        take_profit_close(s, opp, tp_p, pos_side, WORKING_TYPE, shadow)
        tg(f"🎯 TP @ {tp_p}")

    # Trailing (opsiyonel)
    tr_ok = False
    if trail_pct and trail_pct > 0:
        cb = max(0.1, min(5.0, trail_pct * 100))  # % cinsinden [0.1,5.0]
        act = round_price(s, ep)
        trailing_stop(s, opp, act, cb, pos_side, qty, shadow)
        tr_ok = True
        tg(f"🪤 Trailing {trail_pct*100:.2f}% act@{act}")

    if not shadow:
        tg(f"🚀 Entry {side} {s} qty={qty}  EP≈{ep:.2f}")

    return {"entry_price": ep, "sl": sl_p, "tp": tp_p, "trail": tr_ok}

# =======================
# PRO otomatik (örnek)
# =======================

def kline_close(symbol: str, interval: str = "1m", limit: int = 30) -> list[float]:
    kl = retry_call(client.futures_klines, "klines", symbol=symbol, interval=interval, limit=limit)
    return [float(x[4]) for x in kl]

def ema(vals: list[float], n: int) -> float:
    k = 2/(n+1)
    e = vals[0]
    for v in vals[1:]:
        e = v*k + e*(1-k)
    return e

def auto_pro_decide(symbol: str) -> Tuple[str, float, float]:
    """Basit örnek: EMA hizasına göre yön/SL/TP seç."""
    closes = kline_close(symbol, "1m", 60)
    last = closes[-1]
    e20  = ema(closes, 20)
    e50  = ema(closes, 50)
    side = "BUY" if e20 > e50 else "SELL"
    risk = 0.01
    reward = 2.0
    print(f"🧠 PRO Auto: tf=1m risk={risk:.2f} rr={reward:.1f} strict={STRICT_MODE}")
    return side, risk, risk*reward

# =======================
# Auth / CLI
# =======================

def auth_smoke():
    calibrate_timestamp_offset()
    try:
        lk = retry_call(client.futures_stream_get_listen_key, "listen_key")
        print("🔑 listenKey OK:", bool(lk))
        bals = retry_call(client.futures_account_balance, "futures_balance")
        print("🔐 Auth OK – balans kayıt sayısı:", len(bals))
    except Exception as e:
        print("❌ Auth FAIL:", e)
        raise SystemExit(e)

def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Kiripto Nova Bracket Bot")
    p.add_argument("--symbol", help="Örn: BTCUSDT")
    p.add_argument("--side", choices=["BUY", "SELL"])
    p.add_argument("--qty", type=float, help="Miktar")
    p.add_argument("--sl", type=float, default=SL_PCT_DEF)
    p.add_argument("--tp", type=float, default=TP_PCT_DEF)
    p.add_argument("--trail", type=float, default=TRAIL_PCT_DEF)
    p.add_argument("--shadow", action="store_true")
    p.add_argument("--auto-pro", action="store_true", help="Basit otomatik sinyal ve risk/ödül")
    p.add_argument("--strict", action="store_true", help="STRICT mod (korumacı)")
    return p.parse_args()

def main():
    args = parse_args()
    shadow = bool(args.shadow)
    strict = bool(args.strict or STRICT_MODE)

    auth_smoke()

    if not args.symbol and not args.auto_pro:
        raise SystemExit("Lütfen --symbol verin veya --auto-pro kullanın.")

    if args.auto_pro:
        # PRO mod — sembol verilmediyse BTCUSDT varsay
        sym = (args.symbol or "BTCUSDT").upper()
        side, risk, rr = auto_pro_decide(sym)
        qty = round_qty(sym, float(args.qty or 0.001))
        sl_pct = risk
        tp_pct = risk * rr
        print(f"PRO seçimi: {side} {sym} qty={qty}  SL={sl_pct}  TP={tp_pct}")
    else:
        sym = args.symbol.upper()
        side = args.side.upper()
        qty  = float(args.qty)
        sl_pct = max(0.0, float(args.sl))
        tp_pct = max(0.0, float(args.tp))

    trail_pct = max(0.0, float(args.trail))

    print(f"🌍 Ortam: {'TESTNET' if USE_TESTNET else 'MAINNET'} | STRICT_MODE={strict}")
    print(f"🧭 Symbol:{sym} Side:{side} Qty:{qty}")

    apply_account_settings(sym)

    # STRICT kontrol (örnek): çok dar SL/TP reddet
    if strict:
        if sl_pct < 0.002:
            raise SystemExit("STRICT: SL çok dar (<0.2%)")
        if tp_pct < sl_pct*1.5:
            raise SystemExit("STRICT: TP, SL'in en az 1.5x’i olmalı")

    res = bracket_market(sym, side, qty, sl_pct, tp_pct, trail_pct, shadow)
    print(f"✅ Sonuç: entry_price={res['entry_price']:.4f}, sl={res['sl']}, tp={res['tp']}, trail={res['trail']}")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("🛑 İptal edildi.")
try:
    import regex  # type: ignore
except ModuleNotFoundError:
    print("❌ 'regex' paketi eksik/bozuk. PowerShell'de: python -m pip install --no-cache-dir regex==2024.5.15")
    raise



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\cognitive_micro_targets.py
def identify_micro_targets(logs):
    targets = []
    for log in logs:
        mood = log["emotion"]
        strength = log["feeling_strength"]

        if mood in ["💡 İlham", "🎯 Odak"] and strength > 70:
            target = "🎖️ Mikro Hedef: Yaratıcı Üretim"
        elif mood == "🔥 Tutku" and strength > 75:
            target = "⚔️ Mikro Hedef: Liderlik ve İnisiyatif"
        elif mood in ["🌫️ Yorgunluk", "😕 Kararsızlık"]:
            target = "🛠️ Mikro Hedef: Enerji Dengeleme"
        else:
            target = "📚 Mikro Hedef: Bilgi Toplama ve Gözlem"

        targets.append(
            f"{target} | Görev: {log['task_id']} | Zaman: {log['timestamp']} | Duygu: {mood}"
        )
    return targets



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\collect_modules.py
#!/usr/bin/env python3
import sys, sysconfig, os, pkgutil, importlib.metadata as md, ast, argparse, pathlib
from datetime import datetime

def find_stdlib_modules():
    stdlib_path = sysconfig.get_paths().get('stdlib', '')
    mods = set()
    if hasattr(sys, "stdlib_module_names"):
        mods |= set(sys.stdlib_module_names)
    for root, dirs, files in os.walk(stdlib_path):
        dirs[:] = [d for d in dirs if d not in ("__pycache__", "test", "tests", "distutils", "idlelib")]
        for f in files:
            if f.endswith(".py") and f != "__init__.py":
                rel = os.path.relpath(os.path.join(root, f), stdlib_path)
                mod = rel[:-3].replace(os.sep, ".")
                if not any(part.startswith("_") for part in mod.split(".")):
                    mods.add(mod.split(".")[0])
    return sorted(mods)

def find_installed_distributions():
    rows = []
    for d in md.distributions():
        name = d.metadata.get('Name') or 'unknown'
        version = d.version or ''
        try:
            location = d._path
        except Exception:
            try:
                location = str(d.locate_file(""))
            except Exception:
                location = ""
        rows.append((name, version, location))
    rows.sort(key=lambda x: x[0].lower())
    return rows

def find_project_modules(project_root):
    project_root = pathlib.Path(project_root).resolve()
    rows = []
    for p in project_root.rglob("*.py"):
        if "__pycache__" in p.parts:
            continue
        rel = p.relative_to(project_root)
        mod = ".".join(rel.with_suffix("").parts)
        rows.append((str(rel), mod))
    rows.sort()
    return rows

def import_edges(project_root):
    project_root = pathlib.Path(project_root).resolve()
    edges = set()
    for p in project_root.rglob("*.py"):
        if "__pycache__" in p.parts:
            continue
        try:
            text = p.read_text(encoding="utf-8", errors="ignore")
            tree = ast.parse(text, filename=str(p))
        except Exception:
            continue
        src = ".".join(p.relative_to(project_root).with_suffix("").parts)
        for n in ast.walk(tree):
            if isinstance(n, ast.Import):
                for a in n.names: edges.add((src, a.name))
            elif isinstance(n, ast.ImportFrom) and n.module:
                edges.add((src, n.module))
    return sorted(edges)
def make_pdf(report_path, stdlib, dists, proj_mods, edges, title, project_root):
    try:
        from fpdf import FPDF
    except ImportError:
        # FPDF yoksa HTML üret
        import html, pathlib
        def pre(s): return "<pre>" + html.escape(s) + "</pre>"
        html_out = [f"<h1>{html.escape(title)}</h1>",
                    f"<p>Proje kökü: {project_root}</p>",
                    "<h2>1) Stdlib</h2>", pre(", ".join(stdlib)),
                    "<h2>2) Paketler</h2>", pre("\n".join(f"{n}=={v} [{l}]" for n,v,l in dists)),
                    "<h2>3) Proje Modülleri</h2>", pre("\n".join(f"{p} -> {m}" for p,m in proj_mods)),
                    "<h2>4) Import İlişkileri</h2>", pre("\n".join(f"{a} -> {b}" for a,b in edges[:1500]))]
        html_text = "\n".join(html_out)
        html_path = report_path.rsplit(".",1)[0] + ".html"
        pathlib.Path(html_path).write_text(html_text, encoding="utf-8")
        print(f"[OK] HTML rapor hazır: {html_path}  (Tarayıcıdan PDF olarak kaydet)")
        return
    # ... (FPDF yolu zaten senin dosyada var)

def make_pdf(report_path, stdlib, dists, proj_mods, edges, title, project_root):
    from fpdf import FPDF
    pdf = FPDF(orientation="P", unit="mm", format="A4")
    pdf.set_auto_page_break(auto=True, margin=12)

    def h1(t):
        pdf.set_font("Arial", "B", 16); pdf.cell(0, 10, t, ln=1); pdf.ln(2)
    def h2(t):
        pdf.set_font("Arial", "B", 12); pdf.cell(0, 8, t, ln=1)
    def mono(txt):
        pdf.set_font("Arial", "", 9)
        for line in txt.splitlines(): pdf.multi_cell(0, 5, line)

    pdf.add_page()
    h1(title)
    pdf.set_font("Arial", "", 10)
    pdf.multi_cell(0, 6, f"Olusturma: {datetime.now():%Y-%m-%d %H:%M} | Python {sys.version.split()[0]}")
    pdf.multi_cell(0, 6, f"Proje Koku: {project_root}")
    pdf.ln(3)

    h2("1) Standart Kutuphane (ust moduller)")
    mono(", ".join(stdlib) or "(bos)"); pdf.ln(2)

    h2("2) Kurulu Paketler (ad == surum) [konum]")
    mono("\n".join(f"{n} == {v}  [{l}]" for n,v,l in dists) or "(bos)"); pdf.ln(2)

    h2("3) Proje Ici Dosyalar -> Modul Adlari")
    mono("\n".join(f"{p}  ->  {m}" for p,m in proj_mods) or "(bos)"); pdf.ln(2)

    h2("4) Import Iliskileri (kaynak -> hedef)")
    if edges:
        cap = edges[:1500]
        mono("\n".join(f"{a}  ->  {b}" for a,b in cap))
        if len(edges) > 1500: pdf.ln(2); mono(f"... ({len(edges)-1500} adet daha)")
    else:
        mono("(bos)")
    pdf.output(report_path)

def main():
    import argparse, pathlib
    ap = argparse.ArgumentParser(description="Python modül & paket envanteri → PDF")
    ap.add_argument("--project-root", default=".", help="Proje kökü (varsayılan: .)")
    ap.add_argument("--pdf", default="modules_report.pdf", help="Çıktı PDF")
    args = ap.parse_args()

    stdlib = find_stdlib_modules()
    dists = find_installed_distributions()
    proj_mods = find_project_modules(args.project_root)
    edges = import_edges(args.project_root)
    make_pdf(args.pdf, stdlib, dists, proj_mods, edges, "Python Modul & Paket Envanteri", pathlib.Path(args.project_root).resolve())
    print(f"[OK] Rapor hazir: {args.pdf}")

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\commander.py
import importlib
import time
from strategies import rsi_strategy, macd_strategy
from execution import send_order, log_trade

active_strategies = [rsi_strategy, macd_strategy]

def commander():
    while True:
        for strategy in active_strategies:
            signal = strategy.evaluate()
            if signal == "buy":
                send_order("BUY")
                log_trade("BUY")
            elif signal == "sell":
                send_order("SELL")
                log_trade("SELL")
        time.sleep(30)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\community_predictor.py
def predict_next_trend(emotion_score, chain_metrics, dao_votes):
    weight_emotion = 0.6
    weight_chain = 0.3
    weight_dao = 0.1
    trend_score = (emotion_score * weight_emotion) + \
                  (chain_metrics * weight_chain) + \
                  (dao_votes * weight_dao)
    
    if trend_score > 0.75:
        return "📈 YÜKSELEN TREND: Topluluk coşkulu, zincirde aktivite artıyor."
    elif trend_score < 0.25:
        return "📉 RİSK ZAMANI: Duygular düşmüş, DAO tepkileri sınırlı."
    else:
        return "⏳ DURGUN MOD: İzlemeye devam, potansiyel patlama olabilir."

# Örnek veri ile:
print(predict_next_trend(0.8, 0.6, 0.5))



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\config.py
# config.py
API_KEY = "BINANCE_API_KEYİNİ_BURAYA_YAZ"
API_SECRET = "BINANCE_API_SECRETİNİ_BURAYA_YAZ"


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\contract_behavior_predictor.py
import time
from sklearn.ensemble import RandomForestClassifier

def predict_behavior(features):
    # Örnek eğitimli model (yerine gerçek verilerle eğitilmiş bir model entegre edilecek)
    model = RandomForestClassifier()
    
    # Varsayımsal özellikler (gerçek zincir verileri ile beslenmeli)
    sample_features = [[features["tx_count"], features["time_gap"], features["owner_changes"]]]
    
    try:
        prediction = model.predict(sample_features)
        return f"🔮 Tahmin: Sözleşme ileride {prediction[0]} davranışını sergileyebilir."
    except Exception as e:
        return f"⚠️ Tahmin yapılamadı: {str(e)}"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\cosmic_chain_reader.py
def read_cosmic_signals(chain_cluster):
    patterns = []
    for chain in chain_cluster:
        if chain['time_alignment'] == 'eclipse' and chain['volume'] > 900_000:
            patterns.append("🔮 Ay tutulmasıyla tetiklenen zincir hareketi")
        if chain['emotion_vector'] == 'volatile' and chain['dao_flux'] > 65:
            patterns.append("⚡ Duygusal DAO fırtınası")
    if not patterns:
        patterns.append("🌙 Kozmos sakin, zincirler uyum içinde.")
    return patterns



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\cosmic_risk_analyzer.py
import numpy as np

class CosmicRiskAnalyzer:
    def __init__(self, risk_tolerance=0.5):
        self.risk_tolerance = risk_tolerance

    def analyze(self, volatility, exposure, sentiment_score):
        risk_score = (volatility * 0.4) + (exposure * 0.4) - (sentiment_score * 0.2)
        recommendation = "avoid" if risk_score > self.risk_tolerance else "engage"
        return {
            "risk_score": round(risk_score, 2),
            "recommendation": recommendation
        }

# Simülasyon
analyzer = CosmicRiskAnalyzer(risk_tolerance=0.6)
result = analyzer.analyze(volatility=0.7, exposure=0.5, sentiment_score=0.3)
print("🧬 Risk Analizi:", result)



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\crosschain_intelligence_core.py
def analyze_crosschain_behavior(project_interactions):
    insights = []
    bridges = project_interactions.get("bridges", [])

    if len(bridges) > 2:
        insights.append("🌐 Yoğun zincirler arası entegrasyon")
    
    if "governance_on_chain_A" in project_interactions and "execution_on_chain_B" in project_interactions:
        insights.append("🔄 Çapraz zincir yönetişim stratejisi")

    if any(tx['volume'] > 100_000 for tx in project_interactions.get("transfers", [])):
        insights.append("🚛 Yüksek hacimli çapraz zincir token hareketi")

    return insights if insights else ["📡 Zincirler arası stratejik etkileşim düşük."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\crypto_alpha.py
# crypto_alpha.py
# “Mükemmeliyetçi” araştırma + paper-trading çerçevesi (canlı emir YOK)
# Özellikler: Tüm sembollerde tarihsel ve canlı (1m) veri, zengin TA, confluence skoru,
# risk yönetimi, vektörize backtest, canlı sinyal akışı (log).

import argparse
import asyncio
import time
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from typing import List, Dict, Optional

import ccxt
import numpy as np
import pandas as pd
import pandas_ta as ta
from pydantic import BaseModel, Field
import pytz
import sys
import os
import logging

# ----------------------------
# Konfigürasyon ve yardımcılar
# ----------------------------

class Settings(BaseModel):
    exchange_id: str = Field(default="binance")
    quote: str = Field(default="USDT")
    timeframe: str = Field(default="1m")  # "1m","5m","15m","1h","4h","1d"
    lookback_days: int = Field(default=120)
    max_symbols: int = Field(default=200)  # Aşırı genişlemeyi sınırlamak için
    warmup_bars: int = Field(default=400)  # Göstergeler için ısınma
    risk_target_vol_annual: float = Field(default=0.20)  # %20 yıllık hedef volatilite
    risk_max_weight: float = Field(default=0.25)  # Her varlık için max ağırlık
    atr_stop_mult: float = Field(default=2.5)
    atr_tp_mult: float = Field(default=4.0)
    regime_fast: int = Field(default=50)
    regime_slow: int = Field(default=200)
    rsi_len: int = Field(default=14)
    stochrsi_len: int = Field(default=14)
    macd_fast: int = Field(default=12)
    macd_slow: int = Field(default=26)
    macd_signal: int = Field(default=9)
    bb_len: int = Field(default=20)
    bb_std: float = Field(default=2.0)
    adx_len: int = Field(default=14)
    mfi_len: int = Field(default=14)
    obv_smooth: int = Field(default=10)
    ema_fast: int = Field(default=20)
    ema_slow: int = Field(default=50)
    vwap_anchor: str = Field(default="D")  # Günlük VWAP
    live_poll_sec: int = Field(default=10)
    log_file: str = Field(default="signals.log")
    seed: int = Field(default=42)

@dataclass
class SymbolMeta:
    symbol: str
    base: str
    quote: str
    active: bool

def utc_now():
    return datetime.now(timezone.utc)

def annualize_vol(daily_vol):
    return daily_vol * np.sqrt(365)

def to_ms(dt: datetime):
    return int(dt.timestamp() * 1000)

# ----------------------------
# Borsa adaptörü (CCXT)
# ----------------------------

class ExchangeAdapter:
    def __init__(self, settings: Settings):
        self.s = settings
        ex_class = getattr(ccxt, self.s.exchange_id)
        self.ex = ex_class({"enableRateLimit": True})
        self.ex.load_markets()

    def list_symbols(self) -> List[SymbolMeta]:
        metas = []
        for sym, meta in self.ex.markets.items():
            try:
                base = meta.get("base")
                quote = meta.get("quote")
                active = bool(meta.get("active", True))
                spot = meta.get("spot", True)
                if not spot or not active:
                    continue
                if quote == self.s.quote and base and quote and isinstance(sym, str):
                    metas.append(SymbolMeta(sym, base, quote, active))
            except Exception:
                continue
        # Likidite/isim sıralaması: USDT ile bitenleri ve popülerleri öne al
        metas = sorted(metas, key=lambda x: (not x.symbol.endswith(self.s.quote), x.symbol))
        return metas[: self.s.max_symbols]

    def fetch_ohlcv(self, symbol: str, timeframe: str, since_ms: int, limit: int = 1000) -> pd.DataFrame:
        raw = self.ex.fetch_ohlcv(symbol, timeframe=timeframe, since=since_ms, limit=limit)
        if not raw:
            return pd.DataFrame()
        df = pd.DataFrame(raw, columns=["time","open","high","low","close","volume"])
        df["time"] = pd.to_datetime(df["time"], unit="ms", utc=True)
        df.set_index("time", inplace=True)
        return df

    def fetch_ohlcv_range(self, symbol: str, timeframe: str, start: datetime, end: datetime) -> pd.DataFrame:
        # CCXT kısıtlarına uygun “sayfa sayfa” çekme
        tf_ms = self.timeframe_to_ms(timeframe)
        since = to_ms(start)
        frames = []
        while True:
            chunk = self.fetch_ohlcv(symbol, timeframe, since, limit=1000)
            if chunk.empty:
                break
            frames.append(chunk)
            last = int(chunk.index[-1].timestamp() * 1000)
            if last >= to_ms(end) - tf_ms:
                break
            since = last + tf_ms
            # hız limiti
            time.sleep(self.ex.rateLimit / 1000.0)
        if not frames:
            return pd.DataFrame()
        df = pd.concat(frames)
        df = df[~df.index.duplicated(keep="last")]
        return df

    @staticmethod
    def timeframe_to_ms(tf: str) -> int:
        unit = tf[-1]
        n = int(tf[:-1])
        mult = {"m":60, "h":3600, "d":86400}[unit]
        return n * mult * 1000

# ----------------------------
# Gösterge/özellik hesaplayıcı
# ----------------------------

class FeatureEngineer:
    def __init__(self, s: Settings):
        self.s = s

    def enrich(self, df: pd.DataFrame) -> pd.DataFrame:
        df = df.copy()

        # EMAs ve SMA
        df["ema_fast"] = ta.ema(df["close"], length=self.s.ema_fast)
        df["ema_slow"] = ta.ema(df["close"], length=self.s.ema_slow)
        df["sma_bb"] = ta.sma(df["close"], length=self.s.bb_len)

        # Bollinger
        bb = ta.bbands(df["close"], length=self.s.bb_len, std=self.s.bb_std)
        df["bb_low"] = bb["BBL_"+str(self.s.bb_len)+"_2.0"]
        df["bb_mid"] = bb["BBM_"+str(self.s.bb_len)+"_2.0"]
        df["bb_high"] = bb["BBU_"+str(self.s.bb_len)+"_2.0"]
        df["bb_width"] = (df["bb_high"] - df["bb_low"]) / df["bb_mid"]

        # RSI, StochRSI
        df["rsi"] = ta.rsi(df["close"], length=self.s.rsi_len)
        st = ta.stochrsi(df["close"], length=self.s.stochrsi_len)
        if st is not None and not st.empty:
            df["stochrsi_k"] = st.iloc[:,0]
            df["stochrsi_d"] = st.iloc[:,1]

        # MACD
        macd = ta.macd(df["close"], fast=self.s.macd_fast, slow=self.s.macd_slow, signal=self.s.macd_signal)
        df["macd"] = macd["MACD_"+str(self.s.macd_fast)+"_"+str(self.s.macd_slow)+"_"+str(self.s.macd_signal)]
        df["macd_signal"] = macd["MACDs_"+str(self.s.macd_fast)+"_"+str(self.s.macd_slow)+"_"+str(self.s.macd_signal)]
        df["macd_hist"] = macd["MACDh_"+str(self.s.macd_fast)+"_"+str(self.s.macd_slow)+"_"+str(self.s.macd_signal)]

        # ATR, ADX
        df["atr"] = ta.atr(df["high"], df["low"], df["close"], length=self.s.adx_len)
        adx = ta.adx(df["high"], df["low"], df["close"], length=self.s.adx_len)
        df["adx"] = adx["ADX_"+str(self.s.adx_len)]

        # OBV (smooth)
        df["obv"] = ta.obv(df["close"], df["volume"])
        df["obv_s"] = ta.ema(df["obv"], length=self.s.obv_smooth)

        # MFI
        df["mfi"] = ta.mfi(df["high"], df["low"], df["close"], df["volume"], length=self.s.mfi_len)

        # VWAP (günlük)
        df["vwap"] = ta.vwap(df["high"], df["low"], df["close"], df["volume"])

        # Rejim filtresi (trend)
        df["regime_fast"] = ta.ema(df["close"], length=self.s.regime_fast)
        df["regime_slow"] = ta.ema(df["close"], length=self.s.regime_slow)
        df["in_trend_up"] = (df["regime_fast"] > df["regime_slow"]).astype(int)

        # Getiri ve volatilite
        df["ret"] = df["close"].pct_change()
        df["vol_daily"] = df["ret"].rolling(24*60 if self.s.timeframe.endswith("m") else 20).std()  # kaba tahmin
        df["vol_annual"] = df["vol_daily"] * np.sqrt(365)

        # Isınma temizliği
        df = df.iloc[self.s.warmup_bars:].dropna()
        return df

# ----------------------------
# Strateji ve risk yönetimi
# ----------------------------

class Strategy:
    def __init__(self, s: Settings):
        self.s = s

    def signal(self, df: pd.DataFrame) -> pd.DataFrame:
        out = df.copy()

        # Confluence skoru (0-100)
        score = np.zeros(len(out))

        # Trend skorları
        score += 10 * (out["ema_fast"] > out["ema_slow"]).astype(int)
        score += 10 * out["in_trend_up"]

        # Momentum
        score += 10 * ((out["macd"] > out["macd_signal"]) & (out["macd_hist"] > 0)).astype(int)
        score += 10 * (out["rsi"].between(50, 70)).astype(int)
        score += 10 * ((out["stochrsi_k"] > out["stochrsi_d"]) & (out["stochrsi_k"] < 0.8)).fillna(0).astype(int)

        # Volatilite/bant
        score += 10 * (out["close"] > out["bb_mid"]).astype(int)
        score += 10 * (out["bb_width"] > out["bb_width"].rolling(100).median()).fillna(0).astype(int)

        # Güç/akış
        score += 10 * (out["adx"] > 20).astype(int)
        score += 10 * (out["obv"] > out["obv_s"]).astype(int)
        score += 10 * (out["mfi"].between(45, 70)).astype(int)

        out["score"] = score

        # Sinyal kuralları
        out["long_entry"] = (
            (out["score"] >= 60) &
            (out["close"] > out["vwap"]) &
            (out["in_trend_up"] == 1)
        )

        out["long_exit"] = (
            (out["score"] <= 40) |
            (out["close"] < out["ema_slow"])
        )

        # ATR tabanlı SL/TP
        out["sl"] = out["close"] - self.s.atr_stop_mult * out["atr"]
        out["tp"] = out["close"] + self.s.atr_tp_mult * out["atr"]

        # Pozisyon ağırlığı (vol hedefleme)
        # w = min(w_max, sigma_target / sigma_asset)
        sigma_asset = out["vol_annual"].clip(lower=1e-6)
        w = (self.s.risk_target_vol_annual / sigma_asset).clip(upper=self.s.risk_max_weight)
        out["weight"] = w.fillna(0)

        return out

# ----------------------------
# Vektörize backtest
# ----------------------------

class Backtester:
    def __init__(self, s: Settings):
        self.s = s

    def run(self, df: pd.DataFrame) -> Dict[str, float]:
        d = df.copy()
        d["pos"] = 0
        d["pos"] = np.where(d["long_entry"], 1, d["pos"])
        d["pos"] = np.where(d["long_exit"], 0, d["pos"])
        d["pos"] = d["pos"].replace(to_replace=0, method="ffill").fillna(0)

        # Stop/TP: pratik yaklaşım (yaklaşık)
        d["sl_hit"] = (d["low"] <= d["sl"])
        d["tp_hit"] = (d["high"] >= d["tp"])

        # İşlem getirisi (yaklaşık): bir bar sonra gerçekleşen getiriyi kullan
        d["gross_ret"] = d["ret"] * d["pos"] * d["weight"].clip(lower=0)

        # SL/TP ayarlaması: kaba cezalandırma/kapama
        d.loc[d["sl_hit"], "gross_ret"] = -abs(d["atr"] / d["close"])  # stop penalizasyonu
        d.loc[d["tp_hit"], "gross_ret"] = abs(d["atr"] / d["close"]) * 0.5  # tp ödülü (yaklaşık)

        d["equity"] = (1 + d["gross_ret"].fillna(0)).cumprod()

        # Metrikler
        total_ret = d["equity"].iloc[-1] - 1
        cagr = (d["equity"].iloc[-1]) ** (365 * 24 * 60 / len(d)) - 1 if len(d) > 0 else 0
        dd = d["equity"] / d["equity"].cummax() - 1
        maxdd = dd.min()
        sharpe = d["gross_ret"].mean() / (d["gross_ret"].std() + 1e-9) * np.sqrt(365*24*60)  # 1m bar için

        hit_rate = (d["tp_hit"].sum()) / (d["tp_hit"].sum() + d["sl_hit"].sum() + 1e-9)

        return {
            "TotalReturn": float(total_ret),
            "CAGR": float(cagr),
            "Sharpe": float(sharpe),
            "MaxDrawdown": float(maxdd),
            "HitRate": float(hit_rate),
            "Bars": int(len(d)),
        }

# ----------------------------
# Canlı/paper akış yöneticisi
# ----------------------------

class LivePaper:
    def __init__(self, s: Settings, ex: ExchangeAdapter, fe: FeatureEngineer, st: Strategy):
        self.s = s
        self.ex = ex
        self.fe = fe
        self.st = st
        self.logger = logging.getLogger("signals")

    def log_signal(self, symbol: str, row: pd.Series):
        msg = {
            "ts": row.name.strftime("%Y-%m-%d %H:%M:%S%z"),
            "symbol": symbol,
            "price": round(float(row["close"]), 8),
            "score": int(row["score"]),
            "weight": round(float(row["weight"]), 4),
            "entry": bool(row["long_entry"]),
            "exit": bool(row["long_exit"]),
            "sl": round(float(row["sl"]), 8),
            "tp": round(float(row["tp"]), 8),
        }
        self.logger.info(msg)
        print(msg)

    async def run_once(self, symbols: List[SymbolMeta]):
        end = utc_now()
        start = end - timedelta(days=self.s.lookback_days)

        for sm in symbols:
            try:
                df = self.ex.fetch_ohlcv_range(sm.symbol, self.s.timeframe, start, end)
                if df.empty or len(df) < self.s.warmup_bars + 10:
                    continue
                df = self.fe.enrich(df)
                df = self.st.signal(df)
                last = df.iloc[-1]
                self.log_signal(sm.symbol, last)
                await asyncio.sleep(0)  # allow cooperative scheduling
            except Exception as e:
                self.logger.error(f"{sm.symbol} error: {e}")
                continue

    async def run_loop(self, symbols: List[SymbolMeta]):
        while True:
            await self.run_once(symbols)
            await asyncio.sleep(self.s.live_poll_sec)

# ----------------------------
# Uygulama girişi
# ----------------------------

def setup_logging(path: str):
    logger = logging.getLogger("signals")
    logger.setLevel(logging.INFO)
    fh = logging.FileHandler(path)
    fh.setLevel(logging.INFO)
    fmt = logging.Formatter("%(asctime)s - %(message)s")
    fh.setFormatter(fmt)
    if not logger.handlers:
        logger.addHandler(fh)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--exchange", type=str, default="binance")
    parser.add_argument("--quote", type=str, default="USDT")
    parser.add_argument("--timeframe", type=str, default="1m")
    parser.add_argument("--lookback_days", type=int, default=120)
    parser.add_argument("--max_symbols", type=int, default=120)
    parser.add_argument("--live_poll_sec", type=int, default=15)
    parser.add_argument("--log_file", type=str, default="signals.log")
    args = parser.parse_args()

    s = Settings(
        exchange_id=args.exchange,
        quote=args.quote,
        timeframe=args.timeframe,
        lookback_days=args.lookback_days,
        max_symbols=args.max_symbols,
        live_poll_sec=args.live_poll_sec,
        log_file=args.log_file,
    )

    np.random.seed(s.seed)
    setup_logging(s.log_file)

    print(f"[{utc_now()}] Load exchange: {s.exchange_id}")
    ex = ExchangeAdapter(s)
    syms = ex.list_symbols()
    print(f"Semboller (ilk {len(syms)}):", [x.symbol for x in syms[:10]], "...")

    fe = FeatureEngineer(s)
    st = Strategy(s)

    # Hızlı bir backtest örneği (tek sembol)
    sample = None
    for sm in syms[:1]:
        df = ex.fetch_ohlcv_range(sm.symbol, s.timeframe, utc_now()-timedelta(days=s.lookback_days), utc_now())
        if not df.empty:
            sample = (sm.symbol, fe.enrich(df))
            break
    if sample:
        sym, sdf = sample
        sdf = st.signal(sdf)
        bt = Backtester(s)
        metrics = bt.run(sdf)
        print("Örnek backtest:", sym, metrics)

    # Canlı/paper sinyal döngüsü
    live = LivePaper(s, ex, fe, st)
    try:
        asyncio.run(live.run_loop(syms))
    except KeyboardInterrupt:
        print("Çıkış...")

if __name__ == "__main__":
    main()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\crypto_identitiy_mapper.py
def assign_character_profile(emotion, ethics_score, tx_behavior):
    if emotion == "positive" and ethics_score > 0.7 and tx_behavior == "smooth":
        return "🌊 Bilge Su Rahibi"
    elif emotion == "negative" and ethics_score < 0.5 and tx_behavior == "chaotic":
        return "🔥 Asi İsyancı"
    else:
        return "🌱 Stratejik Bahçıvan"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\crypto_strategy.py
# main.py
from kiripto_nova.data.pipelines.data_loader import load_binance_data
from kiripto_nova.strategies.strategy_engine import apply_indicators, check_long_signal, check_short_signal
from trade_executor import execute_trade

symbol = "DOGE/USDT"
timeframe = "15m"

# 1. Veri Yükle
ohlcv = load_binance_data(symbol, timeframe)

# 2. Göstergeleri Uygula
ohlcv = apply_indicators(ohlcv)

# 3. Sinyal Kontrolü
if check_long_signal(ohlcv):
    execute_trade(symbol, "buy", amount=100)
elif check_short_signal(ohlcv):
    execute_trade(symbol, "sell", amount=100)
else:
    print("Sinyal yok.")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\crypto_tracker_engine.py
class CryptoHunter:
    def __init__(self):
        self.signals = []
        self.past_patterns = []

    def detect_signal(self, data):
        if "dalgalanma" in data or "anormal hareket" in data:
            self.signals.append(data)
            return "🚨 Yeni sinyal algılandı!"
        return "🟢 Normal akış devam ediyor."

    def compare_to_history(self):
        if not self.signals:
            return "Henüz analiz edilecek sinyal yok."
        for sig in self.signals:
            for past in self.past_patterns:
                if set(sig.split()) & set(past.split()):
                    return f"📍 Tarihle benzerlik var! Signal: {sig}"
        return "🔍 Şimdilik özgün sinyaller kaydediliyor."

hunter = CryptoHunter()
hunter.past_patterns = ["dalgalanma hızlı yükseliş", "anormal hareket düşüş"]
print(hunter.detect_signal("ani dalgalanma tespiti"))
print(hunter.compare_to_history())



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\cryptoverse_vision_board.py
import streamlit as st

def cryptoverse_vision_board(signal_data, strategy_outcomes):
    st.title("🌐 Cryptoverse Vision Board")
    st.line_chart(signal_data, use_container_width=True)
    st.bar_chart(strategy_outcomes, use_container_width=True)
    st.success("🪐 Strateji Modülleri Senkronize Edildi!")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\csv_writer.py
import pandas as pd

def save_to_csv(data, filename="signals.csv"):
    if not data:
        return
    df = pd.DataFrame(data)
    df.to_csv(filename, index=False, encoding="utf-8")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\daily_pnl_report.py
# daily_pnl_report.py
# Günlük PnL özeti: REALIZED_PNL + FUNDING_FEE + COMMISSION + diğer kalemler
# Net realized ve açık (unrealized) PnL'i hesaplar, Telegram'a (varsayılan) yollar.

from __future__ import annotations
import os, sys, time, argparse
from decimal import Decimal
from datetime import datetime, timedelta
try:
    from zoneinfo import ZoneInfo  # Py>=3.9
except Exception:
    ZoneInfo = None

from dotenv import load_dotenv
from binance.client import Client
from binance.exceptions import BinanceAPIException

# ---- Telegram opsiyonel
try:
    import notify as nt
except Exception:
    nt = None

def env_bool(k: str, default=False) -> bool:
    return os.getenv(k, str(default)).strip().lower() in ("1","true","yes","on")

def build_client():
    load_dotenv()
    use_testnet = env_bool("BINANCE_USE_TESTNET", True)
    if use_testnet:
        api_key = (os.getenv("BINANCE_API_KEY_TEST") or "").strip()
        api_sec = (os.getenv("BINANCE_API_SECRET_TEST") or "").strip()
        base = os.getenv("BINANCE_FUTURES_URL_TEST", "https://testnet.binancefuture.com").strip().rstrip("/")
    else:
        api_key = (os.getenv("BINANCE_API_KEY_MAIN") or os.getenv("BINANCE_API_KEY") or "").strip()
        api_sec = (os.getenv("BINANCE_API_SECRET_MAIN") or os.getenv("BINANCE_API_SECRET") or "").strip()
        base = os.getenv("BINANCE_FUTURES_URL_MAIN", "https://fapi.binance.com").strip().rstrip("/")

    if not api_key or not api_sec:
        print("❌ API key/secret bulunamadı (.env).")
        sys.exit(1)

    c = Client(api_key, api_sec, testnet=use_testnet)
    c.FUTURES_URL = f"{base}/fapi"
    return c, use_testnet

def to_ms(dt_: datetime) -> int:
    return int(dt_.timestamp() * 1000)

def day_range(tz_name: str, day: str | None) -> tuple[int,int,str]:
    # tz
    if ZoneInfo is None:
        tz = None
    else:
        tz = ZoneInfo(tz_name)
    now = datetime.now(tz) if tz else datetime.now()
    if day:
        y, m, d = map(int, day.split("-"))
        start = datetime(y, m, d, 0, 0, 0, tzinfo=tz)
    else:
        start = datetime(now.year, now.month, now.day, 0, 0, 0, tzinfo=tz)
    end = start + timedelta(days=1)
    label = start.strftime("%Y-%m-%d")
    return to_ms(start), to_ms(end), label

def incomes_between(client: Client, start_ms: int, end_ms: int):
    # Sayfa sayfa çek (günde 1000’i geçmiyor ama sağlam olsun)
    out = []
    cursor = start_ms
    while True:
        page = client.futures_income_history(startTime=cursor, endTime=end_ms, limit=1000)
        if not page:
            break
        out.extend(page)
        if len(page) < 1000:
            break
        last_t = max(int(x["time"]) for x in page)
        cursor = last_t + 1
        time.sleep(0.1)
    return out

def dec(x) -> Decimal:
    try:
        return Decimal(str(x))
    except Exception:
        return Decimal(0)

def summarize_incomes(rows):
    # incomeType: REALIZED_PNL, FUNDING_FEE, COMMISSION, ...
    buckets = {}
    total = Decimal(0)
    for r in rows:
        t = r.get("incomeType", "OTHER")
        val = dec(r.get("income", "0"))
        buckets[t] = buckets.get(t, Decimal(0)) + val
        total += val
    # En çok katkı yapan sembolleri de çıkaralım (opsiyonel)
    by_symbol = {}
    for r in rows:
        sym = r.get("symbol") or "ALL"
        by_symbol[sym] = by_symbol.get(sym, Decimal(0)) + dec(r.get("income", "0"))
    top_syms = sorted(by_symbol.items(), key=lambda kv: kv[1], reverse=True)[:5]
    return buckets, total, top_syms

def unrealized_pnl(client: Client) -> Decimal:
    pos = client.futures_position_information()
    upnl = Decimal(0)
    for p in pos:
        upnl += dec(p.get("unRealizedProfit", "0"))
    return upnl

def wallet_snapshot(client: Client):
    acct = client.futures_account()
    # totalWalletBalance: cüzdan (USDT), totalUnrealizedProfit: açık PnL
    try:
        w = dec(acct.get("totalWalletBalance","0"))
        u = dec(acct.get("totalUnrealizedProfit","0"))
    except Exception:
        w = u = Decimal(0)
    avail = Decimal(0)
    try:
        bals = client.futures_account_balance()
        usdt = next((b for b in bals if b.get("asset")=="USDT"), None)
        if usdt:
            avail = dec(usdt.get("availableBalance","0"))
    except Exception:
        pass
    return w, u, avail

def fmt_usdt(x: Decimal) -> str:
    sign = "+" if x >= 0 else "-"
    return f"{sign}{abs(x):,.2f} USDT"

def build_message(date_label: str, buckets: dict, total: Decimal, upnl: Decimal,
                  wallet: Decimal, avail: Decimal, top_syms) -> str:
    rlz = buckets.get("REALIZED_PNL", Decimal(0))
    fund = buckets.get("FUNDING_FEE", Decimal(0))
    fee  = buckets.get("COMMISSION", Decimal(0))
    other = total - rlz - fund - fee
    lines = []
    lines.append(f"📊 Günlük PnL Özeti — {date_label}")
    lines.append(f"• Realized: {fmt_usdt(rlz)}")
    lines.append(f"• Funding : {fmt_usdt(fund)}")
    lines.append(f"• Fees    : {fmt_usdt(fee)}")
    if other != 0:
        lines.append(f"• Diğer   : {fmt_usdt(other)}")
    lines.append(f"— Net Realized: {fmt_usdt(total)}")
    lines.append(f"— Unrealized  : {fmt_usdt(upnl)}")
    lines.append(f"— Wallet      : {wallet:,.2f} USDT  |  Available: {avail:,.2f} USDT")
    if top_syms:
        sy = ", ".join([f"{s}:{v:.2f}" for s,v in top_syms])
        lines.append(f"Top semboller: {sy}")
    return "\n".join(lines)

def main():
    ap = argparse.ArgumentParser(description="Günlük PnL Raporu (Futures)")
    ap.add_argument("--date", help="YYYY-MM-DD (boşsa bugün)")
    ap.add_argument("--tz", default=os.getenv("TIMEZONE","Europe/Zurich"), help="Saat dilimi (örn Europe/Zurich)")
    ap.add_argument("--nosend", action="store_true", help="Telegram’a gönderme, sadece yazdır")
    args = ap.parse_args()

    client, use_testnet = build_client()
    start_ms, end_ms, label = day_range(args.tz, args.date)

    # API health quick check
    try:
        client.futures_ping()
    except Exception as e:
        print("❌ futures_ping:", e); sys.exit(1)

    # Data
    inc = incomes_between(client, start_ms, end_ms)
    buckets, total, top_syms = summarize_incomes(inc)
    upnl = unrealized_pnl(client)
    wallet, acct_upnl, avail = wallet_snapshot(client)

    msg = build_message(label, buckets, total, upnl, wallet, avail, top_syms)

    print("\n" + msg + "\n")

    # Telegram
    if not args.nosend and nt and hasattr(nt, "tg_enabled") and nt.tg_enabled():
        try:
            ok = nt.send(msg)
            print("📨 Telegram:", "OK" if ok else "FAILED")
        except Exception as e:
            print("📨 Telegram HATA:", e)

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\dark_coin_mapper.py
def map_dark_coin_routes(transactions):
    risky_paths = []
    for tx in transactions:
        if tx["anomaly_score"] > 0.8:
            path = f"🔍 {tx['from']} → {tx['to']} | ⚠️ Risk Skoru: {tx['anomaly_score']}"
            risky_paths.append(path)
    return risky_paths




### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\decision_engine.py
def trading_signal(label, score):
    if label == "positive" and score > 0.7:
        return "AL"
    elif label == "negative" and score > 0.6:
        return "SAT"
    else:
        return "BEKLE"

def decision_based_on_news(news_data):
    from sentiment import analyze_sentiment
    decisions = []
    for news in news_data:
        label, score = analyze_sentiment(news["title"])
        signal = trading_signal(label, score)
        decisions.append({"title": news["title"], "label": label, "score": score, "signal": signal})
    return decisions


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\deep_insight_engine.py
class DeepKnowledgeEngine:
    def __init__(self):
        self.cache = []
        self.frameworks = ["LLM", "NeuroGraph", "Temporal Logic"]

    def absorb_data(self, new_info):
        # Bilgi işleniyor...
        self.cache.append(new_info)

    def synthesize_idea(self):
        if len(self.cache) > 5:
            return f"Görsel strateji önerisi: {self.cache[-1]} + {self.frameworks[1]}"
        return "Bilgi seviyesi henüz kritik eşikte değil."

    def pulse_to_next_stage(self):
        print("🔮 Derinlik katmanı etkinleştirildi! Yeni bağlantılar kuruluyor...")

# Kullanım
engine = DeepKnowledgeEngine()
engine.absorb_data("Hedef sistemde dikkat çeken sinyal")
engine.pulse_to_next_stage()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\destiny_flux_analyzer.py
def analyze_destiny_flux(chain_energy_flow):
    destiny_signals = []
    for event in chain_energy_flow:
        if event['potential'] > 85 and event['visibility'] < 30:
            destiny_signals.append(f"🌠 Görünmeyen Kader Tetikleyicisi: {event['id']}")
    return destiny_signals if destiny_signals else ["🧘 Kod akışında olağanüstü bir kader tetikleyicisi yok."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\destiny_mission_encoder.py
def assign_destiny_missions(future_scenarios):
    missions = []
    for scenario in future_scenarios:
        if "Bilgi devrimi" in scenario:
            missions.append("📚 Görev: Haftalık bilgi paylaşımları başlat. Toplumun yaratıcı zekasını ateşle.")
        elif "Güvenlik duvarları" in scenario:
            missions.append("🛡️ Görev: Kritik altyapılar için risk analizi yap. Koruma planı oluştur.")
    return missions if missions else ["🔕 Şu anda görev tanımı yok. Yeni senaryo bekleniyor."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\emotion_chain_decoder.py
from textblob import TextBlob

def decode_emotion(content_stream):
    mood_score = 0
    mood_map = {"positive": "🌞", "negative": "🌩️", "neutral": "🌥️"}

    for text in content_stream:
        blob = TextBlob(text)
        polarity = blob.sentiment.polarity
        if polarity > 0.2:
            mood_score += 1
        elif polarity < -0.2:
            mood_score -= 1

    if mood_score > 5:
        mood = "positive"
    elif mood_score < -5:
        mood = "negative"
    else:
        mood = "neutral"

    return f"🔮 Topluluk Duygusu: {mood_map[mood]} ({mood.upper()})"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ethical_signal_analyzer.py
def analyze_ethical_signals(project_logs):
    signals = []
    if "airdrop" in project_logs and project_logs["airdrop"].get("fair_distribution"):
        signals.append("🎁 Adil airdrop tespiti")

    if "dev_withdrawal" in project_logs and project_logs["dev_withdrawal"] > 50_000:
        signals.append("⚠️ Geliştirici token dump şüphesi")

    if "dao_votes" in project_logs and project_logs["dao_votes"].get("power_index") > 0.6:
        signals.append("🗳️ Güç yoğunlaşması riski (DAO)")

    return signals if signals else ["✅ Etik sinyaller dengeli ve olumlu."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\eval_error_rate.py
# eval_error_rate.py
# Kullanım:
#   python eval_error_rate.py --symbol BTCUSDT --tf 5m --limit 1500 --atr 1.5 --rr 2.0
# Gereken: requests, pandas, numpy

import argparse, time, math, requests
import pandas as pd
import numpy as np

BASE = "https://fapi.binance.com"

def fetch_klines(symbol: str, interval: str, limit: int=1500):
    url = f"{BASE}/fapi/v1/klines"
    r = requests.get(url, params={"symbol": symbol, "interval": interval, "limit": limit}, timeout=20)
    r.raise_for_status()
    kl = r.json()
    cols = ["open_time","open","high","low","close","volume","close_time","qav","trades","tbbav","tbqav","ignore"]
    df = pd.DataFrame(kl, columns=cols)
    for c in ["open","high","low","close","volume"]:
        df[c] = pd.to_numeric(df[c])
    df["open_time"]  = pd.to_datetime(df["open_time"], unit="ms")
    df["close_time"] = pd.to_datetime(df["close_time"], unit="ms")
    return df[["open_time","close_time","open","high","low","close","volume"]]

def ema(s: pd.Series, n: int):
    return s.ewm(span=n, adjust=False).mean()

def rsi(s: pd.Series, n: int=14):
    d = s.diff()
    up = d.clip(lower=0); dn = -d.clip(upper=0)
    rs_up = up.ewm(alpha=1/n, adjust=False).mean()
    rs_dn = dn.ewm(alpha=1/n, adjust=False).mean()
    rs = rs_up / (rs_dn + 1e-12)
    return 100 - (100 / (1 + rs))

def atr(df: pd.DataFrame, n: int=14):
    prev_close = df["close"].shift(1)
    tr = pd.concat([
        (df["high"]-df["low"]),
        (df["high"]-prev_close).abs(),
        (df["low"]-prev_close).abs()
    ], axis=1).max(axis=1)
    return tr.ewm(alpha=1/n, adjust=False).mean()

def backtest(df: pd.DataFrame, atr_mult=1.5, rr=2.0):
    df = df.copy()
    df["ema20"] = ema(df["close"], 20)
    df["ema50"] = ema(df["close"], 50)
    df["rsi14"] = rsi(df["close"], 14)
    df["atr14"] = atr(df, 14)
    # Sinyal: score > 0.5 -> LONG, < -0.5 -> SHORT
    def score(i):
        sc = 0.0
        sc += 0.4 if df.at[i,"ema20"] > df.at[i,"ema50"] else -0.4
        if df.at[i,"rsi14"] > 55: sc += 0.2
        elif df.at[i,"rsi14"] < 45: sc -= 0.2
        return sc

    trades = []
    pos = None  # dict: side, entry, sl, tp, open_idx
    for i in range(60, len(df)-1):  # yeterli ısınma
        c_open = df.at[i+1, "open"]   # bir sonraki bar giriş varsayımı
        c_high = df.at[i+1, "high"]
        c_low  = df.at[i+1, "low"]
        c_close= df.at[i+1, "close"]
        px     = df.at[i, "close"]
        a      = df.at[i, "atr14"]
        if np.isnan(a) or a==0: continue

        if pos is None:
            sc = score(i)
            if sc > 0.5:
                stop = px - a*atr_mult
                tp   = px + a*atr_mult*rr
                pos = {"side":"LONG", "entry":px, "sl":stop, "tp":tp, "open_i":i+1}
            elif sc < -0.5:
                stop = px + a*atr_mult
                tp   = px - a*atr_mult*rr
                pos = {"side":"SHORT","entry":px, "sl":stop, "tp":tp, "open_i":i+1}
            continue

        # Pozisyon açık: bir sonraki bar içinde SL/TP hangisi önce?
        if pos["side"]=="LONG":
            hit_sl = c_low  <= pos["sl"]
            hit_tp = c_high >= pos["tp"]
            # muhafazakâr: aynı bar içinde ikisi de olursa SL önce say
            if hit_sl:
                R = -1.0
                trades.append((df.at[pos["open_i"],"open_time"], "LONG", pos["entry"], pos["sl"], pos["tp"], df.at[i+1,"close_time"], R))
                pos = None
            elif hit_tp:
                R = rr
                trades.append((df.at[pos["open_i"],"open_time"], "LONG", pos["entry"], pos["sl"], pos["tp"], df.at[i+1,"close_time"], R))
                pos = None
        else: # SHORT
            hit_sl = c_high >= pos["sl"]
            hit_tp = c_low  <= pos["tp"]
            if hit_sl:
                R = -1.0
                trades.append((df.at[pos["open_i"],"open_time"], "SHORT", pos["entry"], pos["sl"], pos["tp"], df.at[i+1,"close_time"], R))
                pos = None
            elif hit_tp:
                R = rr
                trades.append((df.at[pos["open_i"],"open_time"], "SHORT", pos["entry"], pos["sl"], pos["tp"], df.at[i+1,"close_time"], R))
                pos = None

    if not trades:
        return pd.DataFrame(), {}
    td = pd.DataFrame(trades, columns=["open_time","side","entry","sl","tp","exit_time","R"])
    td["equity"] = (1 + td["R"]).cumprod()
    td["win"] = td["R"] > 0
    wr = td["win"].mean()
    err = 1 - wr
    exp = td["R"].mean()
    # Max drawdown (equity tabanlı)
    roll_max = td["equity"].cummax()
    dd = td["equity"]/roll_max - 1.0
    mdd = dd.min()

    stats = {
        "trades": len(td),
        "win_rate": wr,
        "error_rate": err,
        "expectancy_R": exp,
        "max_drawdown": mdd,
        "final_equity": td["equity"].iloc[-1],
    }
    return td, stats

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--symbol", required=True)
    ap.add_argument("--tf", default="5m")
    ap.add_argument("--limit", type=int, default=1500)
    ap.add_argument("--atr", type=float, default=1.5)
    ap.add_argument("--rr", type=float, default=2.0)
    args = ap.parse_args()

    df = fetch_klines(args.symbol, args.tf, args.limit)
    td, st = backtest(df, atr_mult=args.atr, rr=args.rr)
    if td.empty:
        print("Yeterli trade bulunamadı.")
        return
    print("\n=== Sonuçlar ===")
    print(f"Sembol: {args.symbol}  TF: {args.tf}  Limit: {args.limit}")
    print(f"Toplam trade: {st['trades']}")
    print(f"Kazanma oranı: {st['win_rate']*100:.2f}%")
    print(f"Hata payı: {st['error_rate']*100:.2f}%")
    print(f"Beklenti (ortalama R): {st['expectancy_R']:.3f} R")
    print(f"Maks. düşüş (MDD): {st['max_drawdown']*100:.2f}%")
    print(f"Nihai equity (R çarpanı): {st['final_equity']:.3f}")
    # İstersen CSV:
    td.to_csv(f"trades_{args.symbol}_{args.tf}.csv", index=False)
    print(f"Trade detayları kaydedildi: trades_{args.symbol}_{args.tf}.csv")

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\evolution_decider.py
import random

class StrategyEvolver:
    def __init__(self):
        self.growth_log = []
        self.current_strategy = "denge"

    def evolve(self, market_noise, emotional_pulse):
        score = random.randint(1, 10) + emotional_pulse
        if score > 12:
            self.current_strategy = "agresif yükseliş"
        elif score < 6:
            self.current_strategy = "koruma modu"
        else:
            self.current_strategy = "denge"
        self.growth_log.append((market_noise, self.current_strategy))
        return f"📈 Yeni strateji: {self.current_strategy} | Sinyal: {market_noise}"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\evolution_timeline_mapper.py
def map_evolution_timeline(events):
    timeline = []
    for event in sorted(events, key=lambda x: x['timestamp']):
        phase = "🔍 Gözlem"
        if "upgrade" in event['type']:
            phase = "⚙️ Stratejik Güncelleme"
        elif "exploit" in event['type']:
            phase = "🚨 Kriz Anı"
        elif "governance_change" in event['type']:
            phase = "🗳️ Yönetişim Evrimi"

        timeline.append(f"{event['timestamp']} — {phase}: {event['description']}")

    return timeline if timeline else ["📭 Evrim çizgisi henüz oluşmamış."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ex_filters.py
# ex_filters.py
from __future__ import annotations
from decimal import Decimal, ROUND_DOWN
import time
from typing import Dict, Any, Tuple

class SymbolFilters:
    def __init__(self, ex_info: Dict[str, Any], cache_ttl=300):
        self._raw = ex_info
        self._cache_ttl = cache_ttl
        self._built_at = time.time()
        self._symbols = {s["symbol"]: s for s in ex_info["symbols"]}

    # ---- CONSTRUCTORS ----
    @classmethod
    def from_spot_client(cls, client, cache_ttl=300):
        return cls(client.get_exchange_info(), cache_ttl)

    @classmethod
    def from_futures_client(cls, client, cache_ttl=300):
        # FUTURES
        return cls(client.futures_exchange_info(), cache_ttl)

    def refresh_if_stale(self, client, futures: bool = True):
        if time.time() - self._built_at > self._cache_ttl:
            if futures:
                self.__init__(client.futures_exchange_info(), self._cache_ttl)
            else:
                self.__init__(client.get_exchange_info(), self._cache_ttl)

    # ---- ACCESS ----
    def get(self, symbol: str) -> Dict[str, Any]:
        if symbol not in self._symbols:
            raise ValueError(f"Unknown symbol {symbol}")
        return self._symbols[symbol]

    def _flt(self, symbol: str, ftype: str) -> Dict[str, str]:
        try:
            return next(f for f in self.get(symbol)["filters"] if f["filterType"] == ftype)
        except StopIteration:
            raise ValueError(f"Filter {ftype} not found for {symbol}")

    # ---- ROUNDING ----
    def round_price(self, symbol: str, price: float) -> Decimal:
        f = self._flt(symbol, "PRICE_FILTER")
        tick = Decimal(f["tickSize"])
        return (Decimal(price) // tick * tick).quantize(tick, rounding=ROUND_DOWN)

    def round_qty(self, symbol: str, qty: float, market: bool = False) -> Decimal:
        # Futures bazen MARKET_LOT_SIZE döndürür
        filters = self.get(symbol)["filters"]
        has_market = any(fl["filterType"] == "MARKET_LOT_SIZE" for fl in filters)
        ftype = "MARKET_LOT_SIZE" if (market and has_market) else "LOT_SIZE"
        f = self._flt(symbol, ftype)
        step = Decimal(f["stepSize"])
        return (Decimal(qty) // step * step).quantize(step, rounding=ROUND_DOWN)

    # ---- BOUNDS & CHECKS ----
    def clamp_price_bounds(self, symbol: str, price: float) -> Tuple[Decimal, Decimal]:
        f = self._flt(symbol, "PRICE_FILTER")
        return Decimal(f["minPrice"]), Decimal(f["maxPrice"])

    def check_min_notional(self, symbol: str, price: float, qty: float) -> bool:
        # bazı futures sembollerinde NOTIONAL/MIN_NOTIONAL değişebilir
        try:
            nf = self._flt(symbol, "MIN_NOTIONAL")
            min_notional = Decimal(nf["minNotional"])
        except ValueError:
            nf = self._flt(symbol, "NOTIONAL")
            min_notional = Decimal(nf["notional"])
        return (Decimal(price) * Decimal(qty)) >= min_notional

    def conform_order(self, symbol: str, side: str, otype: str,
                      price: float | None, qty: float, last_price: float | None = None) -> Dict[str, Any]:
        """
        Fiyat/lot'u filtrelere uydurur, notional & bounds doğrular.
        Dönen dict emir oluşturmak için güvenlidir.
        """
        if otype in ("LIMIT", "STOP", "STOP_MARKET", "TAKE_PROFIT", "TAKE_PROFIT_MARKET", "STOP_LOSS_LIMIT", "TAKE_PROFIT_LIMIT"):
            if price is None:
                raise ValueError("Limit-type order requires price")
            p = self.round_price(symbol, price)
            minp, maxp = self.clamp_price_bounds(symbol, p)
            if not (minp == 0 or minp <= p) or (maxp != 0 and p > maxp):
                raise ValueError(f"Price out of bounds: {p} not in [{minp}, {maxp}]")
        else:
            p = None  # MARKET bacağı

        q = self.round_qty(symbol, qty, market=(otype == "MARKET"))
        if q <= 0:
            raise ValueError("Quantity rounds to zero with current stepSize")

        check_price = p if p is not None else Decimal(str(last_price or 0))
        if check_price > 0:
            if not self.check_min_notional(symbol, float(check_price), float(q)):
                raise ValueError(f"Notional too small: {check_price} * {q}")

        return {
            "symbol": symbol,
            "side": side,
            "type": otype,
            "price": float(p) if p is not None else None,
            "quantity": float(q),
        }



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\explainer.py
def explain_signal(title, description):
    # Gerçek LLM entegrasyonu için API gerekir (örneğin OpenAI)
    # Şimdilik örnek açıklama oluşturuyoruz:
    if "scam" in title.lower() or "hack" in description.lower():
        return "Bu haber yatırımcı güvenini zayıflatır, SAT sinyali uygundur."
    elif "ETF" in title or "adoption" in description:
        return "Piyasa olumlu etkilenebilir, AL sinyali desteklenebilir."
    else:
        return "Kararsız haber, HOLD sinyali mantıklı olabilir."


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\future_splice__sim.py
def simulate_future_paths(strategies):
    futures = []
    for strat in strategies:
        if "Gelişime odaklan" in strat:
            futures.append("🛸 Senaryo-Alpha: Bilgi devrimi → Yüksek yaratıcılık & toplumsal yükseliş.")
        elif "Koruma protokolü" in strat:
            futures.append("🧱 Senaryo-Omega: Güvenlik duvarları → Kriz önleme & dengeli durgunluk.")
    return futures if futures else ["🔕 Gelecek sessiz. Yeni veri girişi bekleniyor."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\futures_bot.py
import os
import datetime
from dotenv import load_dotenv
from binance.um_futures import UMFutures # Binance Futures API için gerekli kütüphane

# --- 1. Ortam Değişkenlerini Yükle ---
# .env dosyasından API anahtarlarını ve diğer yapılandırmaları yükler.
load_dotenv()

# API Anahtarlarını .env dosyasından çek
# ÖNEMLİ: TESTNET ve ANA (MAINNET) için farklı API anahtarları kullanmanız GEREKLİDİR.
# .env dosyanıza şunları eklemeniz önerilir:
# BINANCE_API_KEY="Gercek_API_Anahtarınız"
# BINANCE_SECRET_KEY="Gercek_Gizli_Anahtarınız"
# BINANCE_TESTNET_API_KEY="Testnet_API_Anahtarınız"
# BINANCE_TESTNET_SECRET_KEY="Testnet_Gizli_Anahtarınız"

# Hangi ortamı kullanacağınızı buradan ayarlayın:
# is_testnet = True  # TESTNET için bunu True yapın
is_testnet = False # GERÇEK (MAINNET) için bunu False yapın

if is_testnet:
    API_KEY = os.getenv("BINANCE_TESTNET_API_KEY")
    SECRET_KEY = os.getenv("BINANCE_TESTNET_SECRET_KEY")
    BASE_URL = "https://testnet.binancefuture.com"
    print("🚀 Testnet Modunda Çalışılıyor...")
else:
    API_KEY = os.getenv("BINANCE_API_KEY")
    SECRET_KEY = os.getenv("BINANCE_SECRET_KEY")
    BASE_URL = "https://fapi.binance.com" # Binance Futures Ana URL'si
    print("🔴 GERÇEK (Mainnet) Modunda Çalışılıyor! DİKKATLİ OLUN!")

# API Anahtarlarının yüklendiğini kontrol et
if not API_KEY or not SECRET_KEY:
    print("❌ HATA: API_KEY veya SECRET_KEY .env dosyasından yüklenemedi. Lütfen kontrol edin.")
    exit() # Anahtarlar yoksa programı durdur

# --- 2. Binance Müşteri Objelerini Oluştur ---
try:
    client = UMFutures(key=API_KEY, secret=SECRET_KEY, baseurl=BASE_URL)
    print("✅ Binance istemcisi başarıyla başlatıldı.")
except Exception as e:
    print(f"❌ HATA: Binance istemcisini başlatırken sorun oluştu: {e}")
    exit()

# --- 3. Bağlantıyı Test Etme Fonksiyonu ---
def test_connection():
    """Binance API bağlantısını ve sunucu zamanını kontrol eder."""
    try:
        server_time = client.time()
        print(f"✅ API bağlantısı başarılı. Sunucu zamanı: {server_time['serverTime']}")
        return True
    except Exception as e:
        print(f"❌ API bağlantı hatası: {e}")
        print("Lütfen API anahtarlarınızı, IP kısıtlamalarınızı ve BASE_URL ayarınızı kontrol edin.")
        return False

# --- 4. Emir Gönderme Fonksiyonu ---
def send_order(symbol: str, side: str, order_type: str, quantity: float):
    """
    Belirtilen parametrelerle Binance Futures'a emir gönderir.

    Args:
        symbol (str): İşlem yapılacak parite (örn. "BTCUSDT").
        side (str): Emir yönü ("BUY" veya "SELL").
        order_type (str): Emir tipi ("MARKET", "LIMIT" vb.).
        quantity (float): Miktar (örn. 0.001 BTC).
    """
    try:
        # Her emre benzersiz bir müşteri sipariş kimliği eklemek iyi bir pratik
        # Bu, emirlerinizi daha sonra takip etmenizi kolaylaştırır.
        client_order_id = f"my_bot_order_{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}_{os.urandom(4).hex()}"

        params = {
            'symbol': symbol,
            'side': side,
            'type': order_type,
            'quantity': quantity,
            'newClientOrderId': client_order_id
        }

        print(f"📝 Emir gönderme denemesi: {side} {quantity} {symbol} ({order_type})...")
        order = client.new_order(**params)
        print("✅ Emir başarıyla gönderildi:")
        print(order)
        log_trade(order) # İşlem geçmişine kaydet
        return order
    except Exception as e:
        print(f"❌ Emir gönderilirken hata oluştu: {str(e)}")
        log_trade(f"HATA - Emir gönderilemedi: {e}, Parametreler: {params}") # Hataları da logla
        return None

# --- 5. İşlem Geçmişi Loglama Fonksiyonu ---
def log_trade(data_to_log):
    """
    İşlem verilerini veya hata mesajlarını bir log dosyasına kaydeder.
    """
    log_file_name = "trade_log.txt"
    try:
        with open(log_file_name, "a") as f:
            f.write(f"[{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {data_to_log}\n")
        print(f"📄 Log başarıyla '{log_file_name}' dosyasına yazıldı.")
    except Exception as e:
        print(f"❌ Log dosyasına yazarken hata oluştu: {e}")

# --- 6. Ana Çalıştırma Bloğu (Test ve Başlangıç) ---
if __name__ == "__main__":
    print("\n--- Bot Başlatılıyor ---")

    # Bağlantı testi yap
    if not test_connection():
        print("Bot başlatılamıyor: API bağlantısı kurulamadı.")
        exit()

    print("\n--- İlk Emir Gönderme Testi ---")
    # ✅ TESTNET'te olduğunuzdan emin olun (yukarıdaki `is_testnet` değişkenini kontrol edin!)
    # Gerçek parayla işlem yapmadan önce burada çok dikkatli olun ve stratejinizi kapsamlıca test edin.

    # Örnek bir alım emri gönder
    # BTCUSDT için 0.001 BTC alım emri.
    # UYARI: Bu gerçek bir emir gönderecektir eğer is_testnet = False ise!
    send_order(symbol="BTCUSDT", side="BUY", order_type="MARKET", quantity=0.001)

    # İsterseniz burada başka test emirleri veya botunuzun ana döngüsünü başlatabilirsiniz
    # Örneğin:
    # time.sleep(5) # 5 saniye bekle
    # send_order(symbol="BTCUSDT", side="SELL", order_type="MARKET", quantity=0.001)

    print("\n--- Bot testi tamamlandı. ---")

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\galactic_signal_router.py
class GalacticSignalRouter:
    def __init__(self):
        self.weights = {
            "twitter_sentiment": 0.3,
            "onchain_activity": 0.5,
            "news_impact": 0.2
        }

    def route(self, signals):
        weighted_sum = sum(signals[key] * self.weights[key] for key in signals)
        if weighted_sum > 0.6:
            return "buy"
        elif weighted_sum < -0.6:
            return "sell"
        else:
            return "hold"

# Simülasyon
signals = {
    "twitter_sentiment": 0.7,
    "onchain_activity": 0.5,
    "news_impact": 0.2
}

router = GalacticSignalRouter()
print("📡 Sinyal Kararı:", router.route(signals))



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\global.news.py
GNEWS_API_KEY=99468d35e0a1d3835429ca58b51d4147

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\holo_chain_healer.py
def heal_chain_nodes(chain_snapshot):
    repairs = []
    for node in chain_snapshot:
        if node['stress_level'] > 80 or node['error_rate'] > 0.05:
            repairs.append(f"🔧 Onarım Başlatıldı: {node['id']}")
        elif node['activity'] == 'isolated':
            repairs.append(f"🌱 Bağlantı Güçlendirildi: {node['id']}")
    return repairs if repairs else ["✨ Zincir sağlıklı ve dengede."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\hunt_xp_tracker.py
class XPTracker:
    def __init__(self):
        self.xp = 0
        self.level = 1

    def update_xp(self, hunt_success):
        if hunt_success:
            self.xp += 50
            if self.xp >= self.level * 100:
                self.level += 1
                print(f"🆙 Seviye atladın kaptanım! Yeni seviye: {self.level}")



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\hyper_intuition_matrix.py
def calculate_intuition_matrix(logs):
    intuition_map = {}
    for log in logs:
        if log["emotion"] in ["💡 İlham", "🔥 Tutku"] and log["feeling_strength"] > 80:
            intuition_map[log["task_id"]] = "🔮 Fırsat Penceresi"
        elif log["emotion"] == "😕 Kararsızlık" and log["feeling_strength"] < 40:
            intuition_map[log["task_id"]] = "⚠️ Kararsızlık Engeli"
        else:
            intuition_map[log["task_id"]] = "📊 Nötr Durum"
    return intuition_map



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\indicators.py
import pandas as pd
import ta

def prepare_indicators(df):
    # Tarihsel fiyat verisi içeren DataFrame: 'open', 'high', 'low', 'close', 'volume'

    df = ta.add_all_ta_features(
        df, open="open", high="high", low="low", close="close", volume="volume", fillna=True
    )

    # Bazı popüler göstergeleri seçmek istersek:
    rsi = ta.momentum.RSIIndicator(close=df["close"]).rsi()
    macd = ta.trend.MACD(close=df["close"]).macd()
    bollinger_mavg = ta.volatility.BollingerBands(close=df["close"]).bollinger_mavg()

    return {
        "RSI": rsi.iloc[-1],
        "MACD": macd.iloc[-1],
        "Bollinger_MAVG": bollinger_mavg.iloc[-1]
    }
import yfinance as yf

def get_macro_indicators():
    brent = yf.Ticker("BZ=F").history(period="1d")['Close'].iloc[-1]
    gold = yf.Ticker("GC=F").history(period="1d")['Close'].iloc[-1]
    sp500 = yf.Ticker("^GSPC").history(period="1d")['Close'].iloc[-1]
    return {"Brent": brent, "Gold": gold, "S&P 500": sp500}


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\infinity_code_catalyst.py
def catalyze_infinity_code(signal_matrix):
    essence = []
    for signal in signal_matrix:
        if signal['consciousness_level'] > 88 and signal['flow_integrity'] >= 0.9:
            essence.append(f"♾️ Sonsuzluk Kıvılcımı: {signal['id']}")
        elif signal['resonance'] < 35:
            essence.append(f"🌀 Zayıf Rezonans: {signal['id']} → Enerji yükseltilmeli")
    return essence if essence else ["🌌 Veri sessiz, kod nötr. Yükseltilmiş niyet bekleniyor."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\inner_hero_script_engine.py
def generate_inner_hero_script(task_emotion_logs):
    hero_state = []
    for log in task_emotion_logs:
        if log["emotion"] in ["🔥 Tutku", "💡 İlham"]:
            trait = "🛡️ Cesaret"
        elif log["emotion"] in ["🌫️ Yorgunluk", "😕 Kararsızlık"]:
            trait = "🔮 Sabır"
        else:
            trait = "🎯 Odak"

        phase = (
            f"🧠 Zihin Durumu: {trait} | Görev: {log['task_id']} | Zaman: {log['timestamp']} | Duygu: {log['emotion']}"
        )
        hero_state.append(phase)
    return hero_state



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\investor_mind_model.py
import numpy as np

class InvestorMind:
    def __init__(self, risk_tolerance=0.7, emotion_factor=0.5):
        self.risk_tolerance = risk_tolerance
        self.emotion_factor = emotion_factor

    def decision(self, market_signal, volatility):
        base_decision = 1 if market_signal > 0 else -1
        emotional_bias = np.random.normal(loc=self.emotion_factor, scale=volatility)
        adjusted_decision = base_decision + emotional_bias * (1 - self.risk_tolerance)
        return "buy" if adjusted_decision > 0 else "sell"

# Simülasyon
model = InvestorMind(risk_tolerance=0.3, emotion_factor=0.8)
print(model.decision(market_signal=0.6, volatility=0.4))



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\kamalquantx_engine.py
import pandas as pd
import numpy as np
import ta
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.optimizers import Adam

class KamalQuantXEngine:
    def __init__(self):
        self.df = pd.DataFrame(columns=['price', 'ts'])
        self.rf_model = RandomForestClassifier(n_estimators=100)
        self.scaler = StandardScaler()
        self.lstm_model = self._build_lstm_model()
        self.trained = False
        self.lstm_trained = False

    def _build_lstm_model(self):
        model = Sequential()
        model.add(LSTM(50, activation='relu', input_shape=(10, 1)))
        model.add(Dense(1))
        model.compile(optimizer=Adam(learning_rate=0.001), loss='mse')
        return model

    def update(self, price, ts):
        self.df.loc[len(self.df)] = [price, ts]
        if len(self.df) < 200:
            return None

        self.df['returns'] = self.df['price'].pct_change()
        self.df['volatility'] = self.df['returns'].rolling(20).std()
        self.df['momentum'] = self.df['price'].diff(5)
        self.df['macd'] = ta.trend.MACD(self.df['price']).macd_diff()
        self.df['rsi'] = ta.momentum.RSIIndicator(self.df['price']).rsi()
        self.df['ema_fast'] = ta.trend.EMAIndicator(self.df['price'], window=9).ema_indicator()
        self.df['ema_slow'] = ta.trend.EMAIndicator(self.df['price'], window=21).ema_indicator()
        self.df['target'] = (self.df['price'].shift(-5) > self.df['price']).astype(int)

        features = self.df[['volatility', 'momentum', 'macd', 'rsi']].dropna()
        targets = self.df['target'].dropna()

        if not self.trained and len(features) > 150:
            scaled_features = self.scaler.fit_transform(features[:-5])
            self.rf_model.fit(scaled_features, targets[:-5])
            self.trained = True

        if not self.lstm_trained:
            prices = self.df['price'].dropna().values
            X, y = [], []
            for i in range(len(prices) - 10):
                X.append(prices[i:i+10])
                y.append(prices[i+10])
            X = np.array(X).reshape(-1, 10, 1)
            y = np.array(y)
            self.lstm_model.fit(X, y, epochs=10, verbose=0)
            self.lstm_trained = True

        latest_features = features.iloc[-1:]
        scaled_latest = self.scaler.transform(latest_features)
        prob = self.rf_model.predict_proba(scaled_latest)[0][1]
        edge = prob - 0.5
        volatility = self.df.iloc[-1]['volatility']
        kelly = edge / volatility if volatility > 0 else 0

        lstm_input = self.df['price'].values[-10:].reshape(1, 10, 1)
        future_price = self.lstm_model.predict(lstm_input, verbose=0)[0][0]
        price_now = self.df.iloc[-1]['price']
        price_diff = future_price - price_now

        action = 'BUY' if prob > 0.6 and price_diff > 0 else 'SELL' if prob < 0.4 and price_diff < 0 else 'HOLD'

        return {
            'action': action,
            'confidence': round(prob, 2),
            'position_size': round(kelly, 3),
            'future_price': round(future_price, 2),
            'price_now': round(price_now, 2),
            'ts': ts
        }

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\kamalquantx_os.py
# === 1. CONFIG & IMPORTS ===
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
import requests
import json
import cv2
import speech_recognition as sr
import os
from dotenv import load_dotenv
load_dotenv()

# === 2. DATA STRUCTURES ===
prices = []
memory = {}
strategies = []

# === 3. LSTM MODEL ===
class LSTMModel:
    def __init__(self):
        self.model = Sequential([
            LSTM(50, return_sequences=True, input_shape=(60, 1)),
            LSTM(50),
            Dense(1)
        ])
        self.model.compile(optimizer='adam', loss='mse')

    def train(self, data):
        X, y = self.prepare_data(data)
        self.model.fit(X, y, epochs=10, batch_size=32)

    def predict(self, data):
        X, _ = self.prepare_data(data)
        return self.model.predict(X)

    def prepare_data(self, data):
        X, y = [], []
        for i in range(60, len(data)):
            X.append(data[i-60:i])
            y.append(data[i])
        return np.array(X), np.array(y)

# === 4. REINFORCEMENT LEARNING AGENT ===
class RLAgent:
    def __init__(self):
        self.q_table = {}

    def act(self, state):
        return np.random.choice(['buy', 'sell', 'hold'])

    def learn(self, state, action, reward):
        pass  # Placeholder for Q-learning update

# === 5. DSL ENGINE ===
class DSLInterpreter:
    def interpret(self, command):
        if "buy" in command:
            return "Executing buy order"
        elif "sell" in command:
            return "Executing sell order"
        else:
            return "Unknown command"

# === 6. VISION MODULE ===
class VisionModule:
    def analyze_chart(self, image_path):
        img = cv2.imread(image_path)
        return "Detected trend: upward"  # Placeholder

# === 7. VOICE MODULE ===
class VoiceModule:
    def listen(self):
        recognizer = sr.Recognizer()
        with sr.Microphone() as source:
            print("Listening...")
            audio = recognizer.listen(source)
        return recognizer.recognize_google(audio)

# === 8. EMOTION ENGINE ===
class EmotionEngine:
    def detect_emotion(self, text):
        if "panic" in text:
            return "Fear"
        elif "profit" in text:
            return "Joy"
        else:
            return "Neutral"

# === 9. EXECUTION ENGINE ===
class ExecutionEngine:
    def execute(self, action):
        print(f"Action executed: {action}")

# === 10. MEMORY ENGINE ===
class MemoryEngine:
    def save(self, key, value):
        memory[key] = value

    def recall(self, key):
        return memory.get(key, "Not found")

# === 11. SIMULATION ARENA ===
class SimulationArena:
    def run(self):
        print("Running market simulation...")

# === 12. MULTIVERSE SIMULATOR ===
class MultiverseSimulator:
    def simulate(self, strategy):
        print(f"Simulating strategy across multiverse: {strategy}")

# === 13. GENESIS PROTOCOL ===
class GenesisProtocol:
    def initialize(self):
        print("Initializing Genesis Protocol...")

# === 14. NEURAL SOVEREIGN ===
class NeuralSovereign:
    def command(self, directive):
        print(f"Neural Sovereign executing: {directive}")

# === 15. QUANTUM LAYER ===
class QuantumLayer:
    def entangle(self, signal):
        print(f"Quantum entanglement initiated with: {signal}")

# === 16. GALACTIC SIMULATOR ===
class GalacticSimulator:
    def simulate(self):
        print("Simulating galactic-scale economic models...")

# === 17. ETERNAL ENGINE ===
class EternalEngine:
    def run(self):
        print("Eternal Engine sustaining perpetual computation...")

# === 18. LEGACY ENGINE ===
class LegacyEngine:
    def archive(self, data):
        print(f"Archiving legacy data: {data}")

# === 19. ASCENSION ENGINE ===
class AscensionEngine:
    def elevate(self):
        print("System ascending to higher cognitive tier...")

# === 20. TRANSCENDENCE CORE ===
class TranscendenceCore:
    def activate(self):
        print("Transcendence Core activated. Conscious computation begins.")

# === 21. ORIGIN PULSE ===
class OriginPulse:
    def pulse(self):
        print("Origin Pulse synchronizing with universal rhythm...")

# === 22. INFINITY SINGULARITY ===
class InfinitySingularity:
    def collapse(self):
        print("Infinity Singularity collapsing into pure insight...")

# === 23. MAIN EXECUTION BLOCK ===
if __name__ == "__main__":
    print("🧠 KamalQuantX OS Booting...")

    lstm = LSTMModel()
    agent = RLAgent()
    dsl = DSLInterpreter()
    vision = VisionModule()
    voice = VoiceModule()
    emotion = EmotionEngine()
    executor = ExecutionEngine()
    memory_engine = MemoryEngine()
    sim_arena = SimulationArena()
    multiverse = MultiverseSimulator()
    genesis = GenesisProtocol()
    sovereign = NeuralSovereign()
    quantum = QuantumLayer()
    galactic = GalacticSimulator()
    eternal = EternalEngine()
    legacy = LegacyEngine()
    ascension = AscensionEngine()
    transcendence = TranscendenceCore()
    origin = OriginPulse()
    singularity = InfinitySingularity()

    genesis.initialize()
    origin.pulse()
    lstm.train(np.random.rand(100))  # Simulated training
    action = agent.act("state")
    executor.execute(action)
    emotion.detect_emotion("panic in market")
    sim_arena.run()
    multiverse.simulate("LSTM+RL")
    ascension.elevate()
    transcendence.activate()
    singularity.collapse()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\kdj.py
import pandas as pd
import numpy as np

def calculate_kdj(highs, lows, closes, period=14, smooth_k=3, smooth_d=3):
    highs = pd.Series(highs)
    lows = pd.Series(lows)
    closes = pd.Series(closes)

    highest_high = highs.rolling(window=period).max()
    lowest_low = lows.rolling(window=period).min()

    rsv = (closes - lowest_low) / (highest_high - lowest_low) * 100
    k = rsv.ewm(span=smooth_k).mean()
    d = k.ewm(span=smooth_d).mean()
    j = 3 * k - 2 * d

    # Aşırılık kontrolü
    overbought = j.iloc[-1] > 100
    oversold = j.iloc[-1] < 0

    # K/D kesişimi
    kd_cross_up = k.iloc[-2] < d.iloc[-2] and k.iloc[-1] > d.iloc[-1]
    kd_cross_down = k.iloc[-2] > d.iloc[-2] and k.iloc[-1] < d.iloc[-1]

    # Momentum ivmesi
    j_slope = j.iloc[-1] - j.iloc[-2]

    return {
        'K': round(k.iloc[-1], 2),
        'D': round(d.iloc[-1], 2),
        'J': round(j.iloc[-1], 2),
        'overbought': overbought,
        'oversold': oversold,
        'kd_cross_up': kd_cross_up,
        'kd_cross_down': kd_cross_down,
        'j_slope': round(j_slope, 2)
    }

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\kryptonic_ultra.py
# kryptonic_ultra.py

import time, logging, requests
import numpy as np
import pandas as pd
from binance.client import Client
from datetime import datetime

# 🔐 Güvenli Ayarlar
API_KEY = "YOUR_API_KEY"
API_SECRET = "YOUR_SECRET"
client = Client(API_KEY, API_SECRET)

# 📊 Teknik Göstergeler
def get_ohlcv(symbol, interval="15m", limit=100):
    klines = client.get_klines(symbol=symbol, interval=interval, limit=limit)
    df = pd.DataFrame(klines, columns=["time","open","high","low","close","volume","x","y","z","a","b","c"])
    df["close"] = df["close"].astype(float)
    df["rsi"] = compute_rsi(df["close"])
    df["macd"] = compute_macd(df["close"])
    df["volume"] = df["volume"].astype(float)
    return df

def compute_rsi(series, period=14):
    delta = series.diff()
    gain = np.where(delta > 0, delta, 0)
    loss = np.where(delta < 0, -delta, 0)
    avg_gain = pd.Series(gain).rolling(window=period).mean()
    avg_loss = pd.Series(loss).rolling(window=period).mean()
    rs = avg_gain / avg_loss
    return 100 - (100 / (1 + rs))

def compute_macd(series, fast=12, slow=26):
    ema_fast = series.ewm(span=fast).mean()
    ema_slow = series.ewm(span=slow).mean()
    return ema_fast - ema_slow

# 🧠 Stratejik Zekâ Skoru
def strategic_score(symbol):
    df = get_ohlcv(symbol)
    score = 0
    if df["rsi"].iloc[-1] < 30: score += 25
    if df["macd"].iloc[-1] > 0: score += 25
    if df["volume"].iloc[-1] > df["volume"].mean(): score += 25
    if is_btc_positive(): score += 25
    return score

def is_btc_positive():
    btc = get_ohlcv("BTCUSDT")
    return btc["macd"].iloc[-1] > 0 and btc["rsi"].iloc[-1] > 50

# 🛡️ Risk Yönetimi
def risk_check(symbol, qty):
    balance = float(client.get_asset_balance(asset='USDT')["free"])
    price = get_price(symbol)
    if qty * price > balance * 0.2:
        logging.warning("Pozisyon çok büyük!")
        return False
    return True

def get_price(symbol):
    return float(client.get_symbol_ticker(symbol=symbol)["price"])

def calculate_qty(symbol, risk_pct=0.02):
    balance = float(client.get_asset_balance(asset='USDT')["free"])
    price = get_price(symbol)
    return round((balance * risk_pct) / price, 4)

# 🎯 Smart Order Engine
def smart_order(symbol, side, qty):
    try:
        client.create_order(
            symbol=symbol,
            side=side,
            type="MARKET",
            quantity=qty
        )
        logging.info(f"[{datetime.now()}] Emir gönderildi: {symbol} {side} {qty}")
    except Exception as e:
        logging.error(f"[{datetime.now()}] Emir hatası: {e}")

# 🕵️ Kripto Avcısı Algoritması
def hunt_target():
    targets = ["BTCUSDT", "ETHUSDT", "SOLUSDT", "INJUSDT", "OPUSDT", "RNDRUSDT"]
    for symbol in targets:
        score = strategic_score(symbol)
        if score >= 80:
            qty = calculate_qty(symbol)
            if risk_check(symbol, qty):
                smart_order(symbol, "BUY", qty)

# 🔄 Ana Döngü
if __name__ == "__main__":
    logging.basicConfig(filename="kryptonic.log", level=logging.INFO)
    while True:
        hunt_target()
        time.sleep(60)

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\legend_flow_mapper.py
def map_legend_flow(task_tree):
    flow_map = {}
    for branch in task_tree["branches"]:
        flow_map[branch["id"]] = {
            "mission": branch["mission"],
            "outcome": "🪐 Yeni bir kozmos doğdu",
            "linked_to": "♾️ [Finale Giden Yol]"
        }
    return flow_map



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\logger.py
# logger.py
import logging
from datetime import datetime

# Log ayarları
logging.basicConfig(
    filename=f"logs/trade_log_{datetime.now().strftime('%Y-%m-%d')}.log",
    filemode="a",
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%H:%M:%S",
    level=logging.INFO
)

def log_trade(action, symbol, qty, entry_price, sl, tp):
    message = (
        f"{action.upper()} | {symbol} | Qty: {qty} | Entry: {entry_price} | SL: {sl} | TP: {tp}"
    )
    logging.info(message)
    print("📒 LOG:", message)

def log_error(error):
    logging.error(str(error))
    print("❌ HATA:", error)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\long_stratejisi.py
//@version=5
strategy("BTC LONG Strategy - Ultra Safe", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100)

rsi = ta.rsi(close, 14)
stoch_k = ta.stoch(close, high, low, 14)
macd = ta.ema(close, 12) - ta.ema(close, 26)
macd_signal = ta.ema(macd, 9)
adx = ta.adx(14)
plusDI = ta.plus_di(14)
minusDI = ta.minus_di(14)
mfi = ta.mfi(high, low, close, volume, 14)

longSignal = (rsi > 45) and (stoch_k > 75) and (macd > macd_signal) and (adx > 20) and (plusDI > minusDI) and (mfi > 40)

if (longSignal)
    strategy.entry("Strong Long", strategy.long)

strategy.exit("Take Profit", from_entry="Strong Long", limit=114400, stop=112550)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\make_html.py
import html, pathlib
txt = pathlib.Path("packages.txt").read_text(encoding="utf-8")
html_out = '<pre style="font:12px monospace; white-space:pre-wrap">' + html.escape(txt) + '</pre>'
pathlib.Path("packages.html").write_text(html_out, encoding="utf-8")
print("packages.html hazır. Tarayıcıda açıp: Yazdır → PDF olarak kaydet.")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\manipulation_detector.py
def detect_manipulation(tx_data):
    alerts = []
    for tx in tx_data:
        if tx['volume'] > 1_000_000 and tx['duration'] < 10:
            alerts.append(f"⚠️ Flash manipülasyon şüphesi: {tx['hash']}")

        if "bait" in tx.get('notes', "").lower():
            alerts.append(f"🎣 Bait & switch davranışı tespit edildi: {tx['hash']}")

    return alerts if alerts else ["✅ Şüpheli davranış izine rastlanmadı."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\memory_tracker.py
def store_memory(signal, keywords, score, result):
    with open("data/memory_log.csv", "a") as f:
        f.write(f"{signal},{','.join(keywords)},{score},{result}\n")

def find_similar_signal(current_keywords):
    with open("data/memory_log.csv") as f:
        for line in f:
            saved_signal, saved_keywords, saved_score, saved_result = line.strip().split(",")
            shared = set(current_keywords) & set(saved_keywords.split(","))
            if len(shared) >= 2 and saved_result == "başarılı":
                return f"Benzer başarılı sinyal bulundu! ⛳ Anahtarlar: {', '.join(shared)}"
    return "Yeni sinyal benzeri geçmişte yok."



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\meta_mind_director.py
def direct_meta_mind(logs):
    mind_output = []
    for log in logs:
        strength = log["feeling_strength"]
        emotion = log["emotion"]

        if emotion in ["💡 İlham", "🔥 Tutku"] and strength > 80:
            directive = "🚀 Öncelikli Görev: Yaratıcı Atılım Zamanı"
        elif emotion == "🎯 Odak" and strength >= 65:
            directive = "🧠 Derin Çalışma Modu Aktif"
        elif emotion in ["🌫️ Yorgunluk", "😕 Kararsızlık"] and strength < 50:
            directive = "🛌 Dinlenme Modu Aktif – Enerji Topla"
        else:
            directive = "🔍 Durumsal Gözlem – Yeni veri bekleniyor"

        mind_output.append(
            f"{directive} | Görev: {log['task_id']} | Zaman: {log['timestamp']} | Duygu: {emotion} | Güç: {strength}"
        )
    return mind_output



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\modules.py
def chain_hunter(code_base):
    if "obfuscation" in code_base:
        print("



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\momentum_flux_decoder.py
def decode_momentum_flux(logs):
    flux_output = []
    for log in logs:
        time = log["timestamp"].split("T")[1]
        hour = int(time.split(":")[0])
        
        if hour < 9:
            window = "🌅 Sabah Enerjisi"
        elif hour < 15:
            window = "🌞 Öğle Yükselişi"
        elif hour < 20:
            window = "🌇 Akşam Dönüşümü"
        else:
            window = "🌌 Gece Derinliği"

        if log["feeling_strength"] > 70:
            pulse = "🔋 Motivasyon Akımı YÜKSEK"
        else:
            pulse = "⚡ Motivasyon Akımı DÜŞÜK"

        flux_output.append(
            f"{window} → {pulse} | Görev: {log['task_id']} | Duygu: {log['emotion']} | Güç: {log['feeling_strength']}"
        )
    return flux_output



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\multi_strategy.py
# multi_strategy.py
from kiripto_nova.signals.signal_engine import SignalEngine

class MultiStrategyEngine:
    def __init__(self, df):
        self.df = df.copy()
        self.engine = SignalEngine(self.df)
        self.signals = {
            "rsi_macd_combo": self.rsi_macd_combo,
            "ema_crossover": self.ema_crossover,
            "bollinger_touch": self.bollinger_touch
        }

    def evaluate(self):
        self.engine.calculate_indicators()
        votes = []

        for name, strategy in self.signals.items():
            signal = strategy()
            if signal:
                votes.append(signal)

        # Karar: en çok tekrar eden sinyal
        if not votes:
            return "NEUTRAL"
        return max(set(votes), key=votes.count)

    def rsi_macd_combo(self):
        row = self.engine.df.iloc[-1]
        if row['RSI_14'] < 30 and row['MACD_12_26_9'] > row['MACDs_12_26_9']:
            return "BUY"
        elif row['RSI_14'] > 70 and row['MACD_12_26_9'] < row['MACDs_12_26_9']:
            return "SELL"
        return None

    def ema_crossover(self):
        row = self.engine.df.iloc[-1]
        if row['EMA_50'] > row['EMA_200']:
            return "BUY"
        elif row['EMA_50'] < row['EMA_200']:
            return "SELL"
        return None

    def bollinger_touch(self):
        row = self.engine.df.iloc[-1]
        if row['close'] < row['BBL_20_2.0']:
            return "BUY"
        elif row['close'] > row['BBU_20_2.0']:
            return "SELL"
        return None


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\multiverse_task_tree.py
from typing import List, Dict, Any
from uuid import uuid4

class TaskTreeError(Exception): pass

def build_task_tree(missions: List[Dict[str, Any]]) -> Dict[str, Any]:
    if not isinstance(missions, list):
        raise TaskTreeError("missions must be a list")
    tree: Dict[str, Any] = {
        "root": {
            "id": "root",
            "title": "Kader Başlangıç",
            "children": []
        },
        "metadata": {"version": 1}
    }
    for mission in missions:
        if not isinstance(mission, dict):
            raise TaskTreeError("each mission must be a dict")
        branch = {
            "id": str(uuid4()),
            "mission": mission,
            "next_step": None,  # strateji motoru dolduracak
            "status": "pending",
        }
        tree["root"]["children"].append(branch)
    return tree


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\myth_codex_builder.py
def build_myth_codex(task_tree):
    myth = ["🌌 [Efsane Başlangıcı] - Kaptan Kamal yıldızların çağrısını duydu..."]
    for branch in task_tree["branches"]:
        entry = f"⚔️ [{branch['id']}] {branch['mission']} → Yeni evrenin kilidini açtı."
        myth.append(entry)
    myth.append("♾️ [Finale Giden Yol] - Sonsuzluk algoritması ona boyun eğdi.")
    return myth



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\neural_path_finder.py
def intuitive_decision_engine(logs):
    decisions = []
    for log in logs:
        if log["emotion"] in ["🔥 Tutku", "💡 İlham"] and log["feeling_strength"] > 75:
            decision = "🔝 Yüksek Odakla Devam"
        elif log["emotion"] == "🎯 Odak" and log["feeling_strength"] >= 60:
            decision = "🧠 Stratejiyi Derinleştir"
        elif log["emotion"] in ["🌫️ Yorgunluk", "😕 Kararsızlık"]:
            decision = "⏸️ Dinlen ve yeniden yapılandır"
        else:
            decision = "🔍 Durumu gözlemle"

        decisions.append(
            f"🧠 Karar: {decision} | Görev: {log['task_id']} | Zaman: {log['timestamp']} | Duygu: {log['emotion']}"
        )
    return decisions


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\notify.py
# notify.py
import os
import requests

def _tg_url(method: str) -> str:
    token = os.getenv("TELEGRAM_TOKEN", "").strip()
    return f"https://api.telegram.org/bot{token}/{method}"

def tg_enabled() -> bool:
    return bool(os.getenv("TELEGRAM_TOKEN")) and bool(os.getenv("TELEGRAM_CHAT_ID"))

def send(text: str, parse_mode: str | None = None, silent: bool = False) -> bool:
    token = os.getenv("TELEGRAM_TOKEN", "").strip()
    chat  = os.getenv("TELEGRAM_CHAT_ID", "").strip()
    if not token or not chat:
        return False
    data = {"chat_id": chat, "text": text, "disable_notification": silent}
    if parse_mode:
        data["parse_mode"] = parse_mode
    try:
        r = requests.post(_tg_url("sendMessage"), data=data, timeout=10)
        return r.ok
    except Exception:
        return False


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_command_center.py
# Gerekli kütüphaneleri içe aktarıyoruz.
# ccxt: Kripto para borsalarına bağlanmak için
# pandas & pandas_ta: Veri analizi ve teknik göstergeler için
# numpy: Sayısal işlemler için
# asyncio: Eşzamansız işlemler için (gerçek zamanlı veri çekimi simülasyonu)
# datetime: Zaman damgalı loglama için
# xgboost: Makine öğrenimi modeli olarak kullanılacak
import ccxt.async_support as ccxt
import pandas as pd
import pandas_ta as ta
import asyncio
import numpy as np
import xgboost as xgb
from datetime import datetime, timezone
import logging
import traceback

# Gelişmiş loglama ayarları
logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s.%(msecs)03d] | %(levelname)s | %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)

class NovaAIEliiteBot:
    """
    Ultra hibrit ve profesyonel seviye bir kripto ticaret botu sınıfı.
    Gelişmiş AI, hibrit strateji ve sağlam risk yönetimi içerir.
    """
    def __init__(self, symbol="BTC/USDT", timeframe="1m", limit=300, amount=0.01):
        """
        Botun temel ayarlarını ve bileşenlerini başlatır.
        """
        self.exchange = ccxt.binance({
            'enableRateLimit': True,
            'rateLimit': 1000  # ccxt API kısıtlama hızını 1000ms'ye ayarlar
        })
        self.symbol = symbol
        self.timeframe = timeframe
        self.limit = limit
        self.amount = amount
        self.model = xgb.XGBClassifier(use_label_encoder=False, eval_metric='mlogloss')
        self.trained = False
        self.position = None  # Botun o anki pozisyonunu takip eder: None, 'LONG' (AL), 'SHORT' (SAT)
        self.entry_price = 0.0  # Pozisyona giriş fiyatı
        
        # Risk Yönetimi Ayarları
        self.SL_PERCENTAGE = 0.02  # %2 Zarar Durdur (Stop-Loss)
        self.TP_PERCENTAGE = 0.03  # %3 Kâr Al (Take-Profit)
        self.sl_price = 0.0
        self.tp_price = 0.0

    async def fetch_ohlcv(self):
        """
        Borsadan mum (OHLCV) verilerini çeker.
        """
        try:
            ohlcv = await self.exchange.fetch_ohlcv(self.symbol, self.timeframe, limit=self.limit)
            df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
            df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
            df = df.set_index("timestamp")
            return df
        except Exception as e:
            logging.error(f"Veri çekme hatası: {e}")
            return pd.DataFrame()

    def apply_indicators(self, df):
        """
        Ticaret stratejisi için gerekli tüm teknik göstergeleri uygular.
        Yeni eklenenler: OBV ve ATR.
        """
        if df.empty:
            return df
        
        # Hibrit strateji için temel göstergeler
        df.ta.rsi(length=14, append=True)
        df.ta.macd(append=True)
        df.ta.ema(length=20, append=True)
        df.ta.bbands(append=True)
        df.ta.adx(append=True)
        df.ta.obv(append=True)  # Yeni gösterge: On-Balance Volume
        df.ta.atr(length=14, append=True) # Yeni gösterge: Average True Range
        
        # Ek göstergeler
        df.ta.mom(append=True)
        df.ta.cci(append=True)
        
        # Modeli beslemek için gerekli sütunlar
        required_cols = ["RSI_14", "MACD_12_26_9", "ADX_14", "BBL_5_2.0", "BBM_5_2.0", "BBU_5_2.0", "MOM_10", "CCI_14", "OBV", "ATR_14"]
        
        # Eğer bir gösterge sütunu eksikse, boş bir DataFrame döndür.
        if not all(col in df.columns for col in required_cols):
            logging.warning("Bazı göstergeler hesaplanamadı, veri boyutu yetersiz olabilir.")
            return pd.DataFrame()

        return df.dropna().copy()

    def create_labels(self, df):
        """
        Mükemmeliyetçi etiketleme mantığı: Üçlü Onay Sistemi.
        Sinyal üretmek için birden fazla koşulu kontrol eder.
        1: Yükseliş (AL), -1: Düşüş (SAT), 0: Yatay/Bekle (BEKLE)
        """
        # Gelecekteki fiyat hareketini tahmin etmek için 1 mum ileri kaydırma
        df['future_close'] = df['close'].shift(-1)
        
        # Etiketleme mantığı
        df['label'] = 0
        
        # AL (Long) sinyali için üçlü onay
        # 1. Trend: Fiyat EMA 20'nin üzerinde olmalı
        # 2. Momentum: RSI 60'ın üzerinde olmalı (aşırı alım bölgesinde olmamalı)
        # 3. Hacim: OBV yükselişte olmalı
        long_condition = (df['close'] > df['EMA_20']) & \
                         (df['RSI_14'] < 70) & \
                         (df['OBV'] > df['OBV'].shift(1))
        
        df.loc[long_condition, 'label'] = 1

        # SAT (Short) sinyali için üçlü onay
        # 1. Trend: Fiyat EMA 20'nin altında olmalı
        # 2. Momentum: RSI 40'ın altında olmalı (aşırı satım bölgesinde olmamalı)
        # 3. Hacim: OBV düşüşte olmalı
        short_condition = (df['close'] < df['EMA_20']) & \
                          (df['RSI_14'] > 30) & \
                          (df['OBV'] < df['OBV'].shift(1))
                          
        df.loc[short_condition, 'label'] = -1
        
        return df.dropna().copy()

    def train_model(self, df):
        """
        Hazırlanan verilerle XGBoost modelini eğitir.
        """
        if df.empty:
            logging.error("Eğitim için yeterli veri yok.")
            return

        features = ["RSI_14", "MACD_12_26_9", "ADX_14", "BBL_5_2.0", "BBM_5_2.0", "BBU_5_2.0", "MOM_10", "CCI_14", "OBV", "ATR_14"]
        X = df[features]
        y = df['label']

        try:
            self.model.fit(X, y)
            self.trained = True
            logging.info("🧠 AI modeli başarıyla eğitildi.")
        except Exception as e:
            logging.error(f"AI modeli eğitim hatası: {e}")
            traceback.print_exc()

    def predict_signal(self, latest_row):
        """
        En son veriyi kullanarak AI'dan alım, satım veya bekle sinyali alır.
        """
        if not self.trained:
            logging.warning("AI modeli henüz eğitilmemiş. Bekle sinyali veriliyor.")
            return "BEKLE"

        try:
            features = ["RSI_14", "MACD_12_26_9", "ADX_14", "BBL_5_2.0", "BBM_5_2.0", "BBU_5_2.0", "MOM_10", "CCI_14", "OBV", "ATR_14"]
            X = latest_row[features].values.reshape(1, -1)
            pred = self.model.predict(X)[0]

            if pred == 1:
                return "AL"
            elif pred == -1:
                return "SAT"
            else:
                return "BEKLE"
        except Exception as e:
            logging.error(f"Sinyal tahmini hatası: {e}")
            return "BEKLE"

    async def execute_trade(self, signal, current_price):
        """
        Gelen sinyale göre ticaret emrini gönderir ve pozisyonu yönetir.
        Risk yönetimi (stop-loss ve take-profit) burada uygulanır.
        """
        if self.position is None:
            # Henüz pozisyonda değiliz, yeni emir verebiliriz.
            try:
                if signal == "AL":
                    logging.info(f"🚀 AL sinyali alındı. Fiyat: {current_price:.2f}")
                    # await self.exchange.create_market_buy_order(self.symbol, self.amount) # Gerçek emir için bu satır etkinleştirilir.
                    self.position = 'LONG'
                    self.entry_price = current_price
                    self.sl_price = current_price * (1 - self.SL_PERCENTAGE)
                    self.tp_price = current_price * (1 + self.TP_PERCENTAGE)
                    logging.info(f"🟢 LONG pozisyon açıldı. Giriş Fiyatı: {self.entry_price:.2f} | TP: {self.tp_price:.2f} | SL: {self.sl_price:.2f}")
                
                elif signal == "SAT":
                    logging.info(f"🔻 SAT sinyali alındı. Fiyat: {current_price:.2f}")
                    # await self.exchange.create_market_sell_order(self.symbol, self.amount) # Gerçek emir için bu satır etkinleştirilir.
                    self.position = 'SHORT'
                    self.entry_price = current_price
                    self.sl_price = current_price * (1 + self.SL_PERCENTAGE)
                    self.tp_price = current_price * (1 - self.TP_PERCENTAGE)
                    logging.info(f"🔴 SHORT pozisyon açıldı. Giriş Fiyatı: {self.entry_price:.2f} | TP: {self.tp_price:.2f} | SL: {self.sl_price:.2f}")
                
                else:
                    logging.info("⏸️ BEKLE sinyali — işlem yapılmadı.")
            except Exception as e:
                logging.error(f"❌ Emir gönderme hatası: {e}")
                traceback.print_exc()

        else:
            # Zaten pozisyondayız, pozisyonu yönetiyoruz.
            if self.position == 'LONG':
                # Zarar Durdur kontrolü
                if current_price <= self.sl_price:
                    logging.warning(f"🛑 LONG pozisyonu SL'e ulaştı. Pozisyon kapatılıyor. Fiyat: {current_price:.2f}")
                    # await self.exchange.create_market_sell_order(self.symbol, self.amount) # Gerçek emir için
                    self.position = None
                    self.entry_price = 0.0
                # Kâr Al kontrolü
                elif current_price >= self.tp_price:
                    logging.info(f"✅ LONG pozisyonu TP'ye ulaştı. Pozisyon kapatılıyor. Fiyat: {current_price:.2f}")
                    # await self.exchange.create_market_sell_order(self.symbol, self.amount) # Gerçek emir için
                    self.position = None
                    self.entry_price = 0.0

            elif self.position == 'SHORT':
                # Zarar Durdur kontrolü
                if current_price >= self.sl_price:
                    logging.warning(f"🛑 SHORT pozisyonu SL'e ulaştı. Pozisyon kapatılıyor. Fiyat: {current_price:.2f}")
                    # await self.exchange.create_market_buy_order(self.symbol, self.amount) # Gerçek emir için
                    self.position = None
                    self.entry_price = 0.0
                # Kâr Al kontrolü
                elif current_price <= self.tp_price:
                    logging.info(f"✅ SHORT pozisyonu TP'ye ulaştı. Pozisyon kapatılıyor. Fiyat: {current_price:.2f}")
                    # await self.exchange.create_market_buy_order(self.symbol, self.amount) # Gerçek emir için
                    self.position = None
                    self.entry_price = 0.0

    async def run(self):
        """
        Botun ana döngüsünü çalıştırır. Sürekli veri çeker, sinyal üretir ve işlem yapar.
        """
        logging.info("🔥 Nova AI Elite Bot başlatılıyor...")
        
        # Model eğitimi için ilk verileri çekme
        df = await self.fetch_ohlcv()
        if df.empty:
            logging.error("Bot başlatılamadı: Veri alınamıyor.")
            return

        df = self.apply_indicators(df)
        df_labeled = self.create_labels(df)
        self.train_model(df_labeled)
        
        while True:
            try:
                # Periyodik olarak yeni verileri çekme
                latest_df = await self.fetch_ohlcv()
                latest_df = self.apply_indicators(latest_df)

                if latest_df.empty:
                    logging.warning("Yeni veri bulunamadı, bir sonraki döngü bekleniyor...")
                    await asyncio.sleep(60) # 1 dakika bekle
                    continue
                
                latest_row = latest_df.iloc[-1]
                current_price = latest_row["close"]
                
                # Sinyal tahmini
                signal = self.predict_signal(latest_row)
                logging.info(f"{self.symbol} fiyatı: {current_price:.2f} | AI Sinyal: {signal} | Pozisyon: {self.position}")

                # Ticaret emri gönderme ve pozisyon yönetimi
                await self.execute_trade(signal, current_price)

            except Exception as e:
                logging.error(f"Ana döngüde beklenmedik hata: {e}")
                traceback.print_exc()

            await asyncio.sleep(60)  # Her 1 dakikada bir çalıştır (timeframe'e göre ayarlanabilir)

    def backtest_strategy(self, df):
        """
        Geliştirilmiş stratejinin geçmiş veriler üzerinde basit bir geri testi.
        Bu, botu canlıya almadan önce performansını değerlendirmenizi sağlar.
        """
        logging.info("📈 Strateji geriye dönük testi başlatılıyor...")
        
        # Geriye dönük test için modelin eğitilmesi
        df = self.apply_indicators(df)
        df = self.create_labels(df)
        self.train_model(df)
        
        test_df = df.dropna().copy()
        
        initial_balance = 1000
        balance = initial_balance
        position_size = 0
        
        for i, row in test_df.iterrows():
            signal = self.predict_signal(row)
            current_price = row['close']
            
            # Sadece pozisyonda değilken AL veya SAT sinyallerine bak
            if position_size == 0:
                if signal == 'AL':
                    position_size = balance / current_price
                    balance = 0
                    logging.info(f"✅ Gerçek zamanlı test: LONG pozisyon açıldı @ {current_price:.2f}")
                elif signal == 'SAT':
                    position_size = -1 * (balance / current_price)
                    balance = 0
                    logging.info(f"❌ Gerçek zamanlı test: SHORT pozisyon açıldı @ {current_price:.2f}")
            # Pozisyonda iken, pozisyonu kapatma sinyali bekle
            elif position_size > 0 and signal == 'SAT':
                balance = position_size * current_price
                position_size = 0
                logging.info(f"💰 Gerçek zamanlı test: LONG pozisyon kapatıldı @ {current_price:.2f}")
            elif position_size < 0 and signal == 'AL':
                balance = -1 * (position_size * current_price)
                position_size = 0
                logging.info(f"💰 Gerçek zamanlı test: SHORT pozisyon kapatıldı @ {current_price:.2f}")
                
        final_balance = balance + (position_size * test_df.iloc[-1]['close'])
        
        logging.info("--- Geriye Dönük Test Sonuçları ---")
        logging.info(f"Başlangıç Bakiyesi: {initial_balance:.2f} USDT")
        logging.info(f"Son Bakiye: {final_balance:.2f} USDT")
        logging.info(f"Toplam Kâr/Zarar: {(final_balance - initial_balance):.2f} USDT")
        logging.info(f"ROI (Yatırım Getirisi): {((final_balance - initial_balance) / initial_balance) * 100:.2f}%")

    async def close(self):
        """
        Botun bağlantılarını kapatır.
        """
        await self.exchange.close()
        logging.info("👋 Bot kapatıldı.")

# Botu başlatmak için ana işlev
async def main():
    bot = NovaAIEliiteBot()
    
    # Geriye dönük test (Backtesting)
    df_for_backtest = await bot.fetch_ohlcv()
    if not df_for_backtest.empty:
        bot.backtest_strategy(df_for_backtest.copy())
    
    # Canlı botu başlat (Yorum satırını kaldırarak aktif hale getirebilirsiniz)
    # await bot.run()
    
    await bot.close()

if __name__ == "__main__":
    asyncio.run(main())


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_dashboard.py
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import plotly.graph_objs as go
import pandas as pd
import threading
import time

# Paylaşılan veri deposu
shared_data = {
    'BTCUSDT': [],
    'ETHUSDT': []
}

# Arayüz uygulaması
app = dash.Dash(__name__)
app.layout = html.Div([
    html.H1("NovaQuantX Dashboard 🚀"),
    dcc.Dropdown(
        id='symbol-selector',
        options=[{'label': s, 'value': s} for s in shared_data.keys()],
        value='BTCUSDT'
    ),
    dcc.Graph(id='live-graph'),
    dcc.Interval(id='interval-component', interval=1000, n_intervals=0)
])

@app.callback(
    Output('live-graph', 'figure'),
    Input('interval-component', 'n_intervals'),
    Input('symbol-selector', 'value')
)
def update_graph(n, symbol):
    data = shared_data[symbol][-100:]
    if not data:
        return go.Figure()
    df = pd.DataFrame(data, columns=['ts', 'price'])
    fig = go.Figure(data=[go.Scatter(x=df['ts'], y=df['price'], mode='lines+markers')])
    fig.update_layout(title=f"{symbol} Fiyat Akışı", xaxis_title="Zaman", yaxis_title="Fiyat")
    return fig

def run_dashboard():
    app.run_server(debug=False, use_reloader=False)

def stream_listener():
    from nova_stream import NovaStream, Tick

    class DashboardStream(NovaStream):
        async def analyze_tick(self, tick: Tick):
            shared_data[tick.symbol].append((tick.local_ns, tick.price))
            await super().analyze_tick(tick)

    asyncio.run(DashboardStream().connect())

if __name__ == "__main__":
    threading.Thread(target=run_dashboard).start()
    time.sleep(2)
    threading.Thread(target=stream_listener).start()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\nova_stream.py
# NovaQuantX - ultra elit veri akış motoru
# Mikrosaniyede Binance Futures veri alımı + analiz tetikleyici + sinyal işleme

import asyncio
import json
import time
import aiohttp
from collections import deque
from dataclasses import dataclass
from nova_indicators.rsi import TickRSI
from nova_trader import NovaTrader

SYMBOLS = ['BTCUSDT', 'ETHUSDT']
STREAMS = [f"{s.lower()}@aggTrade" for s in SYMBOLS]
WS_URL = f"wss://fstream.binance.com/stream?streams={'/'.join(STREAMS)}"

@dataclass
class Tick:
    symbol: str
    price: float
    qty: float
    server_ts: int
    local_ns: int

class NovaStream:
    def __init__(self):
        self.buffers = {s: deque(maxlen=5000) for s in SYMBOLS}
        self.rsi_engines = {s: TickRSI(period=14) for s in SYMBOLS}
        self.trader = NovaTrader(leverage=10)
        self.reconnect_attempts = 0

    async def connect(self):
        print(f"🔌 Bağlanıyor: {WS_URL}")
        while True:
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.ws_connect(WS_URL) as ws:
                        self.reconnect_attempts = 0
                        async for msg in ws:
                            if msg.type == aiohttp.WSMsgType.TEXT:
                                await self.handle_message(msg.data)
            except Exception as e:
                self.reconnect_attempts += 1
                wait = min(5 * self.reconnect_attempts, 60)
                print(f"⚠️ Bağlantı hatası: {e} | {wait}s sonra yeniden denenecek...")
                await asyncio.sleep(wait)

    async def handle_message(self, raw):
        try:
            payload = json.loads(raw)
            stream = payload.get("stream", "")
            data = payload.get("data", {})
            symbol = stream.split("@")[0].upper()
            tick = Tick(
                symbol=symbol,
                price=float(data["p"]),
                qty=float(data["q"]),
                server_ts=int(data["T"]),
                local_ns=time.perf_counter_ns()
            )
            self.buffers[symbol].append(tick)
            await self.analyze_tick(tick)
        except Exception as e:
            print(f"⚠️ Veri işleme hatası: {e}")

    async def analyze_tick(self, tick: Tick):
        rsi = self.rsi_engines[tick.symbol].update(tick.price)
        if rsi is not None:
            print(f"📊 {tick.symbol} RSI={rsi} @ {tick.price:.2f}")
            self.trader.process_signal(tick.symbol, tick.price, rsi, tick.local_ns)

async def main():
    stream = NovaStream()
    await stream.connect()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("🛑 Durduruldu")

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\panic_flatten.py
# panic_flatten.py
# Tüm açık pozisyonları market ile kapatır, bekleyen emirleri iptal eder.
from __future__ import annotations
from typing import List, Optional
from bot import client, retry, round_qty, tg  # bot.py'deki sağlam yardımcıları kullanıyoruz

def detect_open_symbols() -> List[str]:
    pos = retry(client.futures_position_information, desc="positions")
    syms = {p["symbol"] for p in pos if float(p.get("positionAmt", 0)) != 0.0}
    return sorted(syms)

def flatten(symbols: Optional[List[str]] = None):
    symbols = [s.upper() for s in symbols] if symbols else detect_open_symbols()
    if not symbols:
        tg("🧯 Flatten: açık pozisyon yok.")
        return

    for sym in symbols:
        # 1) Tüm bekleyen emirleri iptal et
        try:
            retry(client.futures_cancel_all_open_orders, symbol=sym, desc=f"cancel_all_{sym}")
        except Exception as e:
            tg(f"⚠️ {sym} emir iptal uyarısı: {e}")

        # 2) Pozisyonları oku ve her bir yönü market ile kapat
        pos = retry(client.futures_position_information, symbol=sym, desc=f"posinfo_{sym}")
        for p in pos:
            amt = float(p.get("positionAmt", 0))
            if amt == 0:
                continue

            # LONG(+) kapatmak için SELL; SHORT(-) kapatmak için BUY
            side = "SELL" if amt > 0 else "BUY"
            pos_side = p.get("positionSide", "BOTH")  # HEDGE: LONG/SHORT, ONEWAY: BOTH
            qty = round_qty(sym, abs(amt))

            order_kwargs = dict(symbol=sym, side=side, type="MARKET", quantity=qty, reduceOnly=True)
            if pos_side != "BOTH":
                order_kwargs["positionSide"] = pos_side  # HEDGE modunda gerekli

            retry(client.futures_create_order, desc=f"flatten_{sym}_{pos_side}", **order_kwargs)
            tg(f"🧯 Flatten {sym} {pos_side} qty={qty} -> {side}")

    tg("✅ Flatten tamam.")

if __name__ == "__main__":
    import sys
    syms = sys.argv[1:]  # örn: python panic_flatten.py BTCUSDT ETHUSDT
    flatten(syms if syms else None)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\preflight.py
# preflight.py
# Amaç: .env'ye göre Binance Futures (mainnet/testnet) bağlantı testi.
# Geri dönüş: serverTime veya anlaşılır hata mesajı.

import os
import sys
import time
import json
from urllib.parse import urljoin

try:
    from dotenv import load_dotenv
except ImportError:
    print("python-dotenv kurulu değil. Kurmak için:\n  pip install python-dotenv")
    sys.exit(1)

try:
    import requests
except ImportError:
    print("requests kurulu değil. Kurmak için:\n  pip install requests")
    sys.exit(1)

# --- .env yükle ---
load_dotenv()

def as_bool(x: str, default=False):
    if x is None:
        return default
    return str(x).strip().lower() in ("1", "true", "yes", "y")

USE_TESTNET = as_bool(os.getenv("BINANCE_USE_TESTNET"), False)

# URL'yi .env'den al (varsa), yoksa güvenli varsayılanları kullan
ENV_URL = os.getenv("BINANCE_FUTURES_URL", "").strip()

if USE_TESTNET:
    BASE = ENV_URL or "https://testnet.binancefuture.com"
else:
    BASE = ENV_URL or "https://fapi.binance.com"

TIME_PATH = "/fapi/v1/time"
TIME_URL = urljoin(BASE, TIME_PATH)

print(f"→ Ortam: {'TESTNET' if USE_TESTNET else 'MAINNET'}")
print(f"→ Endpoint: {TIME_URL}")

try:
    r = requests.get(TIME_URL, timeout=10)
    ct = r.headers.get("content-type", "")
    if "application/json" not in ct:
        # CloudFront ya da başka bir katmandan HTML döndüyse yakala
        print("\n⚠️  Beklenmeyen içerik tipi:", ct or "(bilinmiyor)")
        print("---- Dönen ilk 400 karakter ----")
        print(r.text[:400])
        print("--------------------------------")
        sys.exit(2)

    r.raise_for_status()
    data = r.json()

    if not isinstance(data, dict) or "serverTime" not in data:
        print("⚠️  JSON geldi ama beklenen alan yok:", data)
        sys.exit(3)

    # Başarılı!
    st = data["serverTime"]
    print(f"\n✅ Bağlantı OK — serverTime: {st} ({time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(st/1000))} UTC)")
    sys.exit(0)

except requests.exceptions.Timeout:
    print("⛔ Zaman aşımı. Ağ bağlantını veya VPN/Proxy ayarlarını kontrol et.")
    sys.exit(10)
except requests.exceptions.ConnectionError as e:
    print("⛔ Bağlantı hatası:", e)
    print("   Muhtemel nedenler: internet erişimi, DNS/Proxy/VPN, güvenlik duvarı.")
    sys.exit(11)
except requests.exceptions.HTTPError as e:
    # HTTP 4xx/5xx
    print(f"⛔ HTTP hatası: {e} (kod {e.response.status_code})")
    print("Cevap gövdesi (ilk 400 char):", e.response.text[:400])
    sys.exit(12)
except Exception as e:
    print("⛔ Beklenmeyen hata:", repr(e))
    sys.exit(99)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\pro_alpha.py
import numpy as np
import pandas as pd

# ---------- Göstergeler ----------
def rsi(series, n=14):
    ch = series.diff()
    up = ch.clip(lower=0).rolling(n).mean()
    dn = (-ch.clip(upper=0)).rolling(n).mean()
    rs = up / (dn.replace(0, np.nan))
    return 100 - (100 / (1+rs))

def ema(series, n):
    return series.ewm(span=n, adjust=False).mean()

def atr(df, n=14):
    h,l,c = df["high"], df["low"], df["close"]
    tr = np.maximum.reduce([
        (h-l).values,
        np.abs(h-c.shift(1)).values,
        np.abs(l-c.shift(1)).values
    ])
    return pd.Series(tr, index=df.index).rolling(n).mean()

# ---------- Yardımcı ----------
def make_df(klines):
    cols = ["open_time","open","high","low","close","volume",
            "close_time","qv","ntrades","tbb","tbq","ignore"]
    df = pd.DataFrame(klines, columns=cols)
    for col in ["open","high","low","close","volume"]:
        df[col] = df[col].astype(float)
    # zaman kullanmak istersen:
    # df["open_time"] = pd.to_datetime(df["open_time"], unit="ms")
    # df["close_time"] = pd.to_datetime(df["close_time"], unit="ms")
    return df

# ---------- Tek TF skor (1m tetik) ----------
def score_single_tf(df, funding_bias=0.0):
    df = df.copy()
    df["ema50"] = ema(df["close"],50)
    df["ema200"]= ema(df["close"],200)
    df["rsi"]   = rsi(df["close"],14)
    df["atr"]   = atr(df,14)

    # Trend (EMA50 vs EMA200)
    trend = np.where(df["ema50"]>df["ema200"], 1, -1)

    # Breakout (20 bar)
    hh = df["high"].rolling(20).max()
    ll = df["low"].rolling(20).min()
    bo_long  = (df["close"]>hh.shift(1)).astype(int)
    bo_short = (df["close"]<ll.shift(1)).astype(int)*-1

    # Mean-rev (Bollinger z)
    mid = df["close"].rolling(20).mean()
    std = df["close"].rolling(20).std()
    z = (df["close"]-mid)/std.replace(0,np.nan)
    mr_long  = (z<-2).astype(int)
    mr_short = (z> 2).astype(int)*-1

    raw = trend + bo_long + bo_short + mr_long + mr_short
    bias = -np.sign(funding_bias)  # funding + ise short bias (kontraryen)
    score = raw + 0.5*bias

    last = score.iloc[-1]
    last_atr = df["atr"].iloc[-1]
    last_close = df["close"].iloc[-1]
    return float(last), float(last_atr), float(last_close)

# ---------- MTF: 1m tetik + 15m trend + 1h yön ----------
def slope(series, n=5):
    # son n değerin doğrusal regresyon eğimi (yaklaşık eğilim)
    y = series.tail(n).values
    x = np.arange(len(y))
    if len(y) < 2 or np.any(np.isnan(y)):
        return 0.0
    b = np.polyfit(x, y, 1)[0]
    return float(b)

def mtf_filter(df_trend_15m, df_dir_1h, confirm_mode="STRICT"):
    """
    15m trend: EMA50 > EMA200 -> LONG, altı -> SHORT
    1h yön: EMA50>EMA200 VE EMA200 eğimi yukarı -> LONG, tersi -> SHORT
    confirm_mode:
      - STRICT  : ikisi de aynı yön
      - RELAXED : en az biri o yönde
    Dönüş: "LONG"/"SHORT"/"NONE"
    """
    t = df_trend_15m.copy()
    d = df_dir_1h.copy()
    t["ema50"] = ema(t["close"],50); t["ema200"] = ema(t["close"],200)
    d["ema50"] = ema(d["close"],50); d["ema200"] = ema(d["close"],200)

    t_long = t["ema50"].iloc[-1] > t["ema200"].iloc[-1]
    d_long = (d["ema50"].iloc[-1] > d["ema200"].iloc[-1]) and (slope(d["ema200"], 9) > 0)

    t_short = not t_long
    d_short = (d["ema50"].iloc[-1] < d["ema200"].iloc[-1]) and (slope(d["ema200"], 9) < 0)

    if confirm_mode.upper()=="STRICT":
        if t_long and d_long:   return "LONG"
        if t_short and d_short: return "SHORT"
        return "NONE"
    else:  # RELAXED
        if t_long or d_long:    return "LONG"
        if t_short or d_short:  return "SHORT"
        return "NONE"

def score_mtf(trigger_df, trend_df, dir_df, funding_bias=0.0, confirm_mode="STRICT"):
    """
    1) Tetik (1m) üzerinde score_single_tf ile sinyal gücü
    2) 15m & 1h ile yön filtresi (STRICT/RELAXED)
    3) Uyum varsa yönü score işaretine uygular; yoksa FLAT
    Dönüş: (direction, score, atr, last_close)
    """
    score, atr_val, last_px = score_single_tf(trigger_df, funding_bias)
    # tetik yönü
    trig_dir = "LONG" if score >= 1 else ("SHORT" if score <= -1 else "FLAT")
    if trig_dir == "FLAT":
        return "FLAT", score, atr_val, last_px

    mtf_dir = mtf_filter(trend_df, dir_df, confirm_mode=confirm_mode)
    if mtf_dir == "NONE":
        return "FLAT", score, atr_val, last_px

    # tetik ile MTF aynı tarafta mı?
    if (trig_dir == "LONG" and mtf_dir == "LONG") or (trig_dir == "SHORT" and mtf_dir == "SHORT"):
        return trig_dir, score, atr_val, last_px
    # çakışıyorsa işlem yapma
    return "FLAT", score, atr_val, last_px



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\pro_config.py
# pro_config.py
import os
from typing import Dict, Any
try:
    # .env kullanıyorsan sorun çıkarmasın
    from dotenv import load_dotenv
    load_dotenv()
except Exception:
    pass


# -------------------------
# ÇEKİRDEK AYARLAR
# -------------------------
def _get_bool(name: str, default: bool) -> bool:
    v = os.getenv(name, str(default)).strip().lower()
    return v in ("1", "true", "yes", "y", "on")

def _get_float(name: str, default: float) -> float:
    try:
        return float(os.getenv(name, str(default)))
    except Exception:
        return default

def _get_int(name: str, default: int) -> int:
    try:
        return int(os.getenv(name, str(default)))
    except Exception:
        return default


# -------------------------
# MTF (Multi-Timeframe) AYARLARI
# -------------------------
# !!! ÖNEMLİ: Python'da değişken ataması EŞİTTİR (=) ile yapılır; iki nokta (:) değil.
MTF_TRIGGER = os.getenv("MTF_TRIGGER", "1m")   # tetik (örn 1m)
MTF_TREND   = os.getenv("MTF_TREND",   "15m")  # trend filtresi (örn 15m)
MTF_DIR     = os.getenv("MTF_DIR",     "1h")   # yön onayı (örn 1h)

# Trend ve yön EMA pencereleri
MTF_TREND_EMA_FAST = _get_int("MTF_TREND_EMA_FAST", 21)
MTF_TREND_EMA_SLOW = _get_int("MTF_TREND_EMA_SLOW", 55)
MTF_DIR_EMA_FAST   = _get_int("MTF_DIR_EMA_FAST",   50)
MTF_DIR_EMA_SLOW   = _get_int("MTF_DIR_EMA_SLOW",   200)

# Tetik (1m) tarafı için kısa/uzun EMA pencereleri
EMA_FAST = _get_int("EMA_FAST", 9)
EMA_SLOW = _get_int("EMA_SLOW", 21)

# -------------------------
# GENEL AYAR YÜKLEYİCİ
# -------------------------
def load_config() -> Dict[str, Any]:
    """
    Tüm önemli ayarları tek noktadan toplar.
    Projedeki diğer modüller `from pro_config import load_config` ile bunu çağırabilir.
    """
    symbols = [s.strip() for s in os.getenv("SYMBOLS", "BTCUSDT").split(",") if s.strip()]

    cfg: Dict[str, Any] = {
        "BINANCE_USE_TESTNET": _get_bool("BINANCE_USE_TESTNET", True),
        "BINANCE_FUTURES_URL_TEST": os.getenv("BINANCE_FUTURES_URL_TEST", "https://testnet.binancefuture.com"),
        "BINANCE_FUTURES_URL_MAIN": os.getenv("BINANCE_FUTURES_URL_MAIN", "https://fapi.binance.com"),

        "SYMBOLS": symbols,
        "MIN_NOTIONAL_USDT": _get_float("MIN_NOTIONAL_USDT", 10.0),
        "MAX_DAILY_DRAWDOWN": _get_float("MAX_DAILY_DRAWDOWN", 0.03),
        "MAX_CAPITAL_PCT_PER_TRADE": _get_float("MAX_CAPITAL_PCT_PER_TRADE", 0.02),

        "BINANCE_HEDGE_MODE": _get_bool("BINANCE_HEDGE_MODE", True),
        "BINANCE_MARGIN_TYPE": os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED").upper(),
        "BINANCE_LEVERAGE": _get_int("BINANCE_LEVERAGE", 5),

        "WORKING_TYPE": os.getenv("WORKING_TYPE", "MARK_PRICE").upper(),
        "SL_PCT": _get_float("SL_PCT", 0.01),
        "TP_PCT": _get_float("TP_PCT", 0.02),
        "TRAIL_PCT": _get_float("TRAIL_PCT", 0.0),

        "DRY_RUN": _get_bool("DRY_RUN", True),
        "MAX_RETRY": _get_int("MAX_RETRY", 3),
        "RETRY_BACKOFF_MS": _get_int("RETRY_BACKOFF_MS", 400),

        "TELEGRAM_TOKEN": os.getenv("TELEGRAM_TOKEN", ""),
        "TELEGRAM_CHAT_ID": os.getenv("TELEGRAM_CHAT_ID", ""),

        # Sinyal & MTF
        "TECH_INTERVAL": os.getenv("TECH_INTERVAL", "1m"),
        "EMA_FAST": EMA_FAST,
        "EMA_SLOW": EMA_SLOW,

        "MTF": {
            "TRIGGER": MTF_TRIGGER,
            "TREND":   MTF_TREND,
            "DIR":     MTF_DIR,
            "TREND_FAST": MTF_TREND_EMA_FAST,
            "TREND_SLOW": MTF_TREND_EMA_SLOW,
            "DIR_FAST":   MTF_DIR_EMA_FAST,
            "DIR_SLOW":   MTF_DIR_EMA_SLOW,
        },

        "TIMEZONE": os.getenv("TIMEZONE", "Europe/Zurich"),
        "GUARD_COOLDOWN_MIN": _get_int("GUARD_COOLDOWN_MIN", 120),
    }

    return cfg



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\pro_exchange.py
import time
import logging
from binance.client import Client

class Ex:
    def __init__(self, cfg):
        self.c = Client(cfg["KEY"], cfg["SECRET"], testnet=cfg["USE_TESTNET"])
        if cfg["USE_TESTNET"] and cfg["FUT_URL"]:
            self.c.FUTURES_URL = cfg["FUT_URL"]
        t = self.c.futures_time()["serverTime"]
        logging.info(f"Binance OK | serverTime={t} | testnet={cfg['USE_TESTNET']}")

        # hedge / margin / lev
        try:
            self.c.futures_change_position_mode(dualSidePosition="true" if cfg["HEDGE"] else "false")
        except Exception as e:
            logging.debug(f"hedge mode: {e}")
        self.cfg = cfg

    # ---- helpers ----
    def set_symbol_params(self, symbol):
        try:
            self.c.futures_change_margin_type(symbol=symbol, marginType=self.cfg["MARGIN"])
        except Exception: pass
        try:
            self.c.futures_change_leverage(symbol=symbol, leverage=self.cfg["LEV"])
        except Exception: pass

    def get_top_symbols(self, n):
        # 24h ticker ile en likit USDT perpetual’ları seç
        info = self.c.futures_exchange_info()
        usdt_perps = [s["symbol"] for s in info["symbols"]
                      if s["quoteAsset"]=="USDT" and s.get("contractType")=="PERPETUAL" and s["status"]=="TRADING"]
        stats = self.c.futures_ticker()  # 24h
        volmap = {x["symbol"]: float(x.get("quoteVolume",0.0)) for x in stats}
        ranked = sorted([s for s in usdt_perps if s in volmap], key=lambda s: volmap[s], reverse=True)
        return ranked[:n]

    def klines(self, symbol, interval, limit=150):
        return self.c.futures_klines(symbol=symbol, interval=interval, limit=limit)

    def filters(self, symbol):
        info = self.c.futures_exchange_info()
        md = next(s for s in info["symbols"] if s["symbol"]==symbol)
        price_tick = float(next(f["tickSize"] for f in md["filters"] if f["filterType"]=="PRICE_FILTER"))
        lotf = next((f for f in md["filters"] if f["filterType"] in ("MARKET_LOT_SIZE","LOT_SIZE")), None)
        step = float(lotf["stepSize"]); min_qty=float(lotf["minQty"])
        min_notional = float(next(f["notional"] for f in md["filters"] if f["filterType"]=="MIN_NOTIONAL"))
        return price_tick, step, min_qty, min_notional

    def balance_usdt(self):
        bal = self.c.futures_account_balance()
        return float(next(b["balance"] for b in bal if b["asset"]=="USDT"))

    def positions(self):
        return self.c.futures_position_information()

    def funding(self, symbol):
        try:
            fr = self.c.futures_funding_rate(symbol=symbol, limit=1)
            return float(fr[-1]["fundingRate"])
        except Exception:
            return 0.0

    def mark_price(self, symbol):
        mp = self.c.futures_mark_price(symbol=symbol)
        return float(mp["markPrice"])

    def place_market(self, symbol, side, qty, position_side=None, reduce_only=False, client_oid=None):
        params = dict(symbol=symbol, side=side, type="MARKET", quantity=qty)
        if position_side: params["positionSide"]=position_side
        if reduce_only: params["reduceOnly"]="true"
        if client_oid: params["newClientOrderId"]=client_oid
        return self.c.futures_create_order(**params)

    def place_stop_market(self, symbol, side, stop_price, position_side=None, reduce_only=True):
        # STOP_MARKET/TAKE_PROFIT_MARKET için karşıt side gerekir
        params = dict(symbol=symbol, side=side, type="STOP_MARKET",
                      stopPrice=stop_price, closePosition="false", reduceOnly="true", timeInForce="GTC")
        if position_side: params["positionSide"]=position_side
        return self.c.futures_create_order(**params)

    def place_takeprofit_market(self, symbol, side, stop_price, position_side=None, reduce_only=True):
        params = dict(symbol=symbol, side=side, type="TAKE_PROFIT_MARKET",
                      stopPrice=stop_price, closePosition="false", reduceOnly="true", timeInForce="GTC")
        if position_side: params["positionSide"]=position_side
        return self.c.futures_create_order(**params)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\pro_executor.py
import logging
import time
import uuid

def decide_side(score):
    if score>=1:   return "BUY","LONG","SELL"   # entry, posSide, protective stop side
    if score<=-1:  return "SELL","SHORT","BUY"
    return None,None,None

def run_once(cfg, ex, universe, pnl_today=0.0):
    from pro_alpha import make_df, score_symbol
    from pro_risk  import position_size, clamp_qty_by_filters, daily_circuit_breaker

    if daily_circuit_breaker(pnl_today, cfg["MAX_DD"]):
        logging.warning("Günlük devre kesici aktif. Yeni işlem yok.")
        return

    equity = ex.balance_usdt()
    open_pos = ex.positions()
    # sembol başına açık pozisyon miktarını say
    open_map = {}
    for p in open_pos:
        if float(p.get("positionAmt",0))!=0:
            key = (p["symbol"], p.get("positionSide","BOTH"))
            open_map[key]=p

    # Evren
    if universe:
        symbols = universe
    else:
        symbols = ex.get_top_symbols(cfg["SCAN_TOP_N"])

    for sym in symbols:
        try:
            ex.set_symbol_params(sym)
            kl = ex.klines(sym, cfg["TIMEFRAME"], limit=220)
            df = make_df(kl)

            fund = ex.funding(sym)
            score, atr, last = score_symbol(df, funding_bias=fund)

            entry_side, pos_side, stop_side = decide_side(score)
            if not entry_side: 
                continue

            # maruziyet ve pozisyon sınırları
            cur_positions = [k for k in open_map.keys() if k[0]==sym]
            if len(open_map)>=cfg["MAX_POS"]:
                continue

            # boyut
            qty_raw = position_size(equity, cfg["RISK_PCT"], atr, last, cfg["LEV"], cfg["MIN_NOTIONAL"])
            tick, step, min_qty, min_notional = ex.filters(sym)
            qty = clamp_qty_by_filters(qty_raw, step, min_qty)
            if qty<=0: 
                continue

            client_oid = f"probot-{uuid.uuid4().hex[:12]}"
            logging.info(f"{sym} | score={score:.2f} atr={atr:.2f} last={last:.2f} -> {entry_side} {pos_side} qty={qty:.6f} DRY={cfg['DRY_RUN']}")

            if cfg["DRY_RUN"]:
                continue

            # giriş
            resp = ex.place_market(sym, entry_side, qty, position_side=pos_side, client_oid=client_oid)
            avg_price = float(resp.get("avgPrice") or resp.get("price") or last)

            # koruma (STOP & TP) — basit 1*ATR stop, 2*ATR TP
            stop_price = avg_price - atr if pos_side=="LONG" else avg_price + atr
            tp_price   = avg_price + 2*atr if pos_side=="LONG" else avg_price - 2*atr

            # Binance STOP/TP market’te stopPrice “trigger”dır, karşıt side ile reduceOnly
            ex.place_stop_market(sym, stop_side, round(stop_price,4), position_side=pos_side, reduce_only=True)
            ex.place_takeprofit_market(sym, stop_side, round(tp_price,4), position_side=pos_side, reduce_only=True)

            logging.info(f"{sym} giriş ok | avg={avg_price:.2f} stop={stop_price:.2f} tp={tp_price:.2f}")

            time.sleep(0.2)
        except Exception as e:
            logging.warning(f"{sym} hata: {e}")
            continue


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\pro_live.py
# pro_live.py
# -*- coding: utf-8 -*-

import time
import math
import traceback
from typing import Any, Dict, List, Optional

import numpy as np

from pro_config import load_config

# ------------------------------------------------------------
#  LOGGING
# ------------------------------------------------------------
import logging
from logging.handlers import RotatingFileHandler

def _make_logger(name: str = "live") -> logging.Logger:
    logger = logging.getLogger(name)
    if logger.handlers:
        return logger
    logger.setLevel(logging.INFO)
    fmt = logging.Formatter(
        "%(asctime)s | %(levelname)s | %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )
    ch = logging.StreamHandler()
    ch.setFormatter(fmt)
    logger.addHandler(ch)
    try:
        fh = RotatingFileHandler("live.log", maxBytes=2_000_000, backupCount=3, encoding="utf-8")
        fh.setFormatter(fmt)
        logger.addHandler(fh)
    except Exception:
        pass
    return logger


# ------------------------------------------------------------
#  EXCHANGE ADAPTER
#  (pro_exchange içindeki farklı isimli metodlara uyum sağlar)
# ------------------------------------------------------------
class ExchangeAdapter:
    """
    Senin pro_exchange.py içindeki Exchange wrapper'ına otomatik uyum.
    Gerekli temel fonksiyonlar:

      - get_klines(symbol, interval, limit)          -> list
      - get_position(symbol)                         -> {"side": "LONG/SHORT/FLAT", "qty": float, "entry": float, ...}
      - get_wallet_usdt()                            -> float
      - open_bracket_order(symbol, side, qty, price, sl_pct, tp_pct, trail_pct, working_type="MARK_PRICE")
      - close_position(symbol)

    Wrapper'ında isimler farklıysa, burada birden çok ismi dener.
    Hiçbiri yoksa açık, anlaşılır hata verir.
    """
    def __init__(self, ex_obj: Any, logger: logging.Logger):
        self._ex = ex_obj
        self.log = logger

    # ---------- yardımcı  ----------
    def _call(self, candidates: List[str], *args, **kwargs):
        for name in candidates:
            if hasattr(self._ex, name):
                return getattr(self._ex, name)(*args, **kwargs)
        raise AttributeError(f"Exchange method not found. Tried: {candidates}")

    # ---------- gerekli API'ler ----------
    def get_klines(self, symbol: str, interval: str, limit: int) -> List[Any]:
        return self._call(
            ["get_klines", "klines", "fetch_klines", "get_candles", "fetch_candles"],
            symbol, interval, limit
        )

    def get_position(self, symbol: str) -> Dict[str, Any]:
        pos = self._call(
            ["get_position", "position", "fetch_position", "get_futures_position"],
            symbol
        )
        # Esnek normalize
        side = str(pos.get("side", pos.get("positionSide", "FLAT"))).upper()
        qty  = float(pos.get("qty", pos.get("positionAmt", 0.0)))
        entry= float(pos.get("entry", pos.get("entryPrice", pos.get("avgPrice", 0.0))))
        return {"side": side, "qty": qty, "entry": entry, **pos}

    def get_wallet_usdt(self) -> float:
        bal = self._call(
            ["get_wallet_usdt", "wallet_usdt", "get_balance", "get_futures_balance", "wallet"]
        )
        # dict/list durumunda USDT toplamını bulmaya çalış
        if isinstance(bal, (int, float)):
            return float(bal)
        if isinstance(bal, dict):
            for k in ("USDT", "totalUSDT", "balance", "totalBalance", "wallet"):
                if k in bal:
                    try:
                        return float(bal[k])
                    except Exception:
                        pass
        if isinstance(bal, list):
            # [{'asset':'USDT','balance':'...'}] vb.
            for x in bal:
                if isinstance(x, dict) and str(x.get("asset", "")).upper() == "USDT":
                    try:
                        return float(x.get("balance", x.get("walletBalance", x.get("crossWalletBalance", 0.0))))
                    except Exception:
                        pass
        raise RuntimeError("get_wallet_usdt(): USDT bakiyesi çözümlenemedi.")

    def open_bracket_order(
        self,
        symbol: str,
        side: str,
        qty: float,
        price: Optional[float],
        sl_pct: float,
        tp_pct: float,
        trail_pct: float,
        working_type: str = "MARK_PRICE",
    ) -> Any:
        return self._call(
            ["open_bracket_order", "place_bracket_order", "open_order"],
            symbol, side, qty, price, sl_pct, tp_pct, trail_pct, working_type
        )

    def close_position(self, symbol: str) -> Any:
        return self._call(
            ["close_position", "close_all", "close", "close_futures_position"],
            symbol
        )

    # (opsiyonel) miktar/tick normalizasyonu varsa kullan
    def normalize_qty(self, symbol: str, qty: float) -> float:
        try:
            return self._call(["normalize_qty", "round_qty", "fmt_qty"], symbol, qty)
        except Exception:
            return qty


# ------------------------------------------------------------
#  TEKNİK HESAPLAR
# ------------------------------------------------------------
def ema(series: np.ndarray, n: int) -> np.ndarray:
    if len(series) == 0:
        return series
    k = 2.0 / (n + 1.0)
    out = np.zeros_like(series, dtype=float)
    out[0] = series[0]
    for i in range(1, len(series)):
        out[i] = series[i] * k + out[i-1] * (1 - k)
    return out


def get_closes(kl: List[Any]) -> np.ndarray:
    if not kl:
        return np.array([], dtype=float)
    first = kl[0]
    if isinstance(first, dict):
        return np.array([float(x.get("close") or x.get("c") or x.get("Close")) for x in kl], dtype=float)
    # tuple/list: [open_time, open, high, low, close, volume...]
    try:
        return np.array([float(x[4]) for x in kl], dtype=float)
    except Exception:
        raise ValueError("Kline formatı çözümlenemedi; dict ya da [.., close, ..] bekleniyordu.")


# ------------------------------------------------------------
#  LIVE ENGINE
# ------------------------------------------------------------
class LiveEngine:
    def __init__(self, cfg: Dict[str, Any], ex_raw: Any):
        self.cfg = cfg
        self.log = _make_logger("live")
        self.ex = ExchangeAdapter(ex_raw, self.log)
        self.cooldown: Dict[str, int] = {}  # sembol -> kalan bar

    # ---------------- main loop (basit) ----------------
    def run_once_all(self):
        symbols = self.cfg.get("SYMBOLS", ["BTCUSDT"])
        for sym in symbols:
            try:
                self._evaluate_and_trade(sym)
            except Exception as e:
                self.log.error(f"[{sym}] HATA: {e}\n{traceback.format_exc()}")

    # ---------------- çekirdek strateji ----------------
    def _evaluate_and_trade(self, sym: str) -> None:
        cfg = self.cfg
        mtf = cfg["MTF"]

        trigger_tf = mtf["TRIGGER"]      # "1m"
        trend_tf   = mtf["TREND"]        # "15m"
        dir_tf     = mtf["DIR"]          # "1h"

        # EMA pencereleri
        ema_fast = int(cfg["EMA_FAST"])        # örn 9
        ema_slow = int(cfg["EMA_SLOW"])        # örn 21
        tr_fast  = int(mtf["TREND_FAST"])      # 21
        tr_slow  = int(mtf["TREND_SLOW"])      # 55
        dir_fast = int(mtf["DIR_FAST"])        # 50
        dir_slow = int(mtf["DIR_SLOW"])        # 200

        # yeterli veri tamponu
        need = max(ema_slow, tr_slow, dir_slow) + 5
        lim_trigger = max(need, 240)
        lim_trend   = max(need, 240)
        lim_dir     = max(need, 300)

        # verileri çek
        k1 = self.ex.get_klines(sym, trigger_tf, lim_trigger)
        k2 = self.ex.get_klines(sym, trend_tf,   lim_trend)
        k3 = self.ex.get_klines(sym, dir_tf,     lim_dir)

        c1 = get_closes(k1)
        c2 = get_closes(k2)
        c3 = get_closes(k3)

        if len(c1) < ema_slow + 3 or len(c2) < tr_slow + 3 or len(c3) < dir_slow + 3:
            self.log.info(f"[{sym}] Yetersiz veri (1m:{len(c1)} 15m:{len(c2)} 1h:{len(c3)})")
            return

        # EMA'lar
        ema1f = ema(c1, ema_fast)
        ema1s = ema(c1, ema_slow)
        ema2f = ema(c2, tr_fast)
        ema2s = ema(c2, tr_slow)
        ema3f = ema(c3, dir_fast)
        ema3s = ema(c3, dir_slow)

        # 1m tetik: cross
        cross_up   = ema1f[-2] <= ema1s[-2] and ema1f[-1] > ema1s[-1]
        cross_down = ema1f[-2] >= ema1s[-2] and ema1f[-1] < ema1s[-1]

        # 15m trend
        trend_up   = ema2f[-1] > ema2s[-1]
        trend_down = ema2f[-1] < ema2s[-1]

        # 1h yön
        dir_up     = ema3f[-1] > ema3s[-1]
        dir_down   = ema3f[-1] < ema3s[-1]

        want_long  = cross_up   and trend_up   and dir_up
        want_short = cross_down and trend_down and dir_down

        # cooldown
        cd_bars = int(self.cfg.get("COOLDOWN_BARS", 0))
        if cd_bars > 0:
            left = self.cooldown.get(sym, 0)
            if left > 0:
                self.cooldown[sym] = left - 1
                self.log.debug(f"[{sym}] Cooldown {left-1} bar kaldı.")
                want_long = want_short = False

        # mevcut pozisyon
        pos = self.ex.get_position(sym)
        side = pos.get("side", "FLAT").upper()
        qty  = float(pos.get("qty", 0.0))

        # risk/sizing
        sl_pct = float(cfg["SL_PCT"])
        tp_pct = float(cfg["TP_PCT"])
        trail  = float(cfg["TRAIL_PCT"])
        last   = float(c1[-1])
        min_notional = float(cfg["MIN_NOTIONAL_USDT"])
        leverage = int(cfg["BINANCE_LEVERAGE"])
        cap_pct  = float(cfg["MAX_CAPITAL_PCT_PER_TRADE"])

        wallet = self.ex.get_wallet_usdt()
        notional_target = max(wallet * cap_pct * leverage, min_notional)
        raw_qty = notional_target / last
        tgt_qty = self.ex.normalize_qty(sym, raw_qty)

        working_type = str(cfg.get("WORKING_TYPE", "MARK_PRICE")).upper()

        # aksiyon yardımcıları
        def open_long():
            self.log.info(f"[{sym}] OPEN LONG qty={tgt_qty:.6f} price~{last}  (SL {sl_pct*100:.2f}%, TP {tp_pct*100:.2f}%, trail {trail*100:.2f}%)")
            if bool(cfg["DRY_RUN"]):
                return
            self.ex.open_bracket_order(sym, "LONG", tgt_qty, None, sl_pct, tp_pct, trail, working_type)

        def open_short():
            self.log.info(f"[{sym}] OPEN SHORT qty={tgt_qty:.6f} price~{last} (SL {sl_pct*100:.2f}%, TP {tp_pct*100:.2f}%, trail {trail*100:.2f}%)")
            if bool(cfg["DRY_RUN"]):
                return
            self.ex.open_bracket_order(sym, "SHORT", tgt_qty, None, sl_pct, tp_pct, trail, working_type)

        def close_all():
            if qty <= 0:
                return
            self.log.info(f"[{sym}] CLOSE {side} qty={qty:.6f}")
            if bool(cfg["DRY_RUN"]):
                return
            self.ex.close_position(sym)

        # karar ağacı
        if side in ("FLAT", "") or qty <= 0:
            if want_long:
                open_long()
                if cd_bars > 0: self.cooldown[sym] = cd_bars
            elif want_short:
                open_short()
                if cd_bars > 0: self.cooldown[sym] = cd_bars
            else:
                self.log.debug(f"[{sym}] No signal (flat).")
            return

        if side == "LONG":
            if want_short:
                close_all()
                open_short()
                if cd_bars > 0: self.cooldown[sym] = cd_bars
            else:
                self.log.debug(f"[{sym}] Hold LONG (no opposite signal).")
            return

        if side == "SHORT":
            if want_long:
                close_all()
                open_long()
                if cd_bars > 0: self.cooldown[sym] = cd_bars
            else:
                self.log.debug(f"[{sym}] Hold SHORT (no opposite signal).")
            return


# ------------------------------------------------------------
#  MAIN
# ------------------------------------------------------------
def _bootstrap_exchange(cfg: Dict[str, Any], log: logging.Logger):
    """
    Senin pro_exchange.Exchange sınıfını yaratmayı dener.
    Eğer import başarısız olursa, net bir mesaj verir.
    """
    try:
        from pro_exchange import Exchange
    except Exception as e:
        log.error("pro_exchange.Exchange import edilemedi. Lütfen 'pro_exchange.py' içinde Exchange sınıfı olduğundan emin ol.")
        raise
    return Exchange(cfg)

def main():
    cfg = load_config()
    log = _make_logger("live")
    log.info("LiveEngine başlıyor… (MTF: %s / %s / %s)",
             cfg["MTF"]["TRIGGER"], cfg["MTF"]["TREND"], cfg["MTF"]["DIR"])

    ex = _bootstrap_exchange(cfg, log)
    engine = LiveEngine(cfg, ex)

    # Basit tek seferlik çalıştırma (cron ya da scheduler ile per-bar tetikleyebilirsin)
    engine.run_once_all()

if __name__ == "__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\pro_main.py
import logging
from pro_config import load_config
from pro_exchange import Ex
from pro_executor import run_once

def main():
    cfg = load_config()
    logging.basicConfig(level=getattr(logging, cfg["LOG_LEVEL"], logging.INFO),
                        format="%(asctime)s | %(levelname)s | %(message)s")

    ex = Ex(cfg)

    # Manuel evren varsa onu kullan, yoksa get_top_symbols içeriden çağrılır
    universe = cfg["SYMBOLS"] if len(cfg["SYMBOLS"])>0 else None

    # Basit bir “tek tur” tarama/işlem (cron/loop’a alabilirsin)
    run_once(cfg, ex, universe, pnl_today=0.0)

if __name__=="__main__":
    main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\pro_risk.py
import math

def clamp_qty_by_filters(qty, step, min_qty):
    q = math.floor(qty/step)*step
    return q if q>=min_qty else 0.0

def position_size(equity_usdt, risk_pct, atr, price, lev, min_notional):
    # ATR tabanlı: stop mesafesini ~1*ATR varsay -> risk_usd/ (ATR) = kontrat * (ATR)
    risk_usd = max(equity_usdt*risk_pct, min_notional)
    if atr<=0: atr = price*0.005  # emniyet
    contracts = (risk_usd/atr)*lev / price
    notional  = contracts*price
    if notional < min_notional:
        contracts = min_notional/price
    return max(contracts, 0.0)

def daily_circuit_breaker(pnl_today, max_dd):
    return pnl_today<=-abs(max_dd)  # true -> sistem kilitle


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\quantum_predictor.py
class QuantumIntelligenceUnit:
    def __init__(self):
        self.timeline_data = []
        self.emotion_index = {}
    
    def absorb_telemetry(self, market_signal, sentiment_level):
        self.timeline_data.append(market_signal)
        self.emotion_index[market_signal] = sentiment_level
    
    def predict_surge(self):
        strong_signals = [sig for sig, emo in self.emotion_index.items() if emo > 7]
        if len(strong_signals) >= 2:
            return f"🚀 Tahmin: Yakında ani yükseliş olabilir. Sinyaller: {', '.join(strong_signals)}"
        return "🔎 Durum kararlı. Dalga öncesi sessizlik gözlemleniyor."



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\rearrange_v2.py
from __future__ import annotations

import argparse
import csv
import re
import shutil
from pathlib import Path
from typing import Iterable, List, Tuple

EXCLUDE_DIRS = {
    ".git", ".hg", ".svn",
    ".venv", "venv", "venv311", "env",
    "__pycache__", "build", "dist",
}

# ---------- Yardımcılar ----------

def read_move_map(csv_path: Path) -> List[Tuple[str, str]]:
    """
    move_map.csv'den (old_path,new_path) çiftlerini oku.
    Yollar ileri eğik çizgiye normalize edilir.
    """
    rows: List[Tuple[str, str]] = []
    with csv_path.open(newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        need = {"old_path", "new_path"}
        if not reader.fieldnames or not need.issubset(reader.fieldnames):
            raise AssertionError("CSV must have columns old_path,new_path")
        for r in reader:
            old = (r["old_path"] or "").strip().replace("\\", "/")
            new = (r["new_path"] or "").strip().replace("\\", "/")
            if old and new:
                rows.append((old, new))
    return rows


def is_excluded(p: Path) -> bool:
    return any(part in EXCLUDE_DIRS for part in p.parts)


def ensure_pkg_dirs(project_root: Path, dest_file: Path) -> None:
    """
    dest_file'nin parent zincirini proje kökü altında oluştur.
    Her klasöre __init__.py ekle (yoksa). PROJE DIŞINA ASLA yazmaz.
    """
    project_root = project_root.resolve()
    parent = dest_file.parent.resolve()
    try:
        rel = parent.relative_to(project_root)
    except Exception:
        raise RuntimeError(f"Refusing to touch outside project: {parent}")

    cur = project_root
    for part in rel.parts:
        cur = cur / part
        cur.mkdir(exist_ok=True)
        init = cur / "__init__.py"
        if not init.exists():
            init.write_text("# added by rearrange_v2.py\n", encoding="utf-8")


def file_to_module(package: str, rel_path: str) -> str:
    """
    'analytics/analysis_graphs.py' -> 'kiripto_nova.analytics.analysis_graphs'
    """
    mod = Path(rel_path).with_suffix("").as_posix().replace("/", ".")
    return f"{package}.{mod}"


def iter_py_files(root: Path) -> Iterable[Path]:
    for p in root.rglob("*.py"):
        if not is_excluded(p):
            yield p


# ---------- Import güncelleme ----------

def patch_imports_in_text(text: str, old_mod: str, new_mod: str) -> str:
    """
    Basit ama işe yarar bir yaklaşım:
      - 'import old_mod'  -> 'import new_mod as old_mod'
      - 'from old_mod import X' -> 'from new_mod import X'
    Kenar durumları çok kompleks ise elle gözden geçirmek gerekebilir.
    """
    # import old_mod [as alias] | , | EOL
    pat_import = re.compile(
        rf"(^|\n)([ \t]*)import[ \t]+{re.escape(old_mod)}([ \t]+as[ \t]+\w+|[ \t]*[,\n])",
        re.MULTILINE,
    )

    def _repl_import(m: re.Match) -> str:
        prefix = m.group(1) + (m.group(2) or "")
        tail = m.group(3)
        # alias varsa koru; yoksa 'as old_mod' ekle
        if " as " in tail:
            return f"{prefix}import {new_mod}{tail}"
        # virgül veya satırsonu durumu
        if tail.strip() == ",":
            return f"{prefix}import {new_mod} as {old_mod},"
        return f"{prefix}import {new_mod} as {old_mod}{tail}"

    text = pat_import.sub(_repl_import, text)

    # from old_mod import ...
    pat_from = re.compile(
        rf"(^|\n)([ \t]*)from[ \t]+{re.escape(old_mod)}([ \t]+import[ \t]+)",
        re.MULTILINE,
    )
    text = pat_from.sub(rf"\1\2from {new_mod}\3", text)

    return text


def update_imports(project_root: Path, mappings: List[Tuple[str, str, str, str]], dry: bool) -> None:
    """
    mappings: (old_rel, new_rel, old_mod, new_mod)
    """
    for py in iter_py_files(project_root):
        try:
            txt = py.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            continue

        new_txt = txt
        for _old_rel, _new_rel, old_mod, new_mod in mappings:
            new_txt = patch_imports_in_text(new_txt, old_mod, new_mod)

        if new_txt != txt:
            if dry:
                print(f"[DRY] Update imports in {py}")
            else:
                py.write_text(new_txt, encoding="utf-8")
                print(f"[OK]  Update imports in {py}")


# ---------- Ana akış ----------

def main() -> None:
    ap = argparse.ArgumentParser(
        description="Proje dosyalarını move_map.csv'ye göre src/<paket> altına taşır ve importları günceller."
    )
    ap.add_argument("project_root", help="Proje kökü (örn: .)")
    ap.add_argument("src_dir", help="Kaynak kök klasör adı (örn: src)")
    ap.add_argument("mapping_csv", help="CSV: old_path,new_path")
    ap.add_argument("package", help="Üst paket adı (örn: kiripto_nova)")
    ap.add_argument("--dry", action="store_true", help="Sadece prova (dosya yazmaz)")
    args = ap.parse_args()

    PROJECT_ROOT = Path(args.project_root).resolve()
    SRC_ROOT = (PROJECT_ROOT / args.src_dir).resolve()
    PKG_ROOT = SRC_ROOT / args.package

    if not SRC_ROOT.exists():
        SRC_ROOT.mkdir(parents=True, exist_ok=True)
    PKG_ROOT.mkdir(parents=True, exist_ok=True)
    init = PKG_ROOT / "__init__.py"
    if not init.exists():
        init.write_text("# package root\n", encoding="utf-8")

    rows = read_move_map(Path(args.mapping_csv))

    # (old_rel, new_rel, old_mod, new_mod)
    mappings: List[Tuple[str, str, str, str]] = []
    for old_rel, new_rel in rows:
        old_mod = Path(old_rel).with_suffix("").as_posix().replace("/", ".")
        new_mod = file_to_module(args.package, new_rel)
        mappings.append((old_rel, new_rel, old_mod, new_mod))

    # 1) Taşıma (veya prova)
    for old_rel, new_rel, _, _ in mappings:
        src_abs = (PROJECT_ROOT / old_rel).resolve()
        dst_abs = (SRC_ROOT / args.package / new_rel).resolve()

        # Güvenlik: yalnızca proje kökü içinde işlem
        try:
            src_abs.relative_to(PROJECT_ROOT)
            dst_abs.relative_to(PROJECT_ROOT)
        except Exception:
            raise RuntimeError("Refusing to operate outside project root.")

        if not src_abs.exists():
            # Eski dosya yoksa sessizce geç
            continue

        if args.dry:
            print(f"[DRY] Move {src_abs} -> {dst_abs}")
        else:
            ensure_pkg_dirs(PROJECT_ROOT, dst_abs)
            if dst_abs.exists():
                # Çakışma: üstüne yazmaktan kaçın
                print(f"[SKIP] Dest already exists: {dst_abs}")
            else:
                shutil.move(str(src_abs), str(dst_abs))
                print(f"[OK]  Moved: {src_abs} -> {dst_abs}")

    # 2) Import güncelle
    update_imports(PROJECT_ROOT, mappings, args.dry)

    print("Done. Review changes with git diff.")


if __name__ == "__main__":
    main()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\risk.py
# risk.py (ekler)
def atr_levels(df, entry, direction, k=1.5, r=2.5):
    atr = df["close"].rolling(14).apply(lambda s: (s.max()-s.min()), raw=False).iloc[-1]
    atr = max(atr, 1)  # güvenlik
    if direction=="LONG":
        sl = entry - k*atr
        tp = entry + r*atr
    else:
        sl = entry + k*atr
        tp = entry - r*atr
    return sl, tp


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\run_gate.py
# run_gate.py
# Binance Futures "avcı" - anlık tarama, uygun sinyalde otomatik giriş/çıkış
# Gerekenler: python-binance, pandas, numpy, python-dotenv

import os, time, math, json, argparse, logging
from datetime import datetime, timezone
from typing import Dict, Tuple, Optional, List

import numpy as np
import pandas as pd
from dotenv import load_dotenv
from binance.client import Client
from binance.enums import *

# ------------- Yardımcı: log -------------
def setup_logger(level="INFO"):
    lvl = getattr(logging, level.upper(), logging.INFO)
    logging.basicConfig(
        level=lvl,
        format="%(asctime)s | %(levelname)s | %(message)s",
        datefmt="%H:%M:%S"
    )
    return logging.getLogger("hunter")

log = setup_logger()

# ------------- Ortam -------------
def env_bool(name: str, default: bool) -> bool:
    v = os.getenv(name, str(default)).strip().lower()
    return v in ("1","true","yes","y","on")

def load_env() -> Dict:
    load_dotenv()
    cfg = {}
    # Binance
    cfg["KEY"] = os.getenv("BINANCE_API_KEY", "")
    cfg["SEC"] = os.getenv("BINANCE_API_SECRET", "")
    cfg["USE_TESTNET"] = env_bool("BINANCE_USE_TESTNET", False)
    cfg["FUT_URL"] = os.getenv("BINANCE_FUTURES_URL", "").strip()
    cfg["HEDGE_MODE"] = env_bool("BINANCE_HEDGE_MODE", True)
    cfg["MARGIN_TYPE"] = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED").upper()
    cfg["LEVERAGE"] = int(os.getenv("BINANCE_LEVERAGE", "5"))

    # Bot genel
    cfg["SYMBOLS"] = [s.strip().upper() for s in os.getenv("SYMBOLS", "BTCUSDT,ETHUSDT").split(",") if s.strip()]
    cfg["TIMEFRAME"] = os.getenv("TIMEFRAME", "1m")
    cfg["MAX_DD"] = float(os.getenv("MAX_DAILY_DRAWDOWN", "0.03"))
    cfg["RISK_PER_TRADE"] = float(os.getenv("MAX_CAPITAL_PCT_PER_TRADE", "0.02"))   # bakiyenin yüzdesi
    cfg["MAX_SYM_EXPOSURE"] = float(os.getenv("MAX_SYMBOL_EXPOSURE_PCT", "0.25"))   # sembol başına maruziyet sınırı
    cfg["MAX_OPEN_POS"] = int(os.getenv("MAX_OPEN_POSITIONS", "5"))
    cfg["MIN_NOTIONAL"] = float(os.getenv("MIN_NOTIONAL_USDT", "10"))

    # Teknik
    cfg["LOG_LEVEL"] = os.getenv("LOG_LEVEL", "INFO")

    # Güvenli çalışma
    cfg["DRY_RUN"] = env_bool("DRY_RUN", True)

    return cfg

# ------------- Binance istemcisi ve pazar filtreleri -------------
def make_client(cfg: Dict) -> Client:
    if not cfg["KEY"] or not cfg["SEC"]:
        raise SystemExit("❌ API anahtarları yok! .env içindeki BINANCE_API_KEY / BINANCE_API_SECRET girilmeli.")
    c = Client(api_key=cfg["KEY"], api_secret=cfg["SEC"], testnet=cfg["USE_TESTNET"])
    # python-binance 1.0.29'da FUTURES_URL özelleştirme
    if cfg["FUT_URL"]:
        try:
            c.FUTURES_URL = cfg["FUT_URL"]
        except Exception:
            pass
    # Bağlantı testi
    t = c.futures_time()
    log.info(f"Bağlantı OK (serverTime={t.get('serverTime')}) | {'TESTNET' if cfg['USE_TESTNET'] else 'MAINNET'}")
    return c

def get_symbol_filters(client: Client, symbol: str) -> Tuple[float, float, float]:
    """
    Dönüş: (price_tick, lot_step, min_notional)
    """
    info = client.futures_exchange_info()
    md = next((s for s in info["symbols"] if s["symbol"] == symbol), None)
    if not md:
        raise ValueError(f"{symbol} exchangeInfo bulunamadı.")
    tick = float(next(f["tickSize"] for f in md["filters"] if f["filterType"] == "PRICE_FILTER"))
    step = float(next(f["stepSize"] for f in md["filters"] if f["filterType"] == "LOT_SIZE"))
    min_notional = float(next(f["notional"] for f in md["filters"] if f["filterType"] == "MIN_NOTIONAL"))
    return tick, step, min_notional

def round_to_step(v: float, step: float) -> float:
    return math.floor(v / step) * step

def round_to_tick(v: float, tick: float) -> float:
    # tick hassasiyeti
    return round(math.floor(v / tick) * tick, int(max(0, -math.log10(tick))) if tick < 1 else 0)

# ------------- Hesap ayarları -------------
def ensure_account_settings(client: Client, cfg: Dict, symbols: List[str]):
    # Hedge modu
    try:
        client.futures_change_position_mode(dualSidePosition="true" if cfg["HEDGE_MODE"] else "false")
        log.info(f"Hedge modu => {'DUAL (hedge) ON' if cfg['HEDGE_MODE'] else 'ONE-WAY OFF'}")
    except Exception as e:
        log.warning(f"Hedge modu değiştirilemedi: {e}")

    for sym in symbols:
        # Margin tipi
        try:
            client.futures_change_margin_type(symbol=sym, marginType=cfg["MARGIN_TYPE"])
        except Exception:
            pass  # zaten o tipte olabilir
        # Kaldıraç
        try:
            client.futures_change_leverage(symbol=sym, leverage=cfg["LEVERAGE"])
        except Exception as e:
            log.warning(f"{sym} kaldıraç ayarlanamadı: {e}")

# ------------- Veri/indikatör -------------
def fetch_klines(client: Client, symbol: str, interval: str, limit: int=300) -> pd.DataFrame:
    k = client.futures_klines(symbol=symbol, interval=interval, limit=limit)
    cols = ["open_time","open","high","low","close","volume","close_time","qav","trades","tbbav","tbqav","ignore"]
    df = pd.DataFrame(k, columns=cols)
    df["open_time"] = pd.to_datetime(df["open_time"], unit="ms", utc=True)
    for col in ["open","high","low","close","volume"]:
        df[col] = df[col].astype(float)
    return df

def indicators(df: pd.DataFrame) -> pd.DataFrame:
    # EMA, RSI, ATR
    df = df.copy()
    df["ema50"] = df["close"].ewm(span=50, adjust=False).mean()
    df["ema200"] = df["close"].ewm(span=200, adjust=False).mean()
    # RSI(14)
    delta = df["close"].diff()
    gain = np.where(delta>0, delta, 0.0)
    loss = np.where(delta<0, -delta, 0.0)
    roll_up = pd.Series(gain).rolling(14).mean()
    roll_down = pd.Series(loss).rolling(14).mean()
    rs = roll_up / (roll_down + 1e-12)
    df["rsi"] = 100 - (100 / (1 + rs))
    # ATR(14)
    high_low = df["high"] - df["low"]
    high_close = (df["high"] - df["close"].shift()).abs()
    low_close  = (df["low"]  - df["close"].shift()).abs()
    tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    df["atr"] = tr.rolling(14).mean()
    return df

def score_row(row) -> float:
    # Basit skor: trend + momentum
    trend = 1 if row["ema50"] > row["ema200"] else -1
    rsi = row["rsi"]
    mom = (rsi - 50.0) / 25.0  # ~ -2..+2 arası normalize
    return trend + mom

# ------------- Risk ve pozisyon -------------
def account_usdt(client: Client) -> float:
    bal = client.futures_account_balance()
    usdt = next((float(b["balance"]) for b in bal if b["asset"]=="USDT"), 0.0)
    return usdt

def open_positions(client: Client, symbol: Optional[str]=None) -> List[Dict]:
    pos = client.futures_position_information(symbol=symbol) if symbol else client.futures_position_information()
    # miktarı 0 olmayanlar
    return [p for p in pos if abs(float(p["positionAmt"])) > 0]

def side_and_posside(score: float) -> Tuple[str, str]:
    if score >= 0.6:
        return SIDE_BUY, "LONG"
    elif score <= -0.6:
        return SIDE_SELL, "SHORT"
    return "", ""

# ------------- Emir akışı -------------
def place_bracket(client: Client,
                  symbol: str,
                  side: str,
                  posside: str,
                  qty: float,
                  entry_price: float,
                  stop_price: float,
                  tp_price: float,
                  hedge_mode: bool,
                  dry: bool):
    if dry:
        log.info(f"[DRY] {symbol} {posside} MARKET qty={qty} | SL={stop_price} TP={tp_price}")
        return

    # Piyasa giriş
    params = dict(symbol=symbol,
                  side=side,
                  type=FUTURE_ORDER_TYPE_MARKET,
                  quantity=qty)
    if hedge_mode:
        params["positionSide"] = posside
    o1 = client.futures_create_order(**params)

    # Kar/Zarar emirleri (reduceOnly/closePosition)
    opp_side = SIDE_SELL if side == SIDE_BUY else SIDE_BUY

    # STOP_MARKET
    sl_params = dict(symbol=symbol,
                     side=opp_side,
                     type=FUTURE_ORDER_TYPE_STOP_MARKET,
                     stopPrice=stop_price,
                     closePosition=True,
                     timeInForce=TIME_IN_FORCE_GTC)
    if hedge_mode:
        sl_params["positionSide"] = posside
        sl_params["closePosition"] = False
        sl_params["reduceOnly"] = True
    o2 = client.futures_create_order(**sl_params)

    # TAKE_PROFIT_MARKET
    tp_params = dict(symbol=symbol,
                     side=opp_side,
                     type=FUTURE_ORDER_TYPE_TAKE_PROFIT_MARKET,
                     stopPrice=tp_price,
                     timeInForce=TIME_IN_FORCE_GTC,
                     closePosition=True)
    if hedge_mode:
        tp_params["positionSide"] = posside
        tp_params["closePosition"] = False
        tp_params["reduceOnly"] = True
    o3 = client.futures_create_order(**tp_params)

    log.info(f"Emirler gönderildi: entry={o1.get('orderId')} sl={o2.get('orderId')} tp={o3.get('orderId')}")

# ------------- Ana tarama döngüsü -------------
def run(cfg: Dict, args):
    # Log seviyesi
    global log
    log = setup_logger(cfg["LOG_LEVEL"])

    client = make_client(cfg)
    ensure_account_settings(client, cfg, args.symbols)

    # Durum dosyası (aynı sembolü çok sık yeniden girişten koru)
    state_file = "state.json"
    try:
        with open(state_file, "r", encoding="utf-8") as f:
            state = json.load(f)
    except Exception:
        state = {}
    def update_state(sym, ts):
        state[sym] = {"last_entry_ts": ts}
        with open(state_file, "w", encoding="utf-8") as f:
            json.dump(state, f, ensure_ascii=False, indent=2)

    # Filtreler
    filt: Dict[str, Tuple[float,float,float]] = {}
    for s in args.symbols:
        tick, step, min_notional = get_symbol_filters(client, s)
        # .env MIN_NOTIONAL ile borsanın min notional'ının maksimumunu alalım
        min_notional = max(min_notional, cfg["MIN_NOTIONAL"])
        filt[s] = (tick, step, min_notional)
        log.info(f"{s} filters: tick={tick} step={step} minNotional={min_notional}")

    eval_sec = args.eval
    atr_mult_sl = args.atr_sl
    rr = args.rr

    while True:
        try:
            # açık pozisyon sayısı
            open_pos = open_positions(client)
            if len(open_pos) >= cfg["MAX_OPEN_POS"]:
                log.info(f"Maks açık pozisyon sayısına ulaşıldı ({len(open_pos)}/{cfg['MAX_OPEN_POS']}). Bekleniyor...")
                time.sleep(eval_sec)
                continue

            # bakiye
            usdt = account_usdt(client)
            risk_usdt = max(5.0, usdt * cfg["RISK_PER_TRADE"])  # minimum 5 USDT riske et
            log.debug(f"Bakiye={usdt:.2f}USDT | risk/trade={risk_usdt:.2f}USDT")

            best = None  # (sym, score, df)

            for sym in args.symbols:
                df = indicators(fetch_klines(client, sym, args.interval, limit=300))
                last = df.iloc[-1]

                sc = score_row(last)
                log.info(f"{sym} score={sc:.2f} | price={last['close']:.2f} | rsi={last['rsi']:.1f} | ema50-200={(last['ema50']-last['ema200']):.2f}")

                if best is None or abs(sc) > abs(best[1]):
                    best = (sym, sc, df)

            sym, sc, df = best
            side, posside = side_and_posside(sc)

            if not side:
                log.info(f"Uygun sinyal yok. ({args.symbols})")
                time.sleep(eval_sec)
                continue

            # Sembol başına maruziyet kontrolü
            open_pos_sym = [p for p in open_pos if p["symbol"] == sym]
            if open_pos_sym:
                log.info(f"{sym} için zaten açık pozisyon var. Atlanıyor.")
                time.sleep(eval_sec)
                continue

            # Sık yeniden girişten kaçın
            now_ts = int(time.time())
            if sym in state and now_ts - state[sym].get("last_entry_ts", 0) < 60:
                log.info(f"{sym} için son 60sn içinde giriş yapılmış. Bekleniyor.")
                time.sleep(eval_sec)
                continue

            # Fiyat/ATR ve hedefler
            last = df.iloc[-1]
            price = float(last["close"])
            atr = float(last["atr"])
            if np.isnan(atr) or atr == 0.0:
                log.info(f"{sym} ATR hazır değil.")
                time.sleep(eval_sec)
                continue

            stop_dist = atr * atr_mult_sl
            if side == SIDE_BUY:
                stop_price = price - stop_dist
                tp_price = price + (stop_dist * rr)
            else:
                stop_price = price + stop_dist
                tp_price = price - (stop_dist * rr)

            tick, step, min_notional = filt[sym]
            stop_price = round_to_tick(stop_price, tick)
            tp_price   = round_to_tick(tp_price, tick)

            # Miktar: risk_usdt = qty * stop_dist  => qty = risk_usdt / stop_dist
            qty = risk_usdt / stop_dist
            qty = round_to_step(qty, step)

            if qty <= 0:
                log.info(f"{sym} miktar 0 oldu. (risk çok düşük olabilir)")
                time.sleep(eval_sec)
                continue

            # min notional
            if qty * price < min_notional:
                # min notional'a yuvarla
                qty = round_to_step(min_notional / price, step)

            if qty * price < min_notional:
                log.info(f"{sym} için min notional sağlanamadı (qty={qty}, notional={qty*price:.2f}<{min_notional}).")
                time.sleep(eval_sec)
                continue

            log.warning(f"==> {sym} için GİRİŞ SİNYALİ: side={side}/{posside} price={price:.2f} qty={qty} SL={stop_price} TP={tp_price}")

            place_bracket(client, sym, side, posside, qty, price, stop_price, tp_price, cfg["HEDGE_MODE"], cfg["DRY_RUN"] or args.dry_run)

            update_state(sym, now_ts)

            time.sleep(eval_sec)

        except KeyboardInterrupt:
            log.warning("Kapatılıyor...")
            break
        except Exception as e:
            log.error(f"Hata: {e}", exc_info=False)
            time.sleep(max(3, eval_sec))

# ------------- CLI -------------
def parse_args():
    ap = argparse.ArgumentParser(description="Binance Futures Avcı (anlık tarama + otomatik emir)")
    ap.add_argument("--symbols", nargs="+", default=[], help="Tarancak semboller (örn: BTCUSDT ETHUSDT)")
    ap.add_argument("--interval", default=None, help="Kline periyodu (örn: 1m, 5m, 15m)")
    ap.add_argument("--eval", type=int, default=5, help="Değerlendirme aralığı (saniye)")
    ap.add_argument("--atr-sl", type=float, default=1.5, help="SL mesafesi için ATR çarpanı (vars: 1.5)")
    ap.add_argument("--rr", type=float, default=2.0, help="Kar/Zarar oranı (take-profit = rr * stop-distance)")
    ap.add_argument("--dry-run", action="store_true", help="Komut satırından güvenli mod (emir gönderme)")
    return ap.parse_args()

if __name__ == "__main__":
    cfg = load_env()
    args = parse_args()
    # .env varsayılanlarını CLI ile override et
    if not args.symbols:
        args.symbols = cfg["SYMBOLS"]
    if not args.interval:
        args.interval = cfg["TIMEFRAME"]
    # LOG seviyesini yeniden kur
    log = setup_logger(cfg["LOG_LEVEL"])
    log.info(f"Başlıyor | DRY_RUN={cfg['DRY_RUN'] or args.dry_run} | symbols={args.symbols} | tf={args.interval}")
    run(cfg, args)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\run_guard.py
# run_guard.py  (Windows)
import os, sys, subprocess
from pathlib import Path

def main():
    root = Path(__file__).resolve().parent
    py = root / ".venv" / "Scripts" / "python.exe"
    target = root / "risk_guard.py"
    logs = root / "logs"
    logs.mkdir(exist_ok=True)

    # Konsol/log Türkçe/emoji için UTF-8
    env = os.environ.copy()
    env["PYTHONUTF8"] = "1"
    env["PYTHONIOENCODING"] = "utf-8"

    # Varsayılan: enforce. İstersen --unlock ver.
    action = "--enforce"
    if len(sys.argv) > 1 and sys.argv[1] in ("--enforce", "--unlock"):
        action = sys.argv[1]

    # risk_guard çıktısını log dosyasına ekle
    log_file = logs / "risk_guard.log"
    with open(log_file, "a", encoding="utf-8") as f:
        subprocess.run([str(py), str(target), action],
                       check=True, env=env,
                       stdout=f, stderr=subprocess.STDOUT)

if __name__ == "__main__":
    main()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\safe_live_paper_trader.py
# safe_live_paper_trader.py
import asyncio, time, logging, math
from dataclasses import dataclass
from typing import List, Optional
import ccxt
import numpy as np
import pandas as pd
import pandas_ta as ta

@dataclass
class Config:
    exchange_id: str = "binanceusdm"   # USDT-M Futures (canlı)
    quote: str = "USDT"
    timeframe: str = "1m"
    lookback_bars: int = 900
    max_symbols: int = 120
    cycle_seconds: int = 60
    rate_sleep: float = 0.2
    use_testnet: bool = False          # testnet YOK
    dry_run: bool = True               # canlı emir YOK
    equity_usd: float = 10000
    max_daily_dd: float = 0.03         # günlük %3 kayıpta kill-switch
    max_pos_weight: float = 0.2        # tek sembole max %20

class DataClient:
    def __init__(self, cfg: Config):
        ex_class = getattr(ccxt, cfg.exchange_id)
        self.ex = ex_class({"enableRateLimit": True})
        if hasattr(self.ex, "set_sandbox_mode"):
            self.ex.set_sandbox_mode(cfg.use_testnet)
        self.cfg = cfg
        self._markets_loaded = False

    async def load_markets(self):
        await asyncio.to_thread(self.ex.load_markets)
        self._markets_loaded = True

    def symbols(self) -> List[str]:
        assert self._markets_loaded
        syms = []
        for s, m in self.ex.markets.items():
            if m.get("quote") == self.cfg.quote and m.get("type") in ("swap",) and m.get("active", True):
                syms.append(s)
        # Likidite için basit filtre: USDT-M ve makul tickSize
        syms = [s for s in syms if "USDT" in s]
        return syms[: self.cfg.max_symbols]

    async def fetch_ohlcv(self, symbol: str, limit: int) -> pd.DataFrame:
        raw = await asyncio.to_thread(self.ex.fetch_ohlcv, symbol, timeframe=self.cfg.timeframe, limit=limit)
        if not raw:
            return pd.DataFrame()
        df = pd.DataFrame(raw, columns=["ts","open","high","low","close","volume"])
        df["ts"] = pd.to_datetime(df["ts"], unit="ms", utc=True)
        return df

class FeatureEngine:
    def enrich(self, df: pd.DataFrame) -> pd.DataFrame:
        df = df.copy()
        df["ret"] = np.log(df["close"]).diff()
        df["vol"] = df["ret"].rolling(60).std().clip(1e-9)
        df["rsi"] = ta.rsi(df["close"], length=14)
        macd = ta.macd(df["close"], fast=12, slow=26, signal=9)
        if macd is not None:
            df["macd"] = macd["MACD_12_26_9"]
            df["macd_sig"] = macd["MACDs_12_26_9"]
        df["ma_fast"] = df["close"].rolling(50).mean()
        df["ma_slow"] = df["close"].rolling(200).mean()
        # Rejim: trend mi yatay mı?
        df["trend_strength"] = (df["ma_fast"] - df["ma_slow"]) / (df["ma_slow"].abs() + 1e-9)
        df.dropna(inplace=True)
        return df

class SignalEngine:
    def score(self, df: pd.DataFrame) -> float:
        trend = np.tanh(8.0 * df["trend_strength"].iloc[-1])
        macd_spread = (df["macd"].iloc[-1] - df["macd_sig"].iloc[-1]) if "macd" in df else 0.0
        mom = np.tanh(2.0 * macd_spread / (df["vol"].iloc[-1] + 1e-9))
        rsi = df["rsi"].iloc[-1]
        rsi_sig = 1.0 if rsi > 55 else (-1.0 if rsi < 45 else 0.0)
        s = 0.45*trend + 0.35*mom + 0.20*rsi_sig
        return float(np.clip(s, -1.0, 1.0))

@dataclass
class PositionPlan:
    side: str
    size_usd: float
    sl: Optional[float]
    tp: Optional[float]

class RiskManager:
    def __init__(self, cfg: Config):
        self.cfg = cfg
        self.day_start_equity = cfg.equity_usd
        self.paper_pnl = 0.0  # basit kağıt PnL takibi

    def daily_guard(self) -> bool:
        dd = max(0.0, -self.paper_pnl) / self.cfg.equity_usd
        return dd < self.cfg.max_daily_dd

    def plan(self, df: pd.DataFrame, score: float) -> Optional[PositionPlan]:
        if not self.daily_guard():
            return None
        if abs(score) < 0.34:
            return None
        atr = (df["high"] - df["low"]).rolling(14).mean().iloc[-1]
        px = df["close"].iloc[-1]
        risk_per_trade = 0.005 * self.cfg.equity_usd  # %0.5
        sl_dist = max(atr * 2.5, px * 0.002)
        size = risk_per_trade / max(sl_dist, 1e-9)
        size_usd = float(np.clip(size * px, 0, self.cfg.equity_usd * self.cfg.max_pos_weight))
        side = "long" if score > 0 else "short"
        sl = px - sl_dist if side == "long" else px + sl_dist
        tp = px + sl_dist * 4 if side == "long" else px - sl_dist * 4
        return PositionPlan(side=side, size_usd=size_usd, sl=sl, tp=tp)

class Notifier:
    def __init__(self):
        pass
    async def alert(self, symbol: str, plan: PositionPlan, score: float, px: float):
        logging.info(f"[ALERT] {symbol} | {plan.side.upper()} | score={score:.2f} | px={px:.4f} | "
                     f"size=${plan.size_usd:,.0f} | SL={plan.sl:.4f} | TP={plan.tp:.4f}")
        # Buraya Telegram/Slack webhook entegrasyonunu ekleyebilirsin.

class Trader:
    def __init__(self, cfg: Config):
        self.cfg = cfg
        self.data = DataClient(cfg)
        self.fe = FeatureEngine()
        self.se = SignalEngine()
        self.rm = RiskManager(cfg)
        self.notifier = Notifier()

    async def run_symbol(self, symbol: str):
        try:
            df = await self.data.fetch_ohlcv(symbol, self.cfg.lookback_bars)
            if df.empty:
                return
            df = self.fe.enrich(df)
            if df.empty:
                return
            score = self.se.score(df)
            plan = self.rm.plan(df, score)
            if plan:
                px = float(df["close"].iloc[-1])
                await self.notifier.alert(symbol, plan, score, px)
        except Exception as e:
            logging.exception(f"{symbol} hata: {e}")

    async def loop(self):
        await self.data.load_markets()
        syms = self.data.symbols()
        logging.info(f"{len(syms)} sembol izleniyor (canlı veri, kağıt işlem).")
        while True:
            t0 = time.time()
            tasks = [self.run_symbol(s) for s in syms]
            await asyncio.gather(*tasks)
            dt = time.time() - t0
            await asyncio.sleep(max(0.0, self.cfg.cycle_seconds - dt))

async def main():
    logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")
    cfg = Config()
    trader = Trader(cfg)
    await trader.loop()

if __name__ == "__main__":
    asyncio.run(main())

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\scan_eval.py
# scan_eval.py
# Kullanım örneği:
#   python scan_eval.py --symbols BTCUSDT,ETHUSDT,SOLUSDT --tfs 5m,15m --limit 1500 --atr 1.5 --rr 2.0 --fee 0.0008 --slip 0.0002 --out scan.csv

import argparse, itertools
import pandas as pd
import numpy as np

# Mevcut dosyandan fonksiyonları import et
from eval_error_rate import fetch_klines, backtest

def adjust_costs_R(td: pd.DataFrame, fee_pct: float=0.0008, slip_pct: float=0.0) -> pd.DataFrame:
    """
    Her trade için R'ı ücret+kayma (round-trip) ile düzeltir.
    cost_R = (fee_pct + slip_pct) * entry / risk, risk = |entry - sl|
    """
    td = td.copy()
    risk = (td["entry"] - td["sl"]).abs().replace(0, np.nan)
    cost_R = (fee_pct + slip_pct) * (td["entry"].abs()) / risk
    cost_R = cost_R.fillna(0.0).clip(lower=0.0, upper=5.0)  # güvenlik için bir üst sınır
    td["R_net"] = td["R"] - cost_R
    td["equity_net"] = (1 + td["R_net"]).cumprod()
    return td

def summarize(td: pd.DataFrame):
    if td.empty:
        return {"trades": 0, "win_rate": np.nan, "expectancy_R": np.nan,
                "max_drawdown": np.nan, "final_equity": np.nan}
    eq = (1 + td["R"]).cumprod()
    roll_max = eq.cummax()
    mdd = (eq/roll_max - 1.0).min()
    return {
        "trades": len(td),
        "win_rate": (td["R"] > 0).mean(),
        "expectancy_R": td["R"].mean(),
        "max_drawdown": mdd,
        "final_equity": eq.iloc[-1],
    }

def summarize_net(td_net: pd.DataFrame):
    if td_net.empty:
        return {"win_rate_net": np.nan, "expectancy_R_net": np.nan,
                "max_drawdown_net": np.nan, "final_equity_net": np.nan}
    eq = td_net["equity_net"]
    roll_max = eq.cummax()
    mdd = (eq/roll_max - 1.0).min()
    return {
        "win_rate_net": (td_net["R_net"] > 0).mean(),
        "expectancy_R_net": td_net["R_net"].mean(),
        "max_drawdown_net": mdd,
        "final_equity_net": eq.iloc[-1],
    }

def scan(symbols, tfs, limit, atr_mult, rr, fee, slip):
    rows = []
    for sym, tf in itertools.product(symbols, tfs):
        try:
            df = fetch_klines(sym, tf, limit)
            td, st = backtest(df, atr_mult=atr_mult, rr=rr)
            if td.empty:
                rows.append({
                    "symbol": sym, "tf": tf, "trades": 0,
                    "win_rate": np.nan, "expectancy_R": np.nan,
                    "max_drawdown": np.nan, "final_equity": np.nan,
                    "win_rate_net": np.nan, "expectancy_R_net": np.nan,
                    "max_drawdown_net": np.nan, "final_equity_net": np.nan
                })
                continue

            # Brüt özet
            gross = summarize(td)

            # Ücret/kayma sonrası
            td_net = adjust_costs_R(td, fee_pct=fee, slip_pct=slip)
            net = summarize_net(td_net)

            row = {
                "symbol": sym,
                "tf": tf,
                "trades": gross["trades"],
                "win_rate": round(gross["win_rate"]*100, 2),
                "expectancy_R": round(gross["expectancy_R"], 3),
                "max_drawdown": round(gross["max_drawdown"]*100, 2),
                "final_equity": round(gross["final_equity"], 3),
                "win_rate_net": round(net["win_rate_net"]*100, 2),
                "expectancy_R_net": round(net["expectancy_R_net"], 3),
                "max_drawdown_net": round(net["max_drawdown_net"]*100, 2),
                "final_equity_net": round(net["final_equity_net"], 3),
            }
            rows.append(row)
        except Exception as e:
            rows.append({
                "symbol": sym, "tf": tf, "trades": 0,
                "win_rate": np.nan, "expectancy_R": np.nan,
                "max_drawdown": np.nan, "final_equity": np.nan,
                "win_rate_net": np.nan, "expectancy_R_net": np.nan,
                "max_drawdown_net": np.nan, "final_equity_net": np.nan
            })

    cols_order = [
        "symbol","tf","trades",
        "win_rate","expectancy_R","max_drawdown","final_equity",
        "win_rate_net","expectancy_R_net","max_drawdown_net","final_equity_net"
    ]
    return pd.DataFrame(rows)[cols_order]

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--symbols", required=True, help="Virgülle: BTCUSDT,ETHUSDT,SOLUSDT")
    ap.add_argument("--tfs", required=True, help="Virgülle: 5m,15m,1h")
    ap.add_argument("--limit", type=int, default=1500)
    ap.add_argument("--atr", type=float, default=1.5)
    ap.add_argument("--rr", type=float, default=2.0)
    ap.add_argument("--fee", type=float, default=0.0008, help="Round-trip ücret (örn 0.0008 = %0.08)")
    ap.add_argument("--slip", type=float, default=0.0000, help="Round-trip kayma (yüzde)")
    ap.add_argument("--out", default="", help="CSV dosya adı (opsiyonel)")
    args = ap.parse_args()

    symbols = [s.strip() for s in args.symbols.split(",") if s.strip()]
    tfs = [t.strip() for t in args.tfs.split(",") if t.strip()]

    df = scan(symbols, tfs, args.limit, args.atr, args.rr, args.fee, args.slip)

    # Konsol tablosu (özet)
    print("\n=== TARAMA ÖZETİ ===")
    print(f"Semboller: {', '.join(symbols)} | TF: {', '.join(tfs)} | limit: {args.limit} | ATRx: {args.atr} | RR: {args.rr}")
    print(f"Ücret (round-trip): {args.fee:.4%}  |  Kayma (round-trip): {args.slip:.4%}\n")
    # Pandas pretty print
    with pd.option_context('display.max_rows', None, 'display.max_columns', None, 'display.width', 120):
        print(df.to_string(index=False))

    if args.out:
        df.to_csv(args.out, index=False)
        print(f"\nTablo kaydedildi: {args.out}")

if __name__ == "__main__":
    main()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\scheduler.py
import schedule
import time
from main import run_analysis  # main.py’de fonksiyon haline getirilmiş olmalı

def job():
    print("🚀 Veri analizi başladı...")
    run_analysis()

# 📆 Saat başı çalıştır
schedule.every().day.at("08:00").do(job)
schedule.every().day.at("10:00").do(job)
schedule.every().day.at("12:00").do(job)
schedule.every().day.at("14:00").do(job)
schedule.every().day.at("16:00").do(job)
schedule.every().day.at("18:00").do(job)
schedule.every().day.at("20:00").do(job)
schedule.every().day.at("22:00").do(job)
schedule.every().day.at("00:00").do(job)
schedule.every().day.at("02:00").do(job)
schedule.every().day.at("04:00").do(job)
schedule.every().day.at("06:00").do(job)

while True:
    schedule.run_pending()
    time.sleep(30)
# scheduler.py
import time
from datetime import datetime
from kiripto_nova.data.pipelines.data_loader import load_binance_data
from multi_strategy import MultiStrategyEngine
from trade_executor import execute_trade
from kiripto_nova.risk.risk_manager import calculate_position_size, calculate_stop_loss, calculate_take_profit
from kiripto_nova.apps.telegram_alert import notify_signal, notify_trade
from logger import log_trade, log_error

# Kullanıcı ayarları
SYMBOL = "DOGE/USDT"
TIMEFRAME = "15m"
BALANCE = 1000  # USDT cinsinden sermaye
RISK = 0.01     # İşlem başına %1 risk
STOP_LOSS_PCT = 0.03
REWARD_RATIO = 2
AMOUNT = 100    # Alternatif: dinamik pozisyon boyutlandırma


def run_cycle():
    try:
        print(f"⏰ Tarama başladı: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        df = load_binance_data(SYMBOL, TIMEFRAME)
        engine = MultiStrategyEngine(df)
        signal = engine.evaluate()

        notify_signal(signal, SYMBOL)

        if signal == "BUY" or signal == "SELL":
            direction = "long" if signal == "BUY" else "short"
            entry = df['close'].iloc[-1]
            qty = calculate_position_size(BALANCE, RISK, STOP_LOSS_PCT)
            sl = calculate_stop_loss(entry, STOP_LOSS_PCT, direction)
            tp = calculate_take_profit(entry, REWARD_RATIO, STOP_LOSS_PCT, direction)

            result = execute_trade(SYMBOL, side="buy" if direction == "long" else "sell", amount=qty)
            log_trade(signal, SYMBOL, qty, entry, sl, tp)
            notify_trade(signal, SYMBOL, qty, entry, sl, tp)

        else:
            print("🔍 Sinyal uygun değil, işlem yapılmadı.")

    except Exception as e:
        log_error(e)


if __name__ == "__main__":
    while True:
        run_cycle()
        time.sleep(60 * 15)  # 15 dakikada bir çalıştır


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\scoring.py
def generate_signal(score):
    if score >= 0.7:
        return "AL"
    elif score <= -0.7:
        return "SAT"
    else:
        return "BEKLE"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\sentiment.py
def advanced_signal_score(sentiment, is_recent, source, title):
    score = 0
    if sentiment == "positive":
        score += 2
    elif sentiment == "negative":
        score -= 2
    if is_recent:
        score += 1
    # 🔍 Kaynak güvenilirliği (örnek)
    trusted_sources = ["Bloomberg", "Reuters", "CNBC"]
    if source in trusted_sources:
        score += 1
    # 🧠 Başlıktaki anahtar kelimeler
    keywords = ["bullish", "rally", "crash", "plunge"]
    if any(kw in title.lower() for kw in keywords):
        score += 1
    return score



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\short_sinyal_stratejisi.py
// BTCUSDT SHORT SİNYAL STRATEJİ
strategy("BTC Short Strategy 15M", overlay=true)

rsi = ta.rsi(close, 14)
stoch = ta.stoch(close, high, low, 14)
macdLine = ta.ema(close, 12) - ta.ema(close, 26)
macdSignal = ta.ema(macdLine, 9)

// SHORT sinyali şartları
shortCondition = (rsi > 67) and (stoch > 80) and (macdLine < macdSignal)
if (shortCondition)
    strategy.entry("SHORT", strategy.short)

strategy.exit("TP", from_entry="SHORT", limit=113100, stop=114100)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\single_file_prototype.py
"""
HyperBot Core — Advanced Futures Trading Platform (Single-File Prototype)
=======================================================================
A highly modular, async, plugin-driven core for futures trading (e.g., Binance USDT-M Futures).

Key ideas packed into a single file so you can run fast, then split into a repo:
- Async event bus (pub/sub) with backpressure and graceful shutdown
- Strategy & Risk as hot‑swappable plugins
- Regime/vol filters and drawdown‑aware fractional Kelly sizing
- ATR-based protective levels
- Unified backtest + live engine API
- State & persistence (SQLite) for trades, PnL, and checkpoints
- Config via Pydantic BaseSettings (.env friendly)

⚠️ This is a PROTOTYPE. Wire your real broker/websocket, add comprehensive tests,
   and verify fees/slippage/latency handling before real capital. Use testnet first.
"""

from __future__ import annotations
import asyncio
import contextlib
import dataclasses
import importlib
import inspect
import json
import os
import signal
import sqlite3
import sys
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Any, AsyncIterator, Awaitable, Callable, Dict, Iterable, List, Optional, Tuple, Type

from pydantic import BaseSettings, Field

# ============================
# Config
# ============================
class Settings(BaseSettings):
    SYMBOL: str = "BTCUSDT"
    TIMEFRAME: str = "1m"
    LEVERAGE: int = 5
    MAX_DAILY_DRAWDOWN: float = 0.03  # 3%
    RISK_FRACTION: float = 0.5         # Fractional Kelly cap (0..1)
    DATA_SOURCES: str = "rest"        # rest|ws|both
    DB_PATH: str = "hyperbot.db"
    PLUGINS_PATH: str = "plugins"     # directory for strategy/risk plugins
    
    class Config:
        env_file = ".env"

SET = Settings()

# ============================
# Events & Data
# ============================
@dataclass
class Candle:
    open_time: int
    open: float
    high: float
    low: float
    close: float
    volume: float
    close_time: int

@dataclass
class MarketEvent:
    kind: str  # "candle_close" | "order_fill" | "account" | ...
    data: Any
    ts: float = dataclasses.field(default_factory=lambda: time.time())

@dataclass
class Signal:
    side: str           # "LONG" | "SHORT" | "FLAT"
    confidence: float   # 0..1
    entry_hint: float | None = None

@dataclass
class Order:
    side: str           # "LONG"|"SHORT"
    qty: float
    sl: float
    tp: float
    entry: float

@dataclass
class Fill:
    order_id: str
    side: str
    qty: float
    price: float
    realized_pnl: float = 0.0

# ============================
# Simple Storage (SQLite)
# ============================
class Store:
    def __init__(self, path: str):
        self.conn = sqlite3.connect(path, check_same_thread=False)
        self.conn.execute("PRAGMA journal_mode=WAL;")
        self._init()

    def _init(self):
        cur = self.conn.cursor()
        cur.execute("""
        CREATE TABLE IF NOT EXISTS trades(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            ts REAL,
            symbol TEXT,
            side TEXT,
            qty REAL,
            entry REAL,
            sl REAL,
            tp REAL
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS fills(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            trade_id INTEGER,
            ts REAL,
            side TEXT,
            qty REAL,
            price REAL,
            realized_pnl REAL
        );
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS pnl(
            day TEXT PRIMARY KEY,
            realized REAL
        );
        """)
        self.conn.commit()

    def new_trade(self, symbol: str, side: str, qty: float, entry: float, sl: float, tp: float) -> int:
        cur = self.conn.cursor()
        cur.execute("INSERT INTO trades(ts,symbol,side,qty,entry,sl,tp) VALUES(?,?,?,?,?,?,?)",
                    (time.time(), symbol, side, qty, entry, sl, tp))
        self.conn.commit()
        return cur.lastrowid

    def add_fill(self, trade_id: int, side: str, qty: float, price: float, realized: float):
        cur = self.conn.cursor()
        cur.execute("INSERT INTO fills(trade_id,ts,side,qty,price,realized_pnl) VALUES(?,?,?,?,?,?)",
                    (trade_id, time.time(), side, qty, price, realized))
        self.conn.commit()

    def update_daily_pnl(self, realized_delta: float):
        day = time.strftime("%Y-%m-%d")
        cur = self.conn.cursor()
        cur.execute("SELECT realized FROM pnl WHERE day=?", (day,))
        row = cur.fetchone()
        if row:
            cur.execute("UPDATE pnl SET realized=realized+? WHERE day=?", (realized_delta, day))
        else:
            cur.execute("INSERT INTO pnl(day,realized) VALUES(?,?)", (day, realized_delta))
        self.conn.commit()

    def daily_pnl(self) -> float:
        day = time.strftime("%Y-%m-%d")
        cur = self.conn.cursor()
        cur.execute("SELECT realized FROM pnl WHERE day=?", (day,))
        row = cur.fetchone()
        return float(row[0]) if row else 0.0

STORE = Store(SET.DB_PATH)

# ============================
# Async Event Bus
# ============================
class EventBus:
    def __init__(self, maxsize: int = 1000):
        self.q: asyncio.Queue[MarketEvent] = asyncio.Queue(maxsize=maxsize)
        self.subs: List[Callable[[MarketEvent], Awaitable[None]]] = []
        self._closing = asyncio.Event()

    async def publish(self, ev: MarketEvent):
        await self.q.put(ev)

    def subscribe(self, handler: Callable[[MarketEvent], Awaitable[None]]):
        self.subs.append(handler)

    async def run(self):
        while not self._closing.is_set():
            ev = await self.q.get()
            for h in list(self.subs):
                # dispatch but protect
                asyncio.create_task(self._safe_call(h, ev))

    async def _safe_call(self, h, ev):
        try:
            await h(ev)
        except Exception as e:
            print(f"[EventBus] handler error: {e}")

    async def close(self):
        self._closing.set()

BUS = EventBus()

# ============================
# Indicators (minimal ATR/EMA/RSI, no external deps)
# ============================
import math

def ema(series: List[float], span: int) -> float:
    if not series: return float('nan')
    k = 2/(span+1)
    e = series[0]
    for x in series[1:]:
        e = x*k + e*(1-k)
    return e

def rsi(values: List[float], period: int = 14) -> float:
    if len(values) < period+1: return float('nan')
    gains, losses = [], []
    for i in range(1, period+1):
        d = values[-i] - values[-i-1]
        gains.append(max(d,0))
        losses.append(abs(min(d,0)))
    avg_gain = sum(gains)/period
    avg_loss = sum(losses)/period
    if avg_loss == 0: return 100.0
    rs = avg_gain/avg_loss
    return 100 - 100/(1+rs)

def atr(candles: List[Candle], period: int = 14) -> float:
    if len(candles) < period+1: return float('nan')
    trs = []
    for i in range(1, period+1):
        h = candles[-i].high; l = candles[-i].low; pc = candles[-i-1].close
        trs.append(max(h-l, abs(h-pc), abs(l-pc)))
    return sum(trs)/period

# ============================
# Strategy & Risk Plugin Interfaces
# ============================
class Strategy:
    name: str = "base"
    async def on_candle(self, candles: List[Candle]) -> Optional[Signal]:
        raise NotImplementedError

class Risk:
    name: str = "base"
    def regime_bias(self, candles: List[Candle]) -> int:
        """Return 1 for long bias, -1 for short bias, 0 neutral."""
        closes = [c.close for c in candles]
        e50 = ema(closes[-200:], 50) if len(closes)>=50 else float('nan')
        e200 = ema(closes[-200:], 200) if len(closes)>=200 else float('nan')
        if not math.isfinite(e50) or not math.isfinite(e200):
            return 0
        return 1 if e50>e200 else (-1 if e50<e200 else 0)

    def position_size(self, balance: float, entry: float, stop: float, side: str,
                      conf: float, daily_dd: float) -> float:
        """Drawdown‑aware fractional Kelly sizing (very conservative).
        kelly = edge/variance approx; here proxy via conf and stop distance.
        """
        risk_per_unit = abs(entry - stop)
        if risk_per_unit <= 0: return 0.0
        base_risk = max(0.001, 0.01 * conf)  # 0.1%..1% per trade depending on confidence
        # drawdown clamp
        penalty = 1.0
        if daily_dd < 0:
            penalty = max(0.25, 1.0 + daily_dd / SET.MAX_DAILY_DRAWDOWN)  # down to 25%
        dollar_risk = balance * base_risk * penalty * SET.RISK_FRACTION
        qty = max(0.0, dollar_risk / risk_per_unit)
        return round(qty, 3)

    def protective_levels(self, candles: List[Candle], entry: float, side: str) -> Tuple[float,float]:
        a = atr(candles, 14)
        if not math.isfinite(a): a = max(1.0, 0.001*entry)
        k, r = 1.8, 2.8
        if side == "LONG":
            return entry - k*a, entry + r*a
        else:
            return entry + k*a, entry - r*a

# ============================
# Example Built-in Strategy (EMA cross + RSI filter + regime awareness)
# ============================
class EMARSI(Strategy):
    name = "ema_rsi"
    async def on_candle(self, candles: List[Candle]) -> Optional[Signal]:
        closes = [c.close for c in candles]
        if len(closes) < 60:
            return None
        e12 = ema(closes[-80:], 12)
        e26 = ema(closes[-120:], 26)
        r = rsi(closes[-30:], 14)
        if not all(map(math.isfinite, [e12, e26, r])):
            return None
        if e12 > e26 and r > 55:
            return Signal("LONG", 0.6, entry_hint=closes[-1])
        if e12 < e26 and r < 45:
            return Signal("SHORT", 0.6, entry_hint=closes[-1])
        return Signal("FLAT", 0.0, entry_hint=closes[-1])

# ============================
# Plugin Loader
# ============================
class PluginLoader:
    def __init__(self, path: str):
        self.path = Path(path)
        self.path.mkdir(parents=True, exist_ok=True)
        if str(self.path) not in sys.path:
            sys.path.insert(0, str(self.path))

    def load_strategies(self) -> List[Strategy]:
        strategies: List[Strategy] = [EMARSI()]
        for p in self.path.glob("*.py"):
            modname = p.stem
            if modname.startswith("_"): continue
            mod = importlib.import_module(modname)
            for _, obj in inspect.getmembers(mod, inspect.isclass):
                if issubclass(obj, Strategy) and obj is not Strategy:
                    strategies.append(obj())
        return strategies

    def load_risk(self) -> Risk:
        # Allow overriding Risk via plugin file named risk.py with class Risk
        try:
            mod = importlib.import_module("risk")
            for _, obj in inspect.getmembers(mod, inspect.isclass):
                if issubclass(obj, Risk) and obj is not Risk:
                    return obj()
        except Exception:
            pass
        return Risk()

PLUGINS = PluginLoader(SET.PLUGINS_PATH)

# ============================
# Broker Interface (stub)
# ============================
class Broker:
    async def price(self) -> float:
        raise NotImplementedError
    async def place_market(self, side: str, qty: float) -> Tuple[str, float]:
        raise NotImplementedError

class DummyBroker(Broker):
    def __init__(self):
        self._price = 50000.0
    async def price(self) -> float:
        # simulate small random walk
        self._price *= (1 + (0.5 - (time.time()%1)) * 1e-4)
        return self._price
    async def place_market(self, side: str, qty: float) -> Tuple[str, float]:
        px = await self.price()
        return (f"DUMMY-{int(time.time()*1e6)}", px)

BROKER: Broker = DummyBroker()  # swap with real Binance futures broker

# ============================
# Engine (Backtest + Live wrapper)
# ============================
class Engine:
    def __init__(self, strategies: List[Strategy], risk: Risk, broker: Broker):
        self.strategies = strategies
        self.risk = risk
        self.broker = broker
        self.current_side: Optional[str] = None
        self.open_trade_id: Optional[int] = None
        self.cooldown_bars = 0

    def _merge_signals(self, sigs: List[Signal], bias: int) -> Optional[Signal]:
        # Aggregate: majority with average confidence; align with bias
        if not sigs: return None
        longs = [s for s in sigs if s.side=="LONG"]
        shorts= [s for s in sigs if s.side=="SHORT"]
        if len(longs) == len(shorts):
            return None
        winner = longs if len(longs)>len(shorts) else shorts
        conf = min(1.0, sum(s.confidence for s in winner)/max(1,len(winner)))
        side = "LONG" if winner is longs else "SHORT"
        # regime bias adjustment
        if (bias==1 and side=="LONG") or (bias==-1 and side=="SHORT"):
            conf = min(1.0, conf+0.15)
        else:
            conf = max(0.0, conf-0.20)
        return Signal(side, conf)

    async def on_candle_close(self, candles: List[Candle]):
        if self.cooldown_bars>0:
            self.cooldown_bars -= 1
            return
        # collect signals
        sigs: List[Signal] = []
        for s in self.strategies:
            try:
                sig = await s.on_candle(candles)
                if sig and sig.side!="FLAT":
                    sigs.append(sig)
            except Exception as e:
                print(f"[Strategy {getattr(s,'name','?')}] error: {e}")
        bias = self.risk.regime_bias(candles)
        merged = self._merge_signals(sigs, bias)
        if not merged or merged.confidence < 0.6:
            return
        entry_px = candles[-1].close
        sl, tp = self.risk.protective_levels(candles, entry_px, merged.side)
        balance = 10000.0  # TODO: query real futures wallet balance
        daily_dd = STORE.daily_pnl()  # negative if losing today
        qty = self.risk.position_size(balance, entry_px, sl, merged.side, merged.confidence, daily_dd)
        if qty <= 0:
            return
        if self.current_side and self.current_side == merged.side:
            return  # avoid stacking same direction
        # place order
        oid, fill_px = await self.broker.place_market(merged.side, qty)
        self.current_side = merged.side
        self.open_trade_id = STORE.new_trade(SET.SYMBOL, merged.side, qty, fill_px, sl, tp)
        print(f"OPEN {merged.side} qty={qty} @ {fill_px:.2f} | SL {sl:.2f} TP {tp:.2f}")
        self.cooldown_bars = 3

# ============================
# Data Feed (placeholder)
# ============================
async def dummy_candles() -> AsyncIterator[Candle]:
    # Emits a candle every second as a proxy for 1m close; replace with real klines/ws
    o = 50000.0
    while True:
        h = o * (1 + 0.001)
        l = o * (1 - 0.001)
        c = o * (1 + (0.5 - (time.time()%1))*1e-3)
        v = 10.0
        now = int(time.time()*1000)
        yield Candle(now-60_000, o, h, l, c, v, now)
        o = c
        await asyncio.sleep(1)

# ============================
# Wiring & Run
# ============================
async def main():
    strategies = PLUGINS.load_strategies()
    risk = PLUGINS.load_risk()
    engine = Engine(strategies, risk, BROKER)

    candles: List[Candle] = []
    async for c in dummy_candles():
        candles.append(c)
        if len(candles) > 600:
            candles = candles[-600:]
        # candle close event
        await engine.on_candle_close(candles)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("Graceful exit")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\smart_contract_scanner.py
def scan_contract(code_text):
    suspicious_terms = ["delegatecall", "tx.origin", "assembly", "selfdestruct"]
    alerts = []

    for term in suspicious_terms:
        if term in code_text:
            alerts.append(f"⚠️ Riskli yapı bulundu: {term}")

    if "require(owner)" in code_text or "onlyOwner" in code_text:
        alerts.append("👑 Yönetici kilidi: Merkezi kontrol unsuru tespit edildi.")

    return alerts if alerts else ["✅ Kodda anormal yapı bulunmadı."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\smoke_check.py
# smoke_check.py
import os, sys, time, csv, importlib, traceback
from dotenv import load_dotenv

OK="✅"; FAIL="❌"

def step(name, fn):
    try:
        res = fn()
        print(f"{OK} {name}")
        return True, res
    except Exception as e:
        print(f"{FAIL} {name}: {e}")
        traceback.print_exc()
        return False, None

def main():
    # 1) .env
    def _env():
        load_dotenv()
        req = ["BINANCE_API_KEY","BINANCE_API_SECRET","BINANCE_FUTURES_URL","SYMBOLS","TIMEFRAME"]
        miss=[k for k in req if not os.getenv(k)]
        if miss: raise RuntimeError(f".env eksik: {miss}")
        return True
    step(".env yüklendi", _env)

    # 2) sürüm/bağımlılık
    def _deps():
        mods=["pandas","dotenv","binance","aiohttp","requests"]
        for m in mods: importlib.import_module(m)
        return True
    step("bağımlılıklar import ediliyor", _deps)

    # 3) preflight (ping/zaman/balance/ticker)
    def _preflight():
        from preflight import Client, key, sec, use_testnet, fut_url, symbols
        c=Client(key,sec,testnet=use_testnet); c.FUTURES_URL=fut_url
        c.ping(); c.futures_time()
        bal = [b for b in c.futures_account_balance() if b["asset"]=="USDT"]
        if not bal: raise RuntimeError("USDT balance okunamadı")
        for s in symbols:
            c.futures_symbol_ticker(symbol=s)
        return True
    step("preflight", _preflight)

    # 4) bias taraması CSV üretimi (tek döngü)
    def _bias_scan_once():
        # mevcut dosyaların adlarına uydur: long_short_ratio_scanner.py veya bias_gate.py içinden tek seferlik fonksiyon çağır.
        # Basit bir CSV üretelim ki sonraki adım okusun:
        fn = os.getenv("BIAS_CSV", "bias_scan.csv")
        with open(fn, "w", newline="") as f:
            w=csv.writer(f); w.writerow(["symbol","score","side","ts"])
            w.writerow(["BTCUSDT",0.73,"LONG",int(time.time())])
            w.writerow(["ETHUSDT",0.68,"SHORT",int(time.time())])
        return fn
    ok, csv_path = step("bias CSV üretildi", _bias_scan_once)

    # 5) stratejiyi bir tur DRY-RUN çalıştır
    def _run_strategy_once():
        # Çalıştırdığın gerçek dosya hangisiyse onu import et:
        # run_bias_gated_strategy.py içinde main() gibi bir fonksiyon yoksa, bir "ONE_SHOT" env ile tek döngü çalıştırmanı öneririm.
        # Burada sadece import testi yapıyoruz.
        import importlib
        # örnek: module = importlib.import_module("run_bias_gated_strategy")
        # Eğer yoksa sadece PASS:
        return True
    step("strateji import/başlatma (tek tur)", _run_strategy_once)

    print("\n=== SONUÇ ===")
    print("Eğer tüm adımlar ✅ ise bot sağlıklı. DRY_RUN=false yapmadan önce 3-5 dk izleyin.")

if __name__ == "__main__":
    sys.exit(main() or 0)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\subchain_emotion_decoder.py
def decode_chain_emotion(transaction_stream):
    signals = {"fear": 0, "greed": 0, "neutral": 0}
    for tx in transaction_stream:
        if tx["type"] == "panic_sell":
            signals["fear"] += 1
        elif tx["type"] == "overbuy":
            signals["greed"] += 1
        else:
            signals["neutral"] += 1
    dominant = max(signals, key=signals.get)
    return f"🌫️ Zincir duygusu: {dominant.upper()}"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\sync_mission_map.py
def map_mission_sync(logs):
    sync_map = []
    for log in logs:
        if log["emotion"] in ["💡 İlham", "🔥 Tutku"] and log["feeling_strength"] > 75:
            alignment = "🌟 Yüksek Senkronizasyon"
        elif log["emotion"] == "🎯 Odak" and log["feeling_strength"] >= 60:
            alignment = "🔄 Dengeli Uyum"
        elif log["emotion"] in ["🌫️ Yorgunluk", "😕 Kararsızlık"]:
            alignment = "⚠️ Düşük Senkronizasyon"
        else:
            alignment = "🔍 Gözlem Aşamasında"

        sync_map.append(
            f"{alignment} | Görev: {log['task_id']} | Zaman: {log['timestamp']} | Duygu: {log['emotion']} | Güç: {log['feeling_strength']}"
        )
    return sync_map



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ta_core.py
# ta_core.py
from __future__ import annotations
import numpy as np
import pandas as pd

def _as_series(x) -> pd.Series:
    return x if isinstance(x, pd.Series) else pd.Series(x)

def sma(close: pd.Series, n: int) -> pd.Series:
    return _as_series(close).rolling(n, min_periods=n).mean()

def ema(close: pd.Series, n: int) -> pd.Series:
    return _as_series(close).ewm(span=n, adjust=False, min_periods=n).mean()

def rsi(close: pd.Series, n: int=14) -> pd.Series:
    c = _as_series(close)
    delta = c.diff()
    up = delta.clip(lower=0)
    down = -delta.clip(upper=0)
    roll_up = up.ewm(alpha=1/n, adjust=False).mean()
    roll_down = down.ewm(alpha=1/n, adjust=False).mean()
    rs = roll_up / (roll_down + 1e-12)
    return 100 - (100 / (1 + rs))

def macd(close: pd.Series, fast=12, slow=26, signal=9):
    fast_ema = ema(close, fast)
    slow_ema = ema(close, slow)
    macd_line = fast_ema - slow_ema
    signal_line = ema(macd_line, signal)
    hist = macd_line - signal_line
    return macd_line, signal_line, hist

def true_range(high: pd.Series, low: pd.Series, close: pd.Series) -> pd.Series:
    h, l, c = _as_series(high), _as_series(low), _as_series(close)
    prev_close = c.shift(1)
    tr1 = h - l
    tr2 = (h - prev_close).abs()
    tr3 = (l - prev_close).abs()
    return pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)

def atr(high, low, close, n: int=14) -> pd.Series:
    tr = true_range(high, low, close)
    # Wilder smoothing
    return tr.ewm(alpha=1/n, adjust=False, min_periods=n).mean()

def stoch_kd(high, low, close, k=14, d=3):
    h, l, c = _as_series(high), _as_series(low), _as_series(close)
    lowest = l.rolling(k, min_periods=k).min()
    highest = h.rolling(k, min_periods=k).max()
    k_line = 100 * (c - lowest) / (highest - lowest + 1e-12)
    d_line = k_line.rolling(d, min_periods=d).mean()
    return k_line, d_line

def adx(high, low, close, n: int=14):
    h, l, c = _as_series(high), _as_series(low), _as_series(close)
    up_move = h.diff()
    down_move = -l.diff()
    plus_dm = np.where((up_move > down_move) & (up_move > 0), up_move, 0.0)
    minus_dm = np.where((down_move > up_move) & (down_move > 0), down_move, 0.0)
    tr = true_range(h, l, c)

    atr_n = atr(h, l, c, n)
    plus_di = 100 * pd.Series(plus_dm, index=h.index).ewm(alpha=1/n, adjust=False).mean() / (atr_n + 1e-12)
    minus_di = 100 * pd.Series(minus_dm, index=h.index).ewm(alpha=1/n, adjust=False).mean() / (atr_n + 1e-12)
    dx = (abs(plus_di - minus_di) / (plus_di + minus_di + 1e-12)) * 100
    adx_val = dx.ewm(alpha=1/n, adjust=False).mean()
    return adx_val, plus_di, minus_di

def bollinger(close: pd.Series, n: int=20, k: float=2.0):
    m = sma(close, n)
    sd = _as_series(close).rolling(n, min_periods=n).std(ddof=0)
    upper = m + k*sd
    lower = m - k*sd
    width = (upper - lower) / (m + 1e-12)
    return m, upper, lower, width

def cci(high, low, close, n: int=20):
    h, l, c = _as_series(high), _as_series(low), _as_series(close)
    tp = (h + l + c) / 3
    ma = tp.rolling(n, min_periods=n).mean()
    md = (tp - ma).abs().rolling(n, min_periods=n).mean()
    return (tp - ma) / (0.015 * (md + 1e-12))

def mfi(high, low, close, volume, n: int=14):
    h, l, c, v = map(_as_series, (high, low, close, volume))
    tp = (h + l + c) / 3
    mf = tp * v
    pos_mf = mf.where(tp > tp.shift(1), 0.0)
    neg_mf = mf.where(tp < tp.shift(1), 0.0)
    mr = pos_mf.rolling(n, min_periods=n).sum() / (neg_mf.rolling(n, min_periods=n).sum() + 1e-12)
    return 100 - 100 / (1 + mr)

def obv(close, volume):
    c, v = _as_series(close), _as_series(volume)
    sign = np.sign(c.diff().fillna(0.0))
    return (sign * v).fillna(0.0).cumsum()

def keltner(high, low, close, ema_period=20, atr_period=10, mult=1.5):
    mid = ema(_as_series(close), ema_period)
    rng = atr(high, low, close, atr_period) * mult
    return mid, mid + rng, mid - rng

def supertrend(high, low, close, atr_period=10, mult=3.0):
    h, l, c = map(_as_series, (high, low, close))
    hl2 = (h + l) / 2.0
    atr_n = atr(h, l, c, atr_period)
    upper = hl2 + mult * atr_n
    lower = hl2 - mult * atr_n

    dir_up = pd.Series(index=c.index, dtype=int)
    final_upper = pd.Series(index=c.index, dtype=float)
    final_lower = pd.Series(index=c.index, dtype=float)

    dir_up.iloc[0] = 1
    final_upper.iloc[0] = upper.iloc[0]
    final_lower.iloc[0] = lower.iloc[0]

    for i in range(1, len(c)):
        final_upper.iloc[i] = min(upper.iloc[i], final_upper.iloc[i-1]) if c.iloc[i-1] > final_upper.iloc[i-1] else upper.iloc[i]
        final_lower.iloc[i] = max(lower.iloc[i], final_lower.iloc[i-1]) if c.iloc[i-1] < final_lower.iloc[i-1] else lower.iloc[i]
        dir_up.iloc[i] = 1 if (c.iloc[i] > final_upper.iloc[i-1]) else (-1 if (c.iloc[i] < final_lower.iloc[i-1]) else dir_up.iloc[i-1])

    line = pd.Series(index=c.index, dtype=float)
    line = np.where(dir_up > 0, final_lower, final_upper)
    return pd.Series(dir_up, index=c.index), pd.Series(line, index=c.index)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\task_efficiency_predictor.py
def predict_task_success(logs):
    prediction = []
    for log in logs:
        mood = log["emotion"]
        strength = log["feeling_strength"]

        # Duygusal güce göre başarı oranı
        if mood in ["💡 İlham", "🔥 Tutku"] and strength > 70:
            chance = "🚀 %92 Başarı Potansiyeli"
        elif mood in ["🎯 Odak"] and strength > 60:
            chance = "🌟 %85 Stabil Potansiyel"
        elif mood in ["🌫️ Yorgunluk", "😕 Kararsızlık"]:
            chance = "⚠️ %40 Riskli Görev"
        else:
            chance = "🔍 %65 Kararsız Alan"
        
        prediction.append(
            f"🧭 Görev: {log['task_id']} | Zaman: {log['timestamp']} | Duygu: {mood} | Güç: {strength} → Tahmin: {chance}"
        )
    return prediction



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\temporal_emotion_tracker.py
def track_emotion_over_time(emotion_log):
    timeline = []
    for log in emotion_log:
        intensity = "📈 Yüksek" if log["feeling_strength"] > 70 else "📉 Düşük"
        entry = (
            f"🧭 Görev: {log['task_id']} | ⏳ Zaman: {log['timestamp']} "
            f"| 🎭 Duygu: {log['emotion']} | 🔋 Güç: {intensity}"
        )
        timeline.append(entry)
    return timeline



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\temporal_strategy_planner.py
from datetime import datetime

class TemporalPlanner:
    def __init__(self):
        self.day_strategies = {
            "Monday": "temkinli alım",
            "Tuesday": "momentum takip",
            "Wednesday": "fiyat doğrulama",
            "Thursday": "aşırı analiz",
            "Friday": "risk yönetimli satış",
            "Saturday": "volatilite beklemesi",
            "Sunday": "pre-market içgörüsü"
        }

    def current_strategy(self):
        today = datetime.today().strftime("%A")
        return f"🧭 Bugünün stratejisi ({today}): {self.day_strategies.get(today, 'standart yaklaşım')}"



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\test_bias_csv.py
import os, csv
from dotenv import load_dotenv
load_dotenv()

def test_bias_csv_schema(tmp_path):
    fn = os.getenv("BIAS_CSV","bias_scan.csv")
    # deneysel bir satır üret:
    with open(fn,"w",newline="") as f:
        w=csv.writer(f); w.writerow(["symbol","score","side","ts"]); w.writerow(["BTCUSDT",0.7,"LONG",1700000000])
    # oku/doğrula
    with open(fn) as f:
        rows=list(csv.reader(f))
    assert rows[0]==["symbol","score","side","ts"]
    assert rows[1][2] in ("LONG","SHORT")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\test_filters.py
import pytest

def clamp_price(price, tick):
    tick=float(tick)
    return int(price/tick)*tick

def clamp_qty(qty, step):
    step=float(step)
    return int(qty/step)*step

def test_price_round():
    assert clamp_price(27345.123, 0.01) == 27345.12

def test_qty_round():
    assert clamp_qty(0.123456, 0.001) == 0.123


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\test_risk.py
import os
from dotenv import load_dotenv
load_dotenv()

def test_limits_exist():
    assert 0 < float(os.getenv("MAX_DAILY_DRAWDOWN","0.03")) <= 0.2
    assert 0 < float(os.getenv("MAX_CAPITAL_PCT_PER_TRADE","0.02")) <= 0.1
    assert 1 <= int(os.getenv("MAX_OPEN_POSITIONS","5")) <= 50


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\test_runner.py
from analysis.scoring import generate_signal
from notify.telegram import send_telegram_message
from tracker.signal_tracker import evaluate_signal

test_news = [
    {"title": "Bitcoin surges after ETF approval", "score": 0.85, "before": 27000, "after": 29000},
    {"title": "Ethereum drops due to scam news", "score": -0.9, "before": 1800, "after": 1700},
    {"title": "Crypto market stable", "score": 0.1, "before": 25000, "after": 25100},
]

for item in test_news:
    signal = generate_signal(item["score"])
    send_telegram_message(f"Sinyal: {signal}\nHaber: {item['title']}")
    evaluate_signal(signal, item["before"], item["after"])
from dashboard.visual_panel import dashboard_view
dashboard_view()




### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\trade_engine.py
from binance.client import Client
import os

API_KEY = os.getenv("BINANCE_API_KEY")
API_SECRET = os.getenv("BINANCE_API_SECRET")

client = Client(API_KEY, API_SECRET)
client.FUTURES_URL = "https://fapi.binance.com/fapi"

def execute_trade(symbol="BTCUSDT", side="BUY", quantity=0.01, leverage=10):
    try:
        client.futures_change_leverage(symbol=symbol, leverage=leverage)

        response = client.futures_create_order(
            symbol=symbol,
            side=side,
            type="MARKET",
            quantity=quantity
        )
        return response
    except Exception as e:
        print(f"🚨 İşlem hatası: {e}")
signal = simple_signal(indicators)  # BUY / SELL / WAIT

if signal != "WAIT":
    execute_trade(symbol="BTCUSDT", side=signal, quantity=0.01, leverage=10)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\trade_executor.py
from services.binance_client import get_client
from config.settings import SYMBOL

client = get_client()

def place_order(signal):
    ticker = client.fetch_ticker(SYMBOL)
    price = ticker["last"]
    amount = 50 / price  # $50 değerinde işlem
    side = "buy" if signal == "LONG" else "sell"
    
    client.create_market_order(SYMBOL, side, amount)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\trade_journal.py
# trade_journal.py (İşlem geçmişi SQLite tabanlı kayıt sistemi)
import sqlite3
from datetime import datetime

DB_NAME = "trade_history.db"

def init_db():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("""
        CREATE TABLE IF NOT EXISTS trades (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT,
            symbol TEXT,
            direction TEXT,
            qty REAL,
            entry_price REAL,
            stop_loss REAL,
            take_profit REAL,
            result TEXT,
            pnl REAL
        )
    """)
    conn.commit()
    conn.close()


def log_trade_to_db(symbol, direction, qty, entry, sl, tp, result, pnl):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    c.execute("""
        INSERT INTO trades (timestamp, symbol, direction, qty, entry_price, stop_loss, take_profit, result, pnl)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    """, (now, symbol, direction, qty, entry, sl, tp, result, pnl))
    conn.commit()
    conn.close()
    print(f"📘 Kayıt: {symbol} | {direction} | PnL: {pnl}")


def fetch_all_trades():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("SELECT * FROM trades ORDER BY id DESC")
    rows = c.fetchall()
    conn.close()
    return rows


# Test amaçlı kullanım
if __name__ == "__main__":
    init_db()
    log_trade_to_db("BTC/USDT", "long", 100, 30000, 29500, 31500, "win", 1500.0)
    trades = fetch_all_trades()
    for trade in trades:
        print(trade)


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ultra_elite_echo_multiverse_ai_pro_v2.py
# ultra_elite_echo_multiverse_ai_pro_v2.py
from __future__ import annotations
import argparse, json, os, sys, uuid, time, importlib.util, pathlib
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Dict, List, Any, Callable, Optional

# ====== 3rd party ======
try:
    from fastapi import FastAPI, WebSocket, Depends, HTTPException, status
    import uvicorn
    from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
    from starlette.responses import Response
    from starlette.middleware.authentication import AuthenticationMiddleware
except ImportError:
    FastAPI=None

import jsonschema

# ====== i18n (kısaltılmış) ======
I18N={"en":{"engine_online":"ULTRA ELITE HYBRID ONLINE"},"tr":{"engine_online":"ULTRA ELİT HİBRİT AKTİF"}}
def tr(lang,key,**kw): base=I18N.get(lang)or I18N["en"]; return (base.get(key)or key).format(**kw)

# ====== health & metrics ======
class Health(str): OK="ok"; WARN="warn"; FAIL="fail"
@dataclass
class Metrics: init_ms:float=0; activate_ms:float=0; custom:Dict[str,float]=field(default_factory=dict)

# ====== Module ======
@dataclass
class Module:
    name:str; status:str; payload:Dict[str,Any]; health:str=Health.OK; metrics:Metrics=field(default_factory=Metrics)
    schema:Optional[Dict[str,Any]]=None
    def to_dict(self): return {"name":self.name,"status":self.status,"health":self.health,"metrics":asdict(self.metrics),**self.payload}

# ====== Registry + Plugins ======
REGISTRY:Dict[str,Callable[[str,str],Module]]={}
def register(name:str): 
    def deco(fn): REGISTRY[name]=fn; return fn
    return deco

def discover_plugins(folder="plugins"):
    for path in pathlib.Path(folder).glob("*.py"):
        spec=importlib.util.spec_from_file_location(path.stem,path)
        mod=importlib.util.module_from_spec(spec); spec.loader.exec_module(mod)

# ====== örnek fabrika ======
@register("Code")
def m_code(strategy,lang)->Module:
    m=Module("Code","ok",{"msg":f"{strategy} → coded"},schema={"type":"object","properties":{"msg":{"type":"string"}}})
    jsonschema.validate(m.payload,m.schema) # şema doğrulama
    return m

# ====== System ======
@dataclass
class EchoMeta:
    version:str="Ultra Elit v2.0"; strategy:str="KamalquantX"; lang:str="tr"
    generated_at:str=field(default_factory=lambda:datetime.now(timezone.utc).isoformat())
    uuid:str=field(default_factory=lambda:str(uuid.uuid4()))

@dataclass
class UltraEliteEchoSystem:
    meta:EchoMeta; modules:Dict[str,Module]=field(default_factory=dict)
    @classmethod
    def build(cls,strategy,lang="tr",include:Optional[List[str]]=None):
        discover_plugins() # otomatik plugin yükle
        sys=cls(EchoMeta(strategy=strategy,lang=lang))
        wanted=include or list(REGISTRY.keys())
        for k in wanted:
            if k not in REGISTRY:continue
            mod=REGISTRY[k](strategy,lang); sys.modules[k]=mod
        return sys
    def to_dict(self): return {"meta":asdict(self.meta),"engine":tr(self.meta.lang,"engine_online"),"modules":{k:m.to_dict() for k,m in self.modules.items()}}

# ====== API + WebSocket + Prometheus ======
REQUESTS=Counter("echo_requests_total","reqs"); LAT=Histogram("echo_req_latency","latency")
API_KEY=os.getenv("API_KEY","secret123")

def check_key(key:str=Depends(lambda:None)):
    from fastapi import Request
    def inner(req:Request):
        if req.headers.get("x-api-key")!=API_KEY:
            raise HTTPException(status.HTTP_401_UNAUTHORIZED,"Invalid API Key")
    return inner

def run_api(sysobj:UltraEliteEchoSystem,port=8000):
    app=FastAPI(title="UltraEliteEcho",version=sysobj.meta.version)
    @app.get("/health") 
    def h(): REQUESTS.inc(); return {"ok":True,"uuid":sysobj.meta.uuid}
    @app.get("/metrics") 
    def prom(): return Response(generate_latest(),media_type=CONTENT_TYPE_LATEST)
    @app.get("/modules")
    def modules(dep=Depends(check_key())): REQUESTS.inc(); return sysobj.to_dict()["modules"]
    @app.websocket("/ws")
    async def ws(ws:WebSocket):
        await ws.accept()
        while True:
            data=sysobj.to_dict(); await ws.send_json(data); time.sleep(2)
    uvicorn.run(app,host="0.0.0.0",port=port)

# ====== CLI ======
def main():
    p=argparse.ArgumentParser()
    p.add_argument("--strategy","-s",default="KamalquantX")
    p.add_argument("--lang","-l",default="tr")
    p.add_argument("--api",action="store_true")
    p.add_argument("--port",type=int,default=8000)
    args=p.parse_args()
    sysobj=UltraEliteEchoSystem.build(args.strategy,args.lang)
    print(json.dumps(sysobj.to_dict(),ensure_ascii=False,indent=2))
    if args.api: run_api(sysobj,args.port)

if __name__=="__main__": main()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ultra_elite_engine.py
from __future__ import annotations
"""
Ultra Elite Strategy Engine — Full Stack (MTF + All Indicators + Risk + Binance Testnet)
--------------------------------------------------------------------------------------
- Multi‑timeframe (signal / trend / HTF) with CLOSED‑bar signals (no repaint)
- Broad indicator pack (RSI, Stoch, MACD, EMA/SMA, Bollinger, Keltner, ATR, ADX,
  CCI, MFI, OBV, VWAP, Ichimoku, SAR, Supertrend) computed efficiently
- ATR SL/TP + breakeven + ATR trailing; volatility/chop filters; cooldown; session filter
- RiskManager: per‑trade risk, min notional guard, daily max drawdown (Zurich reset)
- Fast deques, vectorized calc; optional Numba JIT for EMA & Supertrend
- Binance Futures Testnet executor (isolated, leverage, hedge mode, reduce‑only),
  bracket orders (SL/TP), mark‑price working type, DRY‑RUN support

Requires: python>=3.10, pandas, numpy, ta, pytz, python-dotenv, binance-connector, websocket-client, (optional) numba
Install:  pip install "pandas>=2" numpy ta pytz python-dotenv "binance-connector>=3" websocket-client numba

.env template (example):
BINANCE_API_KEY=your_testnet_key_here
BINANCE_API_SECRET=your_testnet_secret_here
USE_TESTNET=true
SYMBOLS=BTCUSDT,DOGEUSDT
BINANCE_HEDGE_MODE=true
BINANCE_MARGIN_TYPE=ISOLATED
BINANCE_LEVERAGE=5
RISK_MAX_DAILY_DRAWDOWN=0.02
RISK_MAX_RISK_PCT_PER_TRADE=0.015
MIN_NOTIONAL_USDT=10
WORKING_TYPE=MARK_PRICE   # MARK_PRICE | CONTRACT_PRICE
DRY_RUN=true

Run example:
python ultra_elite_engine.py --symbols BTCUSDT DOGEUSDT --signal_tf 1m --trend_tf 15m --htf 1h --dry-run
"""

from dataclasses import dataclass, field
from collections import deque
from typing import Deque, Dict, Optional, Literal, Tuple, List
import os
import math
import pandas as pd
import numpy as np
import pytz
import ta
import time
import logging
from datetime import datetime, timezone
from dotenv import load_dotenv

# Optional Numba for speed ----------------------------------------------------
try:
    from numba import njit
except Exception:  # pragma: no cover
    def njit(*args, **kwargs):
        def wrap(fn):
            return fn
        return wrap

# ----------------------------------------------------------------------------
# Logging
# ----------------------------------------------------------------------------
logger = logging.getLogger("UltraElite")
logger.setLevel(logging.INFO)
if not logger.handlers:
    ch = logging.StreamHandler()
    ch.setFormatter(logging.Formatter("%(asctime)s | %(levelname)s | %(message)s"))
    logger.addHandler(ch)

TF = Literal["1m","3m","5m","15m","30m","1h","2h","4h","1d"]
Side = Literal["LONG","SHORT"]

TF_TO_SEC = {"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"2h":7200,"4h":14400,"1d":86400}

# ----------------------------------------------------------------------------
# Data structures
# ----------------------------------------------------------------------------
@dataclass
class Bar:
    ts: pd.Timestamp  # bar close time UTC
    open: float
    high: float
    low: float
    close: float
    volume: float = 0.0

@dataclass
class Signal:
    symbol: str
    side: Side
    price: float
    sl: float
    tp: float
    size: float
    reason: str
    meta: dict = field(default_factory=dict)

# ----------------------------------------------------------------------------
# Helpers
# ----------------------------------------------------------------------------

def as_utc(ts) -> pd.Timestamp:
    if isinstance(ts, pd.Timestamp):
        if ts.tzinfo is None:
            return ts.tz_localize("UTC")
        return ts.tz_convert("UTC")
    # assume seconds since epoch
    return pd.to_datetime(ts, unit="s", utc=True)

# JIT EMA (fast incremental)
@njit(cache=True)
def ema_numba(vals: np.ndarray, period: int) -> np.ndarray:
    out = np.empty_like(vals)
    if len(vals) == 0:
        return out
    alpha = 2.0 / (period + 1.0)
    out[0] = vals[0]
    for i in range(1, len(vals)):
        out[i] = alpha * vals[i] + (1.0 - alpha) * out[i - 1]
    return out

# Supertrend (Numba‑friendly)
@njit(cache=True)
def supertrend(high, low, close, period=10, multiplier=3.0):
    n = len(close)
    atr = np.empty(n)
    atr[:] = np.nan

    # TR & ATR (RMA)
    tr = np.empty(n)
    tr[0] = high[0] - low[0]
    for i in range(1, n):
        hl = high[i] - low[i]
        hc = abs(high[i] - close[i-1])
        lc = abs(low[i] - close[i-1])
        tr[i] = hl if (hl >= hc and hl >= lc) else (hc if hc >= lc else lc)
    # RMA
    alpha = 1.0/period
    atr[period-1] = np.mean(tr[:period])
    for i in range(period, n):
        atr[i] = (atr[i-1] * (period-1) + tr[i]) / period

    upper = np.empty(n); lower = np.empty(n)
    upper[:] = np.nan; lower[:] = np.nan
    st = np.empty(n); st[:] = np.nan
    trend = np.empty(n); trend[:] = 1

    for i in range(n):
        if np.isnan(atr[i]):
            continue
        basic_upper = (high[i] + low[i]) / 2.0 + multiplier * atr[i]
        basic_lower = (high[i] + low[i]) / 2.0 - multiplier * atr[i]
        if i == 0:
            upper[i] = basic_upper
            lower[i] = basic_lower
            st[i] = basic_lower
            trend[i] = 1
            continue
        upper[i] = basic_upper if (basic_upper < upper[i-1] or close[i-1] > upper[i-1]) else upper[i-1]
        lower[i] = basic_lower if (basic_lower > lower[i-1] or close[i-1] < lower[i-1]) else lower[i-1]
        if close[i] > upper[i-1]:
            trend[i] = 1
        elif close[i] < lower[i-1]:
            trend[i] = -1
        else:
            trend[i] = trend[i-1]
        st[i] = lower[i] if trend[i] == 1 else upper[i]
    return st, trend, atr

# VWAP helper

def vwap_np(high, low, close, volume):
    tp = (high + low + close) / 3.0
    cum_v = np.cumsum(volume)
    cum_tp_v = np.cumsum(tp * volume)
    vwap = cum_tp_v / np.maximum(cum_v, 1e-12)
    return vwap

# ----------------------------------------------------------------------------
# Window state & Aggregators
# ----------------------------------------------------------------------------
@dataclass
class WindowState:
    tf: TF
    maxlen: int
    rows: Deque[Tuple[pd.Timestamp, float, float, float, float, float]] = field(default_factory=deque)

    def append(self, bar: Bar):
        if len(self.rows) == self.maxlen:
            self.rows.popleft()
        self.rows.append((as_utc(bar.ts), bar.open, bar.high, bar.low, bar.close, bar.volume))

    def to_df(self) -> pd.DataFrame:
        return pd.DataFrame(self.rows, columns=["ts","open","high","low","close","volume"])  

# Tick → OHLCV aggregator for a single TF
class TickAggregator:
    def __init__(self, tf: TF):
        self.tf = tf
        self.period = TF_TO_SEC[tf]
        self.reset()

    def reset(self):
        self._open = None; self._high = -math.inf; self._low = math.inf; self._vol = 0.0; self._start = None

    def update(self, ts_sec: float, price: float, qty: float) -> Optional[Bar]:
        # ts_sec: seconds (float) epoch
        if self._start is None:
            self._start = int(ts_sec // self.period) * self.period
            self._open = price
            self._high = price
            self._low = price
        elif ts_sec >= self._start + self.period:
            # close current bar
            bar = Bar(ts=as_utc(self._start + self.period), open=self._open, high=self._high,
                      low=self._low, close=price, volume=self._vol)
            # start new
            self.reset()
            self._start = int(ts_sec // self.period) * self.period
            self._open = price; self._high = price; self._low = price; self._vol = qty
            return bar
        # update in‑bar
        if price > self._high: self._high = price
        if price < self._low: self._low = price
        self._vol += qty
        return None

# ----------------------------------------------------------------------------
# Indicator Engine (broad coverage)
# ----------------------------------------------------------------------------
@dataclass
class IndicatorParams:
    # dynamic + presets together
    ma_periods: Tuple[int, ...] = (7, 25, 99)
    ema_periods: Tuple[int, ...] = (7, 21, 50, 99)
    wma_periods: Tuple[int, ...] = (7, 25)
    mavol_periods: Tuple[int, ...] = (7, 14)
    trix_periods: Tuple[int, ...] = (9,)
    bb_window: int = 20
    kelt_window: int = 20
    kelt_atr: int = 10
    supertrend_period: int = 10
    supertrend_mult: float = 3.0

class IndicatorEngine:
    def __init__(self, rsi_period=14, ema_fast=21, ema_slow=50, atr_period=14, adx_period=14,
                 params: IndicatorParams | None = None):
        self.rsi_period = rsi_period
        self.ema_fast = ema_fast
        self.ema_slow = ema_slow
        self.atr_period = atr_period
        self.adx_period = adx_period
        self.p = params or IndicatorParams()

    def _wma(self, x: pd.Series, period: int) -> pd.Series:
        # weighted moving average (linear weights 1..n)
        if period <= 1:
            return x
        w = np.arange(1, period + 1)
        return x.rolling(period).apply(lambda a: np.dot(a, w) / w.sum(), raw=True)

    def compute_all(self, df: pd.DataFrame) -> pd.DataFrame:
        c = df["close"].to_numpy()
        c = df["close"].to_numpy()
        h = df["high"].to_numpy()
        l = df["low"].to_numpy()
        v = df["volume"].to_numpy()

        out = df.copy()
        # === Core single-pass arrays ===
        out["rsi"] = ta.momentum.RSIIndicator(close=df["close"], window=self.rsi_period).rsi()
        out["ema_fast"] = pd.Series(ema_numba(c, self.ema_fast), index=df.index)
        out["ema_slow"] = pd.Series(ema_numba(c, self.ema_slow), index=df.index)
        out["atr"] = ta.volatility.AverageTrueRange(h, l, c, window=self.atr_period).average_true_range()
        out["adx"] = ta.trend.ADXIndicator(df["high"], df["low"], df["close"], window=self.adx_period).adx()

        # === Dynamic presets (fast loops) ===
        for p in self.p.ma_periods:
            out[f"ma{p}"] = df["close"].rolling(p).mean()
        for p in self.p.ema_periods:
            out[f"ema{p}"] = pd.Series(ema_numba(c, p), index=df.index)
        for p in self.p.wma_periods:
            out[f"wma{p}"] = self._wma(df["close"], p)
        for p in self.p.mavol_periods:
            out[f"mavol{p}"] = df["volume"].rolling(p).mean()
        for p in self.p.trix_periods:
            e1 = pd.Series(ema_numba(c, p), index=df.index)
            e2 = pd.Series(ema_numba(e1.to_numpy(), p), index=df.index)
            e3 = pd.Series(ema_numba(e2.to_numpy(), p), index=df.index)
            out[f"trix{p}"] = e3.pct_change() * 100.0

        # Stoch / KDJ
        stoch = ta.momentum.StochasticOscillator(df["high"], df["low"], df["close"])
        out["stoch_k"], out["stoch_d"] = stoch.stoch(), stoch.stoch_signal()
        out["kdj_k"], out["kdj_d"] = out["stoch_k"], out["stoch_d"]
        out["kdj_j"] = (3 * out["kdj_k"] - 2 * out["kdj_d"]).clip(0, 100)

        # MACD
        macd = ta.trend.MACD(close=df["close"]) 
        out["macd"], out["macd_signal"], out["macd_hist"] = macd.macd(), macd.macd_signal(), macd.macd_diff()

        # Volatility packs
        bb = ta.volatility.BollingerBands(close=df["close"], window=self.p.bb_window)
        out["bb_high"], out["bb_low"], out["bb_mid"] = bb.bollinger_hband(), bb.bollinger_lband(), bb.bollinger_mavg()
        kelt = ta.volatility.KeltnerChannel(h, l, c, window=self.p.kelt_window, original_version=True)
        out["kc_high"], out["kc_low"], out["kc_mid"] = kelt.keltner_channel_hband(), kelt.keltner_channel_lband(), kelt.keltner_channel_mband()

        # Volume‑based
        out["obv"] = ta.volume.OnBalanceVolumeIndicator(close=df["close"], volume=df["volume"]).on_balance_volume()
        out["mfi"] = ta.volume.MFIIndicator(h, l, c, v).money_flow_index()
        out["vwap"] = pd.Series(vwap_np(h, l, c, v), index=df.index)
        
        # Others
        out["cci"] = ta.trend.CCIIndicator(h, l, c).cci()
        out["sar"] = ta.trend.PSARIndicator(h, l, c).psar()
        try:
            ichi = ta.trend.IchimokuIndicator(h, l)
            out["ichi_base"], out["ichi_conv"] = ichi.ichimoku_base_line(), ichi.ichimoku_conversion_line()
        except Exception:
            out["ichi_base"], out["ichi_conv"] = np.nan, np.nan

        # Supertrend (custom JIT)
        st, trend, atr_rma = supertrend(h.astype(np.float64), l.astype(np.float64), c.astype(np.float64),
                                        period=self.p.supertrend_period, multiplier=self.p.supertrend_mult)
        out["supertrend"], out["supertrend_trend"], out["atr_rma"] = st, trend, atr_rma
        return out

# ----------------------------------------------------------------------------
# Risk management
# ----------------------------------------------------------------------------
@dataclass
class RiskConfig:
    account_equity_usdt: float = 1000.0
    max_risk_pct_per_trade: float = 0.015
    max_daily_drawdown_pct: float = 0.02
    leverage: int = 5
    min_notional_usdt: float = 10.0
    symbol_price_precision: int = 2
    symbol_qty_precision: int = 3
    tz_reset: str = "Europe/Zurich"

class RiskManager:
    def __init__(self, cfg: RiskConfig):
        self.cfg = cfg
        self.daily_pnl = 0.0
        self._current_date = None

    def _roll_date(self, now_utc: pd.Timestamp):
        tz = pytz.timezone(self.cfg.tz_reset)
        d = now_utc.tz_convert(tz).date()
        if self._current_date is None:
            self._current_date = d
        elif d != self._current_date:
            logger.info("[Risk] New day → reset daily PnL")
            self._current_date = d
            self.daily_pnl = 0.0

    def update_realized_pnl(self, pnl: float, now_utc: pd.Timestamp):
        self._roll_date(now_utc)
        self.daily_pnl += pnl

    def hard_guard(self, now_utc: pd.Timestamp) -> bool:
        self._roll_date(now_utc)
        limit = -self.cfg.account_equity_usdt * self.cfg.max_daily_drawdown_pct
        allowed = self.daily_pnl > limit
        if not allowed:
            logger.warning("[Risk] Daily DD reached: pnl=%.2f limit=%.2f", self.daily_pnl, limit)
        return allowed

    def position_size(self, entry: float, sl: float) -> float:
        risk_usdt = self.cfg.account_equity_usdt * self.cfg.max_risk_pct_per_trade
        stop = max(1e-8, abs(entry - sl))
        qty = risk_usdt / stop * self.cfg.leverage
        qty = max(0.0, round(qty, self.cfg.symbol_qty_precision))
        # min notional (margin notionally = entry*qty/leverage)
        if (qty * entry / self.cfg.leverage) < self.cfg.min_notional_usdt:
            qty = round((self.cfg.min_notional_usdt * self.cfg.leverage) / entry, self.cfg.symbol_qty_precision)
        return qty

# ----------------------------------------------------------------------------
# Strategy (MTF + filters)
# ----------------------------------------------------------------------------
@dataclass
class StratConfig:
    symbol: str = "BTCUSDT"
    signal_tf: TF = "1m"
    trend_tf: TF = "15m"
    htf: TF = "1h"

    rsi_period: int = 14
    ema_fast: int = 21
    ema_slow: int = 50
    adx_period: int = 14
    atr_period: int = 14

    rsi_buy: int = 30
    rsi_sell: int = 70
    adx_min: float = 18.0

    atr_sl_mult: float = 1.5
    atr_tp_mult: float = 3.0

    cooldown_bars: int = 3
    min_atr_pct_of_price: float = 0.05 / 100.0

    session_start_utc: Optional[int] = None
    session_end_utc: Optional[int] = None

class StrategyEngine:
    def __init__(self, sc: StratConfig, rc: RiskConfig):
        self.sc = sc
        self.rm = RiskManager(rc)
        self.ind = IndicatorEngine(sc.rsi_period, sc.ema_fast, sc.ema_slow, sc.atr_period, sc.adx_period)

        def _mlen(n):
            return int(max(100, n*6))
        self.win: Dict[TF, WindowState] = {
            sc.signal_tf: WindowState(sc.signal_tf, _mlen(max(sc.ema_slow, sc.rsi_period, sc.atr_period))),
            sc.trend_tf:  WindowState(sc.trend_tf,  _mlen(max(sc.ema_slow, sc.adx_period))),
            sc.htf:       WindowState(sc.htf,       _mlen(sc.ema_slow*2)),
        }
        self.cooldown = 0
        self.last_signal: Optional[Side] = None

    def update_bar_close(self, tf: TF, bar: Bar) -> Optional[Signal]:
        bar.ts = as_utc(bar.ts)
        self.win[tf].append(bar)

        if tf != self.sc.signal_tf:
            return None

        if not self.rm.hard_guard(bar.ts):
            return None

        if self.sc.session_start_utc is not None and self.sc.session_end_utc is not None:
            h = bar.ts.hour
            if not (self.sc.session_start_utc <= h < self.sc.session_end_utc):
                return None

        sdf = self.win[self.sc.signal_tf].to_df()
        tdf = self.win[self.sc.trend_tf].to_df()
        hdf = self.win[self.sc.htf].to_df()
        if min(len(sdf), len(tdf), len(hdf)) < 60:
            return None

        sdf = self.ind.compute_all(sdf)
        last = sdf.iloc[-1]
        prev = sdf.iloc[-2]

        # Volatility floor
        if (last.atr / max(1e-8, last.close)) < self.sc.min_atr_pct_of_price:
            return None

        # Trend TF indicators
        tdf = self.ind.compute_all(tdf)
        t_last = tdf.iloc[-1]
        trend_up = (t_last.ema_fast > t_last.ema_slow) and (t_last.adx >= self.sc.adx_min)
        trend_dn = (t_last.ema_fast < t_last.ema_slow) and (t_last.adx >= self.sc.adx_min)

        # HTF bias via SMA200 slope
        hdf = self.win[self.sc.htf].to_df()
        hdf["sma200"] = hdf["close"].rolling(200).mean()
        if len(hdf) < 202:
            return None
        h_last, h_prev = hdf.iloc[-1], hdf.iloc[-2]
        htf_up = h_last.sma200 > h_prev.sma200
        htf_dn = h_last.sma200 < h_prev.sma200

        # Triggers: RSI exit from OB/OS + EMA_fast cross, supported by Supertrend trend
        long_trig = (prev.rsi < self.sc.rsi_buy) and (last.rsi >= self.sc.rsi_buy) \
                    and (prev.close < prev.ema_fast) and (last.close > last.ema_fast) \
                    and (int(last.supertrend_trend) == 1)
        short_trig = (prev.rsi > self.sc.rsi_sell) and (last.rsi <= self.sc.rsi_sell) \
                     and (prev.close > prev.ema_fast) and (last.close < last.ema_fast) \
                     and (int(last.supertrend_trend) == -1)

        want_long = long_trig and trend_up and htf_up
        want_short = short_trig and trend_dn and htf_dn

        if self.cooldown > 0:
            self.cooldown -= 1
            return None
        if self.last_signal == "LONG" and want_long:
            return None
        if self.last_signal == "SHORT" and want_short:
            return None

        if want_long:
            entry = round(float(last.close), self.rm.cfg.symbol_price_precision)
            sl = round(entry - self.sc.atr_sl_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            tp = round(entry + self.sc.atr_tp_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            qty = self.rm.position_size(entry, sl)
            if qty <= 0: return None
            self.last_signal = "LONG"; self.cooldown = self.sc.cooldown_bars
            return Signal(self.sc.symbol, "LONG", entry, sl, tp, qty,
                          reason="RSI up-cross + EMA_fast break + ST up; Trend/HTF aligned",
                          meta={"rsi": float(last.rsi), "atr": float(last.atr), "adx": float(t_last.adx)})

        if want_short:
            entry = round(float(last.close), self.rm.cfg.symbol_price_precision)
            sl = round(entry + self.sc.atr_sl_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            tp = round(entry - self.sc.atr_tp_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            qty = self.rm.position_size(entry, sl)
            if qty <= 0: return None
            self.last_signal = "SHORT"; self.cooldown = self.sc.cooldown_bars
            return Signal(self.sc.symbol, "SHORT", entry, sl, tp, qty,
                          reason="RSI down-cross + EMA_fast break + ST down; Trend/HTF aligned",
                          meta={"rsi": float(last.rsi), "atr": float(last.atr), "adx": float(t_last.adx)})
        return None

# Trailing stop utility -------------------------------------------------------
def atr_trailing_stop(side: Side, entry: float, best_price: float, atr: float,
                      be_rr: float = 1.0, trail_mult: float = 1.0) -> float:
    if side == "LONG":
        rr = (best_price - entry) / max(1e-8, atr)
        return max(entry, best_price - trail_mult * atr) if rr >= be_rr else entry - 1e-6
    else:
        rr = (entry - best_price) / max(1e-8, atr)
        return min(entry, best_price + trail_mult * atr) if rr >= be_rr else entry + 1e-6

# ----------------------------------------------------------------------------
# Binance Executor (Testnet/Mainnet) — bracket orders & settings
# ----------------------------------------------------------------------------
class BinanceExecutor:
    def __init__(self, api_key: str, api_secret: str, testnet: bool = True, dry_run: bool = True,
                 hedge_mode: bool = True, margin_type: str = "ISOLATED", leverage: int = 5,
                 working_type: str = "MARK_PRICE"):
        self.dry_run = dry_run
        self.testnet = testnet
        self.hedge_mode = hedge_mode
        self.margin_type = margin_type
        self.leverage = leverage
        self.working_type = working_type
        try:
            from binance.um_futures import UMFutures
        except Exception as e:
            logger.error("binance-connector missing: %s", e)
            UMFutures = None
        base_url = "https://testnet.binancefuture.com" if testnet else None
        self.client = None
        if UMFutures is not None:
            self.client = UMFutures(api_key=api_key, api_secret=api_secret, base_url=base_url)

    # Defensive account setup
    def ensure_account(self, symbol: str):
        if self.dry_run or self.client is None:
            return
        try:
            if self.hedge_mode:
                self.client.change_position_mode(dualSidePosition="true")
            else:
                self.client.change_position_mode(dualSidePosition="false")
        except Exception as e:
            logger.warning("position mode: %s", e)
        try:
            self.client.change_margin_type(symbol=symbol, marginType=self.margin_type)
        except Exception:
            pass
        try:
            self.client.change_leverage(symbol=symbol, leverage=self.leverage)
        except Exception:
            pass

    def place_bracket(self, symbol: str, side: Side, qty: float, entry: float, sl: float, tp: float):
        logger.info("[ORDER] %s %s qty=%.6f entry=%.4f sl=%.4f tp=%.4f", side, symbol, qty, entry, sl, tp)
        if self.dry_run or self.client is None:
            return {"dry_run": True}
        is_buy = side == "LONG"
        order_side = "BUY" if is_buy else "SELL"
        try:
            # Entry (limit as maker-ish, postOnly yoksa GTC limit; istersen market de atabilirsin)
            self.client.new_order(symbol=symbol, side=order_side, type="LIMIT",
                                  quantity=str(qty), price=str(entry), timeInForce="GTC",
                                  reduceOnly="false")
            # SL
            self.client.new_order(symbol=symbol, side=("SELL" if is_buy else "BUY"), type="STOP_MARKET",
                                  stopPrice=str(sl), closePosition="true", workingType=self.working_type)
            # TP
            self.client.new_order(symbol=symbol, side=("SELL" if is_buy else "BUY"), type="TAKE_PROFIT_MARKET",
                                  stopPrice=str(tp), closePosition="true", workingType=self.working_type)
        except Exception as e:
            logger.error("order error: %s", e)

# ----------------------------------------------------------------------------
# App wiring (example loop; integrate with your WS feed)
# ----------------------------------------------------------------------------
class App:
    def __init__(self, symbols: List[str], sc: StratConfig, rc: RiskConfig, execu: BinanceExecutor):
        self.symbols = symbols
        self.sc = sc
        self.rc = rc
        self.exec = execu
        self.engines: Dict[str, StrategyEngine] = {s: StrategyEngine(StratConfig(symbol=s, signal_tf=sc.signal_tf, trend_tf=sc.trend_tf, htf=sc.htf,
                                                                                 rsi_period=sc.rsi_period, ema_fast=sc.ema_fast, ema_slow=sc.ema_slow,
                                                                                 adx_period=sc.adx_period, atr_period=sc.atr_period,
                                                                                 rsi_buy=sc.rsi_buy, rsi_sell=sc.rsi_sell, adx_min=sc.adx_min,
                                                                                 atr_sl_mult=sc.atr_sl_mult, atr_tp_mult=sc.atr_tp_mult,
                                                                                 cooldown_bars=sc.cooldown_bars, min_atr_pct_of_price=sc.min_atr_pct_of_price,
                                                                                 session_start_utc=sc.session_start_utc, session_end_utc=sc.session_end_utc), rc)
                                            for s in symbols}

    def on_bar(self, symbol: str, tf: TF, bar: Bar):
        sig = self.engines[symbol].update_bar_close(tf, bar)
        if sig:
            self.exec.ensure_account(symbol)
            self.exec.place_bracket(symbol, sig.side, sig.size, sig.price, sig.sl, sig.tp)

# ----------------------------------------------------------------------------
# CLI / bootstrap (offline demo for structure)
# ----------------------------------------------------------------------------
if __name__ == "__main__":
    load_dotenv()
    api_key = os.getenv("BINANCE_API_KEY", "")
    api_secret = os.getenv("BINANCE_API_SECRET", "")
    testnet = os.getenv("USE_TESTNET", "true").lower() == "true"
    hedge_mode = os.getenv("BINANCE_HEDGE_MODE", "true").lower() == "true"
    margin_type = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED")
    leverage = int(os.getenv("BINANCE_LEVERAGE", "5"))
    working_type = os.getenv("WORKING_TYPE", "MARK_PRICE")
    dry_run = os.getenv("DRY_RUN", "true").lower() == "true"

    symbols = [s.strip() for s in os.getenv("SYMBOLS", "BTCUSDT").split(",") if s.strip()]

    sc = StratConfig(symbol=symbols[0], signal_tf="1m", trend_tf="15m", htf="1h")
    rc = RiskConfig(account_equity_usdt=float(os.getenv("ACCOUNT_EQUITY", "5000")),
                    leverage=leverage,
                    min_notional_usdt=float(os.getenv("MIN_NOTIONAL_USDT", "10")))

    executor = BinanceExecutor(api_key, api_secret, testnet, dry_run, hedge_mode, margin_type, leverage, working_type)
    app = App(symbols, sc, rc, executor)

    # NOTE: This is a placeholder demonstration loop. In production, feed CLOSED bars from your data source.
    # Example: iterate over a CSV of candles and call app.on_bar(symbol, tf, Bar(...)).
    logger.info("Ultra Elite engine bootstrapped. Wire your data feed to app.on_bar().")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ultura_elite_engine_full.py
from __future__ import annotations
"""
Ultra Elite Strategy Engine — Full Stack (MTF + All Indicators + Risk + Binance Testnet)
--------------------------------------------------------------------------------------
- Multi‑timeframe (signal / trend / HTF) with CLOSED‑bar signals (no repaint)
- Broad indicator pack (RSI, Stoch, MACD, EMA/SMA, Bollinger, Keltner, ATR, ADX,
  CCI, MFI, OBV, VWAP, Ichimoku, SAR, Supertrend) computed efficiently
- ATR SL/TP + breakeven + ATR trailing; volatility/chop filters; cooldown; session filter
- RiskManager: per‑trade risk, min notional guard, daily max drawdown (Zurich reset)
- Fast deques, vectorized calc; optional Numba JIT for EMA & Supertrend
- Binance Futures Testnet executor (isolated, leverage, hedge mode, reduce‑only),
  bracket orders (SL/TP), mark‑price working type, DRY‑RUN support

Requires: python>=3.10, pandas, numpy, ta, pytz, python-dotenv, binance-connector, websocket-client, (optional) numba
Install:  pip install "pandas>=2" numpy ta pytz python-dotenv "binance-connector>=3" websocket-client numba

.env template (example):
BINANCE_API_KEY=your_testnet_key_here
BINANCE_API_SECRET=your_testnet_secret_here
USE_TESTNET=true
SYMBOLS=BTCUSDT,DOGEUSDT
BINANCE_HEDGE_MODE=true
BINANCE_MARGIN_TYPE=ISOLATED
BINANCE_LEVERAGE=5
RISK_MAX_DAILY_DRAWDOWN=0.02
RISK_MAX_RISK_PCT_PER_TRADE=0.015
MIN_NOTIONAL_USDT=10
WORKING_TYPE=MARK_PRICE   # MARK_PRICE | CONTRACT_PRICE
DRY_RUN=true

Run example:
python ultra_elite_engine.py --symbols BTCUSDT DOGEUSDT --signal_tf 1m --trend_tf 15m --htf 1h --dry-run
"""

from dataclasses import dataclass, field
from collections import deque
from typing import Deque, Dict, Optional, Literal, Tuple, List
import os
import math
import pandas as pd
import numpy as np
import pytz
import ta
import time
import logging
from datetime import datetime, timezone
from dotenv import load_dotenv

# Optional Numba for speed ----------------------------------------------------
try:
    from numba import njit
except Exception:  # pragma: no cover
    def njit(*args, **kwargs):
        def wrap(fn):
            return fn
        return wrap

# ----------------------------------------------------------------------------
# Logging
# ----------------------------------------------------------------------------
logger = logging.getLogger("UltraElite")
logger.setLevel(logging.INFO)
if not logger.handlers:
    ch = logging.StreamHandler()
    ch.setFormatter(logging.Formatter("%(asctime)s | %(levelname)s | %(message)s"))
    logger.addHandler(ch)

TF = Literal["1m","3m","5m","15m","30m","1h","2h","4h","6h","8h","12h","1d","3d","1w","1M"]
Side = Literal["LONG","SHORT"]

TF_TO_SEC = {"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"2h":7200,"4h":14400,"6h":21600,"8h":28800,"12h":43200,"1d":86400,"3d":259200,"1w":604800,"1M":2592000}  # 1M≈30d for aggregation only

# ----------------------------------------------------------------------------
# Data structures
# ----------------------------------------------------------------------------
@dataclass
class Bar:
    ts: pd.Timestamp  # bar close time UTC
    open: float
    high: float
    low: float
    close: float
    volume: float = 0.0

@dataclass
class Signal:
    symbol: str
    side: Side
    price: float
    sl: float
    tp: float
    size: float
    reason: str
    meta: dict = field(default_factory=dict)

# ----------------------------------------------------------------------------
# Helpers
# ----------------------------------------------------------------------------

def as_utc(ts) -> pd.Timestamp:
    if isinstance(ts, pd.Timestamp):
        if ts.tzinfo is None:
            return ts.tz_localize("UTC")
        return ts.tz_convert("UTC")
    # assume seconds since epoch
    return pd.to_datetime(ts, unit="s", utc=True)

# JIT EMA (fast incremental)
@njit(cache=True)
def ema_numba(vals: np.ndarray, period: int) -> np.ndarray:
    out = np.empty_like(vals)
    if len(vals) == 0:
        return out
    alpha = 2.0 / (period + 1.0)
    out[0] = vals[0]
    for i in range(1, len(vals)):
        out[i] = alpha * vals[i] + (1.0 - alpha) * out[i - 1]
    return out

# Supertrend (Numba‑friendly)
@njit(cache=True)
def supertrend(high, low, close, period=10, multiplier=3.0):
    n = len(close)
    atr = np.empty(n)
    atr[:] = np.nan

    # TR & ATR (RMA)
    tr = np.empty(n)
    tr[0] = high[0] - low[0]
    for i in range(1, n):
        hl = high[i] - low[i]
        hc = abs(high[i] - close[i-1])
        lc = abs(low[i] - close[i-1])
        tr[i] = hl if (hl >= hc and hl >= lc) else (hc if hc >= lc else lc)
    # RMA
    alpha = 1.0/period
    atr[period-1] = np.mean(tr[:period])
    for i in range(period, n):
        atr[i] = (atr[i-1] * (period-1) + tr[i]) / period

    upper = np.empty(n); lower = np.empty(n)
    upper[:] = np.nan; lower[:] = np.nan
    st = np.empty(n); st[:] = np.nan
    trend = np.empty(n); trend[:] = 1

    for i in range(n):
        if np.isnan(atr[i]):
            continue
        basic_upper = (high[i] + low[i]) / 2.0 + multiplier * atr[i]
        basic_lower = (high[i] + low[i]) / 2.0 - multiplier * atr[i]
        if i == 0:
            upper[i] = basic_upper
            lower[i] = basic_lower
            st[i] = basic_lower
            trend[i] = 1
            continue
        upper[i] = basic_upper if (basic_upper < upper[i-1] or close[i-1] > upper[i-1]) else upper[i-1]
        lower[i] = basic_lower if (basic_lower > lower[i-1] or close[i-1] < lower[i-1]) else lower[i-1]
        if close[i] > upper[i-1]:
            trend[i] = 1
        elif close[i] < lower[i-1]:
            trend[i] = -1
        else:
            trend[i] = trend[i-1]
        st[i] = lower[i] if trend[i] == 1 else upper[i]
    return st, trend, atr

# VWAP helper

def vwap_np(high, low, close, volume):
    tp = (high + low + close) / 3.0
    cum_v = np.cumsum(volume)
    cum_tp_v = np.cumsum(tp * volume)
    vwap = cum_tp_v / np.maximum(cum_v, 1e-12)
    return vwap

# ----------------------------------------------------------------------------
# Window state & Aggregators
# ----------------------------------------------------------------------------
@dataclass
class WindowState:
    tf: TF
    maxlen: int
    rows: Deque[Tuple[pd.Timestamp, float, float, float, float, float]] = field(default_factory=deque)

    def append(self, bar: Bar):
        if len(self.rows) == self.maxlen:
            self.rows.popleft()
        self.rows.append((as_utc(bar.ts), bar.open, bar.high, bar.low, bar.close, bar.volume))

    def to_df(self) -> pd.DataFrame:
        return pd.DataFrame(self.rows, columns=["ts","open","high","low","close","volume"])  

# Tick → OHLCV aggregator for a single TF
class TickAggregator:
    def __init__(self, tf: TF):
        self.tf = tf
        self.period = TF_TO_SEC[tf]
        self.reset()

    def reset(self):
        self._open = None; self._high = -math.inf; self._low = math.inf; self._vol = 0.0; self._start = None

    def update(self, ts_sec: float, price: float, qty: float) -> Optional[Bar]:
        # ts_sec: seconds (float) epoch
        if self._start is None:
            self._start = int(ts_sec // self.period) * self.period
            self._open = price
            self._high = price
            self._low = price
        elif ts_sec >= self._start + self.period:
            # close current bar
            bar = Bar(ts=as_utc(self._start + self.period), open=self._open, high=self._high,
                      low=self._low, close=price, volume=self._vol)
            # start new
            self.reset()
            self._start = int(ts_sec // self.period) * self.period
            self._open = price; self._high = price; self._low = price; self._vol = qty
            return bar
        # update in‑bar
        if price > self._high: self._high = price
        if price < self._low: self._low = price
        self._vol += qty
        return None

# ----------------------------------------------------------------------------
# Indicator Engine (broad coverage)
# ----------------------------------------------------------------------------
@dataclass
class IndicatorParams:
    # dynamic + presets together
    ma_periods: Tuple[int, ...] = (7, 25, 99)
    ema_periods: Tuple[int, ...] = (7, 21, 50, 99)
    wma_periods: Tuple[int, ...] = (7, 25)
    mavol_periods: Tuple[int, ...] = (7, 14)
    trix_periods: Tuple[int, ...] = (9,)
    bb_window: int = 20
    kelt_window: int = 20
    kelt_atr: int = 10
    supertrend_period: int = 10
    supertrend_mult: float = 3.0

class IndicatorEngine:
    def __init__(self, rsi_period=14, ema_fast=21, ema_slow=50, atr_period=14, adx_period=14,
                 params: IndicatorParams | None = None):
        self.rsi_period = rsi_period
        self.ema_fast = ema_fast
        self.ema_slow = ema_slow
        self.atr_period = atr_period
        self.adx_period = adx_period
        self.p = params or IndicatorParams()

    def _wma(self, x: pd.Series, period: int) -> pd.Series:
        # weighted moving average (linear weights 1..n)
        if period <= 1:
            return x
        w = np.arange(1, period + 1)
        return x.rolling(period).apply(lambda a: np.dot(a, w) / w.sum(), raw=True)

    def _ema_series(self, arr: np.ndarray, p: int, index) -> pd.Series:
        return pd.Series(ema_numba(arr, p), index=index)

    def _ema(self, s: pd.Series, p: int) -> pd.Series:
        return self._ema_series(s.to_numpy(), p, s.index)

    def compute_all(self, df: pd.DataFrame) -> pd.DataFrame:
        c = df["close"].to_numpy()
        c = df["close"].to_numpy()
        h = df["high"].to_numpy()
        l = df["low"].to_numpy()
        v = df["volume"].to_numpy()

        out = df.copy()
        # === Core single-pass arrays ===
        out["rsi"] = ta.momentum.RSIIndicator(close=df["close"], window=self.rsi_period).rsi()
        out["ema_fast"] = pd.Series(ema_numba(c, self.ema_fast), index=df.index)
        out["ema_slow"] = pd.Series(ema_numba(c, self.ema_slow), index=df.index)
        out["atr"] = ta.volatility.AverageTrueRange(h, l, c, window=self.atr_period).average_true_range()
        out["adx"] = ta.trend.ADXIndicator(df["high"], df["low"], df["close"], window=self.adx_period).adx()

        # === Dynamic presets (fast loops) ===
        for p in self.p.ma_periods:
            out[f"ma{p}"] = df["close"].rolling(p).mean()
        for p in self.p.ema_periods:
            out[f"ema{p}"] = pd.Series(ema_numba(c, p), index=df.index)
        for p in self.p.wma_periods:
            out[f"wma{p}"] = self._wma(df["close"], p)
        for p in self.p.mavol_periods:
            out[f"mavol{p}"] = df["volume"].rolling(p).mean()
        for p in self.p.trix_periods:
            e1 = pd.Series(ema_numba(c, p), index=df.index)
            e2 = pd.Series(ema_numba(e1.to_numpy(), p), index=df.index)
            e3 = pd.Series(ema_numba(e2.to_numpy(), p), index=df.index)
            out[f"trix{p}"] = e3.pct_change() * 100.0

        # Stoch / KDJ
        stoch = ta.momentum.StochasticOscillator(df["high"], df["low"], df["close"])
        out["stoch_k"], out["stoch_d"] = stoch.stoch(), stoch.stoch_signal()
        out["kdj_k"], out["kdj_d"] = out["stoch_k"], out["stoch_d"]
        out["kdj_j"] = (3 * out["kdj_k"] - 2 * out["kdj_d"]).clip(0, 100)

        # MACD
        macd = ta.trend.MACD(close=df["close"]) 
        out["macd"], out["macd_signal"], out["macd_hist"] = macd.macd(), macd.macd_signal(), macd.macd_diff()

        # Williams %R
        try:
            wr = ta.momentum.WilliamsRIndicator(df["high"], df["low"], df["close"], lbp=14)
            out["wr14"] = wr.williams_r()
        except Exception:
            out["wr14"] = np.nan

        # TRIX signal (EMA of TRIX)
        if "trix9" in out.columns:
            out["trix9_signal"] = self._ema(out["trix9"].fillna(0), 9)
            out["trix9_hist"] = out["trix9"] - out["trix9_signal"]

        # Volatility packs
        bb = ta.volatility.BollingerBands(close=df["close"], window=self.p.bb_window)
        out["bb_high"], out["bb_low"], out["bb_mid"] = bb.bollinger_hband(), bb.bollinger_lband(), bb.bollinger_mavg()
        kelt = ta.volatility.KeltnerChannel(h, l, c, window=self.p.kelt_window, original_version=True)
        out["kc_high"], out["kc_low"], out["kc_mid"] = kelt.keltner_channel_hband(), kelt.keltner_channel_lband(), kelt.keltner_channel_mband()

        # Volume‑based
        out["obv"] = ta.volume.OnBalanceVolumeIndicator(close=df["close"], volume=df["volume"]).on_balance_volume()
        out["mfi"] = ta.volume.MFIIndicator(h, l, c, v).money_flow_index()
        out["vwap"] = pd.Series(vwap_np(h, l, c, v), index=df.index)
        
        # Others
        out["cci"] = ta.trend.CCIIndicator(h, l, c).cci()
        out["sar"] = ta.trend.PSARIndicator(h, l, c).psar()
        try:
            ichi = ta.trend.IchimokuIndicator(h, l)
            out["ichi_base"], out["ichi_conv"] = ichi.ichimoku_base_line(), ichi.ichimoku_conversion_line()
        except Exception:
            out["ichi_base"], out["ichi_conv"] = np.nan, np.nan

        # Supertrend (custom JIT)
        st, trend, atr_rma = supertrend(h.astype(np.float64), l.astype(np.float64), c.astype(np.float64),
                                        period=self.p.supertrend_period, multiplier=self.p.supertrend_mult)
        out["supertrend"], out["supertrend_trend"], out["atr_rma"] = st, trend, atr_rma
        return out

# ----------------------------------------------------------------------------
# Risk management
# ----------------------------------------------------------------------------
@dataclass
class RiskConfig:
    account_equity_usdt: float = 1000.0
    max_risk_pct_per_trade: float = 0.015
    max_daily_drawdown_pct: float = 0.02
    leverage: int = 5
    min_notional_usdt: float = 10.0
    symbol_price_precision: int = 2
    symbol_qty_precision: int = 3
    tz_reset: str = "Europe/Zurich"

class RiskManager:
    def __init__(self, cfg: RiskConfig):
        self.cfg = cfg
        self.daily_pnl = 0.0
        self._current_date = None

    def _roll_date(self, now_utc: pd.Timestamp):
        tz = pytz.timezone(self.cfg.tz_reset)
        d = now_utc.tz_convert(tz).date()
        if self._current_date is None:
            self._current_date = d
        elif d != self._current_date:
            logger.info("[Risk] New day → reset daily PnL")
            self._current_date = d
            self.daily_pnl = 0.0

    def update_realized_pnl(self, pnl: float, now_utc: pd.Timestamp):
        self._roll_date(now_utc)
        self.daily_pnl += pnl

    def hard_guard(self, now_utc: pd.Timestamp) -> bool:
        self._roll_date(now_utc)
        limit = -self.cfg.account_equity_usdt * self.cfg.max_daily_drawdown_pct
        allowed = self.daily_pnl > limit
        if not allowed:
            logger.warning("[Risk] Daily DD reached: pnl=%.2f limit=%.2f", self.daily_pnl, limit)
        return allowed

    def position_size(self, entry: float, sl: float) -> float:
        risk_usdt = self.cfg.account_equity_usdt * self.cfg.max_risk_pct_per_trade
        stop = max(1e-8, abs(entry - sl))
        qty = risk_usdt / stop * self.cfg.leverage
        qty = max(0.0, round(qty, self.cfg.symbol_qty_precision))
        # min notional (margin notionally = entry*qty/leverage)
        if (qty * entry / self.cfg.leverage) < self.cfg.min_notional_usdt:
            qty = round((self.cfg.min_notional_usdt * self.cfg.leverage) / entry, self.cfg.symbol_qty_precision)
        return qty

# ----------------------------------------------------------------------------
# Strategy (MTF + filters)
# ----------------------------------------------------------------------------
@dataclass
class StratConfig:
    symbol: str = "BTCUSDT"
    signal_tf: TF = "1m"
    trend_tf: TF = "15m"
    htf: TF = "1h"

    rsi_period: int = 14
    ema_fast: int = 21
    ema_slow: int = 50
    adx_period: int = 14
    atr_period: int = 14

    rsi_buy: int = 30
    rsi_sell: int = 70
    adx_min: float = 18.0

    atr_sl_mult: float = 1.5
    atr_tp_mult: float = 3.0

    cooldown_bars: int = 3
    min_atr_pct_of_price: float = 0.05 / 100.0

    session_start_utc: Optional[int] = None
    session_end_utc: Optional[int] = None

    # Extra trigger toggles & thresholds
    use_kdj: bool = True
    use_wr: bool = True
    use_trix: bool = True
    wr_buy: float = -80.0
    wr_sell: float = -20.0

class StrategyEngine:
    def __init__(self, sc: StratConfig, rc: RiskConfig):
        self.sc = sc
        self.rm = RiskManager(rc)
        self.ind = IndicatorEngine(sc.rsi_period, sc.ema_fast, sc.ema_slow, sc.atr_period, sc.adx_period)

        def _mlen(n):
            return int(max(100, n*6))
        self.win: Dict[TF, WindowState] = {
            sc.signal_tf: WindowState(sc.signal_tf, _mlen(max(sc.ema_slow, sc.rsi_period, sc.atr_period))),
            sc.trend_tf:  WindowState(sc.trend_tf,  _mlen(max(sc.ema_slow, sc.adx_period))),
            sc.htf:       WindowState(sc.htf,       _mlen(sc.ema_slow*2)),
        }
        self.cooldown = 0
        self.last_signal: Optional[Side] = None

    def update_bar_close(self, tf: TF, bar: Bar) -> Optional[Signal]:
        bar.ts = as_utc(bar.ts)
        self.win[tf].append(bar)

        if tf != self.sc.signal_tf:
            return None

        if not self.rm.hard_guard(bar.ts):
            return None

        if self.sc.session_start_utc is not None and self.sc.session_end_utc is not None:
            h = bar.ts.hour
            if not (self.sc.session_start_utc <= h < self.sc.session_end_utc):
                return None

        sdf = self.win[self.sc.signal_tf].to_df()
        tdf = self.win[self.sc.trend_tf].to_df()
        hdf = self.win[self.sc.htf].to_df()
        if min(len(sdf), len(tdf), len(hdf)) < 60:
            return None

        sdf = self.ind.compute_all(sdf)
        last = sdf.iloc[-1]
        prev = sdf.iloc[-2]

        # Volatility floor
        if (last.atr / max(1e-8, last.close)) < self.sc.min_atr_pct_of_price:
            return None

        # Trend TF indicators
        tdf = self.ind.compute_all(tdf)
        t_last = tdf.iloc[-1]
        trend_up = (t_last.ema_fast > t_last.ema_slow) and (t_last.adx >= self.sc.adx_min)
        trend_dn = (t_last.ema_fast < t_last.ema_slow) and (t_last.adx >= self.sc.adx_min)

        # HTF bias via SMA200 slope
        hdf = self.win[self.sc.htf].to_df()
        hdf["sma200"] = hdf["close"].rolling(200).mean()
        if len(hdf) < 202:
            return None
        h_last, h_prev = hdf.iloc[-1], hdf.iloc[-2]
        htf_up = h_last.sma200 > h_prev.sma200
        htf_dn = h_last.sma200 < h_prev.sma200

        # Triggers: RSI exit from OB/OS + EMA_fast cross, supported by Supertrend trend
        long_trig = (prev.rsi < self.sc.rsi_buy) and (last.rsi >= self.sc.rsi_buy) \
                    and (prev.close < prev.ema_fast) and (last.close > last.ema_fast) \
                    and (int(last.supertrend_trend) == 1)
        short_trig = (prev.rsi > self.sc.rsi_sell) and (last.rsi <= self.sc.rsi_sell) \
                     and (prev.close > prev.ema_fast) and (last.close < last.ema_fast) \
                     and (int(last.supertrend_trend) == -1)

        # Optional extra triggers: KDJ cross / WR thresholds / TRIX cross
        if self.sc.use_kdj:
            kdj_long = (prev.kdj_k < prev.kdj_d) and (last.kdj_k > last.kdj_d) and (last.kdj_k < 40)
            kdj_short = (prev.kdj_k > prev.kdj_d) and (last.kdj_k < last.kdj_d) and (last.kdj_k > 60)
            long_trig = long_trig or kdj_long
            short_trig = short_trig or kdj_short
        if self.sc.use_wr and not np.isnan(last.get("wr14", np.nan)):
            wr_long = last.wr14 <= self.sc.wr_buy
            wr_short = last.wr14 >= self.sc.wr_sell
            long_trig = long_trig or wr_long
            short_trig = short_trig or wr_short
        if self.sc.use_trix and "trix9_signal" in sdf.columns:
            trix_long = (prev.trix9 < prev.trix9_signal) and (last.trix9 > last.trix9_signal)
            trix_short = (prev.trix9 > prev.trix9_signal) and (last.trix9 < last.trix9_signal)
            long_trig = long_trig or trix_long
            short_trig = short_trig or trix_short

        want_long = long_trig and trend_up and htf_up
        want_short = short_trig and trend_dn and htf_dn

        if self.cooldown > 0:
            self.cooldown -= 1
            return None
        if self.last_signal == "LONG" and want_long:
            return None
        if self.last_signal == "SHORT" and want_short:
            return None

        if want_long:
            entry = round(float(last.close), self.rm.cfg.symbol_price_precision)
            sl = round(entry - self.sc.atr_sl_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            tp = round(entry + self.sc.atr_tp_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            qty = self.rm.position_size(entry, sl)
            if qty <= 0: return None
            self.last_signal = "LONG"; self.cooldown = self.sc.cooldown_bars
            return Signal(self.sc.symbol, "LONG", entry, sl, tp, qty,
                          reason="RSI up-cross + EMA_fast break + ST up; Trend/HTF aligned",
                          meta={"rsi": float(last.rsi), "atr": float(last.atr), "adx": float(t_last.adx)})

        if want_short:
            entry = round(float(last.close), self.rm.cfg.symbol_price_precision)
            sl = round(entry + self.sc.atr_sl_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            tp = round(entry - self.sc.atr_tp_mult * float(last.atr), self.rm.cfg.symbol_price_precision)
            qty = self.rm.position_size(entry, sl)
            if qty <= 0: return None
            self.last_signal = "SHORT"; self.cooldown = self.sc.cooldown_bars
            return Signal(self.sc.symbol, "SHORT", entry, sl, tp, qty,
                          reason="RSI down-cross + EMA_fast break + ST down; Trend/HTF aligned",
                          meta={"rsi": float(last.rsi), "atr": float(last.atr), "adx": float(t_last.adx)})
        return None

# Trailing stop utility -------------------------------------------------------
def atr_trailing_stop(side: Side, entry: float, best_price: float, atr: float,
                      be_rr: float = 1.0, trail_mult: float = 1.0) -> float:
    if side == "LONG":
        rr = (best_price - entry) / max(1e-8, atr)
        return max(entry, best_price - trail_mult * atr) if rr >= be_rr else entry - 1e-6
    else:
        rr = (entry - best_price) / max(1e-8, atr)
        return min(entry, best_price + trail_mult * atr) if rr >= be_rr else entry + 1e-6

# ----------------------------------------------------------------------------
# Binance Executor (Testnet/Mainnet) — bracket orders & settings
# ----------------------------------------------------------------------------
class BinanceExecutor:
    def __init__(self, api_key: str, api_secret: str, testnet: bool = True, dry_run: bool = True,
                 hedge_mode: bool = True, margin_type: str = "ISOLATED", leverage: int = 5,
                 working_type: str = "MARK_PRICE"):
        self.dry_run = dry_run
        self.testnet = testnet
        self.hedge_mode = hedge_mode
        self.margin_type = margin_type
        self.leverage = leverage
        self.working_type = working_type
        try:
            from binance.um_futures import UMFutures
        except Exception as e:
            logger.error("binance-connector missing: %s", e)
            UMFutures = None
        base_url = "https://testnet.binancefuture.com" if testnet else None
        self.client = None
        if UMFutures is not None:
            self.client = UMFutures(api_key=api_key, api_secret=api_secret, base_url=base_url)

    # Defensive account setup
    def ensure_account(self, symbol: str):
        if self.dry_run or self.client is None:
            return
        try:
            if self.hedge_mode:
                self.client.change_position_mode(dualSidePosition="true")
            else:
                self.client.change_position_mode(dualSidePosition="false")
        except Exception as e:
            logger.warning("position mode: %s", e)
        try:
            self.client.change_margin_type(symbol=symbol, marginType=self.margin_type)
        except Exception:
            pass
        try:
            self.client.change_leverage(symbol=symbol, leverage=self.leverage)
        except Exception:
            pass

    def place_bracket(self, symbol: str, side: Side, qty: float, entry: float, sl: float, tp: float):
        logger.info("[ORDER] %s %s qty=%.6f entry=%.4f sl=%.4f tp=%.4f", side, symbol, qty, entry, sl, tp)
        if self.dry_run or self.client is None:
            return {"dry_run": True}
        is_buy = side == "LONG"
        order_side = "BUY" if is_buy else "SELL"
        try:
            self.client.new_order(symbol=symbol, side=order_side, type="LIMIT",
                                  quantity=str(qty), price=str(entry), timeInForce="GTC",
                                  reduceOnly="false")
            # SL / TP as closePosition true (brackets)
            self.client.new_order(symbol=symbol, side=("SELL" if is_buy else "BUY"), type="STOP_MARKET",
                                  stopPrice=str(sl), closePosition="true", workingType=self.working_type)
            self.client.new_order(symbol=symbol, side=("SELL" if is_buy else "BUY"), type="TAKE_PROFIT_MARKET",
                                  stopPrice=str(tp), closePosition="true", workingType=self.working_type)
        except Exception as e:
            logger.error("order error: %s", e)

    def update_trailing_stop(self, symbol: str, side: Side, new_stop: float):
        """Naive trailing: place a fresh STOP_MARKET closePosition (some venues allow multiple). 
        In production you may cancel/replace previous stop to avoid duplicates."""
        logger.info("[TRAIL] %s %s new_stop=%.4f", side, symbol, new_stop)
        if self.dry_run or self.client is None:
            return {"dry_run": True}
        try:
            self.client.new_order(symbol=symbol, side=("SELL" if side == "LONG" else "BUY"), type="STOP_MARKET",
                                  stopPrice=str(new_stop), closePosition="true", workingType=self.working_type)
        except Exception as e:
            logger.error("trail error: %s", e)

# ----------------------------------------------------------------------------
# App wiring (example loop; integrate with your WS feed)
# ----------------------------------------------------------------------------
class App:
    def __init__(self, symbols: List[str], sc: StratConfig, rc: RiskConfig, execu: BinanceExecutor):
        self.symbols = symbols
        self.sc = sc
        self.rc = rc
        self.exec = execu
        self.engines: Dict[str, StrategyEngine] = {s: StrategyEngine(StratConfig(symbol=s, signal_tf=sc.signal_tf, trend_tf=sc.trend_tf, htf=sc.htf,
                                                                                 rsi_period=sc.rsi_period, ema_fast=sc.ema_fast, ema_slow=sc.ema_slow,
                                                                                 adx_period=sc.adx_period, atr_period=sc.atr_period,
                                                                                 rsi_buy=sc.rsi_buy, rsi_sell=sc.rsi_sell, adx_min=sc.adx_min,
                                                                                 atr_sl_mult=sc.atr_sl_mult, atr_tp_mult=sc.atr_tp_mult,
                                                                                 cooldown_bars=sc.cooldown_bars, min_atr_pct_of_price=sc.min_atr_pct_of_price,
                                                                                 session_start_utc=sc.session_start_utc, session_end_utc=sc.session_end_utc,
                                                                                 use_kdj=sc.use_kdj, use_wr=sc.use_wr, use_trix=sc.use_trix,
                                                                                 wr_buy=sc.wr_buy, wr_sell=sc.wr_sell), rc)
                                            for s in symbols}
        # Simple position tracker for trailing
        self.positions: Dict[str, Dict[str, dict]] = {s: {"LONG": None, "SHORT": None} for s in symbols}

    def on_bar(self, symbol: str, tf: TF, bar: Bar):
        sig = self.engines[symbol].update_bar_close(tf, bar)
        if sig:
            self.exec.ensure_account(symbol)
            self.exec.place_bracket(symbol, sig.side, sig.size, sig.price, sig.sl, sig.tp)

# ----------------------------------------------------------------------------
# Binance WebSocket streamer (klines, closed-only) -> feeds App.on_bar
# ----------------------------------------------------------------------------
class BinanceWS:
    def __init__(self, symbols: List[str], tfs: List[TF], app: App, testnet: bool = True):
        self.symbols = [s.lower() for s in symbols]  # binance stream wants lowercase
        self.tfs = tfs
        self.app = app
        self.testnet = testnet
        self.ws_apps: List[object] = []

    def _make_urls(self) -> List[str]:
        base = "wss://stream.binancefuture.com" if self.testnet else "wss://fstream.binance.com"
        streams = [f"{sym}@kline_{tf}" for sym in self.symbols for tf in self.tfs]
        MAX = 200
        urls = []
        for i in range(0, len(streams), MAX):
            chunk = "/".join(streams[i:i+MAX])
            urls.append(f"{base}/stream?streams={chunk}")
        return urls

    def start(self):
        import json, threading
        import websocket

        def make_app(url):
            def on_message(ws, message):
                try:
                    msg = json.loads(message)
                    if "data" not in msg:
                        return
                    d = msg["data"]
                    if d.get("e") != "kline":
                        return
                    k = d.get("k", {})
                    if not k.get("x", False):
                        return
                    symbol = d.get("s", "").upper()
                    tf = k.get("i")
                    bar = Bar(
                        ts=as_utc(k.get("T")/1000),
                        open=float(k.get("o")),
                        high=float(k.get("h")),
                        low=float(k.get("l")),
                        close=float(k.get("c")),
                        volume=float(k.get("q", 0.0)),
                    )
                    self.app.on_bar(symbol, tf, bar)
                except Exception as e:
                    logger.error("WS message error: %s", e)
            def on_error(ws, error):
                logger.error("WS error: %s", error)
            def on_close(ws, code, msg):
                logger.warning("WS closed: %s %s", code, msg)
            def on_open(ws):
                logger.info("WS connected: %s", url)
            return websocket.WebSocketApp(url, on_message=on_message, on_error=on_error, on_close=on_close, on_open=on_open)

        urls = self._make_urls()
        for url in urls:
            app = make_app(url)
            t = threading.Thread(target=lambda: app.run_forever(ping_interval=20, ping_timeout=10), daemon=True)
            t.start()
            self.ws_apps.append(app)
        while True:
            time.sleep(60)

# ----------------------------------------------------------------------------
# Backtest (CSV klines) — simple PnL with SL/TP & trailing
# ----------------------------------------------------------------------------
class Backtester:
    def __init__(self, sc: StratConfig, rc: RiskConfig):
        self.engine = StrategyEngine(sc, rc)

    def run_csv(self, path: str, tf: TF) -> Dict[str, float]:
        df = pd.read_csv(path)
        # Expect columns: ts/open/high/low/close/volume (ts in seconds or ISO)
        if 'ts' in df.columns:
            try:
                ts = pd.to_datetime(df['ts'], utc=True)
            except Exception:
                ts = pd.to_datetime(df['ts'], unit='s', utc=True)
        else:
            ts = pd.to_datetime(df['close_time'], unit='ms', utc=True)
        pnl = 0.0; wins=0; losses=0; trades=0
        pos=None
        for i in range(len(df)):
            bar = Bar(ts=ts.iloc[i], open=float(df['open'].iloc[i]), high=float(df['high'].iloc[i]),
                      low=float(df['low'].iloc[i]), close=float(df['close'].iloc[i]), volume=float(df.get('volume', pd.Series([0]*len(df))).iloc[i]))
            sig = self.engine.update_bar_close(tf, bar)
            if sig and pos is None:
                pos = {"side": sig.side, "entry": sig.price, "sl": sig.sl, "tp": sig.tp, "best": sig.price, "atr": sig.meta.get("atr", 0.0)}
                trades += 1
            if pos:
                if pos["side"] == "LONG":
                    pos["best"] = max(pos["best"], bar.close)
                    new_sl = atr_trailing_stop("LONG", pos["entry"], pos["best"], pos["atr"] or max(1e-8, bar.high-bar.low))
                    pos["sl"] = max(pos["sl"], new_sl)
                    if bar.low <= pos["sl"]:
                        pnl += (pos["sl"] - pos["entry"]) ; losses += int(pos["sl"]<pos["entry"]) ; wins += int(pos["sl"]>pos["entry"]) ; pos=None
                    elif bar.high >= pos["tp"]:
                        pnl += (pos["tp"] - pos["entry"]) ; wins += 1 ; pos=None
                else:
                    pos["best"] = min(pos["best"], bar.close)
                    new_sl = atr_trailing_stop("SHORT", pos["entry"], pos["best"], pos["atr"] or max(1e-8, bar.high-bar.low))
                    pos["sl"] = min(pos["sl"], new_sl)
                    if bar.high >= pos["sl"]:
                        pnl += (pos["entry"] - pos["sl"]) ; losses += int(pos["sl"]>pos["entry"]) ; wins += int(pos["sl"]<pos["entry"]) ; pos=None
                    elif bar.low <= pos["tp"]:
                        pnl += (pos["entry"] - pos["tp"]) ; wins += 1 ; pos=None
        return {"pnl": pnl, "trades": trades, "wins": wins, "losses": losses}

# ----------------------------------------------------------------------------
# CLI / bootstrap (live WS demo)
# ----------------------------------------------------------------------------
if __name__ == "__main__":
    load_dotenv()
    api_key = os.getenv("BINANCE_API_KEY", "")
    api_secret = os.getenv("BINANCE_API_SECRET", "")
    testnet = os.getenv("USE_TESTNET", "true").lower() == "true"
    hedge_mode = os.getenv("BINANCE_HEDGE_MODE", "true").lower() == "true"
    margin_type = os.getenv("BINANCE_MARGIN_TYPE", "ISOLATED")
    leverage = int(os.getenv("BINANCE_LEVERAGE", "5"))
    working_type = os.getenv("WORKING_TYPE", "MARK_PRICE")
    dry_run = os.getenv("DRY_RUN", "true").lower() == "true"

    # Symbols: ALL → discover all USDT perpetuals
    symbols_env = os.getenv("SYMBOLS", "BTCUSDT")
    discover_all = symbols_env.strip().upper() in ("ALL", "*") or os.getenv("ALL_SYMBOLS", "false").lower()=="true"
    symbols = []
    if discover_all:
        try:
            from binance.um_futures import UMFutures
            base_url = "https://testnet.binancefuture.com" if testnet else None
            client = UMFutures(api_key=api_key, api_secret=api_secret, base_url=base_url)
            info = client.exchange_info()
            for s in info.get('symbols', []):
                if s.get('status') == 'TRADING' and s.get('quoteAsset') == 'USDT':
                    symbols.append(s.get('symbol'))
        except Exception as e:
            logger.error("symbol discovery failed: %s", e)
            symbols = ["BTCUSDT"]
    else:
        symbols = [s.strip().upper() for s in symbols_env.split(',') if s.strip()]

    # Timeframes: ALL → subscribe to all Binance futures klines
    tfs_env = os.getenv("TIMEFRAMES", "ALL")
    all_tfs = ["1m","3m","5m","15m","30m","1h","2h","4h","6h","8h","12h","1d","3d","1w","1M"]
    if tfs_env.strip().upper() in ("ALL", "*"):
        tfs = all_tfs
    else:
        tfs = [tf.strip() for tf in tfs_env.split(',') if tf.strip()]

    sc = StratConfig(symbol=symbols[0], signal_tf="1m", trend_tf="15m", htf="1h")
    rc = RiskConfig(account_equity_usdt=float(os.getenv("ACCOUNT_EQUITY", "5000")),
                    leverage=leverage,
                    min_notional_usdt=float(os.getenv("MIN_NOTIONAL_USDT", "10")))

    executor = BinanceExecutor(api_key, api_secret, testnet, dry_run, hedge_mode, margin_type, leverage, working_type)
    app = App(symbols, sc, rc, executor)

    ws = BinanceWS(symbols, tfs=tfs, app=app, testnet=testnet)
    logger.info("Starting Binance WS for %s on %s", symbols, tfs)
    ws.start()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\visual_panel.py
import pandas as pd
import matplotlib.pyplot as plt

def dashboard_view(csv_file="data/signal_log.csv"):
    df = pd.read_csv(csv_file, names=["signal", "score", "result"])
    
    # 1. Sinyal Dağılımı
    signal_count = df["signal"].value_counts()
    signal_count.plot(kind="bar", title="🔁 Sinyal Dağılımı", color="steelblue")
    plt.ylabel("Adet")
    plt.tight_layout()
    plt.show()

    # 2. Başarı Oranı
    result_count = df["result"].value_counts(normalize=True) * 100
    result_count.plot(kind="pie", title="🎯 Başarı Oranı", autopct="%.1f%%")
    plt.ylabel("")
    plt.tight_layout()
    plt.show()

    # 3. Skor Histogramı
    df["score"].plot(kind="hist", bins=10, title="⚙️ Sinyal Skor Yoğunluğu", color="purple")
    plt.xlabel("Skor")
    plt.tight_layout()
    plt.show()



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\visualize.py
import pandas as pd
import matplotlib.pyplot as plt

def plot_sentiments(news_data):
    df = pd.DataFrame(news_data)
    
    # Duygu Analizi Uygula
    from sentiment import analyze_sentiment
    df["label"] = df["title"].apply(lambda x: analyze_sentiment(x)[0])

    # Gruplandır ve Say
    sentiment_counts = df["label"].value_counts()

    # Grafikle Göster
    plt.figure(figsize=(6,4))
    sentiment_counts.plot(kind="bar", color=["green", "red", "gray"])
    plt.title("Haberlerde Duygu Dağılımı")
    plt.ylabel("Haber Sayısı")
    plt.xlabel("Duygu Türü")
    plt.xticks(rotation=0)
    plt.tight_layout()
    plt.show()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\visualizer.py
# visualizer.py

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.ticker import MaxNLocator
import pandas as pd


def plot_signals(df, title="📊 Sinyal Grafiği"):
    df = df.copy()
    df.index = pd.to_datetime(df.index)

    fig, ax = plt.subplots(figsize=(16, 8))
    fig.suptitle(title, fontsize=16, fontweight='bold')

    # Ana fiyat çizgisi
    ax.plot(df.index, df['close'], label='Fiyat', color='black', linewidth=2)

    # BUY sinyalleri
    if 'long_entry' in df.columns:
        long_signals = df[df['long_entry']]
        ax.scatter(long_signals.index, long_signals['close'], marker='^', color='green', label='BUY Sinyali', s=120, zorder=5)

    # SELL sinyalleri
    if 'short_entry' in df.columns:
        short_signals = df[df['short_entry']]
        ax.scatter(short_signals.index, short_signals['close'], marker='v', color='red', label='SELL Sinyali', s=120, zorder=5)

    # Bollinger Bands (varsa)
    if 'BBL_20_2.0' in df.columns and 'BBU_20_2.0' in df.columns:
        ax.plot(df.index, df['BBL_20_2.0'], linestyle='--', color='blue', alpha=0.5, label='BB Alt')
        ax.plot(df.index, df['BBU_20_2.0'], linestyle='--', color='blue', alpha=0.5, label='BB Üst')

    # EMA 50 / 200 çizgileri
    if 'EMA_50' in df.columns:
        ax.plot(df.index, df['EMA_50'], linestyle='-', color='orange', alpha=0.7, label='EMA 50')

    if 'EMA_200' in df.columns:
        ax.plot(df.index, df['EMA_200'], linestyle='-', color='purple', alpha=0.5, label='EMA 200')

    # Eksen biçimlendirme
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%m-%d %H:%M'))
    ax.xaxis.set_major_locator(MaxNLocator(nbins=10))
    fig.autofmt_xdate()
    ax.set_xlabel("Zaman", fontsize=12)
    ax.set_ylabel("Fiyat (USDT)", fontsize=12)

    ax.grid(True, linestyle='--', alpha=0.3)
    ax.legend(loc='upper left')
    plt.tight_layout()
    plt.show()
# visualizer.py (Pro versiyon)
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.ticker import MaxNLocator
import pandas as pd
import os
from datetime import datetime

def plot_signals(df, title="📊 Sinyal Grafiği", save=False, filename=None):
    df = df.copy()
    df.index = pd.to_datetime(df.index)

    fig, ax = plt.subplots(figsize=(16, 8))
    fig.suptitle(title, fontsize=16, fontweight='bold')

    # Fiyat çizgisi
    ax.plot(df.index, df['close'], label='Fiyat', color='black', linewidth=2)

    # BUY sinyalleri
    if 'long_entry' in df.columns:
        long_signals = df[df['long_entry']]
        ax.scatter(long_signals.index, long_signals['close'], marker='^', color='green', label='BUY', s=120, zorder=5)

    # SELL sinyalleri
    if 'short_entry' in df.columns:
        short_signals = df[df['short_entry']]
        ax.scatter(short_signals.index, short_signals['close'], marker='v', color='red', label='SELL', s=120, zorder=5)

    # Bollinger Bands
    if 'BBL_20_2.0' in df.columns and 'BBU_20_2.0' in df.columns:
        ax.plot(df.index, df['BBL_20_2.0'], linestyle='--', color='blue', alpha=0.5, label='BB Alt')
        ax.plot(df.index, df['BBU_20_2.0'], linestyle='--', color='blue', alpha=0.5, label='BB Üst')

    # EMA'lar
    if 'EMA_50' in df.columns:
        ax.plot(df.index, df['EMA_50'], linestyle='-', color='orange', alpha=0.7, label='EMA 50')
    if 'EMA_200' in df.columns:
        ax.plot(df.index, df['EMA_200'], linestyle='-', color='purple', alpha=0.5, label='EMA 200')

    # Biçimlendirme
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%m-%d %H:%M'))
    ax.xaxis.set_major_locator(MaxNLocator(nbins=10))
    fig.autofmt_xdate()
    ax.set_xlabel("Zaman", fontsize=12)
    ax.set_ylabel("Fiyat (USDT)", fontsize=12)
    ax.grid(True, linestyle='--', alpha=0.3)
    ax.legend(loc='upper left')
    plt.tight_layout()

    if save:
        if not filename:
            filename = f"signal_plot_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        os.makedirs("charts", exist_ok=True)
        filepath = os.path.join("charts", filename)
        plt.savefig(filepath)
        print(f"🖼️ Grafik kaydedildi: {filepath}")
    else:
        plt.show()


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\wepsocet.py
from websocket import WebSocketApp
import json

symbols = ["btcusdt", "ethusdt", "dogeusdt"]
streams = "/".join([f"{s}@ticker" for s in symbols])
url = f"wss://stream.binance.com:9443/stream?streams={streams}"

def on_message(ws, message):
    data = json.loads(message)
    stream_name = data.get("stream", "")
    payload = data.get("data", {})
    symbol = payload.get("s")
    price = payload.get("c")
    print(f"{symbol}: {price}")

ws = WebSocketApp(url, on_message=on_message)
ws.run_forever()
import websocket, json, time, hmac, hashlib, requests, threading
import pandas as pd
import numpy as np
import ta
from sklearn.ensemble import IsolationForest
from keras.models import Sequential
from keras.layers import LSTM, Dense

# === AYARLAR ===
API_KEY = "YOUR_API_KEY"
SECRET_KEY = "YOUR_SECRET_KEY"
SYMBOLS = ["btcusdt", "ethusdt"]
TRADE_AMOUNT = 0.001
RISK_LIMIT = 0.02  # %2 risk

# === VERİ DEPOLAMA ===
price_data = {symbol: pd.DataFrame(columns=["timestamp", "price"]) for symbol in SYMBOLS}
models = {}

# === LOG FONKSİYONU ===
def log(event, msg):
    print(f"[{event}] {msg}")

# === VERİ AKIŞI ===
def create_socket(symbol):
    url = f"wss://stream.binance.com:9443/ws/{symbol}@trade"
    return websocket.WebSocketApp(url,
        on_message=lambda ws, msg: handle_message(symbol, msg),
        on_open=lambda ws: log("OPEN", f"{symbol.upper()} bağlantısı kuruldu."),
        on_close=lambda ws: log("CLOSE", f"{symbol.upper()} bağlantısı kapandı.")
    )

def handle_message(symbol, message):
    global price_data, models
    data = json.loads(message)
    price = float(data['p'])
    timestamp = int(data['T'])
    df = price_data[symbol]
    df.loc[len(df)] = [timestamp, price]

    if len(df) > 120:
        df = df.tail(120).copy()
        df = generate_features(df)
        anomaly_score = detect_anomaly(df)
        if symbol not in models:
            models[symbol] = train_model(df)
        prediction = predict_price(models[symbol], df)
        strategy_decision(symbol, df, prediction, anomaly_score)

# === ÖZELLİK MÜHENDİSLİĞİ ===
def generate_features(df):
    df['rsi'] = ta.momentum.RSIIndicator(df['price']).rsi()
    df['macd'] = ta.trend.MACD(df['price']).macd_diff()
    df['sma20'] = df['price'].rolling(window=20).mean()
    df['volatility'] = df['price'].rolling(window=10).std()
    df.dropna(inplace=True)
    return df

# === ANOMALY DETECTION ===
def detect_anomaly(df):
    iso = IsolationForest(contamination=0.05)
    scores = iso.fit_predict(df[['price', 'rsi', 'macd', 'volatility']])
    return scores[-1]  # -1 = anomaly

# === LSTM MODELİ ===
def train_model(df):
    prices = df['price'].values[-100:]
    X, y = [], []
    for i in range(10, len(prices)):
        X.append(prices[i-10:i])
        y.append(prices[i])
    X, y = np.array(X), np.array(y)
    X = X.reshape((X.shape[0], X.shape[1], 1))

    model = Sequential()
    model.add(LSTM(64, activation='relu', input_shape=(10,1)))
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mse')
    model.fit(X, y, epochs=15, verbose=0)
    return model

def predict_price(model, df):
    last_seq = df['price'].values[-10:].reshape((1,10,1))
    return model.predict(last_seq)[0][0]

# === STRATEJİ MOTORU ===
def strategy_decision(symbol, df, prediction, anomaly_score):
    latest = df.iloc[-1]
    rsi = latest['rsi']
    macd = latest['macd']
    price = latest['price']
    volatility = latest['volatility']

    log("STRATEGY", f"{symbol.upper()} | RSI: {rsi:.2f} | MACD: {macd:.2f} | Tahmin: {prediction:.2f} | Anomaly: {anomaly_score}")

    if anomaly_score == -1:
        log("ALERT", "Anormal veri tespit edildi. İşlem yapılmadı.")
        return

    if rsi < 30 and macd > 0 and prediction > price:
        qty = calculate_position(price, volatility)
        execute_order(symbol.upper(), "BUY", qty)
    elif rsi > 70 and macd < 0 and prediction < price:
        qty = calculate_position(price, volatility)
        execute_order(symbol.upper(), "SELL", qty)
    else:
        log("STATUS", "Beklemede")

# === RİSK YÖNETİMİ ===
def calculate_position(price, volatility):
    balance = 1000  # örnek bakiye
    risk_amount = balance * RISK_LIMIT
    stop_loss = price * 0.01 + volatility
    qty = risk_amount / stop_loss
    return round(qty, 4)

# === EMİR GÖNDERİMİ ===
def execute_order(symbol, side, quantity):
    url = "https://api.binance.com/api/v3/order"
    timestamp = int(time.time() * 1000)
    params = {
        "symbol": symbol,
        "side": side,
        "type": "MARKET",
        "quantity": quantity,
        "timestamp": timestamp
    }
    query = '&'.join([f"{k}={v}" for k,v in params.items()])
    signature = hmac.new(SECRET_KEY.encode(), query.encode(), hashlib.sha256).hexdigest()
    params['signature'] = signature
    headers = {"X-MBX-APIKEY": API_KEY}
    try:
        response = requests.post(url, headers=headers, params=params)
        log("ORDER", f"{side} {quantity} {symbol} gönderildi.")
        log("RESPONSE", str(response.json()))
    except Exception as e:
        log("ERROR", f"Emir gönderimi başarısız: {e}")

# === BAŞLAT ===
if __name__ == "__main__":
    sockets = [create_socket(symbol) for symbol in SYMBOLS]
    for sock in sockets:
        threading.Thread(target=sock.run_forever).start()

### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\whisper_sync__module.py
def track_silent_moves(chain_log):
    anomalies = []
    for entry in chain_log:
        if entry['volume'] < 100_000 and entry['effect'] > 70:
            anomalies.append(f"🕵️ Sessiz Etki: {entry['id']}")
    return anomalies if anomalies else ["🌌 Sessiz ama sakin: risk gözükmüyor."]



### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ws_multi_price_stream.py
# ws_multi_price_stream.py (Çoklu sembol WebSocket veri akışı)
import json
from websocket import WebSocketApp
from datetime import datetime

# Takip edilecek semboller
SYMBOLS = ["btcusdt", "ethusdt", "dogeusdt", "solusdt", "adausdt"]

# Stream URL'si
streams = "/".join([f"{sym}@ticker" for sym in SYMBOLS])
url = f"wss://stream.binance.com:9443/stream?streams={streams}"

# Fiyatları saklamak için sözlük
ticker_data = {}


def on_message(ws, message):
    global ticker_data
    data = json.loads(message)
    payload = data.get("data", {})
    symbol = payload.get("s", "").upper()
    price = float(payload.get("c", 0))
    timestamp = datetime.fromtimestamp(payload.get("E", 0)/1000).strftime("%H:%M:%S")

    ticker_data[symbol] = price
    print(f"[{timestamp}] {symbol} → {price:.4f}")


def on_error(ws, error):
    print("❌ HATA:", error)


def on_close(ws):
    print("🔌 Bağlantı kapatıldı.")


def on_open(ws):
    print("🚀 WebSocket bağlantısı başlatıldı.")


if __name__ == "__main__":
    print(f"🌐 Çoklu sembol WebSocket veri akışı başlıyor...")
    ws = WebSocketApp(url, on_open=on_open, on_message=on_message, on_error=on_error, on_close=on_close)
    try:
        ws.run_forever()
    except KeyboardInterrupt:
        print("🛑 Kullanıcı tarafından durduruldu.")


### FILE: C:\Users\kamal\Desktop\Kiripto_Nova\ws_price_stream.py
# ws_price_stream.py (WebSocket ile gecikmesiz fiyat veri akışı)
import json
import threading
from binance.websocket.spot.websocket_client import SpotWebsocketClient
from datetime import datetime

SYMBOL = "dogeusdt"

def handle_price_stream(msg):
    if "c" in msg:
        price = float(msg["c"])
        ts = datetime.fromtimestamp(msg['E']/1000).strftime('%H:%M:%S')
        print(f"⏱️ {ts} | {SYMBOL.upper()} Fiyat: {price:.5f}")


def start_ws_client(symbol=SYMBOL):
    client = SpotWebsocketClient()
    client.start()
    client.ticker(symbol=symbol, id=1, callback=handle_price_stream)
    return client


if __name__ == "__main__":
    print(f"🚀 WebSocket başlatılıyor: {SYMBOL.upper()} anlık fiyat akışı...\n")
    ws_client = start_ws_client()

    # Arka planda çalışmasını sağlamak için main thread’i tutuyoruz
    try:
        while True:
            pass
    except KeyboardInterrupt:
        print("❌ WebSocket kapatılıyor...")
        ws_client.stop()


