from pathlib import Path
import re, sys, py_compile

ROOT = Path(__file__).resolve().parent
SRC = ROOT / "src" / "kiripto_nova"   # proje kökünüzdeki src/kiripto_nova

# Problemli karakterleri sadeleştir / normalize et
REPL = {
    "\u2018": "'", "\u2019": "'",     # ‘ ’ -> '
    "\u201C": '"', "\u201D": '"',     # “ ” -> "
    "\u00AB": '"', "\u00BB": '"',     # « »
    "\u2013": "-", "\u2014": "-",     # – —
    "\u2212": "-",                    # − (minus) -> -
    "\u2026": "...",                  # …
    "\u00A0": " ",                    # NBSP -> normal boşluk
    "\u2000": " ", "\u2001": " ", "\u2002": " ", "\u2003": " ",
    "\u2004": " ", "\u2005": " ", "\u2006": " ", "\u2007": " ",
    "\u2008": " ", "\u2009": " ", "\u200A": " ",
    "\u200B": "",  "\u200C": "",  "\u200D": "",  # zero-width -> sil
    "\ufeff": "",                     # BOM
    "\u2028": "\n", "\u2029": "\n",   # Line sep -> \n
}

LEAD_WS = re.compile(r'^[\t \u00A0\u2000-\u200F]+')  # satır başındaki her tür boşluk
def normalize_indent(line: str) -> str:
    m = LEAD_WS.match(line)
    if not m:
        return line
    head = m.group(0)
    head = head.replace('\t', '    ')                       # tab -> 4 boşluk
    head = re.sub(r'[\u00A0\u2000-\u200F]', ' ', head)      # tüm özel boşluklar -> ' '
    return head + line[m.end():]

def clean_text(t: str) -> str:
    for a, b in REPL.items():
        t = t.replace(a, b)
    t = t.replace('\r\n', '\n').replace('\r', '\n')         # satır sonlarını normalize et
    # trailing whitespace temizliği
    t = "\n".join(s.rstrip() for s in t.splitlines())
    # baştaki boşlukları/indentleri normalize et
    t = "\n".join(normalize_indent(s) for s in t.splitlines())
    return t + "\n"

bad = []
fixed = 0
scanned = 0
errors = []

for p in sorted(SRC.rglob("*.py")):
    if "__pycache__" in p.parts:
        continue
    try:
        scanned += 1
        raw = p.read_bytes()
        txt = raw.decode("utf-8", "replace")
        cleaned = clean_text(txt)
        if cleaned != txt:
            try:
                p.write_text(cleaned, encoding="utf-8", newline="\n")
                print(f"[FIX] {p.relative_to(ROOT)}")
                fixed += 1
            except PermissionError:
                print(f"[SKIP] {p.relative_to(ROOT)} (permission)")
        try:
            py_compile.compile(str(p), doraise=True)
        except Exception as e:
            bad.append(f"{p.relative_to(ROOT)} : {e.__class__.__name__} : {e}")
    except Exception as e:
        errors.append(f"{p}: {e}")

report = ROOT / "compile_report.txt"
report.write_text("\n".join(bad), encoding="utf-8")
print(f"Done. Scanned {scanned} files, fixed {fixed}.")
print(f"Compile check complete. Fails: {len(bad)}")
print(f"Report written to: {report}")
if errors:
    (ROOT / "compile_errors.txt").write_text("\n".join(errors), encoding="utf-8")
